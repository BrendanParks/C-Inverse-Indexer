<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>tommyhashlin.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Linear chained hashtable.  
<a href="#_details">More...</a></p>

<p><a href="tommyhashlin_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin_struct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear chained hashtable.  <a href="structtommy__hashlin__struct.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtommy__node__struct.html">tommy_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear hashtable node.  <a href="#a85850646f4dc979b7b213d8c58c13542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear chained hashtable.  <a href="#ad910f88af8bcd013a8e3cd30d528b904"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a639fc97c94668bac0424691c6a5094cb">tommy_hashlin_init</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the hashtable.  <a href="#a639fc97c94668bac0424691c6a5094cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#af49c4514766dab75ad2157fcd39d1f1f">tommy_hashlin_done</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the hashtable.  <a href="#af49c4514766dab75ad2157fcd39d1f1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957">tommy_hashlin_insert</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin, <a class="el" href="structtommy__node__struct.html">tommy_hashlin_node</a> *node, void *data, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the the hashtable.  <a href="#ad51e1c6766cac604ed1545b5649ff957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a66b7beb2b99431bb90e987bb8f068415">tommy_hashlin_remove</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin, <a class="el" href="tommytypes_8h.html#a891b456a327f318340f65ce1bdff36be">tommy_compare_func</a> *cmp, const void *cmp_arg, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and removes an element from the hashtable.  <a href="#a66b7beb2b99431bb90e987bb8f068415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtommy__node__struct.html">tommy_hashlin_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a2841df6043a5de8b4e47451748d4cfb2">tommy_hashlin_bucket</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bucket of the specified hash.  <a href="#a2841df6043a5de8b4e47451748d4cfb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#add50b5a7780cf631fdaa083227b5a28f">tommy_hashlin_search</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin, <a class="el" href="tommytypes_8h.html#a891b456a327f318340f65ce1bdff36be">tommy_compare_func</a> *cmp, const void *cmp_arg, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches an element in the hashtable.  <a href="#add50b5a7780cf631fdaa083227b5a28f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#afc35c9f3213033f7e814be4bc2a2aef6">tommy_hashlin_remove_existing</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin, <a class="el" href="structtommy__node__struct.html">tommy_hashlin_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the hashtable.  <a href="#afc35c9f3213033f7e814be4bc2a2aef6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a0733a8787930ff45041ece00d5741b4f">tommy_hashlin_count</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements.  <a href="#a0733a8787930ff45041ece00d5741b4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#a478b540a60cfc476cefc976c408c30cc">tommy_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a35bd9d60d6f2039230aefefaaa8a8c1b">tommy_hashlin_memory_usage</a> (<a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *hashlin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of allocated memory.  <a href="#a35bd9d60d6f2039230aefefaaa8a8c1b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Linear chained hashtable. </p>
<p>This hashtable resizes dynamically and progressively using a variation of the linear hashing algorithm described in <a href="http://en.wikipedia.org/wiki/Linear_hashing">http://en.wikipedia.org/wiki/Linear_hashing</a></p>
<p>It starts with the minimal size of 16 buckets, it doubles the size then it reaches a load factor greater than 0.5 and it halves the size with a load factor lower than 0.125.</p>
<p>The progressive resize is good for real-time and interactive applications as it makes insert and delete operations taking always the same time.</p>
<p>For resizing it's used a dynamic array that supports access to not contigous segments. In this way we only allocate additional table segments on the heap, without freeing the previous table, and then not increasing the heap fragmentation.</p>
<p>The resize takes place inside <a class="el" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957" title="Inserts an element in the the hashtable.">tommy_hashlin_insert()</a> and <a class="el" href="tommyhashlin_8h.html#a66b7beb2b99431bb90e987bb8f068415" title="Searches and removes an element from the hashtable.">tommy_hashlin_remove()</a>. No resize is done in the <a class="el" href="tommyhashlin_8h.html#add50b5a7780cf631fdaa083227b5a28f" title="Searches an element in the hashtable.">tommy_hashlin_search()</a> operation.</p>
<p>To initialize the hashtable you have to call <a class="el" href="tommyhashlin_8h.html#a639fc97c94668bac0424691c6a5094cb" title="Initializes the hashtable.">tommy_hashlin_init()</a>.</p>
<div class="fragment"><pre class="fragment"> tommy_hashslin hashlin;

 <a class="code" href="tommyhashlin_8h.html#a639fc97c94668bac0424691c6a5094cb" title="Initializes the hashtable.">tommy_hashlin_init</a>(&amp;hashlin);
</pre></div><p>To insert elements in the hashtable you have to call <a class="el" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957" title="Inserts an element in the the hashtable.">tommy_hashlin_insert()</a> for each element. In the insertion call you have to specify the address of the node, the address of the object, and the hash value of the key to use. The address of the object is used to initialize the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer at the object containing the node.">tommy_node::data</a> field of the node, and the hash to initialize the <a class="el" href="structtommy__node__struct.html#a124aaecab9e5d3d1fbb9239dac779d23" title="Key used to store the node.">tommy_node::key</a> field.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
     <span class="comment">// other fields</span>
     <span class="keywordtype">int</span> value;
 };

 <span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>)); <span class="comment">// creates the object</span>

 obj-&gt;value = ...; <span class="comment">// initializes the object</span>

 <a class="code" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957" title="Inserts an element in the the hashtable.">tommy_hashlin_insert</a>(&amp;hashlin, &amp;obj-&gt;node, obj, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer hash of 32 bits.">tommy_inthash_u32</a>(obj-&gt;value)); <span class="comment">// inserts the object</span>
</pre></div><p>To find and element in the hashtable you have to call <a class="el" href="tommyhashtbl_8h.html#a64a8d1e5598f86042de62cb2b1640c57" title="Searches an element in the hashtable.">tommy_hashtable_search()</a> providing a comparison function, its argument, and the hash of the key to search.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> compare(<span class="keyword">const</span> <span class="keywordtype">void</span>* arg, <span class="keyword">const</span> <span class="keywordtype">void</span>* obj)
 {
     <span class="keywordflow">return</span> (*(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>*)arg != ((<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keywordtype">object</span>*)obj)-&gt;value;
 }

 <span class="keyword">struct </span>object* obj = <a class="code" href="tommyhashlin_8h.html#add50b5a7780cf631fdaa083227b5a28f" title="Searches an element in the hashtable.">tommy_hashlin_search</a>(&amp;hashlin, compare, &amp;value_to_find, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer hash of 32 bits.">tommy_inthash_u32</a>(value_to_find));
 <span class="keywordflow">if</span> (!obj) {
     <span class="comment">// not found</span>
 } <span class="keywordflow">else</span> {
     <span class="comment">// found</span>
 }
</pre></div><p>To iterate over all the elements in the hashtable with the same key, you have to use <a class="el" href="tommyhashlin_8h.html#a2841df6043a5de8b4e47451748d4cfb2" title="Gets the bucket of the specified hash.">tommy_hashlin_bucket()</a> and follow the <a class="el" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">tommy_node::next</a> pointer until NULL. You have also to check explicitely for the key, as the bucket may contains different keys.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a>* i = <a class="code" href="tommyhashlin_8h.html#a2841df6043a5de8b4e47451748d4cfb2" title="Gets the bucket of the specified hash.">tommy_hashlin_bucket</a>(&amp;hashlin, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer hash of 32 bits.">tommy_inthash_u32</a>(value_to_find));
 <span class="keywordflow">while</span> (i) {
     <span class="keyword">struct </span>object* obj = i-&gt;<a class="code" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer at the object containing the node.">data</a>; <span class="comment">// gets the object pointer</span>

     <span class="keywordflow">if</span> (obj-&gt;value == value_to_find) {
         printf(<span class="stringliteral">&quot;%d\n&quot;</span>, obj-&gt;value); <span class="comment">// process the object</span>
     }

     i = i-&gt;<a class="code" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">next</a>; <span class="comment">// goes to the next element</span>
 }
</pre></div><p>To remove an element from the hashtable you have to call <a class="el" href="tommyhashlin_8h.html#a66b7beb2b99431bb90e987bb8f068415" title="Searches and removes an element from the hashtable.">tommy_hashlin_remove()</a> providing a comparison function, its argument, and the hash of the key to search and remove.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object* obj = <a class="code" href="tommytrie_8h.html#a47ed46af4087783c351172280d03ed6b" title="Searches and removes the first element with the specified key.">tommy_trie_remove</a>(&amp;hashtable, compare, &amp;value_to_remove, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer hash of 32 bits.">tommy_inthash_u32</a>(value_to_remove));
 <span class="keywordflow">if</span> (obj) {
     free(obj); <span class="comment">// frees the object allocated memory</span>
 }
</pre></div><p>To destroy the hashtable you have to remove all the elements, and deinitialize the hashtable calling <a class="el" href="tommyhashlin_8h.html#af49c4514766dab75ad2157fcd39d1f1f" title="Deinitializes the hashtable.">tommy_hashlin_done()</a>.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="tommyhashlin_8h.html#af49c4514766dab75ad2157fcd39d1f1f" title="Deinitializes the hashtable.">tommy_hashlin_done</a>(&amp;hashlin);
</pre></div><p>Note that you cannot iterates over all the elements in the hashtable using the hashtable itself. You have to insert all the elements also in a <a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list for collisions into hashtables.">tommy_list</a>, and use the list to iterate. See the <a class="el" href="multiindex.html">Tommy Multi Indexing</a> example for more detail. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a85850646f4dc979b7b213d8c58c13542"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_node" ref="a85850646f4dc979b7b213d8c58c13542" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtommy__node__struct.html">tommy_node</a> <a class="el" href="structtommy__node__struct.html">tommy_hashlin_node</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linear hashtable node. </p>
<p>This is the node that you have to include inside your objects. </p>

</div>
</div>
<a class="anchor" id="ad910f88af8bcd013a8e3cd30d528b904"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin" ref="ad910f88af8bcd013a8e3cd30d528b904" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin_struct</a>  <a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linear chained hashtable. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a639fc97c94668bac0424691c6a5094cb"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_init" ref="a639fc97c94668bac0424691c6a5094cb" args="(tommy_hashlin *hashlin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the hashtable. </p>

</div>
</div>
<a class="anchor" id="af49c4514766dab75ad2157fcd39d1f1f"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_done" ref="af49c4514766dab75ad2157fcd39d1f1f" args="(tommy_hashlin *hashlin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deinitializes the hashtable. </p>

</div>
</div>
<a class="anchor" id="ad51e1c6766cac604ed1545b5649ff957"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_insert" ref="ad51e1c6766cac604ed1545b5649ff957" args="(tommy_hashlin *hashlin, tommy_hashlin_node *node, void *data, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_hashlin_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an element in the the hashtable. </p>

</div>
</div>
<a class="anchor" id="a66b7beb2b99431bb90e987bb8f068415"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_remove" ref="a66b7beb2b99431bb90e987bb8f068415" args="(tommy_hashlin *hashlin, tommy_compare_func *cmp, const void *cmp_arg, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashlin_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a891b456a327f318340f65ce1bdff36be">tommy_compare_func</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches and removes an element from the hashtable. </p>
<p>You have to provide a compare function and the hash of the element you want to remove. If the element is not found, 0 is returned. If more equal elements are present, the first one is removed. This operation is faster than calling <a class="el" href="tommyhashlin_8h.html#a2841df6043a5de8b4e47451748d4cfb2" title="Gets the bucket of the specified hash.">tommy_hashlin_bucket()</a> and <a class="el" href="tommyhashlin_8h.html#afc35c9f3213033f7e814be4bc2a2aef6" title="Removes an element from the hashtable.">tommy_hashlin_remove_existing()</a> separately. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>Compare function called with cmp_arg as first argument and with the element to compare as a second one. The function should return 0 for equal elements, anything other for different elements. </td></tr>
    <tr><td class="paramname">cmp_arg</td><td>Compare argument passed as first argument of the compare function. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash of the element to find and remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The removed element, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2841df6043a5de8b4e47451748d4cfb2"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_bucket" ref="a2841df6043a5de8b4e47451748d4cfb2" args="(tommy_hashlin *hashlin, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtommy__node__struct.html">tommy_hashlin_node</a>* tommy_hashlin_bucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the bucket of the specified hash. </p>
<p>The bucket is guaranteed to contain ALL the elements with the specified hash, but it can contain also others. You can access elements in the bucket following the ::next pointer until 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>Hash of the element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The head of the bucket, or 0 if empty. </dd></dl>

</div>
</div>
<a class="anchor" id="add50b5a7780cf631fdaa083227b5a28f"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_search" ref="add50b5a7780cf631fdaa083227b5a28f" args="(tommy_hashlin *hashlin, tommy_compare_func *cmp, const void *cmp_arg, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashlin_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a891b456a327f318340f65ce1bdff36be">tommy_compare_func</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches an element in the hashtable. </p>
<p>You have to provide a compare function and the hash of the element you want to find. If more equal elements are present, the first one is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>Compare function called with cmp_arg as first argument and with the element to compare as a second one. The function should return 0 for equal elements, anything other for different elements. </td></tr>
    <tr><td class="paramname">cmp_arg</td><td>Compare argument passed as first argument of the compare function. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash of the element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first element found, or 0 if none. </dd></dl>

</div>
</div>
<a class="anchor" id="afc35c9f3213033f7e814be4bc2a2aef6"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_remove_existing" ref="afc35c9f3213033f7e814be4bc2a2aef6" args="(tommy_hashlin *hashlin, tommy_hashlin_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashlin_remove_existing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_hashlin_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an element from the hashtable. </p>
<p>You must already have the address of the element to remove. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer at the object containing the node.">tommy_node::data</a> field of the node removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0733a8787930ff45041ece00d5741b4f"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_count" ref="a0733a8787930ff45041ece00d5741b4f" args="(tommy_hashlin *hashlin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tommy_hashlin_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of elements. </p>

</div>
</div>
<a class="anchor" id="a35bd9d60d6f2039230aefefaaa8a8c1b"></a><!-- doxytag: member="tommyhashlin.h::tommy_hashlin_memory_usage" ref="a35bd9d60d6f2039230aefefaaa8a8c1b" args="(tommy_hashlin *hashlin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#a478b540a60cfc476cefc976c408c30cc">tommy_size_t</a> tommy_hashlin_memory_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of allocated memory. </p>
<p>It includes the size of the <a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542" title="Linear hashtable node.">tommy_hashlin_node</a> of the stored elements. </p>

</div>
</div>
</div>
</body>
</html>
