; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\am\Desktop\tommyds-1.4\benchmark.cc
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?tommy_le_uint32_read@@YAIPBX@Z			; tommy_le_uint32_read
PUBLIC	_tommy_list_tail
PUBLIC	_tommy_list_empty
PUBLIC	_tommy_ctz_u32
PUBLIC	?tommy_chain_splice@@YAXPAUtommy_node_struct@@000@Z ; tommy_chain_splice
PUBLIC	?tommy_chain_concat@@YAXPAUtommy_node_struct@@0@Z ; tommy_chain_concat
PUBLIC	?tommy_chain_merge@@YAXPAUtommy_chain_struct@@0P6AHPBX1@Z@Z ; tommy_chain_merge
PUBLIC	?tommy_chain_merge_degenerated@@YAXPAUtommy_chain_struct@@0P6AHPBX1@Z@Z ; tommy_chain_merge_degenerated
PUBLIC	?tommy_chain_mergesort@@YAXPAUtommy_chain_struct@@P6AHPBX1@Z@Z ; tommy_chain_mergesort
PUBLIC	?tommy_list_set@@YAXPAPAUtommy_node_struct@@PAU1@1@Z ; tommy_list_set
PUBLIC	?tommy_trie_inplace_list_insert_first@@YAPAUtommy_trie_inplace_node_struct@@PAU1@@Z ; tommy_trie_inplace_list_insert_first
PUBLIC	?tommy_trie_inplace_list_insert_tail_not_empty@@YAXPAUtommy_trie_inplace_node_struct@@0@Z ; tommy_trie_inplace_list_insert_tail_not_empty
PUBLIC	?tommy_trie_inplace_list_remove@@YAXPAPAUtommy_trie_inplace_node_struct@@PAU1@@Z ; tommy_trie_inplace_list_remove
PUBLIC	_tommy_roundup_pow2_u32
PUBLIC	?hashdyn_grow_step@@YAXPAUtommy_hashdyn_struct@@@Z ; hashdyn_grow_step
PUBLIC	?hashdyn_shrink_step@@YAXPAUtommy_hashdyn_struct@@@Z ; hashdyn_shrink_step
PUBLIC	_tommy_list_insert_tail
PUBLIC	_tommy_list_insert_first
PUBLIC	_tommy_list_insert_tail_not_empty
PUBLIC	?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_grow_step
PUBLIC	_tommy_list_head
PUBLIC	_tommy_list_remove_existing
PUBLIC	?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr
PUBLIC	_tommy_ilog2_u32
PUBLIC	?tommy_hashlin_pos@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_pos
PUBLIC	?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_shrink_step
PUBLIC	??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
PUBLIC	?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_factor
PUBLIC	?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_factor
PUBLIC	??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>
PUBLIC	??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings::Settings
PUBLIC	??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::KeyInfo
PUBLIC	??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
PUBLIC	??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_empty
PUBLIC	?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
PUBLIC	??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
PUBLIC	??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ; std::move<google_object * &>
PUBLIC	??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
PUBLIC	?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
PUBLIC	?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::squash_deleted
PUBLIC	?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_deleted
PUBLIC	?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
PUBLIC	?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
PUBLIC	??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
PUBLIC	??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,google_object *> >::allocator<std::pair<unsigned int const ,google_object *> >
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
PUBLIC	??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ; std::allocator<char>::allocator<char><std::pair<unsigned int const ,google_object *> >
PUBLIC	??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
PUBLIC	??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
PUBLIC	??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
PUBLIC	??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node><std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >
PUBLIC	??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
PUBLIC	??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node><std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > ><std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	_tommy_trie_count
PUBLIC	_tommy_trie_inplace_count
PUBLIC	_tommy_hashtable_count
PUBLIC	_tommy_hashdyn_count
PUBLIC	_tommy_hashlin_count
PUBLIC	??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::`scalar deleting destructor'
PUBLIC	?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
PUBLIC	?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::clear
PUBLIC	??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::~btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
PUBLIC	??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::~btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
PUBLIC	??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::`scalar deleting destructor'
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tidy
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
PUBLIC	??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Tidy
PUBLIC	??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Tidy
PUBLIC	??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
PUBLIC	??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
PUBLIC	??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
PUBLIC	??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator==
PUBLIC	?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
PUBLIC	??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator->
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator*
PUBLIC	??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator->
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator*
PUBLIC	??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator->
PUBLIC	_tommy_trie_search
PUBLIC	_tommy_trie_inplace_search
PUBLIC	_tommy_hashtable_bucket
PUBLIC	_tommy_hashtable_search
PUBLIC	_tommy_hashdyn_bucket
PUBLIC	_tommy_hashdyn_search
PUBLIC	_tommy_hashlin_search
PUBLIC	??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator!=
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator!=
PUBLIC	?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_deleted
PUBLIC	?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::max_size
PUBLIC	?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::max_size
PUBLIC	?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
PUBLIC	??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ; std::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
PUBLIC	??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z ; std::move<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > > &>
PUBLIC	??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ; std::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
PUBLIC	?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize
PUBLIC	??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue::operator()
PUBLIC	??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>
PUBLIC	??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator[]
PUBLIC	??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::generate_value
PUBLIC	?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_root_node
PUBLIC	??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
PUBLIC	??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int const ,google_object *>
PUBLIC	?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
PUBLIC	?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value
PUBLIC	?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split
PUBLIC	?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_node
PUBLIC	?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_internal
PUBLIC	?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_root
PUBLIC	?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_root_node
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_leaf
PUBLIC	?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_node
PUBLIC	?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split
PUBLIC	?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert
PUBLIC	??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *><unsigned int &,google_object *>
PUBLIC	??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int &,google_object *>
PUBLIC	??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z ; std::make_pair<unsigned int,google_object *>
PUBLIC	??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ; std::forward<google_object *>
PUBLIC	??$forward@I@std@@YA$$QAIAAI@Z			; std::forward<unsigned int>
PUBLIC	??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *><unsigned int,google_object *>
PUBLIC	??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *><unsigned int,google_object *>
PUBLIC	??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::operator*
PUBLIC	??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
PUBLIC	??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ; std::move<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
PUBLIC	??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
PUBLIC	??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
PUBLIC	??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
PUBLIC	??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
PUBLIC	??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::operator[]
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_size
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocate
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode
PUBLIC	??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
PUBLIC	??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
PUBLIC	??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *>
PUBLIC	?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::front
PUBLIC	?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same
PUBLIC	?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert_bucket
PUBLIC	?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::size
PUBLIC	?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::bucket_count
PUBLIC	?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::load_factor
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_load_factor
PUBLIC	?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::begin
PUBLIC	?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::end
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::deallocate
PUBLIC	??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z ; std::_Allocate<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate
PUBLIC	?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::size
PUBLIC	?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::capacity
PUBLIC	?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Grow_to
PUBLIC	??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ; std::_Construct<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
PUBLIC	?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
PUBLIC	??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
PUBLIC	??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
PUBLIC	??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Ufill
PUBLIC	?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Xlen
PUBLIC	?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Orphan_range
PUBLIC	??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const >
PUBLIC	??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ; std::_Val_type<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Umove<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ; std::_Fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ; std::fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
PUBLIC	?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::insert
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
PUBLIC	?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Make_iter
PUBLIC	??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ; std::_Destroy<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::destroy
PUBLIC	??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Destroy
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator!=
PUBLIC	??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
PUBLIC	??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::erase
PUBLIC	?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Assign_n
PUBLIC	?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::assign
PUBLIC	?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Init
PUBLIC	?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
PUBLIC	?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert
PUBLIC	?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::max_size
PUBLIC	?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::max_size
PUBLIC	?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
PUBLIC	??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
PUBLIC	??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
PUBLIC	?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
PUBLIC	?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::begin
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::max_size
PUBLIC	?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::max_size
PUBLIC	?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Incsize
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocate
PUBLIC	??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ; std::move<cpp_object * &>
PUBLIC	??$move@ABI@std@@YA$$QBIABI@Z			; std::move<unsigned int const &>
PUBLIC	??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
PUBLIC	??$forward@$$CBI@std@@YA$$QBIABI@Z		; std::forward<unsigned int const >
PUBLIC	??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ; std::forward<cpp_object *>
PUBLIC	??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *><unsigned int const ,cpp_object *>
PUBLIC	?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::construct
PUBLIC	??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ; std::forward<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *>,std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Insert_rv<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::emplace_front<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
PUBLIC	?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
PUBLIC	?max@?$numeric_limits@I@std@@SAIXZ		; std::numeric_limits<unsigned int>::max
PUBLIC	?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_factor
PUBLIC	?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_threshold
PUBLIC	?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
PUBLIC	?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::begin
PUBLIC	??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
PUBLIC	?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::allocate
PUBLIC	??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ; std::_Ptr_cat<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> >
PUBLIC	??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ; std::forward<std::pair<unsigned int const ,google_object *> const &>
PUBLIC	??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> const &>
PUBLIC	??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z ; std::_Destroy<std::pair<unsigned int const ,google_object *> >
PUBLIC	??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
PUBLIC	??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z ; std::uninitialized_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
PUBLIC	?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::fill_range_with_empty
PUBLIC	?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::reallocate
PUBLIC	?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::realloc_or_die
PUBLIC	?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_table
PUBLIC	?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size
PUBLIC	?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::inc_num_ht_copies
PUBLIC	?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
PUBLIC	??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
PUBLIC	?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
PUBLIC	?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
PUBLIC	??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator++
PUBLIC	??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator!=
PUBLIC	?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from
PUBLIC	?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::use_empty
PUBLIC	??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
PUBLIC	??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
PUBLIC	??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::deallocate
PUBLIC	?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::destroy_buckets
PUBLIC	??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::~libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
PUBLIC	??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::~ValInfo
PUBLIC	??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
PUBLIC	??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
PUBLIC	?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_value
PUBLIC	?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_threshold
PUBLIC	?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_threshold
PUBLIC	?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_size
PUBLIC	?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::reset_thresholds
PUBLIC	??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings &>
PUBLIC	??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings>
PUBLIC	??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo &>
PUBLIC	??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo>
PUBLIC	??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z ; std::_Move<std::pair<unsigned int const ,google_object *> * &>
PUBLIC	??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ; std::swap<std::pair<unsigned int const ,google_object *> *>
PUBLIC	?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
PUBLIC	?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_threshold
PUBLIC	?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@PBD@Z			; std::length_error::length_error
PUBLIC	?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_factor
PUBLIC	?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
PUBLIC	?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::consider_shrink
PUBLIC	?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
PUBLIC	?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
PUBLIC	?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::size
PUBLIC	?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
PUBLIC	?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
PUBLIC	?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::hash
PUBLIC	?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::hash
PUBLIC	??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int const &,unsigned int &>
PUBLIC	??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int const &,unsigned int &>
PUBLIC	??$forward@ABI@std@@YAABIABI@Z			; std::forward<unsigned int const &>
PUBLIC	??$forward@AAI@std@@YAAAIAAI@Z			; std::forward<unsigned int &>
PUBLIC	??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int &,unsigned int const &>
PUBLIC	??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int &,unsigned int const &>
PUBLIC	?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
PUBLIC	?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
PUBLIC	?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
PUBLIC	?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
PUBLIC	?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
PUBLIC	??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
PUBLIC	?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::equals
PUBLIC	?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::equals
PUBLIC	?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted_key
PUBLIC	??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey::operator()
PUBLIC	?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::get_key
PUBLIC	?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::get_key
PUBLIC	?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
PUBLIC	??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey::operator()
PUBLIC	?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::set_key
PUBLIC	?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_key
PUBLIC	?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted
PUBLIC	?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_consider_shrink
PUBLIC	?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
PUBLIC	?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
PUBLIC	??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator==
PUBLIC	?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
PUBLIC	??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator->
PUBLIC	?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::end
PUBLIC	?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end
PUBLIC	?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::key
PUBLIC	?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::compare_keys
PUBLIC	?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key_comp
PUBLIC	??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
PUBLIC	?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::key
PUBLIC	?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key
PUBLIC	?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z ; btree::btree_key_comparer<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> >,0>::bool_compare
PUBLIC	??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::linear_search_plain_compare<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
PUBLIC	?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z ; btree::btree_linear_search_plain_compare<unsigned int,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >::lower_bound
PUBLIC	??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::lower_bound<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
PUBLIC	??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
PUBLIC	??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
PUBLIC	??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree_internal_locate_plain_compare::dispatch<unsigned int,btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::find_unique
PUBLIC	?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::find
PUBLIC	?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
PUBLIC	?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment
PUBLIC	??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator++
PUBLIC	?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::is_root
PUBLIC	??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
PUBLIC	?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
PUBLIC	?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement
PUBLIC	??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
PUBLIC	??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
PUBLIC	??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
PUBLIC	?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end
PUBLIC	?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty
PUBLIC	?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
PUBLIC	?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
PUBLIC	?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left
PUBLIC	?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right
PUBLIC	?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::position
PUBLIC	?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_child
PUBLIC	?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_position
PUBLIC	?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_count
PUBLIC	?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value
PUBLIC	?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
PUBLIC	?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
PUBLIC	?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
PUBLIC	?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
PUBLIC	?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
PUBLIC	?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge_nodes
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
PUBLIC	?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance
PUBLIC	?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::parent
PUBLIC	?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::make_root
PUBLIC	??$_Move@AAI@std@@YA$$QAIAAI@Z			; std::_Move<unsigned int &>
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
PUBLIC	??$btree_swap_helper@I@btree@@YAXAAI0@Z		; btree::btree_swap_helper<unsigned int>
PUBLIC	??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ; std::_Move<google_object * &>
PUBLIC	??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z ; std::swap<google_object *>
PUBLIC	??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z ; btree::btree_swap_helper<google_object *>
PUBLIC	?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::swap
PUBLIC	?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_value
PUBLIC	?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_swap
PUBLIC	?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_child
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ	; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
PUBLIC	??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ	; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *>
PUBLIC	?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
PUBLIC	??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z ; std::_Move<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > * &>
PUBLIC	??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z ; std::swap<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
PUBLIC	??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z ; btree::btree_swap_helper<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
PUBLIC	??$_Move@AAE@std@@YA$$QAEAAE@Z			; std::_Move<unsigned char &>
PUBLIC	??$swap@E@std@@YAXAAE0@Z			; std::swap<unsigned char>
PUBLIC	??$btree_swap_helper@E@btree@@YAXAAE0@Z		; btree::btree_swap_helper<unsigned char>
PUBLIC	?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap
PUBLIC	?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_root
PUBLIC	?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_node
PUBLIC	?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
PUBLIC	?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_root_node
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_destroy
PUBLIC	?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::destroy
PUBLIC	?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_internal_allocator
PUBLIC	?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_leaf_node
PUBLIC	?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink
PUBLIC	?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase
PUBLIC	?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::erase
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::deallocate
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Color
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rmost
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Min
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z ; std::_Destroy<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::destroy
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
PUBLIC	??R?$less@I@std@@QBE_NABI0@Z			; std::less<unsigned int>::operator()
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Isnil
PUBLIC	??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Key
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Left
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Parent
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Root
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lbound
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::deallocate
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Make_iter
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
PUBLIC	??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ; std::_Destroy<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::destroy
PUBLIC	??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ; std::_Dest_val<std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>,std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
PUBLIC	?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::erase
PUBLIC	?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Prevnode
PUBLIC	??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
PUBLIC	??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase_bucket
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
PUBLIC	??R?$equal_to@I@std@@QBE_NABI0@Z		; std::equal_to<unsigned int>::operator()
PUBLIC	??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
PUBLIC	?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Begin
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
PUBLIC	?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::end
PUBLIC	?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
PUBLIC	?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_lo
PUBLIC	??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::operator[]
PUBLIC	?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_hi
PUBLIC	?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_End
PUBLIC	_tommy_inthash_u32
PUBLIC	??Rcpp_tommy_inthash_u32@@QBEII@Z		; cpp_tommy_inthash_u32::operator()
PUBLIC	??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
PUBLIC	?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hashval
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator!=
PUBLIC	?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Nextnode
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
PUBLIC	??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
PUBLIC	?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
PUBLIC	??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
PUBLIC	??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
PUBLIC	??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
PUBLIC	??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator==
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Myval
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator->
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator==
PUBLIC	?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Myval
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator->
PUBLIC	??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
PUBLIC	??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ	; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
PUBLIC	?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
PUBLIC	?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
PUBLIC	?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::max_count
PUBLIC	?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
PUBLIC	?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::leaf
PUBLIC	?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::count
PUBLIC	?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::child
PUBLIC	??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::node_stats
PUBLIC	??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::operator+=
PUBLIC	?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
PUBLIC	?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::bytes_used
PUBLIC	?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::bytes_used
PUBLIC	?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
PUBLIC	?TRIE_INPLACE@@3PAUtrie_inplace_object@@A	; TRIE_INPLACE
PUBLIC	?RBTREE@@3PAUrbt_object@@A			; RBTREE
PUBLIC	?HASHLIN@@3PAUhashtable_object@@A		; HASHLIN
PUBLIC	?RAND1@@3PAIA					; RAND1
PUBLIC	?JUDY@@3PAUjudy_object@@A			; JUDY
PUBLIC	?nedtrie@@3Unedtrie_t@@A			; nedtrie
PUBLIC	?HASHDYN@@3PAUhashtable_object@@A		; HASHDYN
PUBLIC	?JUDYARRAY@@3PAUjudyarray_object@@A		; JUDYARRAY
PUBLIC	?HASHTABLE@@3PAUhashtable_object@@A		; HASHTABLE
PUBLIC	?the_order@@3IA					; the_order
PUBLIC	?the_time@@3_KA					; the_time
PUBLIC	?hashdyn@@3Utommy_hashdyn_struct@@A		; hashdyn
PUBLIC	?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
PUBLIC	?trie_inplace@@3Utommy_trie_inplace_struct@@A	; trie_inplace
PUBLIC	?the_retry@@3IA					; the_retry
PUBLIC	?KHASH@@3PAUkhash_object@@A			; KHASH
PUBLIC	?trie@@3Utommy_trie_struct@@A			; trie
PUBLIC	?GOOGLE@@3PAUgoogle_object@@A			; GOOGLE
PUBLIC	?RAND0@@3PAIA					; RAND0
PUBLIC	?khash@@3PAUkh_word_t@@A			; khash
PUBLIC	?NEDTRIE@@3PAUnedtrie_object@@A			; NEDTRIE
PUBLIC	?trie_allocator@@3Utommy_allocator_struct@@A	; trie_allocator
PUBLIC	?CPP@@3PAUcpp_object@@A				; CPP
PUBLIC	?tree@@3Urbtree_t@@A				; tree
PUBLIC	?hashtable@@3Utommy_hashtable_struct@@A		; hashtable
PUBLIC	?the_operation@@3IA				; the_operation
PUBLIC	?TRIE@@3PAUtrie_object@@A			; TRIE
PUBLIC	?UTHASH@@3PAUuthash_object@@A			; UTHASH
PUBLIC	?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
PUBLIC	?the_log@@3HA					; the_log
PUBLIC	?the_max@@3IA					; the_max
PUBLIC	?LOG@@3PAY2P@15IA				; LOG
PUBLIC	?LAST@@3PAY01IA					; LAST
PUBLIC	?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
PUBLIC	?FORWARD@@3PAIA					; FORWARD
PUBLIC	?the_start_data@@3IA				; the_start_data
PUBLIC	?hashlin@@3Utommy_hashlin_struct@@A		; hashlin
PUBLIC	?CACHE@@3PAEA					; CACHE
PUBLIC	?the_data@@3IA					; the_data
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@D@std@@2HB	; std::numeric_limits<char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_W@std@@2HB	; std::numeric_limits<wchar_t>::max_digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_N@std@@2HB	; std::numeric_limits<bool>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@C@std@@2HB	; std::numeric_limits<signed char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@E@std@@2HB	; std::numeric_limits<unsigned char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@F@std@@2HB	; std::numeric_limits<short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@G@std@@2HB	; std::numeric_limits<unsigned short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@H@std@@2HB	; std::numeric_limits<int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@I@std@@2HB	; std::numeric_limits<unsigned int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@J@std@@2HB	; std::numeric_limits<long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@K@std@@2HB	; std::numeric_limits<unsigned long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_J@std@@2HB	; std::numeric_limits<__int64>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_K@std@@2HB	; std::numeric_limits<unsigned __int64>::max_digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?JudySize@@3PAHA				; JudySize
PUBLIC	?JudyMask@@3PAIA				; JudyMask
PUBLIC	?uthash@@3PAUuthash_object@@A			; uthash
PUBLIC	?judy@@3PAXA					; judy
PUBLIC	?judyarray@@3PAUJudy@@A				; judyarray
PUBLIC	?SEED@@3_KA					; SEED
PUBLIC	?OPERATION_NAME@@3PAPBDA			; OPERATION_NAME
PUBLIC	?ORDER_NAME@@3PAPBDA				; ORDER_NAME
PUBLIC	?DATA_NAME@@3PAPBDA				; DATA_NAME
PUBLIC	?ILLEGAL_BUCKET@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0IB ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ILLEGAL_BUCKET
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@	; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?HT_OCCUPANCY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_OCCUPANCY_PCT
PUBLIC	?HT_EMPTY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_EMPTY_PCT
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_C@_0BA@CGMABIOM@insert?5overflow?$AA@	; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
EXTRN	_memmove:PROC
EXTRN	_strncmp:PROC
EXTRN	_fopen:PROC
EXTRN	_sprintf:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	_calloc:PROC
EXTRN	_JudyLIns:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	_abort:PROC
EXTRN	_JudyLGet:PROC
EXTRN	_JudyLDel:PROC
EXTRN	___iob_func:PROC
EXTRN	_realloc:PROC
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_JudyLMemUsed:PROC
EXTRN	_fclose:PROC
EXTRN	_fprintf:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	_printf:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A DD 01H DUP (?) ; cppmap
?TRIE_INPLACE@@3PAUtrie_inplace_object@@A DD 01H DUP (?) ; TRIE_INPLACE
?RBTREE@@3PAUrbt_object@@A DD 01H DUP (?)		; RBTREE
?HASHLIN@@3PAUhashtable_object@@A DD 01H DUP (?)	; HASHLIN
?RAND1@@3PAIA DD 01H DUP (?)				; RAND1
?JUDY@@3PAUjudy_object@@A DD 01H DUP (?)		; JUDY
?nedtrie@@3Unedtrie_t@@A DB 088H DUP (?)		; nedtrie
?HASHDYN@@3PAUhashtable_object@@A DD 01H DUP (?)	; HASHDYN
?JUDYARRAY@@3PAUjudyarray_object@@A DD 01H DUP (?)	; JUDYARRAY
?HASHTABLE@@3PAUhashtable_object@@A DD 01H DUP (?)	; HASHTABLE
?the_order@@3IA DD 01H DUP (?)				; the_order
?the_time@@3_KA DQ 01H DUP (?)				; the_time
?hashdyn@@3Utommy_hashdyn_struct@@A DB 014H DUP (?)	; hashdyn
?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A DD 01H DUP (?) ; cppunorderedmap
?trie_inplace@@3Utommy_trie_inplace_struct@@A DB 0104H DUP (?) ; trie_inplace
?the_retry@@3IA DD 01H DUP (?)				; the_retry
?KHASH@@3PAUkhash_object@@A DD 01H DUP (?)		; KHASH
?trie@@3Utommy_trie_struct@@A DB 08cH DUP (?)		; trie
?GOOGLE@@3PAUgoogle_object@@A DD 01H DUP (?)		; GOOGLE
?RAND0@@3PAIA DD 01H DUP (?)				; RAND0
?khash@@3PAUkh_word_t@@A DD 01H DUP (?)			; khash
?NEDTRIE@@3PAUnedtrie_object@@A DD 01H DUP (?)		; NEDTRIE
?trie_allocator@@3Utommy_allocator_struct@@A DB 014H DUP (?) ; trie_allocator
?CPP@@3PAUcpp_object@@A DD 01H DUP (?)			; CPP
?tree@@3Urbtree_t@@A DB 020H DUP (?)			; tree
?hashtable@@3Utommy_hashtable_struct@@A DB 010H DUP (?)	; hashtable
?the_operation@@3IA DD 01H DUP (?)			; the_operation
?TRIE@@3PAUtrie_object@@A DD 01H DUP (?)		; TRIE
?UTHASH@@3PAUuthash_object@@A DD 01H DUP (?)		; UTHASH
?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A DD 01H DUP (?) ; googledensehash
?the_log@@3HA DD 01H DUP (?)				; the_log
?the_max@@3IA DD 01H DUP (?)				; the_max
?LOG@@3PAY2P@15IA DD 04ecH DUP (?)			; LOG
?LAST@@3PAY01IA DD 01eH DUP (?)				; LAST
?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A DD 01H DUP (?) ; googlebtree
?FORWARD@@3PAIA DD 01H DUP (?)				; FORWARD
?the_start_data@@3IA DD 01H DUP (?)			; the_start_data
?hashlin@@3Utommy_hashlin_struct@@A DB 0a4H DUP (?)	; hashlin
?CACHE@@3PAEA DB 0800000H DUP (?)			; CACHE
?the_data@@3IA DD 01H DUP (?)				; the_data
?uthash@@3PAUuthash_object@@A DD 01H DUP (?)		; uthash
?judy@@3PAXA DD	01H DUP (?)				; judy
?judyarray@@3PAUJudy@@A DD 01H DUP (?)			; judyarray
?SEED@@3_KA DQ	01H DUP (?)				; SEED
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
CONST	SEGMENT
??_C@_0BA@CGMABIOM@insert?5overflow?$AA@ DB 'insert overflow', 00H ; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?HT_EMPTY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB
CONST	SEGMENT
?HT_EMPTY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB DD 014H ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_EMPTY_PCT
CONST	ENDS
;	COMDAT ?HT_OCCUPANCY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB
CONST	SEGMENT
?HT_OCCUPANCY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB DD 032H ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_OCCUPANCY_PCT
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
CONST	SEGMENT
??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@ DB 'sparsehash'
	DB	': FATAL ERROR: failed to reallocate %lu elements for ptr %p', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@
CONST	SEGMENT
??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@ DB 'resize overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT ?ILLEGAL_BUCKET@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0IB
CONST	SEGMENT
?ILLEGAL_BUCKET@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0IB DD 0ffffffffH ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ILLEGAL_BUCKET
?JudySize@@3PAHA DD 040H				; JudySize
	DD	08H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	020H
?JudyMask@@3PAIA DD 00H					; JudyMask
	DD	0ffH
	DD	0ffffH
	DD	0ffffffH
	DD	0ffffffffH
	ORG $+16
?OPERATION_NAME@@3PAPBDA DD FLAT:$SG-77			; OPERATION_NAME
	DD	FLAT:$SG-78
	DD	FLAT:$SG-79
	DD	FLAT:$SG-80
	DD	FLAT:$SG-81
	DD	FLAT:$SG-82
?ORDER_NAME@@3PAPBDA DD FLAT:$SG-83			; ORDER_NAME
	DD	FLAT:$SG-84
?DATA_NAME@@3PAPBDA DD FLAT:$SG-85			; DATA_NAME
	DD	FLAT:$SG-86
	DD	FLAT:$SG-87
	DD	FLAT:$SG-88
	DD	FLAT:$SG-89
	DD	FLAT:$SG-90
	DD	FLAT:$SG-91
	DD	FLAT:$SG-92
	DD	FLAT:$SG-93
	DD	FLAT:$SG-94
	DD	FLAT:$SG-95
	DD	FLAT:$SG-96
	DD	FLAT:$SG-97
	DD	FLAT:$SG-98
	DD	FLAT:$SG-99
___ac_prime_list DD 00H
	DD	03H
	DD	0bH
	DD	017H
	DD	035H
	DD	061H
	DD	0c1H
	DD	0185H
	DD	0301H
	DD	0607H
	DD	0c07H
	DD	01807H
	DD	03001H
	DD	06011H
	DD	0c005H
	DD	01800dH
	DD	030005H
	DD	060019H
	DD	0c0001H
	DD	0180005H
	DD	030000bH
	DD	060000dH
	DD	0c00005H
	DD	01800013H
	DD	03000005H
	DD	06000017H
	DD	0c000013H
	DD	018000005H
	DD	030000059H
	DD	060000005H
	DD	0c0000001H
	DD	0fffffffbH
___ac_HASH_UPPER DQ 03fe8a3d70a3d70a4r		; 0.77
$SG-77	DB	'insert', 00H
	ORG $+1
$SG-78	DB	'hit', 00H
$SG-79	DB	'miss', 00H
	ORG $+3
$SG-80	DB	'size', 00H
	ORG $+3
$SG-81	DB	'change', 00H
	ORG $+1
$SG-82	DB	'remove', 00H
	ORG $+1
$SG-83	DB	'forward', 00H
$SG-84	DB	'random', 00H
	ORG $+1
$SG-85	DB	'tommy-hashtable', 00H
$SG-86	DB	'tommy-hashdyn', 00H
	ORG $+2
$SG-87	DB	'tommy-hashlin', 00H
	ORG $+2
$SG-88	DB	'tommy-trie', 00H
	ORG $+1
$SG-89	DB	'tommy-trie-inplace', 00H
	ORG $+1
$SG-90	DB	'rbtree', 00H
	ORG $+1
$SG-91	DB	'nedtrie', 00H
$SG-92	DB	'khash', 00H
	ORG $+2
$SG-93	DB	'uthash', 00H
	ORG $+1
$SG-94	DB	'judy', 00H
	ORG $+3
$SG-95	DB	'judyarray', 00H
	ORG $+2
$SG-96	DB	'googledensehash', 00H
$SG-97	DB	'googlebtree', 00H
$SG-98	DB	'c++unorderedmap', 00H
$SG-99	DB	'c++map', 00H
	ORG $+1
$SG-100	DB	'%10s, %10s, %12s, ', 00H
	ORG $+1
$SG-101	DB	'%4u [ns]', 0aH, 00H
	ORG $+2
$SG-102	DB	'%10s, %10s, %12s, ', 00H
	ORG $+1
$SG-103	DB	'%4u [byte]', 0aH, 00H
$SG-104	DB	'dat_%s_%s.lst', 00H
	ORG $+2
$SG-105	DB	'JudyLIns', 00H
	ORG $+3
$SG-106	DB	'benchmark.cc', 00H
	ORG $+3
$SG-107	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-108	DB	'JudyLDel', 00H
	ORG $+3
$SG-109	DB	'benchmark.cc', 00H
	ORG $+3
$SG-110	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-111	DB	'JudyLIns', 00H
	ORG $+3
$SG-112	DB	'benchmark.cc', 00H
	ORG $+3
$SG-113	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-114	DB	'JudyLDel', 00H
	ORG $+3
$SG-115	DB	'benchmark.cc', 00H
	ORG $+3
$SG-116	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-117	DB	'wt', 00H
	ORG $+1
$SG-118	DB	'0', 09H, 00H
	ORG $+1
$SG-119	DB	'%s', 09H, 00H
$SG-120	DB	0aH, 00H
	ORG $+2
$SG-121	DB	'%d %s %s', 00H
	ORG $+3
$SG-122	DB	' (skipped, too slow)', 0aH, 00H
	ORG $+2
$SG-123	DB	0aH, 00H
	ORG $+2
$SG-124	DB	'at', 00H
	ORG $+1
$SG-125	DB	'%u', 09H, 00H
$SG-126	DB	'%u', 09H, 00H
$SG-127	DB	0aH, 00H
	ORG $+2
$SG-128	DB	'Cache miss %d [ns]', 0aH, 00H
$SG-129	DB	'Tommy benchmark program.', 0aH, 00H
	ORG $+2
$SG-130	DB	'-l', 00H
	ORG $+1
$SG-131	DB	'-s', 00H
	ORG $+1
$SG-132	DB	'-m', 00H
	ORG $+1
$SG-133	DB	'-n', 00H
	ORG $+1
$SG-134	DB	'-N', 00H
	ORG $+1
$SG-135	DB	'Missing data in %s', 0aH, 00H
$SG-136	DB	'-d', 00H
	ORG $+1
$SG-137	DB	'Missing data in %s', 0aH, 00H
$SG-138	DB	'Unknown data %s', 0aH, 00H
	ORG $+3
$SG-139	DB	'Unknown option %s', 0aH, 00H
	ORG $+1
$SG-140	DB	'OK', 0aH, 00H
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 08H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_K@std@@2HB DD 015H	; std::numeric_limits<unsigned __int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_J@std@@2HB DD 014H	; std::numeric_limits<__int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@K@std@@2HB DD 0bH	; std::numeric_limits<unsigned long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@J@std@@2HB DD 0bH	; std::numeric_limits<long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@I@std@@2HB DD 0bH	; std::numeric_limits<unsigned int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@H@std@@2HB DD 0bH	; std::numeric_limits<int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@G@std@@2HB DD 06H	; std::numeric_limits<unsigned short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@F@std@@2HB DD 06H	; std::numeric_limits<short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@E@std@@2HB DD 04H	; std::numeric_limits<unsigned char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@C@std@@2HB DD 04H	; std::numeric_limits<signed char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_N@std@@2HB DD 00H	; std::numeric_limits<bool>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_W@std@@2HB DD 06H	; std::numeric_limits<wchar_t>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@D@std@@2HB DD 04H	; std::numeric_limits<char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 01H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
CONST	ENDS
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAE@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
??$_Move@AAE@std@@YA$$QAEAAE@Z PROC			; std::_Move<unsigned char &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAE@std@@YA$$QAEAAE@Z ENDP			; std::_Move<unsigned char &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z
_TEXT	SEGMENT
??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z PROC ; std::_Move<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > * &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z ENDP ; std::_Move<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@ABI@std@@YA$$QBIABI@Z
_TEXT	SEGMENT
??$move@ABI@std@@YA$$QBIABI@Z PROC			; std::move<unsigned int const &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@ABI@std@@YA$$QBIABI@Z ENDP			; std::move<unsigned int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z PROC ; std::forward<cpp_object *>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ENDP ; std::forward<cpp_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@$$CBI@std@@YA$$QBIABI@Z
_TEXT	SEGMENT
??$forward@$$CBI@std@@YA$$QBIABI@Z PROC			; std::forward<unsigned int const >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@$$CBI@std@@YA$$QBIABI@Z ENDP			; std::forward<unsigned int const >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@E@std@@YAXAAE0@Z
_TEXT	SEGMENT
??$swap@E@std@@YAXAAE0@Z PROC				; std::swap<unsigned char>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8a 11		 mov	 dl, BYTE PTR [ecx]
  00002	53		 push	 ebx

; 103  : 	_Left = _Move(_Right);

  00003	8a 18		 mov	 bl, BYTE PTR [eax]
  00005	88 19		 mov	 BYTE PTR [ecx], bl

; 104  : 	_Right = _Move(_Tmp);

  00007	88 10		 mov	 BYTE PTR [eax], dl
  00009	5b		 pop	 ebx

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@E@std@@YAXAAE0@Z ENDP				; std::swap<unsigned char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z
_TEXT	SEGMENT
??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z PROC ; std::swap<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z ENDP ; std::swap<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 136  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 137  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z PROC ; std::_Destroy<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z
_TEXT	SEGMENT
??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z PROC ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 202  : 		{	// construct from compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 203  : 		}

  0000a	c3		 ret	 0
??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z ENDP ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int const ,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z PROC ; std::_Move<google_object * &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ENDP ; std::_Move<google_object * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z PROC ; std::forward<std::pair<unsigned int const ,google_object *> const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ENDP ; std::forward<std::pair<unsigned int const ,google_object *> const &>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@E@btree@@YAXAAE0@Z
_TEXT	SEGMENT
??$btree_swap_helper@E@btree@@YAXAAE0@Z PROC		; btree::btree_swap_helper<unsigned char>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8a 11		 mov	 dl, BYTE PTR [ecx]
  00002	53		 push	 ebx
  00003	8a 18		 mov	 bl, BYTE PTR [eax]
  00005	88 19		 mov	 BYTE PTR [ecx], bl
  00007	88 10		 mov	 BYTE PTR [eax], dl
  00009	5b		 pop	 ebx

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@E@btree@@YAXAAE0@Z ENDP		; btree::btree_swap_helper<unsigned char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z
_TEXT	SEGMENT
??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z PROC ; btree::btree_swap_helper<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z ENDP ; btree::btree_swap_helper<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 2080 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	7c 02		 jl	 SHORT $LN4@max
  00006	8b c1		 mov	 eax, ecx
$LN4@max:

; 2081 : 	}

  00008	c3		 ret	 0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>, COMDAT
; _this$ = eax

; 126  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 127  : 		}

  0000d	c3		 ret	 0
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ PROC		; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *>, COMDAT
; _this$ = eax

; 183  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 184  : 		}

  0000d	c3		 ret	 0
??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ ENDP		; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ
_TEXT	SEGMENT
?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost, COMDAT
; _this$ = eax

; 546  :   btree_node** mutable_rightmost() { return &fields_.rightmost; }

  00000	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00005	c3		 ret	 0
?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z PROC ; std::move<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ENDP ; std::move<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z
_TEXT	SEGMENT
??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z PROC ; std::swap<google_object *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z ENDP ; std::swap<google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@I@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
??$forward@I@std@@YA$$QAIAAI@Z PROC			; std::forward<unsigned int>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@I@std@@YA$$QAIAAI@Z ENDP			; std::forward<unsigned int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z PROC ; std::forward<google_object *>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ENDP ; std::forward<google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned int const ,google_object *> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z
_TEXT	SEGMENT
??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z PROC ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ENDP ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z
_TEXT	SEGMENT
??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z PROC ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ENDP ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 2095 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00004	7c 02		 jl	 SHORT $LN4@min
  00006	8b c1		 mov	 eax, ecx
$LN4@min:

; 2096 : 	}

  00008	c3		 ret	 0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z
_TEXT	SEGMENT
?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_destroy, COMDAT

; 726  :     fields_.values[i].~mutable_value_type();
; 727  :   }

  00000	c3		 ret	 0
?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z
_TEXT	SEGMENT
?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_child, COMDAT
; _this$ = eax
; _i$ = ecx

; 573  :   btree_node** mutable_child(int i) { return &fields_.children[i]; }

  00000	8d 84 88 00 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx*4+256]
  00007	c3		 ret	 0
?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_child
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_count, COMDAT
; _this$ = eax

; 530  :   void set_count(int v) { fields_.count = v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 4d 08	 mov	 cl, BYTE PTR _v$[ebp]
  00006	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_position, COMDAT
; _this$ = eax

; 526  :   void set_position(int v) { fields_.position = v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 4d 08	 mov	 cl, BYTE PTR _v$[ebp]
  00006	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_position
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ
_TEXT	SEGMENT
?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::position, COMDAT
; _this$ = eax

; 525  :   int position() const { return fields_.position; }

  00000	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  00004	c3		 ret	 0
?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::position
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z PROC ; std::move<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > > &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z ENDP ; std::move<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > > &>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z
_TEXT	SEGMENT
??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z PROC ; btree::btree_swap_helper<google_object *>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z ENDP ; btree::btree_swap_helper<google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z PROC ; std::_Destroy<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ENDP ; std::_Destroy<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned int const ,cpp_object *> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z
_TEXT	SEGMENT
??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z PROC ; std::_Val_type<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ENDP ; std::_Val_type<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __Last$ = ecx
; __Dest$ = eax

; 2438 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]

; 2439 : 	while (_First != _Last)

  00006	3b d1		 cmp	 edx, ecx
  00008	74 16		 je	 SHORT $LN1@Copy_backw
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL2@Copy_backw:

; 2440 : 		*--_Dest = *--_Last;

  00010	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  00013	83 e9 04	 sub	 ecx, 4
  00016	83 e8 04	 sub	 eax, 4
  00019	89 30		 mov	 DWORD PTR [eax], esi
  0001b	3b ca		 cmp	 ecx, edx
  0001d	75 f1		 jne	 SHORT $LL2@Copy_backw
  0001f	5e		 pop	 esi
$LN1@Copy_backw:

; 2441 : 	return (_Dest);
; 2442 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z PROC ; std::_Fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Last$ = ecx
; __Val$ = edx

; 2690 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2691 : 	for (; _First != _Last; ++_First)

  00006	3b c1		 cmp	 eax, ecx
  00008	74 12		 je	 SHORT $LN1@Fill
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@Fill:

; 2692 : 		*_First = _Val;

  00010	8b 32		 mov	 esi, DWORD PTR [edx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c0 04	 add	 eax, 4
  00017	3b c1		 cmp	 eax, ecx
  00019	75 f5		 jne	 SHORT $LL3@Fill
  0001b	5e		 pop	 esi
$LN1@Fill:

; 2693 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ENDP ; std::_Fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z
_TEXT	SEGMENT
??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z PROC ; std::_Unchecked<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __Src$ = eax

; 267  : 	return (_Src);
; 268  : 	}

  00000	c3		 ret	 0
??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ENDP ; std::_Unchecked<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00006	3b ca		 cmp	 ecx, edx
  00008	74 15		 je	 SHORT $LN1@Move
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00010	8b 31		 mov	 esi, DWORD PTR [ecx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c1 04	 add	 ecx, 4
  00017	83 c0 04	 add	 eax, 4
  0001a	3b ca		 cmp	 ecx, edx
  0001c	75 f2		 jne	 SHORT $LL3@Move
  0001e	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z
_TEXT	SEGMENT
??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z PROC ; std::_Move<std::pair<unsigned int const ,google_object *> * &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z ENDP ; std::_Move<std::pair<unsigned int const ,google_object *> * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
??$_Move@AAI@std@@YA$$QAIAAI@Z PROC			; std::_Move<unsigned int &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::_Move<unsigned int &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z
_TEXT	SEGMENT
??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z PROC ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z ENDP ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z
_TEXT	SEGMENT
??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z PROC ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z ENDP ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@AAI@std@@YAAAIAAI@Z
_TEXT	SEGMENT
??$forward@AAI@std@@YAAAIAAI@Z PROC			; std::forward<unsigned int &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAI@std@@YAAAIAAI@Z ENDP			; std::forward<unsigned int &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABI@std@@YAABIABI@Z
_TEXT	SEGMENT
??$forward@ABI@std@@YAABIABI@Z PROC			; std::forward<unsigned int const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@ABI@std@@YAABIABI@Z ENDP			; std::forward<unsigned int const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z PROC ; std::_Ptr_cat<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> >, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ENDP ; std::_Ptr_cat<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z PROC ; std::allocator<char>::allocator<char><std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ENDP ; std::allocator<char>::allocator<char><std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::size, COMDAT
; _this$ = eax

; 877  : 		return (this->_Mysize);

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 878  : 		}

  00003	c3		 ret	 0
?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size, COMDAT
; _this$ = eax

; 389  : 		return (_List.size());

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 390  : 		}

  00003	c3		 ret	 0
?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z PROC ; std::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00007	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00014	8a 0a		 mov	 cl, BYTE PTR [edx]
  00016	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 146  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ENDP ; std::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = eax

; 38   : 		{	// construct with null node pointer

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00006	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_load_factor, COMDAT
; _this$ = eax

; 485  : 		return (_Max_bucket_size);

  00000	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]

; 486  : 		}

  00005	c3		 ret	 0
?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_load_factor
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::bucket_count, COMDAT
; _this$ = eax

; 423  : 		return (_Maxidx);

  00000	8b 40 24	 mov	 eax, DWORD PTR [eax+36]

; 424  : 		}

  00003	c3		 ret	 0
?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::bucket_count
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_size, COMDAT

; 874  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z PROC ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::key, COMDAT
; _x$ = eax

; 324  :   static const Key& key(const mutable_value_type &x) { return x.first; }

  00000	c3		 ret	 0
?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z ENDP ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::key
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::max_size, COMDAT

; 74   :     return static_cast<size_type>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 75   :   }

  00005	c3		 ret	 0
?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z PROC ; std::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00007	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00014	8a 0a		 mov	 cl, BYTE PTR [edx]
  00016	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 228  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ENDP ; std::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >, COMDAT
; _this$ = eax

; 208  : 		{	// construct with null node pointer

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00006	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size, COMDAT
; _this$ = eax

; 869  : 		return (this->_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_max_count$ = 12					; size = 4
?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_leaf, COMDAT
; _f$ = eax

; 686  :       leaf_fields *f, btree_node *parent, int max_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 687  :     btree_node *n = reinterpret_cast<btree_node*>(f);
; 688  :     f->leaf = 1;
; 689  :     f->position = 0;
; 690  :     f->max_count = max_count;

  00003	8a 55 0c	 mov	 dl, BYTE PTR _max_count$[ebp]
  00006	32 c9		 xor	 cl, cl

; 691  :     f->count = 0;

  00008	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 692  :     f->parent = parent;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  0000e	66 c7 00 01 00	 mov	 WORD PTR [eax], 1
  00013	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 693  :     if (!NDEBUG) {
; 694  :       memset(&f->values, 0, max_count * sizeof(value_type));
; 695  :     }
; 696  :     return n;
; 697  :   }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_leaf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z
_TEXT	SEGMENT
?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_value, COMDAT
; _this$ = eax
; _i$ = ecx

; 563  :     return &fields_.values[i];

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 564  :   }

  00004	c3		 ret	 0
?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z
_TEXT	SEGMENT
?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key, COMDAT
; _this$ = eax
; _i$ = ecx

; 554  :     return params_type::key(fields_.values[i]);

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 555  :   }

  00004	c3		 ret	 0
?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ
_TEXT	SEGMENT
?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size, COMDAT
; _this$ = eax

; 550  :   size_type* mutable_size() { return &fields_.size; }

  00000	05 84 01 00 00	 add	 eax, 388		; 00000184H
  00005	c3		 ret	 0
?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ
_TEXT	SEGMENT
?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_internal_allocator, COMDAT
; _this$ = eax

; 1235 :     return static_cast<internal_allocator_type*>(&root_);
; 1236 :   }

  00000	c3		 ret	 0
?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_internal_allocator
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ
_TEXT	SEGMENT
?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key_comp, COMDAT
; _this$ = eax

; 1117 :     return *this;
; 1118 :   }

  00000	c3		 ret	 0
?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key_comp
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::max_size, COMDAT

; 506  :   size_type max_size() const  { return val_info.max_size(); }

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  00005	c3		 ret	 0
?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::destroy
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ
_TEXT	SEGMENT
?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::key, COMDAT
; _this$ = eax

; 803  :     return node->key(position);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8d 44 ca 08	 lea	 eax, DWORD PTR [edx+ecx*8+8]

; 804  :   }

  00009	c3		 ret	 0
?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ
_TEXT	SEGMENT
?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::parent, COMDAT
; _this$ = eax

; 534  :   btree_node* parent() const { return fields_.parent; }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::parent
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z PROC ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >, COMDAT
; _this$ = eax

; 198  :       : Compare(c) {
; 199  :   }

  00000	c3		 ret	 0
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z ENDP ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_root, COMDAT
; _this$ = eax

; 1215 :   node_type** mutable_root() { return &root_.data; }

  00000	c3		 ret	 0
?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z PROC ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __First$ = edx
; __Last$ = ecx

; 2459 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Copy_backward(_First, _Last,
; 2461 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	3b d1		 cmp	 edx, ecx
  00008	74 16		 je	 SHORT $LN5@Copy_backw@2
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Copy_backw@2:
  00010	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  00013	83 e9 04	 sub	 ecx, 4
  00016	83 e8 04	 sub	 eax, 4
  00019	89 30		 mov	 DWORD PTR [eax], esi
  0001b	3b ca		 cmp	 ecx, edx
  0001d	75 f1		 jne	 SHORT $LL6@Copy_backw@2
  0001f	5e		 pop	 esi
$LN5@Copy_backw@2:

; 2462 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ENDP ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z PROC ; std::fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Last$ = ecx
; __Val$ = edx

; 2713 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2714 : 	_DEBUG_RANGE(_First, _Last);
; 2715 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

  00006	3b c1		 cmp	 eax, ecx
  00008	74 12		 je	 SHORT $LN7@fill
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL9@fill:
  00010	8b 32		 mov	 esi, DWORD PTR [edx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c0 04	 add	 eax, 4
  00017	3b c1		 cmp	 eax, ecx
  00019	75 f5		 jne	 SHORT $LL9@fill
  0001b	5e		 pop	 esi
$LN7@fill:

; 2716 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ENDP ; std::fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Val$ = eax

; 111  : 	return ((_Ty *) &(char&)_Val);
; 112  : 	}

  00000	c3		 ret	 0
??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const >, COMDAT
; __Val$ = eax

; 111  : 	return ((_Ty *) &(char&)_Val);
; 112  : 	}

  00000	c3		 ret	 0
??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z PROC ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	3b ca		 cmp	 ecx, edx
  00008	74 15		 je	 SHORT $LN5@Move@2
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL7@Move@2:
  00010	8b 31		 mov	 esi, DWORD PTR [ecx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c1 04	 add	 ecx, 4
  00017	83 c0 04	 add	 eax, 4
  0001a	3b ca		 cmp	 ecx, edx
  0001c	75 f2		 jne	 SHORT $LL7@Move@2
  0001e	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ENDP ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node><std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node><std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node><std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node><std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z
_TEXT	SEGMENT
??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z PROC ; std::swap<std::pair<unsigned int const ,google_object *> *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ENDP ; std::swap<std::pair<unsigned int const ,google_object *> *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z
_TEXT	SEGMENT
??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z PROC ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	57		 push	 edi

; 103  : 	_Left = _Move(_Right);

  00007	8b 38		 mov	 edi, DWORD PTR [eax]
  00009	89 39		 mov	 DWORD PTR [ecx], edi
  0000b	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000e	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 104  : 	_Right = _Move(_Tmp);
; 105  : 	}

  00011	5f		 pop	 edi
  00012	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00015	89 10		 mov	 DWORD PTR [eax], edx
  00017	5e		 pop	 esi
  00018	c3		 ret	 0
??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ENDP ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z
_TEXT	SEGMENT
??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z PROC ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);
; 103  : 	_Left = _Move(_Right);

  00000	f3 0f 7e 18	 movq	 xmm3, QWORD PTR [eax]
  00004	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00008	f3 0f 7e 49 08	 movq	 xmm1, QWORD PTR [ecx+8]
  0000d	f3 0f 7e 51 10	 movq	 xmm2, QWORD PTR [ecx+16]
  00012	66 0f d6 19	 movq	 QWORD PTR [ecx], xmm3
  00016	f3 0f 7e 58 08	 movq	 xmm3, QWORD PTR [eax+8]
  0001b	66 0f d6 59 08	 movq	 QWORD PTR [ecx+8], xmm3
  00020	f3 0f 7e 58 10	 movq	 xmm3, QWORD PTR [eax+16]
  00025	66 0f d6 59 10	 movq	 QWORD PTR [ecx+16], xmm3

; 104  : 	_Right = _Move(_Tmp);

  0002a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0002e	66 0f d6 48 08	 movq	 QWORD PTR [eax+8], xmm1
  00033	66 0f d6 50 10	 movq	 QWORD PTR [eax+16], xmm2

; 105  : 	}

  00038	c3		 ret	 0
??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ENDP ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z PROC ; std::move<cpp_object * &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ENDP ; std::move<cpp_object * &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>,std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>,std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > ><std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > ><std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>, COMDAT
; __Val$ = eax

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);
; 69   : 		}

  00000	c3		 ret	 0
??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z PROC ; std::move<google_object * &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ENDP ; std::move<google_object * &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z PROC ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>, COMDAT
; __Val$ = eax

; 69   : 		{	// extract key from element value
; 70   : 		return (_Val.first);
; 71   : 		}

  00000	c3		 ret	 0
??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = eax

; 111  : 	return ((_Ty *) &(char&)_Val);
; 112  : 	}

  00000	c3		 ret	 0
??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8a 11		 mov	 dl, BYTE PTR [ecx]
  00002	53		 push	 ebx

; 103  : 	_Left = _Move(_Right);

  00003	8a 18		 mov	 bl, BYTE PTR [eax]
  00005	88 19		 mov	 BYTE PTR [ecx], bl

; 104  : 	_Right = _Move(_Tmp);

  00007	88 10		 mov	 BYTE PTR [eax], dl
  00009	5b		 pop	 ebx

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Compat, COMDAT

; 253  : 		}

  00000	c3		 ret	 0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Compat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::max_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z
_TEXT	SEGMENT
?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::reallocate, COMDAT
; _p$ = edx
; _n$ = eax

; 70   :     return static_cast<pointer>(realloc(p, n * sizeof(value_type)));

  00000	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00007	51		 push	 ecx
  00008	52		 push	 edx
  00009	e8 00 00 00 00	 call	 _realloc
  0000e	83 c4 08	 add	 esp, 8

; 71   :   }

  00011	c3		 ret	 0
?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 204  : 		}

  00009	c3		 ret	 0
??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z
_TEXT	SEGMENT
?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Orphan_range, COMDAT

; 1454 : 		}

  00000	c3		 ret	 0
?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Orphan_range
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::capacity
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z
_TEXT	SEGMENT
?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::realloc_or_die, COMDAT
; _ptr$ = edi
; _n$ = esi

; 1142 :       pointer retval = this->reallocate(ptr, n);

  00000	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00007	50		 push	 eax
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 _realloc
  0000e	83 c4 08	 add	 esp, 8

; 1143 :       if (retval == NULL) {

  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN2@realloc_or

; 1144 :         // We really should use PRIuS here, but I don't want to have to add
; 1145 :         // a whole new configure option, with concomitant macro namespace
; 1146 :         // pollution, just to print this (unlikely) error message.  So I cast.
; 1147 :         fprintf(stderr, "sparsehash: FATAL ERROR: failed to reallocate "
; 1148 :                 "%lu elements for ptr %p",
; 1149 :                 static_cast<unsigned long>(n), ptr);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
  0001c	e8 00 00 00 00	 call	 ___iob_func
  00021	83 c0 40	 add	 eax, 64			; 00000040H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _fprintf
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1150 :         exit(1);

  0002d	6a 01		 push	 1
  0002f	e8 00 00 00 00	 call	 _exit
$LN7@realloc_or:
$LN2@realloc_or:

; 1151 :       }
; 1152 :       return retval;
; 1153 :     }

  00034	c3		 ret	 0
$LN6@realloc_or:
?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::realloc_or_die
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 209  : 		}

  00009	c3		 ret	 0
??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator!=
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 1
?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_table, COMDAT
; _new_size$ = edi

; 604  :                     true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00007	56		 push	 esi

; 605  :     table = val_info.realloc_or_die(table, new_size);

  00008	8b 73 34	 mov	 esi, DWORD PTR [ebx+52]
  0000b	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 _realloc
  00019	83 c4 08	 add	 esp, 8
  0001c	85 c0		 test	 eax, eax
  0001e	75 1f		 jne	 SHORT $LN3@resize_tab
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
  00027	e8 00 00 00 00	 call	 ___iob_func
  0002c	83 c0 40	 add	 eax, 64			; 00000040H
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _fprintf
  00035	83 c4 10	 add	 esp, 16			; 00000010H
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 _exit
$LN10@resize_tab:
$LN3@resize_tab:
  0003f	5e		 pop	 esi
  00040	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00043	5b		 pop	 ebx

; 606  :   }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN9@resize_tab:
?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_table
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey::operator(), COMDAT
; _value$ = eax
; _new_key$ = ecx

; 129  :       *const_cast<Key*>(&value->first) = new_key;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 130  :       // It would be nice to clear the rest of value here as well, in
; 131  :       // case it's taking up a lot of memory.  We do this by clearing
; 132  :       // the value.  This assumes T has a zero-arg constructor!
; 133  :       value->second = T();

  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 134  :     }

  0000b	c3		 ret	 0
??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey::operator()
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey::operator(), COMDAT
; _p$ = eax

; 124  :       return p.first;
; 125  :     }

  00000	c3		 ret	 0
??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey::operator()
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ
_TEXT	SEGMENT
?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::inc_num_ht_copies, COMDAT
; _this$ = eax

; 126  :     ++num_ht_copies_;

  00000	ff 40 14	 inc	 DWORD PTR [eax+20]

; 127  :   }

  00003	c3		 ret	 0
?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::inc_num_ht_copies
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z PROC ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>, COMDAT
; _this$ = eax

; 41   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z ENDP ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::set_key, COMDAT
; _v$ = eax
; _k$ = ecx

; 1196 :       SetKey::operator()(v, k);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1197 :     }

  0000b	c3		 ret	 0
?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::set_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::get_key, COMDAT
; _v$ = eax

; 1193 :       return ExtractKey::operator()(v);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1194 :     }

  00002	c3		 ret	 0
?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::get_key
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ
_TEXT	SEGMENT
?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::use_empty, COMDAT
; _this$ = eax

; 109  :     return use_empty_;

  00000	8a 40 11	 mov	 al, BYTE PTR [eax+17]

; 110  :   }

  00003	c3		 ret	 0
?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::use_empty
_TEXT	ENDS
PUBLIC	__real@3e4ccccd
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z
_TEXT	SEGMENT
?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_factor, COMDAT
; _this$ = eax

; 78   :     shrink_factor_ = f;

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00008	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 79   :   }

  0000d	c3		 ret	 0
?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_factor
_TEXT	ENDS
PUBLIC	__real@3f000000
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z
_TEXT	SEGMENT
?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_factor, COMDAT
; _this$ = eax

; 72   :     enlarge_factor_ = f;

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00008	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 73   :   }

  0000d	c3		 ret	 0
?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_factor
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::operator+=, COMDAT
; _this$ = eax
; _x$ = ecx

; 900  :       leaf_nodes += x.leaf_nodes;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	01 10		 add	 DWORD PTR [eax], edx

; 901  :       internal_nodes += x.internal_nodes;

  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	01 48 04	 add	 DWORD PTR [eax+4], ecx

; 902  :       return *this;
; 903  :     }

  0000a	c3		 ret	 0
??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::operator+=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::node_stats, COMDAT
; _this$ = eax
; _l$ = ecx

; 896  :           internal_nodes(i) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 897  :     }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::node_stats
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00000	c3		 ret	 0
??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000a	c2 04 00	 ret	 4
??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::operator[], COMDAT
; _this$ = eax
; __Pos$ = edx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 941  : 		}

  00005	c3		 ret	 0
??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::operator[]
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z
_TEXT	SEGMENT
?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::child, COMDAT
; _this$ = eax
; _i$ = ecx

; 572  :   btree_node* child(int i) const { return fields_.children[i]; }

  00000	8b 84 88 00 01
	00 00		 mov	 eax, DWORD PTR [eax+ecx*4+256]
  00007	c3		 ret	 0
?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::child
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ
_TEXT	SEGMENT
?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost, COMDAT
; _this$ = eax

; 545  :   btree_node* rightmost() const { return fields_.rightmost; }

  00000	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  00006	c3		 ret	 0
?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ
_TEXT	SEGMENT
?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::leaf, COMDAT
; _this$ = eax

; 522  :   bool leaf() const { return fields_.leaf; }

  00000	8a 00		 mov	 al, BYTE PTR [eax]
  00002	c3		 ret	 0
?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::leaf
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 131  : 		{	// construct by copying _Pair_base

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 132  : 		}

  0000a	c3		 ret	 0
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$equal_to@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$equal_to@I@std@@QBE_NABI0@Z PROC			; std::equal_to<unsigned int>::operator(), COMDAT
; __Left$ = eax
; __Right$ = edx

; 92   : 		return (_Left == _Right);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 93   : 		}

  00009	c3		 ret	 0
??R?$equal_to@I@std@@QBE_NABI0@Z ENDP			; std::equal_to<unsigned int>::operator()
_TEXT	ENDS
PUBLIC	__real@4f800000
;	COMDAT __real@4f800000
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\hashtable-common.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z
_TEXT	SEGMENT
tv71 = -12						; size = 8
tv131 = -8						; size = 4
tv68 = -8						; size = 4
tv129 = -2						; size = 2
?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size, COMDAT
; _this$ = ecx
; _x$ = eax

; 97   :   size_type shrink_size(size_type x) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 98   :     return static_cast<size_type>(x * shrink_factor_);

  00006	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax
  00009	db 45 f8	 fild	 DWORD PTR tv131[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@shrink_siz
  00010	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN3@shrink_siz:
  00016	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  00019	d9 7d fe	 fnstcw	 WORD PTR tv129[ebp]
  0001c	0f b7 45 fe	 movzx	 eax, WORD PTR tv129[ebp]
  00020	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00025	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00028	d9 6d f8	 fldcw	 WORD PTR tv68[ebp]
  0002b	df 7d f4	 fistp	 QWORD PTR tv71[ebp]
  0002e	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00031	d9 6d fe	 fldcw	 WORD PTR tv129[ebp]

; 99   :   }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z
_TEXT	SEGMENT
tv71 = -12						; size = 8
tv131 = -8						; size = 4
tv68 = -8						; size = 4
tv129 = -2						; size = 2
?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_size, COMDAT
; _this$ = ecx
; _x$ = eax

; 94   :   size_type enlarge_size(size_type x) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 95   :     return static_cast<size_type>(x * enlarge_factor_);

  00006	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax
  00009	db 45 f8	 fild	 DWORD PTR tv131[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@enlarge_si
  00010	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN3@enlarge_si:
  00016	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00019	d9 7d fe	 fnstcw	 WORD PTR tv129[ebp]
  0001c	0f b7 45 fe	 movzx	 eax, WORD PTR tv129[ebp]
  00020	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00025	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00028	d9 6d f8	 fldcw	 WORD PTR tv68[ebp]
  0002b	df 7d f4	 fistp	 QWORD PTR tv71[ebp]
  0002e	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00031	d9 6d fe	 fldcw	 WORD PTR tv129[ebp]

; 96   :   }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z
_TEXT	SEGMENT
?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_threshold, COMDAT
; _this$ = eax
; _t$ = ecx

; 91   :     shrink_threshold_ = t;

  00000	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 92   :   }

  00003	c3		 ret	 0
?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ
_TEXT	SEGMENT
?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_threshold, COMDAT
; _this$ = eax

; 88   :     return shrink_threshold_;

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 89   :   }

  00003	c3		 ret	 0
?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z
_TEXT	SEGMENT
?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_threshold, COMDAT
; _this$ = eax
; _t$ = ecx

; 85   :     enlarge_threshold_ = t;

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 86   :   }

  00002	c3		 ret	 0
?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ
_TEXT	SEGMENT
?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_threshold, COMDAT
; _this$ = eax

; 82   :     return enlarge_threshold_;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   :   }

  00002	c3		 ret	 0
?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ
_TEXT	SEGMENT
?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_factor, COMDAT
; _this$ = eax

; 75   :     return shrink_factor_;

  00000	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]

; 76   :   }

  00005	c3		 ret	 0
?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_factor
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ
_TEXT	SEGMENT
?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_factor, COMDAT
; _this$ = eax

; 69   :     return enlarge_factor_;

  00000	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]

; 70   :   }

  00005	c3		 ret	 0
?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_factor
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z
_TEXT	SEGMENT
??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>, COMDAT
; _this$ = eax

; 60   :     set_enlarge_factor(ht_occupancy_flt);

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00008	33 c9		 xor	 ecx, ecx
  0000a	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 61   :     set_shrink_factor(ht_empty_flt);

  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001c	66 89 48 10	 mov	 WORD PTR [eax+16], cx
  00020	88 48 12	 mov	 BYTE PTR [eax+18], cl
  00023	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00026	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 62   :   }

  0002b	c3		 ret	 0
??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 57   :   libc_allocator_with_realloc(const libc_allocator_with_realloc&) {}

  00000	c3		 ret	 0
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_key, COMDAT
; _v$ = eax
; _k$ = ecx

; 1218 :     key_info.set_key(v, k);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1219 :   }

  0000b	c3		 ret	 0
?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::get_key, COMDAT
; _v$ = eax

; 1215 :     return key_info.get_key(v);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1216 :   }

  00002	c3		 ret	 0
?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::get_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z PROC ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; ___that$ = ecx
  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000a	c3		 ret	 0
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ENDP ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = eax

; 93   : 		return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 94   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z PROC ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 151  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; _this$ = eax

; 512  : 		{	// construct empty vector with allocator

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 513  : 		}

  0000a	c3		 ret	 0
??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Myval, COMDAT
; __Pnode$ = eax

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00000	83 c0 08	 add	 eax, 8

; 572  : 		}

  00003	c3		 ret	 0
?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Myval
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z
_TEXT	SEGMENT
?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Prevnode, COMDAT
; __Pnode$ = eax

; 566  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	83 c0 04	 add	 eax, 4

; 567  : 		}

  00003	c3		 ret	 0
?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Prevnode
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z
_TEXT	SEGMENT
?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Nextnode, COMDAT
; __Pnode$ = eax

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);
; 562  : 		}

  00000	c3		 ret	 0
?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Nextnode
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = eax

; 502  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 503  : 		}

  00009	c3		 ret	 0
??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z PROC ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval1$ = eax
; __Keyval2$ = edx

; 159  : 		return (!_Keyeqobj(_Keyval1, _Keyval2));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 160  : 		}

  00009	c3		 ret	 0
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z ENDP ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z
_TEXT	SEGMENT
??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z PROC ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>, COMDAT
; _this$ = eax
; __Traits$ = ecx

; 42   : 		{	// construct with specified comparator

  00000	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00003	66 89 10	 mov	 WORD PTR [eax], dx

; 43   : 		}

  00006	c3		 ret	 0
??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_hi, COMDAT
; _this$ = eax
; __Bucket$ = edx

; 708  : 		return (_Vec[2 * _Bucket + 1]);

  00000	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00003	8d 44 d1 04	 lea	 eax, DWORD PTR [ecx+edx*8+4]

; 709  : 		}

  00007	c3		 ret	 0
?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_hi
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_lo, COMDAT
; _this$ = eax
; __Bucket$ = edx

; 698  : 		return (_Vec[2 * _Bucket]);

  00000	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00003	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]

; 699  : 		}

  00006	c3		 ret	 0
?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_lo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>, COMDAT
; _this$ = eax
; _n$ = ecx

; 769  :         position(p) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 770  :   }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ
_TEXT	SEGMENT
?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::max_count, COMDAT
; _this$ = eax

; 531  :   int max_count() const { return fields_.max_count; }

  00000	0f b6 40 02	 movzx	 eax, BYTE PTR [eax+2]
  00004	c3		 ret	 0
?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::max_count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ
_TEXT	SEGMENT
?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::count, COMDAT
; _this$ = eax

; 529  :   int count() const { return fields_.count; }

  00000	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00004	c3		 ret	 0
?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
$T164544 = -16						; size = 8
_this$ = -8						; size = 4
tv230 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_node$ = 12						; size = 4
?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats, COMDAT
; _this$ = ecx

; 1364 :   node_stats internal_stats(const node_type *node) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1365 :     if (!node) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  00009	53		 push	 ebx
  0000a	33 db		 xor	 ebx, ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00011	3b c3		 cmp	 eax, ebx
  00013	75 11		 jne	 SHORT $LN5@internal_s

; 1366 :       return node_stats(0, 0);

  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	89 18		 mov	 DWORD PTR [eax], ebx
  0001a	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 1376 :   }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN5@internal_s:

; 1367 :     }
; 1368 :     if (node->leaf()) {

  00026	38 18		 cmp	 BYTE PTR [eax], bl
  00028	74 15		 je	 SHORT $LN4@internal_s

; 1369 :       return node_stats(1, 0);

  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  00033	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 1376 :   }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN4@internal_s:

; 1370 :     }
; 1371 :     node_stats res(0, 1);

  0003f	33 f6		 xor	 esi, esi
  00041	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 1372 :     for (int i = 0; i <= node->count(); ++i) {

  00044	38 58 03	 cmp	 BYTE PTR [eax+3], bl
  00047	72 2f		 jb	 SHORT $LN1@internal_s

; 1370 :     }
; 1371 :     node_stats res(0, 1);

  00049	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0004e	89 45 fc	 mov	 DWORD PTR tv230[ebp], eax
$LN3@internal_s:

; 1373 :       res += internal_stats(node->child(i));

  00051	8b 45 fc	 mov	 eax, DWORD PTR tv230[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	50		 push	 eax
  00057	8d 4d f0	 lea	 ecx, DWORD PTR $T164544[ebp]
  0005a	51		 push	 ecx
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00063	03 30		 add	 esi, DWORD PTR [eax]
  00065	03 78 04	 add	 edi, DWORD PTR [eax+4]
  00068	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  0006b	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  0006f	83 45 fc 04	 add	 DWORD PTR tv230[ebp], 4
  00073	43		 inc	 ebx
  00074	3b d8		 cmp	 ebx, eax
  00076	7e d9		 jle	 SHORT $LN3@internal_s
$LN1@internal_s:

; 1374 :     }
; 1375 :     return res;

  00078	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007b	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1376 :   }

  0007e	5f		 pop	 edi
  0007f	89 30		 mov	 DWORD PTR [eax], esi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root, COMDAT
; _this$ = eax

; 1214 :   const node_type* root() const { return root_.data; }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root, COMDAT
; _this$ = eax

; 1213 :   node_type* root() { return root_.data; }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 151  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z
_TEXT	SEGMENT
??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::KeyInfo, COMDAT
; _this$ = eax

; 1191 :     }

  00000	c3		 ret	 0
??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::KeyInfo
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z
_TEXT	SEGMENT
?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_deleted, COMDAT
; _this$ = eax

; 119  :     use_deleted_ = t;

  00000	c6 40 12 01	 mov	 BYTE PTR [eax+18], 1

; 120  :   }

  00004	c3		 ret	 0
?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z
_TEXT	SEGMENT
?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_empty, COMDAT
; _this$ = eax

; 112  :     use_empty_ = t;

  00000	c6 40 11 01	 mov	 BYTE PTR [eax+17], 1

; 113  :   }

  00004	c3		 ret	 0
?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z
_TEXT	SEGMENT
?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_consider_shrink, COMDAT
; _this$ = eax
; _t$ = ecx

; 105  :     consider_shrink_ = t;

  00000	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 106  :   }

  00003	c3		 ret	 0
?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_consider_shrink
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ
_TEXT	SEGMENT
?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::consider_shrink, COMDAT
; _this$ = eax

; 102  :     return consider_shrink_;

  00000	8a 40 10	 mov	 al, BYTE PTR [eax+16]

; 103  :   }

  00003	c3		 ret	 0
?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::consider_shrink
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z
_TEXT	SEGMENT
??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings::Settings, COMDAT
; _this$ = eax

; 1181 :             hf, HT_OCCUPANCY_PCT / 100.0f, HT_EMPTY_PCT / 100.0f) {}

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00008	33 c9		 xor	 ecx, ecx
  0000a	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001c	66 89 48 10	 mov	 WORD PTR [eax+16], cx
  00020	88 48 12	 mov	 BYTE PTR [eax+18], cl
  00023	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00026	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  0002b	c3		 ret	 0
??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings::Settings
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z
_TEXT	SEGMENT
?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::allocate, COMDAT
; _n$ = eax

; 64   :     return static_cast<pointer>(malloc(n * sizeof(value_type)));

  00000	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _malloc
  0000d	83 c4 04	 add	 esp, 4

; 65   :   }

  00010	c3		 ret	 0
?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::allocate
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ
_TEXT	SEGMENT
?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::size, COMDAT
; _this$ = ecx

; 505  :   size_type size() const      { return num_elements - num_deleted; }

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	2b 41 20	 sub	 eax, DWORD PTR [ecx+32]
  00006	c3		 ret	 0
?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z
_TEXT	SEGMENT
??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::generate_value, COMDAT
; _this$ = eax
; _k$ = ecx

; 238  :     generate_value(const key_type &k)

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 239  :         : key(k) {
; 240  :     }

  00002	c3		 ret	 0
??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::generate_value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = eax

; 47   : 		return (_Mylist::_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 48   : 		}

  00005	c3		 ret	 0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*, COMDAT
; _this$ = eax

; 202  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 203  : 		if (this->_Getcont() == 0
; 204  : 			|| this->_Ptr == 0
; 205  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 206  : 			{	// report error
; 207  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 208  : 			_SCL_SECURE_OUT_OF_RANGE;
; 209  : 			}
; 210  : 
; 211  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 212  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 213  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 214  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 215  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 216  : 
; 217  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 218  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z PROC ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 234  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ENDP ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = eax

; 122  : 		return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*, COMDAT
; _this$ = eax

; 172  :   reference operator*() const { return *pos; }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*, COMDAT
; _this$ = eax

; 230  :   reference operator*() const { return *pos; }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ PROC ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >, COMDAT
; _this$ = eax

; 139  : 		{	// construct with default hasher and equality comparator
; 140  : 		}

  00000	c3		 ret	 0
??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ ENDP ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Myval
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 633  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Right
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 628  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Parent
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);
; 623  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Left
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 613  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Isnil
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 607  : 		return ((char&)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 608  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Color
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = eax

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rmost
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00011	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00013	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  0001c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00022	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00025	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00027	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1780 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00038	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003a	89 02		 mov	 DWORD PTR [edx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003c	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1780 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00045	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00048	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1780 : 		}

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>, COMDAT
; _this$ = eax
; _x$ = ecx

; 773  :         position(x.position) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 774  :   }

  0000a	c3		 ret	 0
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z
_TEXT	SEGMENT
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value, COMDAT
; _this$ = eax
; _i$ = ecx

; 560  :     return reinterpret_cast<const_reference>(fields_.values[i]);

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 561  :   }

  00004	c3		 ret	 0
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z
_TEXT	SEGMENT
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value, COMDAT
; _this$ = eax
; _i$ = ecx

; 557  :     return reinterpret_cast<reference>(fields_.values[i]);

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 558  :   }

  00004	c3		 ret	 0
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$less@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$less@I@std@@QBE_NABI0@Z PROC			; std::less<unsigned int>::operator(), COMDAT
; __Left$ = eax
; __Right$ = edx

; 125  : 		return (_Left < _Right);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 126  : 		}

  00008	c3		 ret	 0
??R?$less@I@std@@QBE_NABI0@Z ENDP			; std::less<unsigned int>::operator()
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ
_TEXT	SEGMENT
_stats$ = -8						; size = 8
?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::bytes_used, COMDAT
; _this$ = ecx

; 1173 :   size_type bytes_used() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1174 :     node_stats stats = internal_stats(root());

  00007	8b 31		 mov	 esi, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _stats$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats

; 1175 :     if (stats.leaf_nodes == 1 && stats.internal_nodes == 0) {

  00013	8b 45 f8	 mov	 eax, DWORD PTR _stats$[ebp]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _stats$[ebp+4]
  00019	83 f8 01	 cmp	 eax, 1
  0001c	75 14		 jne	 SHORT $LN2@bytes_used
  0001e	85 c9		 test	 ecx, ecx
  00020	75 10		 jne	 SHORT $LN2@bytes_used

; 1176 :       return sizeof(*this) +
; 1177 :           sizeof(base_fields) + root()->max_count() * sizeof(value_type);

  00022	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00026	8d 04 c5 0c 00
	00 00		 lea	 eax, DWORD PTR [eax*8+12]

; 1183 :     }
; 1184 :   }

  0002d	5e		 pop	 esi
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN2@bytes_used:

; 1178 :     } else {
; 1179 :       return sizeof(*this) +
; 1180 :           sizeof(root_fields) - sizeof(internal_fields) +
; 1181 :           stats.leaf_nodes * sizeof(leaf_fields) +
; 1182 :           stats.internal_nodes * sizeof(internal_fields);

  00032	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00035	c1 e1 07	 shl	 ecx, 7
  00038	c1 e0 08	 shl	 eax, 8
  0003b	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]

; 1183 :     }
; 1184 :   }

  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::bytes_used
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>, COMDAT
; _this$ = eax

; 126  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 127  : 		}

  0000d	c3		 ret	 0
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z PROC ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 234  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ENDP ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z
_TEXT	SEGMENT
?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::deallocate, COMDAT
; _p$ = eax

; 67   :     free(p);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 _free
  00006	59		 pop	 ecx

; 68   :   }

  00007	c3		 ret	 0
?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::deallocate
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count, COMDAT
; _this$ = eax

; 508  :   size_type bucket_count() const      { return num_buckets; }

  00000	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00003	c3		 ret	 0
?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z
_TEXT	SEGMENT
?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::destroy_buckets, COMDAT

; 358  :     for ( ; first != last; ++first)
; 359  :       table[first].~value_type();
; 360  :   }

  00000	c3		 ret	 0
?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::destroy_buckets
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00000	c3		 ret	 0
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator->, COMDAT
; _this$ = eax

; 52   : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 53   : 		}

  00005	c3		 ret	 0
??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 282  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 283  : 		if (this->_Getcont() == 0
; 284  : 			|| this->_Getcont() != _Right._Getcont())
; 285  : 			{	// report error
; 286  : 			_DEBUG_ERROR("list iterators incompatible");
; 287  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 288  : 			}
; 289  : 
; 290  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 291  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 292  : 			&& this->_Getcont() == _Right._Getcont());
; 293  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 294  : 
; 295  : 		return (this->_Ptr == _Right._Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 296  : 		}

  00009	c3		 ret	 0
??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 331  : 		}

  00009	c3		 ret	 0
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator->, COMDAT
; _this$ = eax

; 809  :     return &node->value(position);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8d 44 ca 08	 lea	 eax, DWORD PTR [edx+ecx*8+8]

; 810  :   }

  00009	c3		 ret	 0
??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z
_TEXT	SEGMENT
??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator!=, COMDAT
; _this$ = ecx
; _x$ = eax

; 798  :     return node != x.node || position != x.position;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	75 0b		 jne	 SHORT $LN3@operator
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	75 03		 jne	 SHORT $LN3@operator
  0000e	33 c0		 xor	 eax, eax

; 799  :   }

  00010	c3		 ret	 0
$LN3@operator:

; 798  :     return node != x.node || position != x.position;

  00011	b8 01 00 00 00	 mov	 eax, 1

; 799  :   }

  00016	c3		 ret	 0
??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z
_TEXT	SEGMENT
??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator==, COMDAT
; _this$ = ecx
; _x$ = eax

; 795  :     return node == x.node && position == x.position;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	75 0e		 jne	 SHORT $LN3@operator@2
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	75 06		 jne	 SHORT $LN3@operator@2
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 796  :   }

  00013	c3		 ret	 0
$LN3@operator@2:

; 795  :     return node == x.node && position == x.position;

  00014	33 c0		 xor	 eax, eax

; 796  :   }

  00016	c3		 ret	 0
??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>, COMDAT
; _this$ = eax
; _x$ = ecx

; 773  :         position(x.position) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 774  :   }

  0000a	c3		 ret	 0
??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z
_TEXT	SEGMENT
??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==, COMDAT
; _this$ = eax
; _it$ = edx

; 187  :   bool operator==(const iterator& it) const { return pos == it.pos; }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00008	0f 94 c0	 sete	 al
  0000b	c3		 ret	 0
??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->, COMDAT
; _this$ = eax

; 173  :   pointer operator->() const { return &(operator*()); }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z
_TEXT	SEGMENT
??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator!=, COMDAT
; _this$ = eax
; _it$ = edx

; 246  :   bool operator!=(const const_iterator& it) const { return pos != it.pos; }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00008	0f 95 c0	 setne	 al
  0000b	c3		 ret	 0
??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z
_TEXT	SEGMENT
??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==, COMDAT
; _this$ = eax
; _it$ = edx

; 245  :   bool operator==(const const_iterator& it) const { return pos == it.pos; }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00008	0f 94 c0	 sete	 al
  0000b	c3		 ret	 0
??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->, COMDAT
; _this$ = eax

; 231  :   pointer operator->() const { return &(operator*()); }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z
_TEXT	SEGMENT
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax
; _it$ = ecx

; 225  :     : ht(it.ht), pos(it.pos), end(it.end) { }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	c3		 ret	 0
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,google_object *> >::allocator<std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,google_object *> >::allocator<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator->, COMDAT
; _this$ = eax

; 809  :     return &node->value(position);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8d 44 ca 08	 lea	 eax, DWORD PTR [edx+ecx*8+8]

; 810  :   }

  00009	c3		 ret	 0
??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z
_TEXT	SEGMENT
??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator==, COMDAT
; _this$ = ecx
; _x$ = eax

; 795  :     return node == x.node && position == x.position;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	75 0e		 jne	 SHORT $LN3@operator@3
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	75 06		 jne	 SHORT $LN3@operator@3
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 796  :   }

  00013	c3		 ret	 0
$LN3@operator@3:

; 795  :     return node == x.node && position == x.position;

  00014	33 c0		 xor	 eax, eax

; 796  :   }

  00016	c3		 ret	 0
??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ
_TEXT	SEGMENT
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ PROC ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >, COMDAT
; _this$ = eax

; 195  :   btree_key_compare_to_adapter() { }

  00000	c3		 ret	 0
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ ENDP ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ
_TEXT	SEGMENT
_stats$164942 = -8					; size = 8
?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::bytes_used, COMDAT
; _this$ = ecx

; 111  :   size_type bytes_used() const { return tree_.bytes_used(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b 31		 mov	 esi, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _stats$164942[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00013	8b 45 f8	 mov	 eax, DWORD PTR _stats$164942[ebp]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _stats$164942[ebp+4]
  00019	83 f8 01	 cmp	 eax, 1
  0001c	75 14		 jne	 SHORT $LN4@bytes_used@2
  0001e	85 c9		 test	 ecx, ecx
  00020	75 10		 jne	 SHORT $LN4@bytes_used@2
  00022	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00026	8d 04 c5 0c 00
	00 00		 lea	 eax, DWORD PTR [eax*8+12]
  0002d	5e		 pop	 esi
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN4@bytes_used@2:
  00032	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00035	c1 e1 07	 shl	 ecx, 7
  00038	c1 e0 08	 shl	 eax, 8
  0003b	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::bytes_used
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ PROC	; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>, COMDAT
; _this$ = eax

; 183  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 184  : 		}

  0000d	c3		 ret	 0
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ ENDP	; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::~libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >, COMDAT

; 58   :   ~libc_allocator_with_realloc() {}

  00000	c3		 ret	 0
??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::~libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ
_TEXT	SEGMENT
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 56   :   libc_allocator_with_realloc() {}

  00000	c3		 ret	 0
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count, COMDAT
; _this$ = eax

; 223  :   size_type bucket_count() const      { return rep.bucket_count(); }

  00000	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00003	c3		 ret	 0
?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
_TEXT	ENDS
PUBLIC	?rbt_size@@YAIPAUrbtree_t@@I@Z			; rbt_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark.cc
;	COMDAT ?rbt_size@@YAIPAUrbtree_t@@I@Z
_TEXT	SEGMENT
?rbt_size@@YAIPAUrbtree_t@@I@Z PROC			; rbt_size, COMDAT

; 1992 : 	struct rbt_object element;
; 1993 : 	(void)tree;
; 1994 : 	return count * sizeof(element.link);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00005	03 c0		 add	 eax, eax
  00007	03 c0		 add	 eax, eax
  00009	03 c0		 add	 eax, eax

; 1995 : }

  0000b	c3		 ret	 0
?rbt_size@@YAIPAUrbtree_t@@I@Z ENDP			; rbt_size
_TEXT	ENDS
PUBLIC	?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z ; googlebtree_size
; Function compile flags: /Ogtp
;	COMDAT ?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z
_TEXT	SEGMENT
_stats$165005 = -8					; size = 8
?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z PROC ; googlebtree_size, COMDAT

; 1985 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  0000c	56		 push	 esi

; 1986 : 	return googlebtree->bytes_used();

  0000d	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000f	56		 push	 esi
  00010	8d 45 f8	 lea	 eax, DWORD PTR _stats$165005[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00019	8b 45 f8	 mov	 eax, DWORD PTR _stats$165005[ebp]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _stats$165005[ebp+4]
  0001f	83 f8 01	 cmp	 eax, 1
  00022	75 14		 jne	 SHORT $LN6@googlebtre
  00024	85 c9		 test	 ecx, ecx
  00026	75 10		 jne	 SHORT $LN6@googlebtre
  00028	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  0002c	8d 04 c5 0c 00
	00 00		 lea	 eax, DWORD PTR [eax*8+12]

; 1987 : }

  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0

; 1986 : 	return googlebtree->bytes_used();

$LN6@googlebtre:
  00038	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0003b	c1 e1 07	 shl	 ecx, 7
  0003e	c1 e0 08	 shl	 eax, 8
  00041	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]

; 1987 : }

  00045	5e		 pop	 esi
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z ENDP ; googlebtree_size
_TEXT	ENDS
PUBLIC	?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z ; googledensehash_size
; Function compile flags: /Ogtp
;	COMDAT ?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z
_TEXT	SEGMENT
?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z PROC ; googledensehash_size, COMDAT

; 1978 : 	googledensehash_t::value_type element;
; 1979 : 	return googledensehash->bucket_count() * sizeof(element);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00005	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00008	03 c0		 add	 eax, eax
  0000a	03 c0		 add	 eax, eax
  0000c	03 c0		 add	 eax, eax

; 1980 : }

  0000e	c3		 ret	 0
?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z ENDP ; googledensehash_size
_TEXT	ENDS
PUBLIC	?khash_size@@YAIPAUkh_word_t@@@Z		; khash_size
; Function compile flags: /Ogtp
;	COMDAT ?khash_size@@YAIPAUkh_word_t@@@Z
_TEXT	SEGMENT
?khash_size@@YAIPAUkh_word_t@@@Z PROC			; khash_size, COMDAT

; 1969 : {

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash

; 1970 : 	return khash->n_buckets * sizeof(void*) /* val */
; 1971 : 		+ khash->n_buckets * sizeof(uint32_t) /* key */
; 1972 : 		+ (khash->n_buckets >> 4) * sizeof(uint32_t); /* flags */

  00005	8b 00		 mov	 eax, DWORD PTR [eax]
  00007	8b c8		 mov	 ecx, eax
  00009	c1 e9 04	 shr	 ecx, 4
  0000c	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0000f	03 c0		 add	 eax, eax
  00011	03 c0		 add	 eax, eax

; 1973 : }

  00013	c3		 ret	 0
?khash_size@@YAIPAUkh_word_t@@@Z ENDP			; khash_size
_TEXT	ENDS
PUBLIC	?nedtrie_size@@YAIPAUnedtrie_t@@@Z		; nedtrie_size
; Function compile flags: /Ogtp
;	COMDAT ?nedtrie_size@@YAIPAUnedtrie_t@@@Z
_TEXT	SEGMENT
?nedtrie_size@@YAIPAUnedtrie_t@@@Z PROC			; nedtrie_size, COMDAT

; 1964 : 	struct nedtrie_object element;
; 1965 : 	return nedtrie->count * sizeof(element.link);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  00005	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00008	03 c0		 add	 eax, eax
  0000a	03 c0		 add	 eax, eax

; 1966 : }

  0000c	c3		 ret	 0
?nedtrie_size@@YAIPAUnedtrie_t@@@Z ENDP			; nedtrie_size
_TEXT	ENDS
PUBLIC	?uthash_size@@YAIPAUuthash_object@@@Z		; uthash_size
; Function compile flags: /Ogtp
;	COMDAT ?uthash_size@@YAIPAUuthash_object@@@Z
_TEXT	SEGMENT
?uthash_size@@YAIPAUuthash_object@@@Z PROC		; uthash_size, COMDAT

; 1951 : {

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash

; 1952 : 	UT_hash_table* table;
; 1953 : 	if (!obj)

  00005	85 c0		 test	 eax, eax
  00007	75 03		 jne	 SHORT $LN2@uthash_siz
$LN5@uthash_siz:

; 1954 : 		return 0;

  00009	33 c0		 xor	 eax, eax

; 1960 : }

  0000b	c3		 ret	 0
$LN2@uthash_siz:

; 1955 : 	table = obj->hh.tbl;

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 1956 : 	if (!table)

  0000e	85 c0		 test	 eax, eax

; 1957 : 		return 0;

  00010	74 f7		 je	 SHORT $LN5@uthash_siz

; 1958 : 	return table->num_buckets * (tommy_size_t)sizeof(table->buckets[0])
; 1959 : 		+ table->num_items * (tommy_size_t)sizeof(UT_hash_handle);

  00012	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	c1 e1 05	 shl	 ecx, 5
  0001b	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0001e	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 1960 : }

  00021	c3		 ret	 0
?uthash_size@@YAIPAUuthash_object@@@Z ENDP		; uthash_size
_TEXT	ENDS
PUBLIC	?order_done@@YAXXZ				; order_done
; Function compile flags: /Ogtp
;	COMDAT ?order_done@@YAXXZ
_TEXT	SEGMENT
?order_done@@YAXXZ PROC					; order_done, COMDAT

; 699  : 	free(FORWARD);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _free

; 700  : 	free(RAND0);

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RAND0@@3PAIA ; RAND0
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _free

; 701  : 	free(RAND1); 

  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _free
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : }

  00026	c3		 ret	 0
?order_done@@YAXXZ ENDP					; order_done
_TEXT	ENDS
PUBLIC	?cache_clear@@YAXXZ				; cache_clear
; Function compile flags: /Ogtp
;	COMDAT ?cache_clear@@YAXXZ
_TEXT	SEGMENT
?cache_clear@@YAXXZ PROC				; cache_clear, COMDAT

; 641  : 	unsigned i;
; 642  : 
; 643  : 	/* read & write */
; 644  : 	for(i=0;i<sizeof(CACHE);i += 32)

  00000	33 c0		 xor	 eax, eax
  00002	b1 01		 mov	 cl, 1
  00004	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL3@cache_clea:

; 645  : 		CACHE[i] += 1;

  00010	00 88 00 00 00
	00		 add	 BYTE PTR ?CACHE@@3PAEA[eax], cl
  00016	83 c0 20	 add	 eax, 32			; 00000020H
  00019	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0001e	72 f0		 jb	 SHORT $LL3@cache_clea

; 646  : 
; 647  : #ifdef WIN32
; 648  : 	Sleep(0);

  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 649  : #endif
; 650  : }

  00028	c3		 ret	 0
?cache_clear@@YAXXZ ENDP				; cache_clear
_TEXT	ENDS
PUBLIC	?open@@YAPAU_iobuf@@PBD@Z			; open
; Function compile flags: /Ogtp
;	COMDAT ?open@@YAPAU_iobuf@@PBD@Z
_TEXT	SEGMENT
_buf$ = -128						; size = 128
_mode$ = 8						; size = 4
?open@@YAPAU_iobuf@@PBD@Z PROC				; open, COMDAT

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 623  : 	char buf[128];
; 624  : 	sprintf(buf, "dat_%s_%s.lst", ORDER_NAME[the_order], OPERATION_NAME[the_operation]);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00008	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0000f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00015	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0001c	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8d 4d 80	 lea	 ecx, DWORD PTR _buf$[ebp]
  00027	68 00 00 00 00	 push	 OFFSET $SG-104
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _sprintf

; 625  : 	return fopen(buf, mode);

  00032	8b 55 08	 mov	 edx, DWORD PTR _mode$[ebp]
  00035	52		 push	 edx
  00036	8d 45 80	 lea	 eax, DWORD PTR _buf$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _fopen
  0003f	83 c4 18	 add	 esp, 24			; 00000018H

; 626  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?open@@YAPAU_iobuf@@PBD@Z ENDP				; open
_TEXT	ENDS
PUBLIC	?mem@@YAXII@Z					; mem
; Function compile flags: /Ogtp
;	COMDAT ?mem@@YAXII@Z
_TEXT	SEGMENT
?mem@@YAXII@Z PROC					; mem, COMDAT
; _data$ = eax
; _v$ = esi

; 605  : 	if (!the_log) {

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00007	75 3e		 jne	 SHORT $LN1@mem

; 606  : 		printf("%10s, %10s, %12s, ", ORDER_NAME[the_order], OPERATION_NAME[the_operation], DATA_NAME[data]);

  00009	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA[eax*4]
  00010	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA+12
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0001b	51		 push	 ecx
  0001c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00023	52		 push	 edx
  00024	51		 push	 ecx
  00025	68 00 00 00 00	 push	 OFFSET $SG-102
  0002a	e8 00 00 00 00	 call	 _printf

; 607  : 		printf("%4u [byte]\n", (unsigned)(v / the_max));

  0002f	33 d2		 xor	 edx, edx
  00031	8b c6		 mov	 eax, esi
  00033	f7 35 00 00 00
	00		 div	 DWORD PTR ?the_max@@3IA	; the_max
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET $SG-103
  0003f	e8 00 00 00 00	 call	 _printf
  00044	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@mem:

; 608  : 	} 
; 609  : 
; 610  : 	LOG[the_retry][the_data][the_order][the_operation] = (unsigned)(v / the_max);

  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0004d	33 d2		 xor	 edx, edx
  0004f	8b c6		 mov	 eax, esi
  00051	f7 35 00 00 00
	00		 div	 DWORD PTR ?the_max@@3IA	; the_max
  00057	8b d1		 mov	 edx, ecx
  00059	c1 e2 04	 shl	 edx, 4
  0005c	2b d1		 sub	 edx, ecx
  0005e	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?the_data@@3IA ; the_data
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  0006a	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  0006d	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00076	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00079	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2P@15IA[edx*4], eax

; 611  : }

  00080	c3		 ret	 0
?mem@@YAXII@Z ENDP					; mem
_TEXT	ENDS
PUBLIC	?is_select@@YAHI@Z				; is_select
; Function compile flags: /Ogtp
;	COMDAT ?is_select@@YAHI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?is_select@@YAHI@Z PROC					; is_select, COMDAT

; 571  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 572  : 	return the_data == data;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  00009	33 c0		 xor	 eax, eax
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR _data$[ebp]
  0000e	0f 94 c0	 sete	 al

; 573  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?is_select@@YAHI@Z ENDP					; is_select
_TEXT	ENDS
PUBLIC	?is_listed@@YAHI@Z				; is_listed
; Function compile flags: /Ogtp
;	COMDAT ?is_listed@@YAHI@Z
_TEXT	SEGMENT
?is_listed@@YAHI@Z PROC					; is_listed, COMDAT

; 561  : 	(void)data;
; 562  : 
; 563  : 	/* always have all the columns, we exclude them in the graphs */
; 564  : 	return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 565  : }

  00005	c3		 ret	 0
?is_listed@@YAHI@Z ENDP					; is_listed
_TEXT	ENDS
PUBLIC	?rnd@@YAII@Z					; rnd
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Ogtp
;	COMDAT ?rnd@@YAII@Z
_TEXT	SEGMENT
tv131 = -8						; size = 8
_max$ = 8						; size = 4
?rnd@@YAII@Z PROC					; rnd, COMDAT

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _max$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 425  : 
; 426  : 	/* it may happen as the divider is approximated down */
; 427  : 	if (r >= max)

  0000c	6a 00		 push	 0
  0000e	53		 push	 ebx
  0000f	6a ff		 push	 -1
  00011	6a ff		 push	 -1
  00013	e8 00 00 00 00	 call	 __aulldiv
  00018	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?SEED@@3_KA+4
  0001e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?SEED@@3_KA
  00024	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax
  00027	89 55 fc	 mov	 DWORD PTR tv131[ebp+4], edx
  0002a	8d 9b 00 00 00
	00		 npad	 6
$loop$144281:

; 411  : 	unsigned r;
; 412  : 	tommy_uint64_t divider;
; 413  :     
; 414  : loop:    
; 415  : 	/* linear congruential generator from MMIX by Donald Knuth, http://en.wikipedia.org/wiki/Linear_congruential_generator */
; 416  : #ifdef _MSC_VER
; 417  : 	divider = 0xFFFFFFFFFFFFFFFF / max;
; 418  : 	SEED = SEED * 6364136223846793005 + 1442695040888963407;

  00030	68 2d f4 51 58	 push	 1481765933		; 5851f42dH
  00035	68 2d 7f 95 4c	 push	 1284865837		; 4c957f2dH
  0003a	57		 push	 edi
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 __allmul

; 419  : #else
; 420  : 	divider = 0xFFFFFFFFFFFFFFFFULL / max;
; 421  : 	SEED = SEED * 6364136223846793005LL + 1442695040888963407LL;
; 422  : #endif
; 423  :  
; 424  : 	r = (unsigned)(SEED / divider);

  00041	8b 4d f8	 mov	 ecx, DWORD PTR tv131[ebp]
  00044	05 4f 81 67 f7	 add	 eax, -144211633		; f767814fH
  00049	8b f0		 mov	 esi, eax
  0004b	8b 45 fc	 mov	 eax, DWORD PTR tv131[ebp+4]
  0004e	50		 push	 eax
  0004f	81 d2 7e 7b 05
	14		 adc	 edx, 335903614		; 14057b7eH
  00055	51		 push	 ecx
  00056	8b fa		 mov	 edi, edx
  00058	57		 push	 edi
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 __aulldiv

; 425  : 
; 426  : 	/* it may happen as the divider is approximated down */
; 427  : 	if (r >= max)

  0005f	3b c3		 cmp	 eax, ebx
  00061	73 cd		 jae	 SHORT $loop$144281

; 428  : 		goto loop;
; 429  : 
; 430  : 	return r;
; 431  : }

  00063	89 3d 04 00 00
	00		 mov	 DWORD PTR ?SEED@@3_KA+4, edi
  00069	5f		 pop	 edi
  0006a	89 35 00 00 00
	00		 mov	 DWORD PTR ?SEED@@3_KA, esi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?rnd@@YAII@Z ENDP					; rnd
_TEXT	ENDS
EXTRN	__alldiv:PROC
EXTRN	__alldvrm:PROC
_win_frequency DQ 01H DUP (?)
; Function compile flags: /Ogtp
;	COMDAT ?nano@@YA_KXZ
_TEXT	SEGMENT
tv70 = -8						; size = 8
_t$ = -8						; size = 8
?nano@@YA_KXZ PROC					; nano, COMDAT

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 349  : 	tommy_uint64_t ret;
; 350  : #if defined(_WIN32)   
; 351  : 	LARGE_INTEGER t;
; 352  : 
; 353  : 	if (!QueryPerformanceCounter(&t))

  00009	8d 45 f8	 lea	 eax, DWORD PTR _t$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00013	85 c0		 test	 eax, eax
  00015	75 09		 jne	 SHORT $LN1@nano

; 354  : 		return 0;

  00017	33 d2		 xor	 edx, edx

; 359  : #elif defined(__MACH__)
; 360  : 	mach_timebase_info_data_t info;
; 361  : 	kern_return_t r;
; 362  : 	tommy_uint64_t t;
; 363  : 
; 364  : 	t = mach_absolute_time();
; 365  : 
; 366  : 	r = mach_timebase_info(&info);
; 367  : 	if (r != 0) {
; 368  : 		abort();
; 369  : 	}
; 370  : 
; 371  : 	ret = (t / info.denom) * info.numer;
; 372  : 	
; 373  : 	ret += (t % info.denom) * info.numer / info.denom;
; 374  : #elif defined(__linux)
; 375  : 	struct timespec ts;
; 376  : 	int r;
; 377  : 
; 378  : 	r = clock_gettime(CLOCK_MONOTONIC, &ts);
; 379  : 	if (r != 0) {
; 380  : 		abort();
; 381  : 	}
; 382  : 
; 383  : 	ret = ts.tv_sec * (tommy_uint64_t)1000000000 + ts.tv_nsec;
; 384  : #else
; 385  : 	struct timeval tv;
; 386  : 	int r;
; 387  : 
; 388  : 	r = gettimeofday(&tv, 0);
; 389  : 	if (r != 0) {
; 390  : 		abort();
; 391  : 	}
; 392  : 
; 393  : 	ret = tv.tv_sec * (tommy_uint64_t)1000000000 + tv.tv_usec * 1000;
; 394  : #endif
; 395  : 	return ret;
; 396  : }

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN1@nano:

; 355  : 
; 356  : 	ret = (t.QuadPart / win_frequency.QuadPart) * 1000000000;
; 357  : 
; 358  : 	ret += (t.QuadPart % win_frequency.QuadPart) * 1000000000 / win_frequency.QuadPart;

  00020	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00026	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp+4]
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  00032	56		 push	 esi
  00033	57		 push	 edi
  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 __alldvrm
  0003b	6a 00		 push	 0
  0003d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00042	53		 push	 ebx
  00043	51		 push	 ecx
  00044	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00047	89 55 fc	 mov	 DWORD PTR tv70[ebp+4], edx
  0004a	e8 00 00 00 00	 call	 __allmul
  0004f	56		 push	 esi
  00050	57		 push	 edi
  00051	52		 push	 edx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __alldiv
  00058	8b 4d f8	 mov	 ecx, DWORD PTR tv70[ebp]
  0005b	6a 00		 push	 0
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 45 fc	 mov	 eax, DWORD PTR tv70[ebp+4]
  00062	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	8b fa		 mov	 edi, edx
  0006b	e8 00 00 00 00	 call	 __allmul
  00070	03 c6		 add	 eax, esi
  00072	13 d7		 adc	 edx, edi

; 359  : #elif defined(__MACH__)
; 360  : 	mach_timebase_info_data_t info;
; 361  : 	kern_return_t r;
; 362  : 	tommy_uint64_t t;
; 363  : 
; 364  : 	t = mach_absolute_time();
; 365  : 
; 366  : 	r = mach_timebase_info(&info);
; 367  : 	if (r != 0) {
; 368  : 		abort();
; 369  : 	}
; 370  : 
; 371  : 	ret = (t / info.denom) * info.numer;
; 372  : 	
; 373  : 	ret += (t % info.denom) * info.numer / info.denom;
; 374  : #elif defined(__linux)
; 375  : 	struct timespec ts;
; 376  : 	int r;
; 377  : 
; 378  : 	r = clock_gettime(CLOCK_MONOTONIC, &ts);
; 379  : 	if (r != 0) {
; 380  : 		abort();
; 381  : 	}
; 382  : 
; 383  : 	ret = ts.tv_sec * (tommy_uint64_t)1000000000 + ts.tv_nsec;
; 384  : #else
; 385  : 	struct timeval tv;
; 386  : 	int r;
; 387  : 
; 388  : 	r = gettimeofday(&tv, 0);
; 389  : 	if (r != 0) {
; 390  : 		abort();
; 391  : 	}
; 392  : 
; 393  : 	ret = tv.tv_sec * (tommy_uint64_t)1000000000 + tv.tv_usec * 1000;
; 394  : #endif
; 395  : 	return ret;
; 396  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?nano@@YA_KXZ ENDP					; nano
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nano_init@@YAXXZ
_TEXT	SEGMENT
?nano_init@@YAXXZ PROC					; nano_init, COMDAT

; 340  : #if defined(_WIN32)
; 341  : 	if (!QueryPerformanceFrequency(&win_frequency)) {

  00000	68 00 00 00 00	 push	 OFFSET _win_frequency
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  0000b	85 c0		 test	 eax, eax
  0000d	75 0c		 jne	 SHORT $LN1@nano_init

; 342  : 		win_frequency.QuadPart = 0;

  0000f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00013	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR _win_frequency, xmm0
$LN1@nano_init:

; 343  : 	}
; 344  : #endif
; 345  : }

  0001b	c3		 ret	 0
?nano_init@@YAXXZ ENDP					; nano_init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_del_word@@YAXPAUkh_word_t@@I@Z
_TEXT	SEGMENT
?kh_del_word@@YAXPAUkh_word_t@@I@Z PROC			; kh_del_word, COMDAT
; _x$ = eax

; 286  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	56		 push	 esi
  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00007	3b 06		 cmp	 eax, DWORD PTR [esi]
  00009	74 2a		 je	 SHORT $LN1@kh_del_wor
  0000b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000e	8b c8		 mov	 ecx, eax
  00010	83 e0 0f	 and	 eax, 15			; 0000000fH
  00013	c1 e9 04	 shr	 ecx, 4
  00016	57		 push	 edi
  00017	8d 3c 00	 lea	 edi, DWORD PTR [eax+eax]
  0001a	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0001d	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00020	8b cf		 mov	 ecx, edi
  00022	d3 e8		 shr	 eax, cl
  00024	a8 03		 test	 al, 3
  00026	75 0c		 jne	 SHORT $LN4@kh_del_wor
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	d3 e0		 shl	 eax, cl
  0002f	09 02		 or	 DWORD PTR [edx], eax
  00031	ff 4e 04	 dec	 DWORD PTR [esi+4]
$LN4@kh_del_wor:
  00034	5f		 pop	 edi
$LN1@kh_del_wor:
  00035	5e		 pop	 esi
  00036	c3		 ret	 0
?kh_del_word@@YAXPAUkh_word_t@@I@Z ENDP			; kh_del_word
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@41f0000000000000
EXTRN	_memset:PROC
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?kh_resize_word@@YAXPAUkh_word_t@@I@Z
_TEXT	SEGMENT
tv552 = -28						; size = 8
tv558 = -24						; size = 4
tv397 = -24						; size = 4
_tmp$144117 = -20					; size = 4
_tmp$144115 = -20					; size = 4
tv554 = -16						; size = 4
_j$ = -16						; size = 4
_new_flags$ = -12					; size = 4
_val$144100 = -8					; size = 4
_key$144099 = -4					; size = 4
tv557 = -2						; size = 2
_new_n_buckets$ = 8					; size = 4
?kh_resize_word@@YAXPAUkh_word_t@@I@Z PROC		; kh_resize_word, COMDAT
; _h$ = edi

; 286  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _new_n_buckets$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  0000e	83 f9 fb	 cmp	 ecx, -5			; fffffffbH
  00011	73 0a		 jae	 SHORT $LN23@kh_resize_
$LL24@kh_resize_:
  00013	48		 dec	 eax
  00014	39 0c 85 00 00
	00 00		 cmp	 DWORD PTR ___ac_prime_list[eax*4], ecx
  0001b	77 f6		 ja	 SHORT $LL24@kh_resize_
$LN23@kh_resize_:
  0001d	56		 push	 esi
  0001e	8b 34 85 04 00
	00 00		 mov	 esi, DWORD PTR ___ac_prime_list[eax*4+4]
  00025	8b c6		 mov	 eax, esi
  00027	89 45 e8	 mov	 DWORD PTR tv558[ebp], eax
  0002a	db 45 e8	 fild	 DWORD PTR tv558[ebp]
  0002d	89 75 08	 mov	 DWORD PTR _new_n_buckets$[ebp], esi
  00030	85 c0		 test	 eax, eax
  00032	79 06		 jns	 SHORT $LN36@kh_resize_
  00034	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN36@kh_resize_:
  0003a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR ___ac_HASH_UPPER
  00040	d9 7d fe	 fnstcw	 WORD PTR tv557[ebp]
  00043	0f b7 45 fe	 movzx	 eax, WORD PTR tv557[ebp]
  00047	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  0004d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00052	89 45 f0	 mov	 DWORD PTR tv554[ebp], eax
  00055	d9 6d f0	 fldcw	 WORD PTR tv554[ebp]
  00058	df 7d e4	 fistp	 QWORD PTR tv552[ebp]
  0005b	8b 45 e4	 mov	 eax, DWORD PTR tv552[ebp]
  0005e	89 45 e8	 mov	 DWORD PTR tv397[ebp], eax
  00061	d9 6d fe	 fldcw	 WORD PTR tv557[ebp]
  00064	39 47 04	 cmp	 DWORD PTR [edi+4], eax
  00067	0f 83 c6 01 00
	00		 jae	 $LN18@kh_resize_
  0006d	8b ce		 mov	 ecx, esi
  0006f	c1 e9 04	 shr	 ecx, 4
  00072	53		 push	 ebx
  00073	8d 1c 8d 04 00
	00 00		 lea	 ebx, DWORD PTR [ecx*4+4]
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 _malloc
  00080	53		 push	 ebx
  00081	68 aa 00 00 00	 push	 170			; 000000aaH
  00086	50		 push	 eax
  00087	89 45 f4	 mov	 DWORD PTR _new_flags$[ebp], eax
  0008a	e8 00 00 00 00	 call	 _memset
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
  00092	39 37		 cmp	 DWORD PTR [edi], esi
  00094	73 24		 jae	 SHORT $LN33@kh_resize_
  00096	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00099	8d 1c b5 00 00
	00 00		 lea	 ebx, DWORD PTR [esi*4]
  000a0	53		 push	 ebx
  000a1	52		 push	 edx
  000a2	e8 00 00 00 00	 call	 _realloc
  000a7	89 47 14	 mov	 DWORD PTR [edi+20], eax
  000aa	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  000ad	53		 push	 ebx
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _realloc
  000b4	83 c4 10	 add	 esp, 16			; 00000010H
  000b7	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN33@kh_resize_:
  000ba	33 c0		 xor	 eax, eax
  000bc	89 45 f0	 mov	 DWORD PTR _j$[ebp], eax
  000bf	39 07		 cmp	 DWORD PTR [edi], eax
  000c1	0f 84 23 01 00
	00		 je	 $LN15@kh_resize_
$LL17@kh_resize_:
  000c7	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000ca	8b c8		 mov	 ecx, eax
  000cc	c1 e9 04	 shr	 ecx, 4
  000cf	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  000d2	8b 16		 mov	 edx, DWORD PTR [esi]
  000d4	8b c8		 mov	 ecx, eax
  000d6	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000d9	03 c9		 add	 ecx, ecx
  000db	d3 ea		 shr	 edx, cl
  000dd	f6 c2 03	 test	 dl, 3
  000e0	0f 85 f5 00 00
	00		 jne	 $LN35@kh_resize_
  000e6	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  000e9	8b 1c 82	 mov	 ebx, DWORD PTR [edx+eax*4]
  000ec	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  000ef	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  000f2	ba 01 00 00 00	 mov	 edx, 1
  000f7	d3 e2		 shl	 edx, cl
  000f9	89 45 f8	 mov	 DWORD PTR _val$144100[ebp], eax
  000fc	09 16		 or	 DWORD PTR [esi], edx
$LN37@kh_resize_:
  000fe	33 d2		 xor	 edx, edx
  00100	8b c3		 mov	 eax, ebx
  00102	f7 75 08	 div	 DWORD PTR _new_n_buckets$[ebp]
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _new_n_buckets$[ebp]
  00108	49		 dec	 ecx
  00109	8b c3		 mov	 eax, ebx
  0010b	89 5d fc	 mov	 DWORD PTR _key$144099[ebp], ebx
  0010e	8b 5d f4	 mov	 ebx, DWORD PTR _new_flags$[ebp]
  00111	8b f2		 mov	 esi, edx
  00113	33 d2		 xor	 edx, edx
  00115	f7 f1		 div	 ecx
  00117	8b c6		 mov	 eax, esi
  00119	c1 e8 04	 shr	 eax, 4
  0011c	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0011f	8b ce		 mov	 ecx, esi
  00121	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00124	03 c9		 add	 ecx, ecx
  00126	d3 e8		 shr	 eax, cl
  00128	a8 02		 test	 al, 2
  0012a	75 2f		 jne	 SHORT $LN9@kh_resize_
  0012c	8d 64 24 00	 npad	 4
$LL10@kh_resize_:
  00130	8b 4d 08	 mov	 ecx, DWORD PTR _new_n_buckets$[ebp]
  00133	8d 44 32 01	 lea	 eax, DWORD PTR [edx+esi+1]
  00137	3b c1		 cmp	 eax, ecx
  00139	72 09		 jb	 SHORT $LN8@kh_resize_
  0013b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0013e	2b c1		 sub	 eax, ecx
  00140	03 f0		 add	 esi, eax
  00142	eb 02		 jmp	 SHORT $LN7@kh_resize_
$LN8@kh_resize_:
  00144	8b f0		 mov	 esi, eax
$LN7@kh_resize_:
  00146	8b c6		 mov	 eax, esi
  00148	c1 e8 04	 shr	 eax, 4
  0014b	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0014e	8b ce		 mov	 ecx, esi
  00150	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00153	03 c9		 add	 ecx, ecx
  00155	d3 e8		 shr	 eax, cl
  00157	a8 02		 test	 al, 2
  00159	74 d5		 je	 SHORT $LL10@kh_resize_
$LN9@kh_resize_:
  0015b	8b 55 f4	 mov	 edx, DWORD PTR _new_flags$[ebp]
  0015e	8b ce		 mov	 ecx, esi
  00160	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00163	03 c9		 add	 ecx, ecx
  00165	bb 02 00 00 00	 mov	 ebx, 2
  0016a	8b c6		 mov	 eax, esi
  0016c	c1 e8 04	 shr	 eax, 4
  0016f	d3 e3		 shl	 ebx, cl
  00171	03 c0		 add	 eax, eax
  00173	03 c0		 add	 eax, eax
  00175	f7 d3		 not	 ebx
  00177	21 1c 10	 and	 DWORD PTR [eax+edx], ebx
  0017a	3b 37		 cmp	 esi, DWORD PTR [edi]
  0017c	73 48		 jae	 SHORT $LN34@kh_resize_
  0017e	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00181	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  00184	d3 ea		 shr	 edx, cl
  00186	f6 c2 03	 test	 dl, 3
  00189	75 3b		 jne	 SHORT $LN34@kh_resize_
  0018b	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0018e	8b 1c b2	 mov	 ebx, DWORD PTR [edx+esi*4]
  00191	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]
  00194	89 5d ec	 mov	 DWORD PTR _tmp$144115[ebp], ebx
  00197	8b 5d fc	 mov	 ebx, DWORD PTR _key$144099[ebp]
  0019a	89 1a		 mov	 DWORD PTR [edx], ebx
  0019c	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0019f	8b 5d ec	 mov	 ebx, DWORD PTR _tmp$144115[ebp]
  001a2	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]
  001a5	8b 32		 mov	 esi, DWORD PTR [edx]
  001a7	89 75 ec	 mov	 DWORD PTR _tmp$144117[ebp], esi
  001aa	8b 75 f8	 mov	 esi, DWORD PTR _val$144100[ebp]
  001ad	89 32		 mov	 DWORD PTR [edx], esi
  001af	8b 55 ec	 mov	 edx, DWORD PTR _tmp$144117[ebp]
  001b2	03 47 10	 add	 eax, DWORD PTR [edi+16]
  001b5	89 55 f8	 mov	 DWORD PTR _val$144100[ebp], edx
  001b8	ba 01 00 00 00	 mov	 edx, 1
  001bd	d3 e2		 shl	 edx, cl
  001bf	09 10		 or	 DWORD PTR [eax], edx
  001c1	e9 38 ff ff ff	 jmp	 $LN37@kh_resize_
$LN34@kh_resize_:
  001c6	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  001c9	8b 4d fc	 mov	 ecx, DWORD PTR _key$144099[ebp]
  001cc	89 0c b0	 mov	 DWORD PTR [eax+esi*4], ecx
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _val$144100[ebp]
  001d2	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  001d5	89 04 b2	 mov	 DWORD PTR [edx+esi*4], eax
  001d8	8b 45 f0	 mov	 eax, DWORD PTR _j$[ebp]
$LN35@kh_resize_:
  001db	8b 75 08	 mov	 esi, DWORD PTR _new_n_buckets$[ebp]
  001de	40		 inc	 eax
  001df	89 45 f0	 mov	 DWORD PTR _j$[ebp], eax
  001e2	3b 07		 cmp	 eax, DWORD PTR [edi]
  001e4	0f 85 dd fe ff
	ff		 jne	 $LL17@kh_resize_
$LN15@kh_resize_:
  001ea	39 37		 cmp	 DWORD PTR [edi], esi
  001ec	76 24		 jbe	 SHORT $LN1@kh_resize_
  001ee	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  001f1	8d 1c b5 00 00
	00 00		 lea	 ebx, DWORD PTR [esi*4]
  001f8	53		 push	 ebx
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 _realloc
  001ff	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  00202	53		 push	 ebx
  00203	52		 push	 edx
  00204	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00207	e8 00 00 00 00	 call	 _realloc
  0020c	83 c4 10	 add	 esp, 16			; 00000010H
  0020f	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN1@kh_resize_:
  00212	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 _free
  0021b	8b 4d f4	 mov	 ecx, DWORD PTR _new_flags$[ebp]
  0021e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00221	8b 45 e8	 mov	 eax, DWORD PTR tv397[ebp]
  00224	83 c4 04	 add	 esp, 4
  00227	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0022a	89 37		 mov	 DWORD PTR [edi], esi
  0022c	89 57 08	 mov	 DWORD PTR [edi+8], edx
  0022f	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00232	5b		 pop	 ebx
$LN18@kh_resize_:
  00233	5e		 pop	 esi
  00234	8b e5		 mov	 esp, ebp
  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
?kh_resize_word@@YAXPAUkh_word_t@@I@Z ENDP		; kh_resize_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_get_word@@YAIPAUkh_word_t@@I@Z
_TEXT	SEGMENT
tv225 = -4						; size = 4
_last$144062 = -4					; size = 4
_key$ = 8						; size = 4
?kh_get_word@@YAIPAUkh_word_t@@I@Z PROC			; kh_get_word, COMDAT

; 286  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 4d 08	 mov	 ecx, DWORD PTR _key$[ebp]
  00007	53		 push	 ebx
  00008	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  0000e	57		 push	 edi
  0000f	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00011	85 ff		 test	 edi, edi
  00013	0f 84 a1 00 00
	00		 je	 $LN8@kh_get_wor
  00019	8b c1		 mov	 eax, ecx
  0001b	33 d2		 xor	 edx, edx
  0001d	f7 f7		 div	 edi
  0001f	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  00022	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00025	89 45 fc	 mov	 DWORD PTR tv225[ebp], eax
  00028	8b c1		 mov	 eax, ecx
  0002a	56		 push	 esi
  0002b	8b f2		 mov	 esi, edx
  0002d	33 d2		 xor	 edx, edx
  0002f	f7 75 fc	 div	 DWORD PTR tv225[ebp]
  00032	8b c6		 mov	 eax, esi
  00034	c1 e8 04	 shr	 eax, 4
  00037	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0003a	8b ce		 mov	 ecx, esi
  0003c	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0003f	03 c9		 add	 ecx, ecx
  00041	d3 e8		 shr	 eax, cl
  00043	89 75 fc	 mov	 DWORD PTR _last$144062[ebp], esi
  00046	a8 02		 test	 al, 2
  00048	75 47		 jne	 SHORT $LN6@kh_get_wor
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL7@kh_get_wor:
  00050	a8 01		 test	 al, 1
  00052	75 10		 jne	 SHORT $LN5@kh_get_wor
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00059	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005c	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0005f	39 04 b1	 cmp	 DWORD PTR [ecx+esi*4], eax
  00062	74 2d		 je	 SHORT $LN6@kh_get_wor
$LN5@kh_get_wor:
  00064	8d 44 32 01	 lea	 eax, DWORD PTR [edx+esi+1]
  00068	3b c7		 cmp	 eax, edi
  0006a	72 09		 jb	 SHORT $LN4@kh_get_wor
  0006c	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0006f	2b cf		 sub	 ecx, edi
  00071	03 f1		 add	 esi, ecx
  00073	eb 02		 jmp	 SHORT $LN3@kh_get_wor
$LN4@kh_get_wor:
  00075	8b f0		 mov	 esi, eax
$LN3@kh_get_wor:
  00077	3b 75 fc	 cmp	 esi, DWORD PTR _last$144062[ebp]
  0007a	74 35		 je	 SHORT $LN14@kh_get_wor
  0007c	8b c6		 mov	 eax, esi
  0007e	c1 e8 04	 shr	 eax, 4
  00081	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  00084	8b ce		 mov	 ecx, esi
  00086	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00089	03 c9		 add	 ecx, ecx
  0008b	d3 e8		 shr	 eax, cl
  0008d	a8 02		 test	 al, 2
  0008f	74 bf		 je	 SHORT $LL7@kh_get_wor
$LN6@kh_get_wor:
  00091	8b d6		 mov	 edx, esi
  00093	8b ce		 mov	 ecx, esi
  00095	c1 ea 04	 shr	 edx, 4
  00098	8b 04 93	 mov	 eax, DWORD PTR [ebx+edx*4]
  0009b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0009e	03 c9		 add	 ecx, ecx
  000a0	d3 e8		 shr	 eax, cl
  000a2	a8 03		 test	 al, 3
  000a4	8b c7		 mov	 eax, edi
  000a6	75 02		 jne	 SHORT $LN15@kh_get_wor
  000a8	8b c6		 mov	 eax, esi
$LN15@kh_get_wor:
  000aa	5e		 pop	 esi
  000ab	5f		 pop	 edi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN14@kh_get_wor:
  000b1	5e		 pop	 esi
  000b2	8b c7		 mov	 eax, edi
  000b4	5f		 pop	 edi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN8@kh_get_wor:
  000ba	5f		 pop	 edi
  000bb	33 c0		 xor	 eax, eax
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?kh_get_word@@YAIPAUkh_word_t@@I@Z ENDP			; kh_get_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_destroy_word@@YAXPAUkh_word_t@@@Z
_TEXT	SEGMENT
?kh_destroy_word@@YAXPAUkh_word_t@@@Z PROC		; kh_destroy_word, COMDAT

; 286  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	56		 push	 esi
  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@kh_destroy
  0000b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _free
  00014	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _free
  0001d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 _free
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _free
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@kh_destroy:
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
?kh_destroy_word@@YAXPAUkh_word_t@@@Z ENDP		; kh_destroy_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_init_word@@YAPAUkh_word_t@@XZ
_TEXT	SEGMENT
?kh_init_word@@YAPAUkh_word_t@@XZ PROC			; kh_init_word, COMDAT

; 286  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	6a 1c		 push	 28			; 0000001cH
  00002	6a 01		 push	 1
  00004	e8 00 00 00 00	 call	 _calloc
  00009	83 c4 08	 add	 esp, 8
  0000c	c3		 ret	 0
?kh_init_word@@YAPAUkh_word_t@@XZ ENDP			; kh_init_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_nobblezeros@@YAHPAUnedtrie_t@@@Z
_TEXT	SEGMENT
?nedtrie_t_nobblezeros@@YAHPAUnedtrie_t@@@Z PROC	; nedtrie_t_nobblezeros, COMDAT

; 284  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	33 c0		 xor	 eax, eax
  00002	c3		 ret	 0
?nedtrie_t_nobblezeros@@YAHPAUnedtrie_t@@@Z ENDP	; nedtrie_t_nobblezeros
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_func@@YAIPBUnedtrie_object@@@Z
_TEXT	SEGMENT
?nedtrie_func@@YAIPBUnedtrie_object@@@Z PROC		; nedtrie_func, COMDAT
; _r$ = eax

; 281  : 	return r->value;

  00000	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 282  : }

  00003	c3		 ret	 0
?nedtrie_func@@YAIPBUnedtrie_object@@@Z ENDP		; nedtrie_func
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_new@@YAXPAUrbtree_t@@@Z
_TEXT	SEGMENT
?rbt_new@@YAXPAUrbtree_t@@@Z PROC			; rbt_new, COMDAT

; 275  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A+8
  00005	b9 04 00 00 00	 mov	 ecx, OFFSET ?tree@@3Urbtree_t@@A+4
  0000a	83 e0 01	 and	 eax, 1
  0000d	0b c1		 or	 eax, ecx
  0000f	83 c8 01	 or	 eax, 1
  00012	83 e0 fe	 and	 eax, -2			; fffffffeH
  00015	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, ecx
  0001b	89 0d 04 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+4, ecx
  00021	a3 08 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+8, eax
  00026	c3		 ret	 0
?rbt_new@@YAXPAUrbtree_t@@@Z ENDP			; rbt_new
_TEXT	ENDS
PUBLIC	?tommy_hashtable_compare@@YAHPBX0@Z		; tommy_hashtable_compare
; Function compile flags: /Ogtp
;	COMDAT ?tommy_hashtable_compare@@YAHPBX0@Z
_TEXT	SEGMENT
_void_arg$ = 8						; size = 4
_void_obj$ = 12						; size = 4
?tommy_hashtable_compare@@YAHPBX0@Z PROC		; tommy_hashtable_compare, COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 264  : 	const unsigned* arg = (const unsigned*)void_arg;
; 265  : 	const struct hashtable_object* obj = (const struct hashtable_object*)void_obj;
; 266  : 
; 267  : 	if (*arg == obj->value)

  00003	8b 45 08	 mov	 eax, DWORD PTR _void_arg$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR _void_obj$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00010	0f 95 c0	 setne	 al

; 268  : 		return 0;
; 269  : 
; 270  : 	return 1;
; 271  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?tommy_hashtable_compare@@YAHPBX0@Z ENDP		; tommy_hashtable_compare
_TEXT	ENDS
PUBLIC	?rbt_compare@@YAHPBX0@Z				; rbt_compare
; Function compile flags: /Ogtp
;	COMDAT ?rbt_compare@@YAHPBX0@Z
_TEXT	SEGMENT
?rbt_compare@@YAHPBX0@Z PROC				; rbt_compare, COMDAT
; _void_a$ = eax
; _void_b$ = ecx

; 249  : 	const struct rbt_object* a = (const struct rbt_object*)void_a;
; 250  : 	const struct rbt_object* b = (const struct rbt_object*)void_b;
; 251  : 
; 252  : 	int va = a->value;

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 	int vb = b->value;

  00003	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 254  : 
; 255  : 	if (va < vb)

  00006	3b c1		 cmp	 eax, ecx
  00008	7d 04		 jge	 SHORT $LN2@rbt_compar

; 256  : 		return -1;

  0000a	83 c8 ff	 or	 eax, -1

; 258  : 		return 1;
; 259  : 	return 0;
; 260  : }

  0000d	c3		 ret	 0
$LN2@rbt_compar:

; 257  : 	if (va > vb)

  0000e	33 d2		 xor	 edx, edx
  00010	3b c1		 cmp	 eax, ecx
  00012	0f 9f c2	 setg	 dl
  00015	8b c2		 mov	 eax, edx

; 258  : 		return 1;
; 259  : 	return 0;
; 260  : }

  00017	c3		 ret	 0
?rbt_compare@@YAHPBX0@Z ENDP				; rbt_compare
_TEXT	ENDS
PUBLIC	?judy_last@@YAPAIPAUJudy@@III@Z			; judy_last
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_last@@YAPAIPAUJudy@@III@Z
_TEXT	SEGMENT
_node$ = -4						; size = 4
_off$ = 8						; size = 4
_depth$ = 12						; size = 4
?judy_last@@YAPAIPAUJudy@@III@Z PROC			; judy_last, COMDAT
; _judy$ = ecx
; _next$ = eax

; 904  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR _off$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f8		 mov	 edi, eax

; 905  : JudySlot *table, *inner;
; 906  : uint keysize, size;
; 907  : JudySlot *node;
; 908  : int slot, cnt;
; 909  : uchar *base;
; 910  : 
; 911  : 	while( next ) {

  0000c	85 ff		 test	 edi, edi
  0000e	0f 84 22 01 00
	00		 je	 $LN22@judy_last
$LL23@judy_last:

; 912  : 		if( judy->level < judy->max )

  00014	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00017	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  0001a	73 04		 jae	 SHORT $LN21@judy_last

; 913  : 			judy->level++;

  0001c	40		 inc	 eax
  0001d	89 41 28	 mov	 DWORD PTR [ecx+40], eax
$LN21@judy_last:

; 914  : 
; 915  : 		judy->stack[judy->level].next = next;

  00020	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00023	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00026	89 7c 81 34	 mov	 DWORD PTR [ecx+eax*4+52], edi

; 916  : 		judy->stack[judy->level].off = off;

  0002a	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0002d	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00030	89 5c 91 38	 mov	 DWORD PTR [ecx+edx*4+56], ebx

; 917  : 		size = JudySize[next & 0x07];

  00034	8b d7		 mov	 edx, edi
  00036	83 e2 07	 and	 edx, 7
  00039	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edx*4]

; 918  : 		switch( next & 0x07 ) {

  00040	83 fa 07	 cmp	 edx, 7
  00043	0f 87 e5 00 00
	00		 ja	 $LN37@judy_last
  00049	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN43@judy_last[edx*4]
$LN18@judy_last:

; 919  : 		case JUDY_1:
; 920  : 		case JUDY_2:
; 921  : 		case JUDY_4:
; 922  : 		case JUDY_8:
; 923  : 		case JUDY_16:
; 924  : 		case JUDY_32:
; 925  : #ifdef ASKITIS
; 926  : 		case JUDY_64:
; 927  : #endif
; 928  : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  00050	83 e3 03	 and	 ebx, 3

; 929  : 			slot = size / (sizeof(JudySlot) + keysize);
; 930  : 			base = (uchar *)(next & JUDY_mask);
; 931  : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00053	83 e7 f8	 and	 edi, -8			; fffffff8H
  00056	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00059	89 55 fc	 mov	 DWORD PTR _node$[ebp], edx
  0005c	be 04 00 00 00	 mov	 esi, 4
  00061	33 d2		 xor	 edx, edx
  00063	2b f3		 sub	 esi, ebx
  00065	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00068	f7 f3		 div	 ebx

; 932  : 			judy->stack[judy->level].slot = --slot;

  0006a	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0006d	8d 54 52 0f	 lea	 edx, DWORD PTR [edx+edx*2+15]
  00071	48		 dec	 eax
  00072	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 933  : 
; 934  : #if BYTE_ORDER != BIG_ENDIAN
; 935  : 			if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth )

  00075	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00078	85 d2		 test	 edx, edx
  0007a	75 12		 jne	 SHORT $LN39@judy_last
  0007c	8b d8		 mov	 ebx, eax
  0007e	0f af de	 imul	 ebx, esi
  00081	38 14 3b	 cmp	 BYTE PTR [ebx+edi], dl
  00084	0f 84 b5 00 00
	00		 je	 $LN16@judy_last
  0008a	85 d2		 test	 edx, edx
  0008c	74 0f		 je	 SHORT $LN34@judy_last
$LN39@judy_last:
  0008e	8b 7d 0c	 mov	 edi, DWORD PTR _depth$[ebp]
  00091	47		 inc	 edi
  00092	89 7d 0c	 mov	 DWORD PTR _depth$[ebp], edi
  00095	3b fa		 cmp	 edi, edx
  00097	0f 84 a2 00 00
	00		 je	 $LN16@judy_last
$LN34@judy_last:

; 940  : 
; 941  : 			next = node[-slot-1];
; 942  : 			off += keysize;

  0009d	8b 5d 08	 mov	 ebx, DWORD PTR _off$[ebp]
  000a0	8d 14 85 04 00
	00 00		 lea	 edx, DWORD PTR [eax*4+4]
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000aa	2b c2		 sub	 eax, edx
  000ac	8b 38		 mov	 edi, DWORD PTR [eax]
  000ae	03 de		 add	 ebx, esi

; 943  : 			continue;

  000b0	eb 79		 jmp	 SHORT $LN40@judy_last
$LN14@judy_last:

; 944  : 
; 945  : 		case JUDY_radix:
; 946  : 			table = (JudySlot *)(next & JUDY_mask);

  000b2	8b f7		 mov	 esi, edi

; 947  : 			off++;

  000b4	43		 inc	 ebx
  000b5	83 e6 f8	 and	 esi, -8			; fffffff8H

; 948  : 
; 949  : 			if( judy->depth )

  000b8	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  000bc	89 5d 08	 mov	 DWORD PTR _off$[ebp], ebx
  000bf	74 08		 je	 SHORT $LN12@judy_last

; 950  : 			  if( !(off & JUDY_key_mask) )

  000c1	f6 c3 03	 test	 bl, 3
  000c4	75 03		 jne	 SHORT $LN12@judy_last

; 951  : 				depth++;

  000c6	ff 45 0c	 inc	 DWORD PTR _depth$[ebp]
$LN12@judy_last:

; 952  : 
; 953  : 			for( slot = 256; slot--; ) {

  000c9	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000ce	8b ff		 npad	 2
$LL11@judy_last:

; 954  : 			  judy->stack[judy->level].slot = slot;

  000d0	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  000d3	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  000d7	4a		 dec	 edx
  000d8	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 955  : 			  if( (inner = (JudySlot *)(table[slot >> 4] & JUDY_mask)) ) {

  000db	8b c2		 mov	 eax, edx
  000dd	c1 f8 04	 sar	 eax, 4
  000e0	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000e3	83 e0 f8	 and	 eax, -8			; fffffff8H
  000e6	74 22		 je	 SHORT $LN9@judy_last

; 956  : 				if( (next = inner[slot & 0x0F]) )

  000e8	8b fa		 mov	 edi, edx
  000ea	83 e7 0f	 and	 edi, 15			; 0000000fH
  000ed	8b 3c b8	 mov	 edi, DWORD PTR [eax+edi*4]
  000f0	85 ff		 test	 edi, edi
  000f2	74 1c		 je	 SHORT $LN3@judy_last

; 957  : 				  if( !judy->depth && !slot || judy->depth && depth == judy->depth )

  000f4	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  000f7	85 f6		 test	 esi, esi
  000f9	75 08		 jne	 SHORT $LN42@judy_last
  000fb	85 d2		 test	 edx, edx
  000fd	74 39		 je	 SHORT $LN24@judy_last
  000ff	85 f6		 test	 esi, esi
  00101	74 2b		 je	 SHORT $LN37@judy_last
$LN42@judy_last:
  00103	39 75 0c	 cmp	 DWORD PTR _depth$[ebp], esi
  00106	74 30		 je	 SHORT $LN24@judy_last

; 963  : 			}
; 964  : 			continue;

  00108	eb 24		 jmp	 SHORT $LN37@judy_last
$LN9@judy_last:

; 958  : 					return &inner[0];
; 959  : 				  else
; 960  : 					break;
; 961  : 			  } else
; 962  : 				slot &= 0xF0;

  0010a	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
$LN3@judy_last:

; 952  : 
; 953  : 			for( slot = 256; slot--; ) {

  00110	85 d2		 test	 edx, edx
  00112	75 bc		 jne	 SHORT $LL11@judy_last

; 969  : 			base = (uchar *)(next & JUDY_mask);
; 970  : 			cnt = JUDY_span_bytes;
; 971  : 			if( !base[cnt - 1] )	// leaf node?

  00114	eb 18		 jmp	 SHORT $LN37@judy_last
$LN2@judy_last:

; 965  : 
; 966  : #ifndef ASKITIS
; 967  : 		case JUDY_span:
; 968  : 			node = (JudySlot *)((next & JUDY_mask) + JudySize[JUDY_span]);

  00116	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?JudySize@@3PAHA+28
  0011b	83 e7 f8	 and	 edi, -8			; fffffff8H

; 969  : 			base = (uchar *)(next & JUDY_mask);
; 970  : 			cnt = JUDY_span_bytes;
; 971  : 			if( !base[cnt - 1] )	// leaf node?

  0011e	80 7f 1b 00	 cmp	 BYTE PTR [edi+27], 0
  00122	74 2e		 je	 SHORT $LN32@judy_last

; 973  : 			next = node[-1];

  00124	8b 7c 07 fc	 mov	 edi, DWORD PTR [edi+eax-4]

; 974  : 			off += cnt;

  00128	83 c3 1c	 add	 ebx, 28			; 0000001cH
$LN40@judy_last:
  0012b	89 5d 08	 mov	 DWORD PTR _off$[ebp], ebx
$LN37@judy_last:

; 905  : JudySlot *table, *inner;
; 906  : uint keysize, size;
; 907  : JudySlot *node;
; 908  : int slot, cnt;
; 909  : uchar *base;
; 910  : 
; 911  : 	while( next ) {

  0012e	85 ff		 test	 edi, edi
  00130	0f 85 de fe ff
	ff		 jne	 $LL23@judy_last
$LN22@judy_last:

; 975  : 			continue;
; 976  : #endif
; 977  : 		}
; 978  : 	}
; 979  : 	return NULL;

  00136	33 c0		 xor	 eax, eax
$LN24@judy_last:
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx

; 980  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
$LN16@judy_last:
  0013f	5f		 pop	 edi

; 936  : #else
; 937  : 			if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
; 938  : #endif
; 939  : 				return &node[-slot-1];

  00140	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  00147	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0014a	5e		 pop	 esi
  0014b	2b c1		 sub	 eax, ecx
  0014d	5b		 pop	 ebx

; 980  : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
$LN32@judy_last:

; 972  : 				return &node[-1];

  00152	8d 44 07 fc	 lea	 eax, DWORD PTR [edi+eax-4]
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx

; 980  : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
  0015d	8d 49 00	 npad	 3
$LN43@judy_last:
  00160	00 00 00 00	 DD	 $LN14@judy_last
  00164	00 00 00 00	 DD	 $LN18@judy_last
  00168	00 00 00 00	 DD	 $LN18@judy_last
  0016c	00 00 00 00	 DD	 $LN18@judy_last
  00170	00 00 00 00	 DD	 $LN18@judy_last
  00174	00 00 00 00	 DD	 $LN18@judy_last
  00178	00 00 00 00	 DD	 $LN18@judy_last
  0017c	00 00 00 00	 DD	 $LN2@judy_last
?judy_last@@YAPAIPAUJudy@@III@Z ENDP			; judy_last
_TEXT	ENDS
PUBLIC	?judy_slot@@YAPAIPAUJudy@@PAEI@Z		; judy_slot
; Function compile flags: /Ogtp
;	COMDAT ?judy_slot@@YAPAIPAUJudy@@PAEI@Z
_TEXT	SEGMENT
tv395 = -24						; size = 4
tv592 = -20						; size = 4
_test$ = -16						; size = 4
tv375 = -12						; size = 4
_tst$ = -12						; size = 4
_node$ = -8						; size = 4
_depth$ = -4						; size = 4
_buff$ = 8						; size = 4
?judy_slot@@YAPAIPAUJudy@@PAEI@Z PROC			; judy_slot, COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray

; 525  : judyvalue *src = (judyvalue *)buff;
; 526  : int slot, size, keysize, tst, cnt;
; 527  : JudySlot next = *judy->root;

  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	57		 push	 edi

; 528  : judyvalue value, test = 0;

  00011	33 ff		 xor	 edi, edi

; 529  : JudySlot *table;
; 530  : JudySlot *node;
; 531  : uint depth = 0;
; 532  : uint off = 0;

  00013	33 db		 xor	 ebx, ebx
  00015	89 7d f0	 mov	 DWORD PTR _test$[ebp], edi
  00018	89 7d fc	 mov	 DWORD PTR _depth$[ebp], edi

; 533  : uchar *base;
; 534  : 
; 535  : #ifndef ASKITIS
; 536  : 	judy->level = 0;

  0001b	89 7e 28	 mov	 DWORD PTR [esi+40], edi

; 537  : #endif
; 538  : 
; 539  : 	while( next ) {

  0001e	3b cf		 cmp	 ecx, edi
  00020	75 11		 jne	 SHORT $LN37@judy_slot
$LN36@judy_slot:
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 653  : 				continue;
; 654  : 			}
; 655  : 			return NULL;
; 656  : #endif
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : 	return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	5b		 pop	 ebx

; 661  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
  0002b	eb 03 8d 49 00	 npad	 5
$LL62@judy_slot:

; 537  : #endif
; 538  : 
; 539  : 	while( next ) {

  00030	8b 7d fc	 mov	 edi, DWORD PTR _depth$[ebp]
$LN37@judy_slot:

; 540  : #ifndef ASKITIS
; 541  : 		if( judy->level < judy->max )

  00033	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00036	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  00039	73 04		 jae	 SHORT $LN35@judy_slot

; 542  : 			judy->level++;

  0003b	40		 inc	 eax
  0003c	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN35@judy_slot:

; 543  : 
; 544  : 		judy->stack[judy->level].next = next;

  0003f	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00042	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00045	89 4c 86 34	 mov	 DWORD PTR [esi+eax*4+52], ecx

; 545  : 		judy->stack[judy->level].off = off;

  00049	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0004c	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0004f	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx

; 546  : #endif
; 547  : 		size = JudySize[next & 0x07];

  00053	8b d1		 mov	 edx, ecx
  00055	83 e2 07	 and	 edx, 7
  00058	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edx*4]

; 548  : 
; 549  : 		switch( next & 0x07 ) {

  0005f	83 fa 07	 cmp	 edx, 7
  00062	0f 87 a0 01 00
	00		 ja	 $LN33@judy_slot
  00068	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN73@judy_slot[edx*4]
$LN32@judy_slot:

; 550  : 
; 551  : 		case JUDY_1:
; 552  : 		case JUDY_2:
; 553  : 		case JUDY_4:
; 554  : 		case JUDY_8:
; 555  : 		case JUDY_16:
; 556  : 		case JUDY_32:
; 557  : #ifdef ASKITIS
; 558  : 		case JUDY_64:
; 559  : #endif
; 560  : 			base = (uchar *)(next & JUDY_mask);

  0006f	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00072	89 4d f4	 mov	 DWORD PTR tv375[ebp], ecx

; 561  : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00075	03 c8		 add	 ecx, eax
  00077	89 4d f8	 mov	 DWORD PTR _node$[ebp], ecx

; 562  : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  0007a	8b d3		 mov	 edx, ebx
  0007c	83 e2 03	 and	 edx, 3
  0007f	b9 04 00 00 00	 mov	 ecx, 4
  00084	2b ca		 sub	 ecx, edx

; 563  : 			cnt = size / (sizeof(JudySlot) + keysize);

  00086	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00089	33 d2		 xor	 edx, edx
  0008b	f7 f7		 div	 edi

; 564  : 			slot = cnt;

  0008d	8b f8		 mov	 edi, eax

; 565  : 			value = 0;

  0008f	33 c0		 xor	 eax, eax

; 566  : 
; 567  : 			if( judy->depth ) {

  00091	39 46 30	 cmp	 DWORD PTR [esi+48], eax
  00094	74 1a		 je	 SHORT $LL29@judy_slot

; 568  : 				value = src[depth++];

  00096	8b 55 fc	 mov	 edx, DWORD PTR _depth$[ebp]
  00099	8b 45 08	 mov	 eax, DWORD PTR _buff$[ebp]
  0009c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 569  : 				off |= JUDY_key_mask;

  0009f	83 cb 03	 or	 ebx, 3
  000a2	42		 inc	 edx

; 570  : 				off++;

  000a3	43		 inc	 ebx

; 571  : 				value &= JudyMask[keysize];

  000a4	23 04 8d 00 00
	00 00		 and	 eax, DWORD PTR ?JudyMask@@3PAIA[ecx*4]
  000ab	89 55 fc	 mov	 DWORD PTR _depth$[ebp], edx

; 572  : 			} else

  000ae	eb 09		 jmp	 SHORT $LN27@judy_slot
$LL29@judy_slot:

; 573  : 			  do {
; 574  : 				value <<= 8;
; 575  : 				if( off < max )
; 576  : 					value |= buff[off];
; 577  : 			  } while( ++off & JUDY_key_mask );

  000b0	43		 inc	 ebx
  000b1	c1 e0 08	 shl	 eax, 8
  000b4	f6 c3 03	 test	 bl, 3
  000b7	75 f7		 jne	 SHORT $LL29@judy_slot
$LN27@judy_slot:

; 578  : 
; 579  : 			//  find slot > key
; 580  : 
; 581  : 			while( slot-- ) {

  000b9	85 ff		 test	 edi, edi
  000bb	74 2f		 je	 SHORT $LN58@judy_slot
  000bd	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?JudyMask@@3PAIA[ecx*4]
  000c4	89 55 e8	 mov	 DWORD PTR tv395[ebp], edx
  000c7	8b d1		 mov	 edx, ecx
  000c9	f7 da		 neg	 edx
  000cb	89 55 ec	 mov	 DWORD PTR tv592[ebp], edx
  000ce	8b d7		 mov	 edx, edi
  000d0	0f af d1	 imul	 edx, ecx
  000d3	03 55 f4	 add	 edx, DWORD PTR tv375[ebp]
$LL25@judy_slot:
  000d6	03 55 ec	 add	 edx, DWORD PTR tv592[ebp]

; 582  : 				test = *(judyvalue *)(base + slot * keysize);
; 583  : #if BYTE_ORDER == BIG_ENDIAN
; 584  : 				test >>= 8 * (JUDY_key_size - keysize); 
; 585  : #else
; 586  : 				test &= JudyMask[keysize];

  000d9	8b 4d e8	 mov	 ecx, DWORD PTR tv395[ebp]
  000dc	23 0a		 and	 ecx, DWORD PTR [edx]
  000de	4f		 dec	 edi
  000df	89 4d f0	 mov	 DWORD PTR _test$[ebp], ecx

; 587  : #endif
; 588  : 				if( test <= value )

  000e2	3b c8		 cmp	 ecx, eax
  000e4	76 0a		 jbe	 SHORT $LN24@judy_slot

; 578  : 
; 579  : 			//  find slot > key
; 580  : 
; 581  : 			while( slot-- ) {

  000e6	85 ff		 test	 edi, edi
  000e8	75 ec		 jne	 SHORT $LL25@judy_slot
  000ea	eb 03		 jmp	 SHORT $LN60@judy_slot
$LN58@judy_slot:
  000ec	8b 4d f0	 mov	 ecx, DWORD PTR _test$[ebp]
$LN60@judy_slot:
  000ef	4f		 dec	 edi
$LN24@judy_slot:

; 589  : 					break;
; 590  : 			}
; 591  : #ifndef ASKITIS
; 592  : 			judy->stack[judy->level].slot = slot;

  000f0	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000f3	8d 54 52 0f	 lea	 edx, DWORD PTR [edx+edx*2+15]
  000f7	89 3c 96	 mov	 DWORD PTR [esi+edx*4], edi

; 593  : #endif
; 594  : 			if( test == value ) {

  000fa	3b c8		 cmp	 ecx, eax
  000fc	0f 85 20 ff ff
	ff		 jne	 $LN36@judy_slot

; 595  : 
; 596  : 				// is this a leaf?
; 597  : 
; 598  : 				if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth )

  00102	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00105	85 c9		 test	 ecx, ecx
  00107	75 0c		 jne	 SHORT $LN66@judy_slot
  00109	84 c0		 test	 al, al
  0010b	0f 84 08 01 00
	00		 je	 $LN20@judy_slot
  00111	85 c9		 test	 ecx, ecx
  00113	74 09		 je	 SHORT $LN61@judy_slot
$LN66@judy_slot:
  00115	39 4d fc	 cmp	 DWORD PTR _depth$[ebp], ecx
  00118	0f 84 fb 00 00
	00		 je	 $LN20@judy_slot
$LN61@judy_slot:

; 600  : 
; 601  : 				next = node[-slot-1];

  0011e	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00121	8d 0c bd 04 00
	00 00		 lea	 ecx, DWORD PTR [edi*4+4]
  00128	2b c1		 sub	 eax, ecx
  0012a	8b 08		 mov	 ecx, DWORD PTR [eax]

; 602  : 				continue;

  0012c	e9 d7 00 00 00	 jmp	 $LN33@judy_slot
$LN18@judy_slot:

; 603  : 			}
; 604  : 
; 605  : 			return NULL;
; 606  : 
; 607  : 		case JUDY_radix:
; 608  : 			table = (JudySlot  *)(next & JUDY_mask); // outer radix

  00131	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 609  : 
; 610  : 			if( judy->depth )

  00134	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  00138	8b d1		 mov	 edx, ecx
  0013a	74 1d		 je	 SHORT $LN15@judy_slot

; 611  : 				slot = (src[depth] >> ((JUDY_key_size - ++off & JUDY_key_mask) * 8)) & 0xff;

  0013c	8b 45 08	 mov	 eax, DWORD PTR _buff$[ebp]
  0013f	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00142	43		 inc	 ebx
  00143	8b cb		 mov	 ecx, ebx
  00145	f7 d9		 neg	 ecx
  00147	83 e1 03	 and	 ecx, 3
  0014a	03 c9		 add	 ecx, ecx
  0014c	03 c9		 add	 ecx, ecx
  0014e	03 c9		 add	 ecx, ecx
  00150	d3 e8		 shr	 eax, cl
  00152	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00157	eb 02		 jmp	 SHORT $LN14@judy_slot
$LN15@judy_slot:

; 612  : 			else if( off < max )
; 613  : 				slot = buff[off++];
; 614  : 			else
; 615  : 				slot = 0;

  00159	33 c0		 xor	 eax, eax
$LN14@judy_slot:

; 616  : #ifndef ASKITIS
; 617  : 			//	put radix slot on judy stack
; 618  : 
; 619  : 			judy->stack[judy->level].slot = slot;

  0015b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0015e	8d 4c 49 0f	 lea	 ecx, DWORD PTR [ecx+ecx*2+15]
  00162	89 04 8e	 mov	 DWORD PTR [esi+ecx*4], eax

; 620  : #endif
; 621  : 			if( (next = table[slot >> 4]) )

  00165	8b c8		 mov	 ecx, eax
  00167	c1 f9 04	 sar	 ecx, 4
  0016a	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0016d	85 c9		 test	 ecx, ecx
  0016f	0f 84 ad fe ff
	ff		 je	 $LN36@judy_slot

; 622  : 				table = (JudySlot  *)(next & JUDY_mask); // inner radix
; 623  : 			else
; 624  : 				return NULL;
; 625  : 
; 626  : 			if( judy->depth )

  00175	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00178	83 e1 f8	 and	 ecx, -8			; fffffff8H
  0017b	85 d2		 test	 edx, edx
  0017d	74 0d		 je	 SHORT $LN68@judy_slot

; 627  : 				if( !(off & JUDY_key_mask) )

  0017f	f6 c3 03	 test	 bl, 3
  00182	75 04		 jne	 SHORT $LN10@judy_slot

; 628  : 					depth++;

  00184	47		 inc	 edi
  00185	89 7d fc	 mov	 DWORD PTR _depth$[ebp], edi
$LN10@judy_slot:

; 629  : 
; 630  : 			if( !judy->depth && !slot || judy->depth && depth == judy->depth )	// leaf?

  00188	85 d2		 test	 edx, edx
  0018a	75 0c		 jne	 SHORT $LN70@judy_slot
$LN68@judy_slot:
  0018c	85 c0		 test	 eax, eax
  0018e	0f 84 98 00 00
	00		 je	 $LN8@judy_slot
  00194	85 d2		 test	 edx, edx
  00196	74 08		 je	 SHORT $LN5@judy_slot
$LN70@judy_slot:
  00198	3b fa		 cmp	 edi, edx
  0019a	0f 84 8c 00 00
	00		 je	 $LN8@judy_slot
$LN5@judy_slot:

; 632  : 					return &table[slot & 0x0F];
; 633  : 				else
; 634  : 					return NULL;
; 635  : 
; 636  : 			next = table[slot & 0x0F];

  001a0	83 e0 0f	 and	 eax, 15			; 0000000fH
  001a3	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]

; 637  : 			continue;

  001a6	eb 60		 jmp	 SHORT $LN33@judy_slot
$LN4@judy_slot:

; 638  : 
; 639  : #ifndef ASKITIS
; 640  : 		case JUDY_span:
; 641  : 			node = (JudySlot *)((next & JUDY_mask) + JudySize[JUDY_span]);

  001a8	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?JudySize@@3PAHA+28
  001ae	8b f9		 mov	 edi, ecx
  001b0	83 e7 f8	 and	 edi, -8			; fffffff8H
  001b3	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  001b6	89 45 f8	 mov	 DWORD PTR _node$[ebp], eax

; 642  : 			base = (uchar *)(next & JUDY_mask);
; 643  : 			cnt = tst = JUDY_span_bytes;
; 644  : 			if( tst > (int)(max - off) )

  001b9	8b c3		 mov	 eax, ebx
  001bb	f7 d8		 neg	 eax
  001bd	c7 45 f4 1c 00
	00 00		 mov	 DWORD PTR _tst$[ebp], 28 ; 0000001cH
  001c4	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  001c7	7d 03		 jge	 SHORT $LN3@judy_slot

; 645  : 				tst = max - off;

  001c9	89 45 f4	 mov	 DWORD PTR _tst$[ebp], eax
$LN3@judy_slot:

; 646  : 			value = strncmp((const char *)base, (const char *)(buff + off), tst);

  001cc	8b 4d f4	 mov	 ecx, DWORD PTR _tst$[ebp]
  001cf	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  001d2	51		 push	 ecx
  001d3	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  001d6	50		 push	 eax
  001d7	57		 push	 edi
  001d8	e8 00 00 00 00	 call	 _strncmp
  001dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 			if( !value && tst < cnt && !base[tst] ) // leaf?

  001e0	85 c0		 test	 eax, eax
  001e2	0f 85 3a fe ff
	ff		 jne	 $LN36@judy_slot
  001e8	8b 45 f4	 mov	 eax, DWORD PTR _tst$[ebp]
  001eb	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  001ee	7d 09		 jge	 SHORT $LN71@judy_slot
  001f0	80 3c 38 00	 cmp	 BYTE PTR [eax+edi], 0
  001f4	74 4b		 je	 SHORT $LN47@judy_slot

; 649  : 
; 650  : 			if( !value && tst == cnt ) {

  001f6	83 f8 1c	 cmp	 eax, 28			; 0000001cH
$LN71@judy_slot:
  001f9	0f 85 23 fe ff
	ff		 jne	 $LN36@judy_slot

; 651  : 				next = node[-1];

  001ff	8b 4d f8	 mov	 ecx, DWORD PTR _node$[ebp]
  00202	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]

; 652  : 				off += cnt;

  00205	83 c3 1c	 add	 ebx, 28			; 0000001cH
$LN33@judy_slot:

; 537  : #endif
; 538  : 
; 539  : 	while( next ) {

  00208	85 c9		 test	 ecx, ecx
  0020a	0f 85 20 fe ff
	ff		 jne	 $LL62@judy_slot

; 653  : 				continue;
; 654  : 			}
; 655  : 			return NULL;
; 656  : #endif
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : 	return NULL;

  00210	5f		 pop	 edi
  00211	5e		 pop	 esi
  00212	33 c0		 xor	 eax, eax
  00214	5b		 pop	 ebx

; 661  : }

  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c3		 ret	 0
$LN20@judy_slot:

; 599  : 					return &node[-slot-1];

  00219	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0021c	8d 14 bd 04 00
	00 00		 lea	 edx, DWORD PTR [edi*4+4]
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	2b c2		 sub	 eax, edx
  00227	5b		 pop	 ebx

; 661  : }

  00228	8b e5		 mov	 esp, ebp
  0022a	5d		 pop	 ebp
  0022b	c3		 ret	 0
$LN8@judy_slot:

; 631  : 				if( table[slot & 0x0F] )	// occupied?

  0022c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0022f	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00232	8b 01		 mov	 eax, DWORD PTR [ecx]
  00234	f7 d8		 neg	 eax
  00236	5f		 pop	 edi
  00237	1b c0		 sbb	 eax, eax
  00239	5e		 pop	 esi
  0023a	23 c1		 and	 eax, ecx
  0023c	5b		 pop	 ebx

; 661  : }

  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c3		 ret	 0
$LN47@judy_slot:

; 648  : 				return &node[-1];

  00241	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00244	5f		 pop	 edi
  00245	5e		 pop	 esi
  00246	83 c0 fc	 add	 eax, -4			; fffffffcH
  00249	5b		 pop	 ebx

; 661  : }

  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
  0024e	8b ff		 npad	 2
$LN73@judy_slot:
  00250	00 00 00 00	 DD	 $LN18@judy_slot
  00254	00 00 00 00	 DD	 $LN32@judy_slot
  00258	00 00 00 00	 DD	 $LN32@judy_slot
  0025c	00 00 00 00	 DD	 $LN32@judy_slot
  00260	00 00 00 00	 DD	 $LN32@judy_slot
  00264	00 00 00 00	 DD	 $LN32@judy_slot
  00268	00 00 00 00	 DD	 $LN32@judy_slot
  0026c	00 00 00 00	 DD	 $LN4@judy_slot
?judy_slot@@YAPAIPAUJudy@@PAEI@Z ENDP			; judy_slot
_TEXT	ENDS
PUBLIC	?judy_free@@YAXPAUJudy@@PAXH@Z			; judy_free
; Function compile flags: /Ogtp
;	COMDAT ?judy_free@@YAXPAUJudy@@PAXH@Z
_TEXT	SEGMENT
_judy$ = 8						; size = 4
?judy_free@@YAXPAUJudy@@PAXH@Z PROC			; judy_free, COMDAT
; _block$ = ecx
; _type$ = eax

; 409  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _judy$[ebp]

; 410  : 	if( type == JUDY_radix )

  00006	85 c0		 test	 eax, eax
  00008	75 13		 jne	 SHORT $LN2@judy_free

; 411  : 		type = JUDY_radix_equiv;

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	56		 push	 esi

; 416  : #endif
; 417  : 
; 418  : 	*((void **)(block)) = judy->reuse[type];

  00010	8b 74 82 04	 mov	 esi, DWORD PTR [edx+eax*4+4]
  00014	89 31		 mov	 DWORD PTR [ecx], esi

; 419  : 	judy->reuse[type] = (void **)block;

  00016	89 4c 82 04	 mov	 DWORD PTR [edx+eax*4+4], ecx
  0001a	5e		 pop	 esi

; 420  : 	return;
; 421  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN2@judy_free:

; 412  : 
; 413  : #ifndef ASKITIS
; 414  : 	if( type == JUDY_span )

  0001d	83 f8 07	 cmp	 eax, 7
  00020	75 05		 jne	 SHORT $LN1@judy_free

; 415  : 		type = JUDY_span_equiv;

  00022	b8 03 00 00 00	 mov	 eax, 3
$LN1@judy_free:
  00027	56		 push	 esi

; 416  : #endif
; 417  : 
; 418  : 	*((void **)(block)) = judy->reuse[type];

  00028	8b 74 82 04	 mov	 esi, DWORD PTR [edx+eax*4+4]
  0002c	89 31		 mov	 DWORD PTR [ecx], esi

; 419  : 	judy->reuse[type] = (void **)block;

  0002e	89 4c 82 04	 mov	 DWORD PTR [edx+eax*4+4], ecx
  00032	5e		 pop	 esi

; 420  : 	return;
; 421  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?judy_free@@YAXPAUJudy@@PAXH@Z ENDP			; judy_free
_TEXT	ENDS
PUBLIC	?judy_alloc@@YAPAXPAUJudy@@I@Z			; judy_alloc
; Function compile flags: /Ogtp
;	COMDAT ?judy_alloc@@YAPAXPAUJudy@@I@Z
_TEXT	SEGMENT
tv263 = -8						; size = 4
tv271 = -4						; size = 4
_judy$ = 8						; size = 4
?judy_alloc@@YAPAXPAUJudy@@I@Z PROC			; judy_alloc, COMDAT
; _type$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR _judy$[ebp]

; 269  : uint amt, idx, min;
; 270  : JudySeg *seg;
; 271  : void **block;
; 272  : void **rtn;
; 273  : 
; 274  : 	if( !judy->seg )

  0000a	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0000d	85 c0		 test	 eax, eax
  0000f	75 05		 jne	 SHORT $LN17@judy_alloc
  00011	5f		 pop	 edi

; 352  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN17@judy_alloc:

; 275  : #if defined(STANDALONE) || defined(ASKITIS)
; 276  : 			judy_abort("illegal allocation from judy clone");
; 277  : #else
; 278  : 			return NULL;
; 279  : #endif
; 280  : 
; 281  : 	if( type == JUDY_radix )

  00016	85 c9		 test	 ecx, ecx
  00018	75 07		 jne	 SHORT $LN16@judy_alloc

; 282  : 		type = JUDY_radix_equiv;

  0001a	b9 04 00 00 00	 mov	 ecx, 4

; 283  : 
; 284  : #ifndef ASKITIS
; 285  : 	if( type == JUDY_span )

  0001f	eb 0a		 jmp	 SHORT $LN15@judy_alloc
$LN16@judy_alloc:
  00021	83 f9 07	 cmp	 ecx, 7
  00024	75 05		 jne	 SHORT $LN15@judy_alloc

; 286  : 		type = JUDY_span_equiv;

  00026	b9 03 00 00 00	 mov	 ecx, 3
$LN15@judy_alloc:

; 287  : #endif
; 288  : 
; 289  : 	amt = JudySize[type];

  0002b	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR ?JudySize@@3PAHA[ecx*4]
  00032	53		 push	 ebx
  00033	8b 18		 mov	 ebx, DWORD PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR tv263[ebp], eax

; 290  : 
; 291  : 	if( amt & 0x07 )

  00038	f6 c3 07	 test	 bl, 7
  0003b	74 04		 je	 SHORT $LN32@judy_alloc

; 292  : 		amt |= 0x07, amt += 1;

  0003d	83 cb 07	 or	 ebx, 7
  00040	43		 inc	 ebx
$LN32@judy_alloc:

; 293  : 
; 294  : 	//	see if free block is already available
; 295  : 
; 296  : 	if( (block = judy->reuse[type]) ) {

  00041	8d 54 8f 04	 lea	 edx, DWORD PTR [edi+ecx*4+4]
  00045	56		 push	 esi
  00046	8b 32		 mov	 esi, DWORD PTR [edx]
  00048	89 55 fc	 mov	 DWORD PTR tv271[ebp], edx
  0004b	85 f6		 test	 esi, esi
  0004d	74 19		 je	 SHORT $LN13@judy_alloc

; 297  : 		judy->reuse[type] = (void**)*block;

  0004f	8b 06		 mov	 eax, DWORD PTR [esi]

; 298  : 		memset (block, 0, amt);

  00051	53		 push	 ebx

; 350  : 	memset (rtn, 0, JudySize[type]);

  00052	6a 00		 push	 0
  00054	56		 push	 esi
  00055	89 02		 mov	 DWORD PTR [edx], eax
  00057	e8 00 00 00 00	 call	 _memset
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 	return (void *)rtn;

  0005f	8b c6		 mov	 eax, esi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	5f		 pop	 edi

; 352  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN13@judy_alloc:

; 299  : 		return (void *)block;
; 300  : 	}
; 301  : 
; 302  : 	//	break down available larger block
; 303  : 	//	for reuse into smaller blocks
; 304  : 
; 305  : 	if( type >= JUDY_1 )

  00068	83 f9 01	 cmp	 ecx, 1
  0006b	72 1e		 jb	 SHORT $LN26@judy_alloc

; 306  : 	  for( idx = type; idx++ < JUDY_max; )

  0006d	8b c1		 mov	 eax, ecx
  0006f	83 f9 06	 cmp	 ecx, 6
  00072	73 17		 jae	 SHORT $LN26@judy_alloc
$LL11@judy_alloc:

; 307  : 		if( block = judy->reuse[idx] ) {

  00074	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00077	83 c2 04	 add	 edx, 4
  0007a	40		 inc	 eax
  0007b	85 f6		 test	 esi, esi
  0007d	0f 85 9f 00 00
	00		 jne	 $LN25@judy_alloc

; 306  : 	  for( idx = type; idx++ < JUDY_max; )

  00083	83 f8 06	 cmp	 eax, 6
  00086	72 ec		 jb	 SHORT $LL11@judy_alloc

; 307  : 		if( block = judy->reuse[idx] ) {

  00088	8b 55 fc	 mov	 edx, DWORD PTR tv271[ebp]
$LN26@judy_alloc:

; 314  : 		  return (void *)block;
; 315  : 		}
; 316  : 
; 317  : 	min = amt < JUDY_cache_line ? JUDY_cache_line : amt;

  0008b	b8 08 00 00 00	 mov	 eax, 8
  00090	83 fb 08	 cmp	 ebx, 8
  00093	72 02		 jb	 SHORT $LN21@judy_alloc
  00095	8b c3		 mov	 eax, ebx
$LN21@judy_alloc:

; 318  : 
; 319  : 	if( judy->seg->next < min + sizeof(*seg) ) {

  00097	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0009a	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0009d	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  000a0	73 2f		 jae	 SHORT $LN4@judy_alloc

; 320  : 		if( (seg = (JudySeg*)malloc (JUDY_seg)) ) {

  000a2	68 00 00 01 00	 push	 65536			; 00010000H
  000a7	e8 00 00 00 00	 call	 _malloc
  000ac	83 c4 04	 add	 esp, 4
  000af	85 c0		 test	 eax, eax
  000b1	0f 84 b6 00 00
	00		 je	 $LN5@judy_alloc

; 321  : 			seg->next = JUDY_seg;

  000b7	c7 40 04 00 00
	01 00		 mov	 DWORD PTR [eax+4], 65536 ; 00010000H

; 322  : 			seg->seg = judy->seg;

  000be	8b 57 24	 mov	 edx, DWORD PTR [edi+36]

; 323  : 			judy->seg = seg;
; 324  : 			seg->next -= (JudySlot)seg & (JUDY_cache_line - 1);

  000c1	8b c8		 mov	 ecx, eax
  000c3	89 10		 mov	 DWORD PTR [eax], edx

; 325  : 		} else {

  000c5	8b 55 fc	 mov	 edx, DWORD PTR tv271[ebp]
  000c8	83 e1 07	 and	 ecx, 7
  000cb	89 47 24	 mov	 DWORD PTR [edi+36], eax
  000ce	29 48 04	 sub	 DWORD PTR [eax+4], ecx
$LN4@judy_alloc:

; 330  : #endif
; 331  : 		}
; 332  : 
; 333  : #if defined(STANDALONE) || defined(ASKITIS)
; 334  : 		MaxMem += JUDY_seg;
; 335  : #endif
; 336  : 	}
; 337  : 
; 338  : 	//	generate additional free blocks
; 339  : 	//	to fill up to cache line size
; 340  : 
; 341  : 	rtn = (void **)((uchar *)judy->seg + judy->seg->next - amt);

  000d1	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	2b f3		 sub	 esi, ebx
  000d9	03 f0		 add	 esi, eax

; 342  : 
; 343  : 	for( idx = type; amt & (JUDY_cache_line - 1); amt <<= 1 ) {

  000db	f6 c3 07	 test	 bl, 7
  000de	74 22		 je	 SHORT $LN1@judy_alloc
$LL31@judy_alloc:

; 344  : 		block = (void **)((uchar *)judy->seg + judy->seg->next - 2 * amt);

  000e0	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  000e3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000e6	8d 3c 1b	 lea	 edi, DWORD PTR [ebx+ebx]
  000e9	2b c7		 sub	 eax, edi
  000eb	8b 7d 08	 mov	 edi, DWORD PTR _judy$[ebp]
  000ee	03 c1		 add	 eax, ecx

; 345  : 		judy->reuse[idx++] = block;

  000f0	89 02		 mov	 DWORD PTR [edx], eax
  000f2	03 db		 add	 ebx, ebx
  000f4	83 c2 04	 add	 edx, 4

; 346  : 		*block = 0;

  000f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000fd	f6 c3 07	 test	 bl, 7
  00100	75 de		 jne	 SHORT $LL31@judy_alloc
$LN1@judy_alloc:

; 347  : 	}
; 348  : 
; 349  : 	judy->seg->next -= amt;

  00102	8b 47 24	 mov	 eax, DWORD PTR [edi+36]

; 350  : 	memset (rtn, 0, JudySize[type]);

  00105	8b 4d f8	 mov	 ecx, DWORD PTR tv263[ebp]
  00108	29 58 04	 sub	 DWORD PTR [eax+4], ebx
  0010b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010d	52		 push	 edx
  0010e	6a 00		 push	 0
  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 _memset
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 	return (void *)rtn;

  00119	8b c6		 mov	 eax, esi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	5f		 pop	 edi

; 352  : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN25@judy_alloc:

; 308  : 		  judy->reuse[idx] = (void**)*block;

  00122	8d 54 87 04	 lea	 edx, DWORD PTR [edi+eax*4+4]
  00126	8b 3e		 mov	 edi, DWORD PTR [esi]
  00128	89 3a		 mov	 DWORD PTR [edx], edi

; 309  : 		  while( idx-- > type) {

  0012a	3b c1		 cmp	 eax, ecx
  0012c	76 2a		 jbe	 SHORT $LN30@judy_alloc
  0012e	8b ff		 npad	 2
$LL8@judy_alloc:

; 310  : 			judy->reuse[idx] = block + JudySize[idx] / sizeof(void *);

  00130	8b 3c 85 fc ff
	ff ff		 mov	 edi, DWORD PTR ?JudySize@@3PAHA[eax*4-4]
  00137	48		 dec	 eax
  00138	c1 ef 02	 shr	 edi, 2
  0013b	8d 3c be	 lea	 edi, DWORD PTR [esi+edi*4]
  0013e	83 ea 04	 sub	 edx, 4
  00141	89 3a		 mov	 DWORD PTR [edx], edi

; 311  : 			block[JudySize[idx] / sizeof(void *)] = 0;

  00143	8b 3c 85 00 00
	00 00		 mov	 edi, DWORD PTR ?JudySize@@3PAHA[eax*4]
  0014a	c1 ef 02	 shr	 edi, 2
  0014d	c7 04 be 00 00
	00 00		 mov	 DWORD PTR [esi+edi*4], 0
  00154	3b c1		 cmp	 eax, ecx
  00156	77 d8		 ja	 SHORT $LL8@judy_alloc
$LN30@judy_alloc:

; 312  : 		  }
; 313  : 		  memset (block, 0, amt);

  00158	53		 push	 ebx

; 350  : 	memset (rtn, 0, JudySize[type]);

  00159	6a 00		 push	 0
  0015b	56		 push	 esi
  0015c	e8 00 00 00 00	 call	 _memset
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 	return (void *)rtn;

  00164	8b c6		 mov	 eax, esi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	5f		 pop	 edi

; 352  : }

  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN5@judy_alloc:
  0016d	5e		 pop	 esi
  0016e	5b		 pop	 ebx

; 326  : #if defined(STANDALONE) || defined(ASKITIS)
; 327  : 			judy_abort("Out of virtual memory");
; 328  : #else
; 329  : 			return NULL;

  0016f	33 c0		 xor	 eax, eax
  00171	5f		 pop	 edi

; 352  : }

  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?judy_alloc@@YAPAXPAUJudy@@I@Z ENDP			; judy_alloc
_TEXT	ENDS
PUBLIC	?judy_size@@YAIPAUJudy@@@Z			; judy_size
; Function compile flags: /Ogtp
;	COMDAT ?judy_size@@YAIPAUJudy@@@Z
_TEXT	SEGMENT
?judy_size@@YAIPAUJudy@@@Z PROC				; judy_size, COMDAT

; 252  : 	JudySeg* seg;
; 253  : 	uint count;
; 254  : 
; 255  : 	seg = judy->seg;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00005	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]

; 256  : 	count = 0;

  00008	33 c0		 xor	 eax, eax

; 257  : 	while (seg) {

  0000a	85 c9		 test	 ecx, ecx
  0000c	74 12		 je	 SHORT $LN1@judy_size
  0000e	8b ff		 npad	 2
$LL2@judy_size:

; 258  : 		count += JUDY_seg - seg->next;

  00010	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00015	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]

; 259  : 		seg = (JudySeg*)seg->seg;

  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	03 c2		 add	 eax, edx
  0001c	85 c9		 test	 ecx, ecx
  0001e	75 f0		 jne	 SHORT $LL2@judy_size
$LN1@judy_size:

; 260  : 	}
; 261  : 
; 262  : 	return count;
; 263  : }

  00020	c3		 ret	 0
?judy_size@@YAIPAUJudy@@@Z ENDP				; judy_size
_TEXT	ENDS
PUBLIC	?judy_close@@YAXPAUJudy@@@Z			; judy_close
; Function compile flags: /Ogtp
;	COMDAT ?judy_close@@YAXPAUJudy@@@Z
_TEXT	SEGMENT
?judy_close@@YAXPAUJudy@@@Z PROC			; judy_close, COMDAT

; 244  : JudySeg *seg, *nxt = judy->seg;
; 245  : 
; 246  : 	while( (seg = nxt) )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00005	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00008	85 c0		 test	 eax, eax
  0000a	74 16		 je	 SHORT $LN1@judy_close
  0000c	56		 push	 esi
  0000d	8d 49 00	 npad	 3
$LL2@judy_close:

; 247  : 		nxt = (JudySeg*)seg->seg, free (seg);

  00010	8b 30		 mov	 esi, DWORD PTR [eax]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _free
  00018	83 c4 04	 add	 esp, 4
  0001b	8b c6		 mov	 eax, esi
  0001d	85 f6		 test	 esi, esi
  0001f	75 ef		 jne	 SHORT $LL2@judy_close
  00021	5e		 pop	 esi
$LN1@judy_close:

; 248  : }

  00022	c3		 ret	 0
?judy_close@@YAXPAUJudy@@@Z ENDP			; judy_close
_TEXT	ENDS
PUBLIC	?judy_open@@YAPAXII@Z				; judy_open
; Function compile flags: /Ogtp
;	COMDAT ?judy_open@@YAPAXII@Z
_TEXT	SEGMENT
?judy_open@@YAPAXII@Z PROC				; judy_open, COMDAT

; 204  : {

  00000	57		 push	 edi

; 205  : JudySeg *seg;
; 206  : Judy *judy;
; 207  : uint amt;
; 208  : 
; 209  : 	max++;		// allow for zero terminator on keys
; 210  : 
; 211  : 	if( (seg = (JudySeg*)malloc(JUDY_seg)) ) {

  00001	68 00 00 01 00	 push	 65536			; 00010000H
  00006	e8 00 00 00 00	 call	 _malloc
  0000b	8b f8		 mov	 edi, eax
  0000d	83 c4 04	 add	 esp, 4
  00010	85 ff		 test	 edi, edi
  00012	74 3f		 je	 SHORT $LN3@judy_open

; 219  : #endif
; 220  : 	}
; 221  : 
; 222  : 	amt = sizeof(Judy) + max * sizeof(JudyStack);
; 223  : 
; 224  : 	if( amt & (JUDY_cache_line - 1) )
; 225  : 		amt |= JUDY_cache_line - 1, amt++;
; 226  : 
; 227  : #if defined(STANDALONE) || defined(ASKITIS)
; 228  : 	MaxMem += JUDY_seg;
; 229  : #endif
; 230  : 
; 231  : 	seg->next -= (JudySlot)seg & (JUDY_cache_line - 1);

  00014	56		 push	 esi
  00015	8b cf		 mov	 ecx, edi
  00017	83 e1 07	 and	 ecx, 7

; 232  : 	seg->next -= amt;

  0001a	b8 b0 cf 00 00	 mov	 eax, 53168		; 0000cfb0H
  0001f	2b c1		 sub	 eax, ecx

; 233  : 
; 234  : 	judy = (Judy *)((uchar *)seg + seg->next);
; 235  : 	memset(judy, 0, amt);

  00021	68 50 30 00 00	 push	 12368			; 00003050H
  00026	8d 34 38	 lea	 esi, DWORD PTR [eax+edi]
  00029	6a 00		 push	 0
  0002b	56		 push	 esi
  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00032	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 236  : 	judy->depth = depth;
; 237  :  	judy->seg = seg;

  0003d	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00040	c7 46 30 01 00
	00 00		 mov	 DWORD PTR [esi+48], 1

; 238  : 	judy->max = max;

  00047	c7 46 2c 01 04
	00 00		 mov	 DWORD PTR [esi+44], 1025 ; 00000401H

; 239  : 	return judy;

  0004e	8b c6		 mov	 eax, esi
  00050	5e		 pop	 esi
  00051	5f		 pop	 edi

; 240  : }

  00052	c3		 ret	 0
$LN3@judy_open:

; 212  : 		seg->seg = NULL;
; 213  : 		seg->next = JUDY_seg;
; 214  : 	} else {
; 215  : #if defined(STANDALONE) || defined(ASKITIS)
; 216  : 		judy_abort ("No virtual memory");
; 217  : #else
; 218  : 		return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	5f		 pop	 edi

; 240  : }

  00056	c3		 ret	 0
?judy_open@@YAPAXII@Z ENDP				; judy_open
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\nedtries\nedtrie.h
_TEXT	ENDS
;	COMDAT ?nedtriebitscanr@@YAII@Z
_TEXT	SEGMENT
_bitpos$ = -4						; size = 4
?nedtriebitscanr@@YAII@Z PROC				; nedtriebitscanr, COMDAT
; _value$ = eax

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : #ifdef _MSC_VER
; 135  :   unsigned long bitpos;
; 136  : #if defined(_M_IA64) || defined(_M_X64) || defined(WIN64)
; 137  :   assert(8==sizeof(size_t));
; 138  :   _BitScanReverse64(&bitpos, value | 1);
; 139  : #else
; 140  :   assert(4==sizeof(size_t));
; 141  :   _BitScanReverse(&bitpos, value | 1);

  00004	83 c8 01	 or	 eax, 1
  00007	0f bd c0	 bsr	 eax, eax
  0000a	89 45 fc	 mov	 DWORD PTR _bitpos$[ebp], eax

; 142  : #endif
; 143  :   return (unsigned) bitpos;
; 144  : #elif defined(__GNUC__)
; 145  :   return sizeof(value)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(value | 1);
; 146  : #else
; 147  :   /* The following code is illegal C, but it almost certainly will work.
; 148  :   If not use the legal implementation below */
; 149  :   unsigned bitpos;
; 150  : #if 1
; 151  : 	union {
; 152  : 		unsigned asInt[2];
; 153  : 		double asDouble;
; 154  : 	};
; 155  : 	int n;
; 156  : 
; 157  : 	asDouble = (double)value + 0.5;
; 158  : 	n = (asInt[0 /*Use 1 if your CPU is big endian!*/] >> 20) - 1023;
; 159  : #warning Make sure you change the line above me if your CPU is big endian!
; 160  : 	return (unsigned) n;
; 161  : #else
; 162  :   size_t x=value;
; 163  : 	x = x | (x >> 1);
; 164  : 	x = x | (x >> 2);
; 165  : 	x = x | (x >> 4);
; 166  : 	x = x | (x >> 8);
; 167  : 	x = x | (x >>16);
; 168  : 	x = ~x;
; 169  : 	x = x - ((x >> 1) & 0x55555555);
; 170  : 	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
; 171  : 	x = (x + (x >> 4)) & 0x0F0F0F0F;
; 172  : 	x = x + (x << 8);
; 173  : 	x = x + (x << 16);
; 174  : 	return x >> 24;
; 175  : #endif
; 176  : #endif
; 177  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?nedtriebitscanr@@YAII@Z ENDP				; nedtriebitscanr
_TEXT	ENDS
PUBLIC	_tommy_hashlin_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashlin.c
;	COMDAT _tommy_hashlin_memory_usage
_TEXT	SEGMENT
_tommy_hashlin_memory_usage PROC			; COMDAT

; 319  : 	return hashlin->bucket_max * (tommy_size_t)sizeof(hashlin->bucket[0][0])
; 320  : 		+ hashlin->count * (tommy_size_t)sizeof(tommy_hashlin_node);

  00000	a1 a0 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  00005	8b 0d 84 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000e	03 c0		 add	 eax, eax
  00010	03 c0		 add	 eax, eax

; 321  : }

  00012	c3		 ret	 0
_tommy_hashlin_memory_usage ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashlin_done
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashlin_done
_TEXT	SEGMENT
_tommy_hashlin_done PROC				; COMDAT

; 62   : 	/* we assume to be empty, so we free only the first bucket */
; 63   : 	assert(hashlin->bucket_mac == 1);
; 64   : 
; 65   : 	tommy_free(hashlin->bucket[0]);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _free
  0000b	59		 pop	 ecx

; 66   : }

  0000c	c3		 ret	 0
_tommy_hashlin_done ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashlin_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashlin_init
_TEXT	SEGMENT
_tommy_hashlin_init PROC				; COMDAT

; 46   : 	/* fixed initial size */
; 47   : 	hashlin->bucket_bit = TOMMY_HASHLIN_BIT;
; 48   : 	hashlin->bucket_max = 1 << hashlin->bucket_bit;
; 49   : 	hashlin->bucket_mask = hashlin->bucket_max - 1;
; 50   : 	hashlin->bucket[0] = tommy_cast(tommy_hashlin_node**, tommy_malloc(hashlin->bucket_max * sizeof(tommy_hashlin_node*)));

  00000	68 00 01 00 00	 push	 256			; 00000100H
  00005	c7 05 80 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, 6
  0000f	c7 05 84 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132, 64 ; 00000040H
  00019	c7 05 88 00 00
	00 3f 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136, 63 ; 0000003fH
  00023	e8 00 00 00 00	 call	 _malloc

; 51   : 	memset(hashlin->bucket[0], 0, hashlin->bucket_max * sizeof(tommy_hashlin_node*));

  00028	68 00 01 00 00	 push	 256			; 00000100H
  0002d	6a 00		 push	 0
  0002f	50		 push	 eax
  00030	a3 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A, eax
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 52   : 	hashlin->bucket_mac = 1;

  0003d	c7 05 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140, 1

; 53   : 
; 54   : 	/* stable state */
; 55   : 	hashlin->state = TOMMY_HASHLIN_STATE_STABLE;

  00047	c7 05 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0

; 56   : 
; 57   : 	hashlin->count = 0;

  00051	c7 05 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160, 0

; 58   : }

  0005b	c3		 ret	 0
_tommy_hashlin_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_done
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashdyn.c
;	COMDAT _tommy_hashdyn_done
_TEXT	SEGMENT
_tommy_hashdyn_done PROC				; COMDAT

; 50   : 	tommy_free(hashdyn->bucket);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _free
  0000b	59		 pop	 ecx

; 51   : }

  0000c	c3		 ret	 0
_tommy_hashdyn_done ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashdyn_init
_TEXT	SEGMENT
_tommy_hashdyn_init PROC				; COMDAT

; 38   : 	/* fixed initial size */
; 39   : 	hashdyn->bucket_bit = TOMMY_HASHDYN_BIT;
; 40   : 	hashdyn->bucket_max = 1 << hashdyn->bucket_bit;
; 41   : 	hashdyn->bucket_mask = hashdyn->bucket_max - 1;
; 42   : 	hashdyn->bucket = tommy_cast(tommy_hashdyn_node**, tommy_malloc(hashdyn->bucket_max * sizeof(tommy_hashdyn_node*)));

  00000	6a 40		 push	 64			; 00000040H
  00002	c7 05 04 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4, 4
  0000c	c7 05 08 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8, 16 ; 00000010H
  00016	c7 05 0c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12, 15 ; 0000000fH
  00020	e8 00 00 00 00	 call	 _malloc

; 43   : 	memset(hashdyn->bucket, 0, hashdyn->bucket_max * sizeof(tommy_hashdyn_node*));

  00025	6a 40		 push	 64			; 00000040H
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A, eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 44   : 
; 45   : 	hashdyn->count = 0;

  00037	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, 0

; 46   : }

  00041	c3		 ret	 0
_tommy_hashdyn_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_done
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashtbl.c
;	COMDAT _tommy_hashtable_done
_TEXT	SEGMENT
_tommy_hashtable_done PROC				; COMDAT

; 53   : 	tommy_free(hashtable->bucket);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _free
  0000b	59		 pop	 ecx

; 54   : }

  0000c	c3		 ret	 0
_tommy_hashtable_done ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_bucket
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrieinp.c
;	COMDAT _tommy_trie_inplace_bucket
_TEXT	SEGMENT
_tommy_trie_inplace_bucket PROC				; COMDAT
; _key$ = edx

; 252  : 	tommy_trie_inplace_node* node;
; 253  : 	unsigned shift;
; 254  : 
; 255  : 	node = trie_inplace->bucket[key >> TOMMY_TRIE_INPLACE_BUCKET_SHIFT];

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]

; 256  : 	shift = TOMMY_TRIE_INPLACE_BUCKET_SHIFT;

  0000c	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH

; 257  : 
; 258  : 	while (node && node->key != key) {

  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $LN1@tommy_trie
  00015	56		 push	 esi
$LL2@tommy_trie:
  00016	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00019	74 12		 je	 SHORT $LN9@tommy_trie

; 259  : 		node = node->map[(key >> shift) & TOMMY_TRIE_INPLACE_TREE_MASK];

  0001b	8b f2		 mov	 esi, edx
  0001d	d3 ee		 shr	 esi, cl

; 260  : 		shift -= TOMMY_TRIE_INPLACE_TREE_BIT;

  0001f	83 e9 02	 sub	 ecx, 2
  00022	83 e6 03	 and	 esi, 3
  00025	8b 44 b0 10	 mov	 eax, DWORD PTR [eax+esi*4+16]
  00029	85 c0		 test	 eax, eax
  0002b	75 e9		 jne	 SHORT $LL2@tommy_trie
$LN9@tommy_trie:
  0002d	5e		 pop	 esi
$LN1@tommy_trie:

; 261  : 	}
; 262  : 
; 263  : 	return node;
; 264  : }

  0002e	c3		 ret	 0
_tommy_trie_inplace_bucket ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_inplace_init
_TEXT	SEGMENT
_tommy_trie_inplace_init PROC				; COMDAT

; 97   : {

  00000	57		 push	 edi

; 98   : 	unsigned i;
; 99   : 
; 100  : 	for(i=0;i<TOMMY_TRIE_INPLACE_BUCKET_MAX;++i)
; 101  : 		trie_inplace->bucket[i] = 0;

  00001	33 c0		 xor	 eax, eax
  00003	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00008	bf 00 00 00 00	 mov	 edi, OFFSET ?trie_inplace@@3Utommy_trie_inplace_struct@@A ; trie_inplace
  0000d	f3 ab		 rep stosd

; 102  : 	
; 103  : 	trie_inplace->count = 0;

  0000f	a3 00 01 00 00	 mov	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256, eax
  00014	5f		 pop	 edi

; 104  : }

  00015	c3		 ret	 0
_tommy_trie_inplace_init ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_trie_inplace_list_remove@@YAXPAPAUtommy_trie_inplace_node_struct@@PAU1@@Z
_TEXT	SEGMENT
?tommy_trie_inplace_list_remove@@YAXPAPAUtommy_trie_inplace_node_struct@@PAU1@@Z PROC ; tommy_trie_inplace_list_remove, COMDAT
; _let_ptr$ = esi
; _node$ = eax

; 79   : 	tommy_trie_inplace_node* head = *let_ptr;
; 80   : 
; 81   : 	/* remove from the "circular" prev list */
; 82   : 	if (node->next) { 

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 16		 mov	 edx, DWORD PTR [esi]
  00004	85 c9		 test	 ecx, ecx
  00006	74 0a		 je	 SHORT $LN4@tommy_trie@2

; 83   : 		node->next->prev = node->prev;

  00008	57		 push	 edi
  00009	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000c	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0000f	5f		 pop	 edi

; 84   : 	} else {

  00010	eb 06		 jmp	 SHORT $LN3@tommy_trie@2
$LN4@tommy_trie@2:

; 85   : 		head->prev = node->prev; /* the last */

  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN3@tommy_trie@2:

; 86   : 	}
; 87   : 
; 88   : 	/* remove from the "0 terminated" next list */
; 89   : 	if (head == node) {

  00018	3b d0		 cmp	 edx, eax

; 90   : 		*let_ptr = node->next; /* the new first */

  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	75 03		 jne	 SHORT $LN2@tommy_trie@2
  0001e	89 16		 mov	 DWORD PTR [esi], edx

; 93   : 	}
; 94   : }

  00020	c3		 ret	 0
$LN2@tommy_trie@2:

; 91   : 	} else {
; 92   : 		node->prev->next = node->next;

  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	89 11		 mov	 DWORD PTR [ecx], edx

; 93   : 	}
; 94   : }

  00026	c3		 ret	 0
?tommy_trie_inplace_list_remove@@YAXPAPAUtommy_trie_inplace_node_struct@@PAU1@@Z ENDP ; tommy_trie_inplace_list_remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_trie_inplace_list_insert_tail_not_empty@@YAXPAUtommy_trie_inplace_node_struct@@0@Z
_TEXT	SEGMENT
?tommy_trie_inplace_list_insert_tail_not_empty@@YAXPAUtommy_trie_inplace_node_struct@@0@Z PROC ; tommy_trie_inplace_list_insert_tail_not_empty, COMDAT
; _head$ = ecx
; _node$ = eax

; 63   : 	/* insert in the list in the last position */
; 64   : 
; 65   : 	/* insert in the "circular" prev list */
; 66   : 	node->prev = head->prev;

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 67   : 	head->prev = node;

  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 68   : 
; 69   : 	/* insert in the "0 terminated" next list */
; 70   : 	node->next = 0;
; 71   : 	node->prev->next = node;

  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 72   : }

  00014	c3		 ret	 0
?tommy_trie_inplace_list_insert_tail_not_empty@@YAXPAUtommy_trie_inplace_node_struct@@0@Z ENDP ; tommy_trie_inplace_list_insert_tail_not_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_trie_inplace_list_insert_first@@YAPAUtommy_trie_inplace_node_struct@@PAU1@@Z
_TEXT	SEGMENT
?tommy_trie_inplace_list_insert_first@@YAPAUtommy_trie_inplace_node_struct@@PAU1@@Z PROC ; tommy_trie_inplace_list_insert_first, COMDAT
; _node$ = eax

; 48   : 	/* one element "circular" prev list */   
; 49   : 	node->prev = node;

  00000	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 50   : 
; 51   : 	/* one element "0 terminated" next list */
; 52   : 	node->next = 0;

  00003	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 53   : 
; 54   : 	return node;
; 55   : }

  00009	c3		 ret	 0
?tommy_trie_inplace_list_insert_first@@YAPAUtommy_trie_inplace_node_struct@@PAU1@@Z ENDP ; tommy_trie_inplace_list_insert_first
_TEXT	ENDS
PUBLIC	_tommy_trie_bucket
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrie.c
;	COMDAT _tommy_trie_bucket
_TEXT	SEGMENT
_tommy_trie_bucket PROC					; COMDAT
; _key$ = edx

; 295  : 	tommy_trie_node* node;
; 296  : 	void* ptr;
; 297  : 	unsigned type;
; 298  : 	unsigned shift;
; 299  : 
; 300  : 	ptr = trie->bucket[key >> TOMMY_TRIE_BUCKET_SHIFT];

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  0000c	56		 push	 esi

; 301  : 
; 302  : 	shift = TOMMY_TRIE_BUCKET_SHIFT;

  0000d	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH

; 303  : 
; 304  : recurse:
; 305  : 	if (!ptr)

  00012	85 c0		 test	 eax, eax
  00014	74 16		 je	 SHORT $LN10@tommy_trie@3
$recurse$86538:

; 307  : 
; 308  : 	type = trie_get_type(ptr);

  00016	a8 01		 test	 al, 1

; 309  : 
; 310  : 	switch (type) {

  00018	74 16		 je	 SHORT $LN3@tommy_trie@3

; 314  : 			return 0;
; 315  : 		return node;
; 316  : 	default:
; 317  : 	case TOMMY_TRIE_TYPE_TREE :
; 318  : 		ptr = trie_get_tree(ptr)->map[(key >> shift) & TOMMY_TRIE_TREE_MASK];

  0001a	8b f2		 mov	 esi, edx
  0001c	d3 ee		 shr	 esi, cl

; 319  : 		shift -= TOMMY_TRIE_TREE_BIT;

  0001e	83 e9 03	 sub	 ecx, 3
  00021	83 e6 07	 and	 esi, 7
  00024	8b 44 b0 ff	 mov	 eax, DWORD PTR [eax+esi*4-1]
  00028	85 c0		 test	 eax, eax
  0002a	75 ea		 jne	 SHORT $recurse$86538
$LN10@tommy_trie@3:

; 306  : 		return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 320  : 		goto recurse;
; 321  : 	}
; 322  : }

  0002f	c3		 ret	 0
$LN3@tommy_trie@3:

; 311  : 	case TOMMY_TRIE_TYPE_NODE :
; 312  : 		node = tommy_cast(tommy_trie_node*, ptr);
; 313  : 		if (node->key != key)

  00030	33 c9		 xor	 ecx, ecx
  00032	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00035	5e		 pop	 esi
  00036	0f 95 c1	 setne	 cl
  00039	49		 dec	 ecx
  0003a	23 c1		 and	 eax, ecx

; 320  : 		goto recurse;
; 321  : 	}
; 322  : }

  0003c	c3		 ret	 0
_tommy_trie_bucket ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_done
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_done
_TEXT	SEGMENT
_tommy_trie_done PROC					; COMDAT

; 92   :     /* we assume to be empty, and if we are empty all the bucket are 0 */
; 93   :     assert(trie->count == 0);
; 94   : }

  00000	c3		 ret	 0
_tommy_trie_done ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_init
_TEXT	SEGMENT
_tommy_trie_init PROC					; COMDAT

; 79   : 	unsigned i;
; 80   : 
; 81   : 	for(i=0;i<TOMMY_TRIE_BUCKET_MAX;++i)
; 82   : 		trie->bucket[i] = 0;

  00000	33 c0		 xor	 eax, eax
  00002	a3 00 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A, eax
  00007	a3 04 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+4, eax
  0000c	a3 08 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+8, eax
  00011	a3 0c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+12, eax
  00016	a3 10 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+16, eax
  0001b	a3 14 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+20, eax
  00020	a3 18 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+24, eax
  00025	a3 1c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+28, eax
  0002a	a3 20 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+32, eax
  0002f	a3 24 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+36, eax
  00034	a3 28 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+40, eax
  00039	a3 2c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+44, eax
  0003e	a3 30 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+48, eax
  00043	a3 34 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+52, eax
  00048	a3 38 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+56, eax
  0004d	a3 3c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+60, eax
  00052	a3 40 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64, eax
  00057	a3 44 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+68, eax
  0005c	a3 48 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+72, eax
  00061	a3 4c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+76, eax
  00066	a3 50 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+80, eax
  0006b	a3 54 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+84, eax
  00070	a3 58 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+88, eax
  00075	a3 5c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+92, eax
  0007a	a3 60 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+96, eax
  0007f	a3 64 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+100, eax
  00084	a3 68 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+104, eax
  00089	a3 6c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+108, eax
  0008e	a3 70 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+112, eax
  00093	a3 74 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+116, eax
  00098	a3 78 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+120, eax
  0009d	a3 7c 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+124, eax

; 83   :    
; 84   : 	trie->count = 0;

  000a2	a3 80 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128, eax

; 85   : 	trie->node_count = 0;

  000a7	a3 84 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+132, eax

; 86   : 
; 87   : 	trie->alloc = alloc;

  000ac	c7 05 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+136, OFFSET ?trie_allocator@@3Utommy_allocator_struct@@A ; trie_allocator

; 88   : }

  000b6	c3		 ret	 0
_tommy_trie_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_allocator_free
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyalloc.c
;	COMDAT _tommy_allocator_free
_TEXT	SEGMENT
_tommy_allocator_free PROC				; COMDAT
; _alloc$ = eax
; _ptr$ = ecx

; 127  : 	tommy_allocator_entry* free_block = tommy_cast(tommy_allocator_entry*, ptr);
; 128  : 	
; 129  : 	/* put it in the free list */
; 130  : 	free_block->next = alloc->free_block;

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	89 11		 mov	 DWORD PTR [ecx], edx

; 131  : 	alloc->free_block = free_block;
; 132  : 
; 133  : 	--alloc->count;

  00004	ff 48 10	 dec	 DWORD PTR [eax+16]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 134  : }

  00009	c3		 ret	 0
_tommy_allocator_free ENDP
_TEXT	ENDS
PUBLIC	_tommy_allocator_alloc
; Function compile flags: /Ogtp
;	COMDAT _tommy_allocator_alloc
_TEXT	SEGMENT
_tommy_allocator_alloc PROC				; COMDAT
; _alloc$ = esi

; 83   : 	void* ptr;
; 84   : 
; 85   : 	/* if no free block available */
; 86   : 	if (!alloc->free_block) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	75 50		 jne	 SHORT $LN1@tommy_allo

; 87   : 		tommy_uintptr_t off, mis;
; 88   : 		tommy_size_t size = TOMMY_ALLOCATOR_BLOCK_SIZE;

  00005	53		 push	 ebx
  00006	57		 push	 edi
  00007	bf c0 0f 00 00	 mov	 edi, 4032		; 00000fc0H

; 89   : 		char* data = tommy_cast(char*, tommy_malloc(size));

  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 _malloc
  00012	8b c8		 mov	 ecx, eax

; 90   : 		tommy_allocator_entry* segment = (tommy_allocator_entry*)data;
; 91   : 
; 92   : 		/* put in the segment list */
; 93   : 		segment->next = alloc->used_segment;

  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 94   : 		alloc->used_segment = segment;
; 95   : 		data += sizeof(tommy_allocator_entry);
; 96   : 
; 97   : 		/* align if not aligned */
; 98   : 		off = (tommy_uintptr_t)data;
; 99   : 		mis = off % alloc->align_size;

  00019	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0001c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0001f	83 c1 04	 add	 ecx, 4
  00022	33 d2		 xor	 edx, edx
  00024	8b c1		 mov	 eax, ecx
  00026	f7 f3		 div	 ebx
  00028	83 c4 04	 add	 esp, 4

; 100  : 		if (mis != 0) {

  0002b	85 d2		 test	 edx, edx
  0002d	74 0e		 je	 SHORT $LN7@tommy_allo

; 101  : 			data += alloc->align_size - mis;

  0002f	8b c3		 mov	 eax, ebx
  00031	2b c2		 sub	 eax, edx
  00033	03 c8		 add	 ecx, eax

; 102  : 			size -= alloc->align_size - mis;

  00035	2b d3		 sub	 edx, ebx
  00037	8d ba c0 0f 00
	00		 lea	 edi, DWORD PTR [edx+4032]
$LN7@tommy_allo:

; 103  : 		}
; 104  : 
; 105  : 		/* insert in free list */
; 106  : 		while (size >= alloc->block_size) {

  0003d	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00040	72 11		 jb	 SHORT $LN9@tommy_allo
$LL2@tommy_allo:

; 107  : 			tommy_allocator_entry* free_block = (tommy_allocator_entry*)data;
; 108  : 			free_block->next = alloc->free_block;

  00042	8b 16		 mov	 edx, DWORD PTR [esi]
  00044	89 11		 mov	 DWORD PTR [ecx], edx

; 109  : 			alloc->free_block = free_block;
; 110  : 
; 111  : 			data += alloc->block_size;

  00046	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00049	89 0e		 mov	 DWORD PTR [esi], ecx

; 112  : 			size -= alloc->block_size;

  0004b	2b f8		 sub	 edi, eax
  0004d	03 c8		 add	 ecx, eax
  0004f	3b f8		 cmp	 edi, eax
  00051	73 ef		 jae	 SHORT $LL2@tommy_allo
$LN9@tommy_allo:
  00053	5f		 pop	 edi
  00054	5b		 pop	 ebx
$LN1@tommy_allo:

; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	/* remove one from the free list */
; 117  : 	ptr = alloc->free_block;

  00055	8b 06		 mov	 eax, DWORD PTR [esi]

; 118  : 	alloc->free_block = alloc->free_block->next;

  00057	8b 08		 mov	 ecx, DWORD PTR [eax]

; 119  : 	
; 120  : 	++alloc->count;

  00059	ff 46 10	 inc	 DWORD PTR [esi+16]
  0005c	89 0e		 mov	 DWORD PTR [esi], ecx

; 121  : 
; 122  : 	return ptr;
; 123  : }

  0005e	c3		 ret	 0
_tommy_allocator_alloc ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z
_TEXT	SEGMENT
?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z PROC	; allocator_reset, COMDAT

; 64   : 	tommy_allocator_entry* block = alloc->used_segment;

  00000	a1 04 00 00 00	 mov	 eax, DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4

; 65   : 	while (block) {

  00005	85 c0		 test	 eax, eax
  00007	74 19		 je	 SHORT $LN1@allocator_
  00009	56		 push	 esi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL2@allocator_:

; 66   : 		tommy_allocator_entry* block_next = block->next;

  00010	8b 30		 mov	 esi, DWORD PTR [eax]

; 67   : 		tommy_free(block);

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _free
  00018	83 c4 04	 add	 esp, 4

; 68   : 		block = block_next;

  0001b	8b c6		 mov	 eax, esi
  0001d	85 f6		 test	 esi, esi
  0001f	75 ef		 jne	 SHORT $LL2@allocator_
  00021	5e		 pop	 esi
$LN1@allocator_:

; 69   : 	}
; 70   : 
; 71   : 	alloc->count = 0;

  00022	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+16, 0

; 72   : 	alloc->free_block = 0;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A, 0

; 73   : 	alloc->used_segment = 0;

  00036	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4, 0

; 74   : }

  00040	c3		 ret	 0
?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z ENDP	; allocator_reset
_TEXT	ENDS
PUBLIC	_tommy_allocator_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_allocator_init
_TEXT	SEGMENT
_tommy_allocator_init PROC				; COMDAT

; 42   : 	/* setup the minimal alignment */
; 43   : 	if (align_size < sizeof(void*))
; 44   : 		align_size = sizeof(void*);
; 45   : 
; 46   : 	/* ensure that the block_size keeps the alignment */
; 47   : 	if (block_size % align_size != 0) {
; 48   : 		block_size += align_size - block_size % align_size;
; 49   : 	}
; 50   : 
; 51   : 	alloc->block_size = block_size;

  00000	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00005	a3 08 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+8, eax

; 52   : 	alloc->align_size = align_size;

  0000a	a3 0c 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+12, eax

; 53   : 
; 54   : 	alloc->count = 0;

  0000f	33 c0		 xor	 eax, eax
  00011	a3 10 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+16, eax

; 55   : 	alloc->free_block = 0;

  00016	a3 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A, eax

; 56   : 	alloc->used_segment = 0;

  0001b	a3 04 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4, eax

; 57   : }

  00020	c3		 ret	 0
_tommy_allocator_init ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashlin.h
_TEXT	ENDS
;	COMDAT _tommy_hashlin_count
_TEXT	SEGMENT
_tommy_hashlin_count PROC				; COMDAT

; 250  : 	return hashlin->count;

  00000	a1 a0 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 251  : }

  00005	c3		 ret	 0
_tommy_hashlin_count ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashdyn.h
_TEXT	ENDS
;	COMDAT _tommy_hashdyn_count
_TEXT	SEGMENT
_tommy_hashdyn_count PROC				; COMDAT

; 240  : 	return hashdyn->count;

  00000	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16

; 241  : }

  00005	c3		 ret	 0
_tommy_hashdyn_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_hashdyn_bucket
_TEXT	SEGMENT
_hash$ = 8						; size = 4
_tommy_hashdyn_bucket PROC				; COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  : 	return hashdyn->bucket[hash & hashdyn->bucket_mask];

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  00008	23 45 08	 and	 eax, DWORD PTR _hash$[ebp]
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 204  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_tommy_hashdyn_bucket ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashtbl.h
_TEXT	ENDS
;	COMDAT _tommy_hashtable_count
_TEXT	SEGMENT
_tommy_hashtable_count PROC				; COMDAT

; 225  : 	return hashtable->count;

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 226  : }

  00005	c3		 ret	 0
_tommy_hashtable_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_hashtable_bucket
_TEXT	SEGMENT
_hash$ = 8						; size = 4
_tommy_hashtable_bucket PROC				; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 188  : 	return hashtable->bucket[hash & hashtable->bucket_mask];

  00003	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00008	23 45 08	 and	 eax, DWORD PTR _hash$[ebp]
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 189  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_tommy_hashtable_bucket ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrieinp.h
_TEXT	ENDS
;	COMDAT _tommy_trie_inplace_count
_TEXT	SEGMENT
_tommy_trie_inplace_count PROC				; COMDAT

; 225  : 	return trie_inplace->count;

  00000	a1 00 01 00 00	 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256

; 226  : }

  00005	c3		 ret	 0
_tommy_trie_inplace_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_trie_inplace_search
_TEXT	SEGMENT
_tommy_trie_inplace_search PROC				; COMDAT
; _key$ = edx

; 205  : 	tommy_trie_inplace_node* i = tommy_trie_inplace_bucket(trie_inplace, key);

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]
  0000c	56		 push	 esi
  0000d	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00012	85 c0		 test	 eax, eax
  00014	74 1d		 je	 SHORT $LN10@tommy_trie@4
$LL5@tommy_trie@4:
  00016	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00019	74 14		 je	 SHORT $LN4@tommy_trie@4
  0001b	8b f2		 mov	 esi, edx
  0001d	d3 ee		 shr	 esi, cl
  0001f	83 e9 02	 sub	 ecx, 2
  00022	83 e6 03	 and	 esi, 3
  00025	8b 44 b0 10	 mov	 eax, DWORD PTR [eax+esi*4+16]
  00029	85 c0		 test	 eax, eax
  0002b	75 e9		 jne	 SHORT $LL5@tommy_trie@4
  0002d	5e		 pop	 esi

; 211  : }

  0002e	c3		 ret	 0

; 205  : 	tommy_trie_inplace_node* i = tommy_trie_inplace_bucket(trie_inplace, key);

$LN4@tommy_trie@4:

; 206  : 
; 207  : 	if (!i)

  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $LN1@tommy_trie@4
$LN10@tommy_trie@4:

; 208  : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 211  : }

  00036	c3		 ret	 0
$LN1@tommy_trie@4:

; 209  : 
; 210  : 	return i->data;

  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	5e		 pop	 esi

; 211  : }

  0003b	c3		 ret	 0
_tommy_trie_inplace_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrie.h
_TEXT	ENDS
;	COMDAT _tommy_trie_count
_TEXT	SEGMENT
_tommy_trie_count PROC					; COMDAT

; 253  : 	return trie->count;

  00000	a1 80 00 00 00	 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A+128

; 254  : }

  00005	c3		 ret	 0
_tommy_trie_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_trie_search
_TEXT	SEGMENT
_tommy_trie_search PROC					; COMDAT
; _key$ = edx

; 233  : 	tommy_trie_node* i = tommy_trie_bucket(trie, key);

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  0000c	56		 push	 esi
  0000d	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  00012	85 c0		 test	 eax, eax
  00014	74 1d		 je	 SHORT $LN15@tommy_trie@5
$recurse$165329:
  00016	a8 01		 test	 al, 1
  00018	74 14		 je	 SHORT $LN6@tommy_trie@5
  0001a	8b f2		 mov	 esi, edx
  0001c	d3 ee		 shr	 esi, cl
  0001e	83 e9 03	 sub	 ecx, 3
  00021	83 e6 07	 and	 esi, 7
  00024	8b 44 b0 ff	 mov	 eax, DWORD PTR [eax+esi*4-1]
  00028	85 c0		 test	 eax, eax
  0002a	75 ea		 jne	 SHORT $recurse$165329
  0002c	5e		 pop	 esi

; 239  : }

  0002d	c3		 ret	 0

; 233  : 	tommy_trie_node* i = tommy_trie_bucket(trie, key);

$LN6@tommy_trie@5:
  0002e	39 50 0c	 cmp	 DWORD PTR [eax+12], edx

; 234  : 
; 235  : 	if (!i)

  00031	74 04		 je	 SHORT $LN1@tommy_trie@5
$LN15@tommy_trie@5:

; 236  : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 239  : }

  00036	c3		 ret	 0
$LN1@tommy_trie@5:

; 237  : 
; 238  : 	return i->data;

  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	5e		 pop	 esi

; 239  : }

  0003b	c3		 ret	 0
_tommy_trie_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommylist.h
_TEXT	ENDS
;	COMDAT _tommy_list_insert_tail_not_empty
_TEXT	SEGMENT
_tommy_list_insert_tail_not_empty PROC			; COMDAT
; _head$ = ecx
; _node$ = eax

; 191  : 	/* insert in the "circular" prev list */
; 192  : 	node->prev = head->prev;

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 193  : 	head->prev = node;

  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 194  : 
; 195  : 	/* insert in the "0 terminated" next list */
; 196  : 	node->next = 0;
; 197  : 	node->prev->next = node;

  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 198  : }

  00014	c3		 ret	 0
_tommy_list_insert_tail_not_empty ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_insert_first
_TEXT	SEGMENT
_tommy_list_insert_first PROC				; COMDAT
; _list$ = ecx
; _node$ = eax

; 154  : 	/* one element "circular" prev list */   
; 155  : 	node->prev = node;

  00000	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 156  : 
; 157  : 	/* one element "0 terminated" next list */
; 158  : 	node->next = 0;

  00003	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 159  : 
; 160  : 	*list = node;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 161  : }

  0000b	c3		 ret	 0
_tommy_list_insert_first ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_head
_TEXT	SEGMENT
_tommy_list_head PROC					; COMDAT
; _list$ = eax

; 130  : 	return *list;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 131  : }

  00002	c3		 ret	 0
_tommy_list_head ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhash.h
_TEXT	ENDS
;	COMDAT _tommy_inthash_u32
_TEXT	SEGMENT
_tommy_inthash_u32 PROC					; COMDAT
; _key$ = ecx

; 82   : 	key -= key << 6;

  00000	8b c1		 mov	 eax, ecx
  00002	c1 e0 06	 shl	 eax, 6
  00005	2b c8		 sub	 ecx, eax

; 83   : 	key ^= key >> 17;

  00007	8b d1		 mov	 edx, ecx
  00009	c1 ea 11	 shr	 edx, 17			; 00000011H
  0000c	33 ca		 xor	 ecx, edx

; 84   : 	key -= key << 9;

  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e0 09	 shl	 eax, 9
  00013	2b c8		 sub	 ecx, eax

; 85   : 	key ^= key << 4;

  00015	8b d1		 mov	 edx, ecx
  00017	c1 e2 04	 shl	 edx, 4
  0001a	33 ca		 xor	 ecx, edx

; 86   : 	key -= key << 3;

  0001c	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00023	2b c8		 sub	 ecx, eax

; 87   : 	key ^= key << 10;

  00025	8b d1		 mov	 edx, ecx
  00027	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0002a	33 ca		 xor	 ecx, edx

; 88   : 	key ^= key >> 15;

  0002c	8b c1		 mov	 eax, ecx
  0002e	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00031	33 c1		 xor	 eax, ecx

; 89   : 
; 90   : 	return key;
; 91   : }

  00033	c3		 ret	 0
_tommy_inthash_u32 ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytypes.h
_TEXT	ENDS
;	COMDAT _tommy_roundup_pow2_u32
_TEXT	SEGMENT
_tommy_roundup_pow2_u32 PROC				; COMDAT
; _value$ = ecx

; 318  : 	/* Round up to the next highest power of 2 */
; 319  : 	/* from http://www-graphics.stanford.edu/~seander/bithacks.html */
; 320  : 
; 321  : 	--value;

  00000	49		 dec	 ecx

; 322  : 	value |= value >> 1;

  00001	8b c1		 mov	 eax, ecx
  00003	d1 e8		 shr	 eax, 1
  00005	0b c8		 or	 ecx, eax

; 323  : 	value |= value >> 2;

  00007	8b d1		 mov	 edx, ecx
  00009	c1 ea 02	 shr	 edx, 2
  0000c	0b ca		 or	 ecx, edx

; 324  : 	value |= value >> 4;

  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e8 04	 shr	 eax, 4
  00013	0b c8		 or	 ecx, eax

; 325  : 	value |= value >> 8;

  00015	8b d1		 mov	 edx, ecx
  00017	c1 ea 08	 shr	 edx, 8
  0001a	0b ca		 or	 ecx, edx

; 326  : 	value |= value >> 16;

  0001c	8b c1		 mov	 eax, ecx
  0001e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00021	0b c1		 or	 eax, ecx

; 327  : 	++value;

  00023	40		 inc	 eax

; 328  : 
; 329  : 	return value;
; 330  : }

  00024	c3		 ret	 0
_tommy_roundup_pow2_u32 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_ilog2_u32
_TEXT	SEGMENT
_count$ = -4						; size = 4
_value$ = 8						; size = 4
_tommy_ilog2_u32 PROC					; COMDAT

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 251  : #if defined(_MSC_VER)
; 252  : 	unsigned long count;
; 253  : 	_BitScanReverse(&count, value);

  00004	0f bd 45 08	 bsr	 eax, DWORD PTR _value$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 254  : 	return count;
; 255  : #elif defined(__GNUC__)
; 256  : 	/*
; 257  : 	 * GCC implements __builtin_clz(x) as "__builtin_clz(x) = bsr(x) ^ 31"
; 258  : 	 *
; 259  : 	 * Where "x ^ 31 = 31 - x", but gcc does not optimize "31 - __builtin_clz(x)" to bsr(x),
; 260  : 	 * but generates 31 - (bsr(x) xor 31).
; 261  : 	 *
; 262  : 	 * So we write "__builtin_clz(x) ^ 31" instead of "31 - __builtin_clz(x)".
; 263  : 	 */
; 264  : 	return __builtin_clz(value) ^ 31;
; 265  : #else
; 266  : 	/* Find the log base 2 of an N-bit integer in O(lg(N)) operations with multiply and lookup */
; 267  : 	/* from http://graphics.stanford.edu/~seander/bithacks.html */
; 268  : 	static const int TOMMY_DE_BRUIJN_INDEX_ILOG2[32] = {
; 269  : 		0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,
; 270  : 		8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31
; 271  : 	};
; 272  : 
; 273  : 	value |= value >> 1;
; 274  : 	value |= value >> 2;
; 275  : 	value |= value >> 4;
; 276  : 	value |= value >> 8;
; 277  : 	value |= value >> 16;
; 278  : 
; 279  : 	return TOMMY_DE_BRUIJN_INDEX_ILOG2[(tommy_uint32_t)(value * 0x07C4ACDDU) >> 27];
; 280  : #endif
; 281  : }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_tommy_ilog2_u32 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN7@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN7@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@

; 31   : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 49   : 		}

  00000	c3		 ret	 0
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\limits
_TEXT	ENDS
;	COMDAT ?max@?$numeric_limits@I@std@@SAIXZ
_TEXT	SEGMENT
?max@?$numeric_limits@I@std@@SAIXZ PROC			; std::numeric_limits<unsigned int>::max, COMDAT

; 778  : 		{	// return maximum value
; 779  : 		return (UINT_MAX);

  00000	83 c8 ff	 or	 eax, -1

; 780  : 		}

  00003	c3		 ret	 0
?max@?$numeric_limits@I@std@@SAIXZ ENDP			; std::numeric_limits<unsigned int>::max
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Where$ = eax

; 57   : 	return (_Where);
; 58   : 	}

  00000	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = -4						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = esi

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b ce		 mov	 ecx, esi
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Message$[ebp], 0
  00011	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z PROC ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 164  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ENDP ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z PROC ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 248  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ENDP ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z PROC ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ENDP ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z PROC ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 146  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z
_TEXT	SEGMENT
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN3@construct
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN3@construct:

; 203  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z PROC ; std::_Construct<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN3@Construct
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Construct:

; 49   : 	}

  00008	c3		 ret	 0
??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ENDP ; std::_Construct<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z PROC ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *><unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 256  : 		}

  0000a	c3		 ret	 0
??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z ENDP ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *><unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *><unsigned int &,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *><unsigned int &,google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z PROC ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN7@Cons_val
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN7@Cons_val:

; 281  : 	}

  00008	c3		 ret	 0
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z ENDP ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 164  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z
_TEXT	SEGMENT
?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_internal, COMDAT
; _f$ = eax
; _parent$ = edx

; 699  :     btree_node *n = init_leaf(f, parent, kNodeValues);

  00000	32 c9		 xor	 cl, cl
  00002	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00008	88 48 03	 mov	 BYTE PTR [eax+3], cl
  0000b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 700  :     f->leaf = 0;

  0000e	88 08		 mov	 BYTE PTR [eax], cl

; 701  :     if (!NDEBUG) {
; 702  :       memset(f->children, 0, sizeof(f->children));
; 703  :     }
; 704  :     return n;
; 705  :   }

  00010	c3		 ret	 0
?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_internal
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z
_TEXT	SEGMENT
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN5@construct@2
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN5@construct@2:

; 198  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN3@construct@3
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@3:

; 203  : 		}

  0000e	c3		 ret	 0
?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::construct
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init, COMDAT
; _this$ = eax
; _x$ = ecx

; 722  :   void value_init(int i, const value_type &x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 723  :     new (&fields_.values[i]) mutable_value_type(x);

  00003	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00006	8d 44 d0 08	 lea	 eax, DWORD PTR [eax+edx*8+8]
  0000a	85 c0		 test	 eax, eax
  0000c	74 0a		 je	 SHORT $LN3@value_init
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 10		 mov	 DWORD PTR [eax], edx
  00012	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@value_init:

; 724  :   }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z
_TEXT	SEGMENT
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init, COMDAT
; _this$ = eax
; _i$ = ecx

; 720  :     new (&fields_.values[i]) mutable_value_type;

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]
  00004	85 c0		 test	 eax, eax
  00006	74 0d		 je	 SHORT $LN3@value_init@2
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN3@value_init@2:

; 721  :   }

  00015	c3		 ret	 0
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_child, COMDAT
; _i$ = ecx
; _c$ = eax

; 574  :   void set_child(int i, btree_node *c) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]

; 575  :     *mutable_child(i) = c;

  00006	89 84 8a 00 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+256], eax

; 576  :     c->fields_.parent = this;

  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 577  :     c->fields_.position = i;

  00010	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 578  :   }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_child
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost, COMDAT
; _this$ = eax

; 1224 :   node_type** mutable_rightmost() { return root()->mutable_rightmost(); }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00007	c3		 ret	 0
?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *><unsigned int,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *><unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z PROC ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int &,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 248  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ENDP ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int &,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z PROC ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN9@Cons_val@2
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN9@Cons_val@2:

; 281  : 	}

  00008	c3		 ret	 0
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z ENDP ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00006	3b ca		 cmp	 ecx, edx
  00008	74 19		 je	 SHORT $LN4@Uninit_mov
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00010	85 c0		 test	 eax, eax
  00012	74 04		 je	 SHORT $LN20@Uninit_mov
  00014	8b 31		 mov	 esi, DWORD PTR [ecx]
  00016	89 30		 mov	 DWORD PTR [eax], esi
$LN20@Uninit_mov:

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00018	83 c1 04	 add	 ecx, 4
  0001b	83 c0 04	 add	 eax, 4
  0001e	3b ca		 cmp	 ecx, edx
  00020	75 ee		 jne	 SHORT $LL6@Uninit_mov
  00022	5e		 pop	 esi
$LN4@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);
; 438  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN3@Construct@2
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct@2:

; 49   : 	}

  0000e	c3		 ret	 0
??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *>,std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN7@Cons_val@3
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@3:

; 281  : 	}

  0000e	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *>,std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 248  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 146  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::destroy, COMDAT

; 713  :     for (int i = 0; i < count(); ++i) {
; 714  :       value_destroy(i);
; 715  :     }
; 716  :   }

  00000	c3		 ret	 0
?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z
_TEXT	SEGMENT
?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z PROC ; btree::btree_key_comparer<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> >,0>::bool_compare, COMDAT
; _x$ = eax
; _y$ = edx

; 234  :     return comp(x, y);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 235  :   }

  00008	c3		 ret	 0
?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z ENDP ; btree::btree_key_comparer<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> >,0>::bool_compare
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 228  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ
_TEXT	SEGMENT
?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::make_root, COMDAT
; _this$ = eax

; 540  :     assert(parent()->is_root());
; 541  :     fields_.parent = fields_.parent->parent();

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 542  :   }

  00009	c3		 ret	 0
?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::make_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ
_TEXT	SEGMENT
?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::is_root, COMDAT
; _this$ = eax

; 538  :   bool is_root() const { return parent()->leaf(); }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8a 01		 mov	 al, BYTE PTR [ecx]
  00005	c3		 ret	 0
?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::is_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_leaf_node, COMDAT
; _node$ = eax

; 1275 :     node->destroy();
; 1276 :     mutable_internal_allocator()->deallocate(
; 1277 :         reinterpret_cast<char*>(node),
; 1278 :         sizeof(base_fields) + node->max_count() * sizeof(value_type));

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 1279 :   }

  00007	c3		 ret	 0
?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_leaf_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ
_TEXT	SEGMENT
?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_root_node, COMDAT
; _this$ = eax

; 1270 :     root()->destroy();
; 1271 :     mutable_internal_allocator()->deallocate(
; 1272 :         reinterpret_cast<char*>(root()), sizeof(root_fields));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 1273 :   }

  00009	c3		 ret	 0
?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_root_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_node, COMDAT
; _node$ = eax

; 1264 :     node->destroy();
; 1265 :     assert(node != root());
; 1266 :     mutable_internal_allocator()->deallocate(
; 1267 :         reinterpret_cast<char*>(node), sizeof(internal_fields));

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 1268 :   }

  00007	c3		 ret	 0
?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_node
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@I@btree@@YAXAAI0@Z
_TEXT	SEGMENT
??$btree_swap_helper@I@btree@@YAXAAI0@Z PROC		; btree::btree_swap_helper<unsigned int>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@I@btree@@YAXAAI0@Z ENDP		; btree::btree_swap_helper<unsigned int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z
_TEXT	SEGMENT
??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z PROC ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *><unsigned int,google_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 256  : 		}

  0000a	c3		 ret	 0
??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z ENDP ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *><unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z PROC ; std::make_pair<unsigned int,google_object *>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 368  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 370  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 371  : 	return (_Mypair((typename _Unrefwrap<_Ty1>::type)_Val1,

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 372  : 		_STD forward<_Ty2>(_Val2)));
; 373  : 	}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z ENDP ; std::make_pair<unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_compare_keys@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@btree@@YA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@0@ABI1@Z
_TEXT	SEGMENT
??$btree_compare_keys@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@btree@@YA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@0@ABI1@Z PROC ; btree::btree_compare_keys<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >, COMDAT
; _x$ = eax
; _y$ = edx

; 265  :   typedef btree_key_comparer<Key, Compare,
; 266  :       btree_is_key_compare_to<Compare>::value> key_comparer;
; 267  :   return key_comparer::bool_compare(comp, x, y);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 268  : }

  00008	c3		 ret	 0
??$btree_compare_keys@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@btree@@YA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@0@ABI1@Z ENDP ; btree::btree_compare_keys<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Count$ = eax
; __Pval$ = edx

; 558  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 559  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 560  : //	if (_Count < 0)
; 561  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 562  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 563  : 
; 564  : 	_FwdIt _Next = _First;
; 565  : 
; 566  : 	_TRY_BEGIN
; 567  : 	for (; 0 < _Count; --_Count, ++_First)

  00006	85 c0		 test	 eax, eax
  00008	74 15		 je	 SHORT $LN4@Uninit_fil
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Uninit_fil:

; 568  : 		_Cons_val(_Al, _First, *_Pval);

  00010	85 c9		 test	 ecx, ecx
  00012	74 04		 je	 SHORT $LN22@Uninit_fil
  00014	8b 32		 mov	 esi, DWORD PTR [edx]
  00016	89 31		 mov	 DWORD PTR [ecx], esi
$LN22@Uninit_fil:

; 559  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 560  : //	if (_Count < 0)
; 561  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 562  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 563  : 
; 564  : 	_FwdIt _Next = _First;
; 565  : 
; 566  : 	_TRY_BEGIN
; 567  : 	for (; 0 < _Count; --_Count, ++_First)

  00018	83 c1 04	 add	 ecx, 4
  0001b	48		 dec	 eax
  0001c	75 f2		 jne	 SHORT $LL6@Uninit_fil
  0001e	5e		 pop	 esi
$LN4@Uninit_fil:

; 569  : 	_CATCH_ALL
; 570  : 	for (; _Next != _First; ++_Next)
; 571  : 		_Dest_val(_Al, _Next);
; 572  : 	_RERAISE;
; 573  : 	_CATCH_END
; 574  : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$166286 = -4					; size = 1
__Dest$ = 8						; size = 4
??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$166286[ebp]
  00007	50		 push	 eax
  00008	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00011	83 c4 08	 add	 esp, 8

; 472  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z PROC	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int &,unsigned int const &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z ENDP	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int &,unsigned int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z PROC	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int const &,unsigned int &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z ENDP	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int const &,unsigned int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >, COMDAT
; __Last$ = ecx
; __Val$ = edx

; 479  : 	{	// copy _Val throughout raw [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 480  : 	_DEBUG_RANGE(_First, _Last);
; 481  : 	_FwdIt _Next = _First;
; 482  : 
; 483  : 	_TRY_BEGIN
; 484  : 	for (; _First != _Last; ++_First)

  00006	3b c1		 cmp	 eax, ecx
  00008	74 1c		 je	 SHORT $LN4@Uninit_fil@2
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Uninit_fil@2:

; 485  : 		_Construct(&*_First, _Val);

  00010	85 c0		 test	 eax, eax
  00012	74 0a		 je	 SHORT $LN16@Uninit_fil@2
  00014	8b 32		 mov	 esi, DWORD PTR [edx]
  00016	89 30		 mov	 DWORD PTR [eax], esi
  00018	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001b	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN16@Uninit_fil@2:

; 480  : 	_DEBUG_RANGE(_First, _Last);
; 481  : 	_FwdIt _Next = _First;
; 482  : 
; 483  : 	_TRY_BEGIN
; 484  : 	for (; _First != _Last; ++_First)

  0001e	83 c0 08	 add	 eax, 8
  00021	3b c1		 cmp	 eax, ecx
  00023	75 eb		 jne	 SHORT $LL6@Uninit_fil@2
  00025	5e		 pop	 esi
$LN4@Uninit_fil@2:

; 486  : 	_CATCH_ALL
; 487  : 	for (; _Next != _First; ++_Next)
; 488  : 		_Destroy(&*_Next);
; 489  : 	_RERAISE;
; 490  : 	_CATCH_END
; 491  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z
_TEXT	SEGMENT
_iter$ = 8						; size = 8
??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = eax

; 2188 : inline IterType btree<P>::internal_last(IterType iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2189 :   while (iter.node && iter.position == iter.node->count()) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp+4]
  00009	56		 push	 esi
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 1e		 je	 SHORT $LN2@internal_l
  0000e	8b ff		 npad	 2
$LL3@internal_l:
  00010	0f b6 71 03	 movzx	 esi, BYTE PTR [ecx+3]
  00014	3b d6		 cmp	 edx, esi
  00016	75 14		 jne	 SHORT $LN2@internal_l

; 2190 :     iter.position = iter.node->position();

  00018	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0001c	89 55 0c	 mov	 DWORD PTR _iter$[ebp+4], edx

; 2191 :     iter.node = iter.node->parent();

  0001f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00022	89 4d 08	 mov	 DWORD PTR _iter$[ebp], ecx

; 2192 :     if (iter.node->leaf()) {

  00025	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00028	74 e6		 je	 SHORT $LL3@internal_l

; 2193 :       iter.node = NULL;

  0002a	33 c9		 xor	 ecx, ecx
$LN2@internal_l:

; 2194 :     }
; 2195 :   }
; 2196 :   return iter;

  0002c	89 08		 mov	 DWORD PTR [eax], ecx
  0002e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00031	5e		 pop	 esi

; 2197 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow, COMDAT
; _this$ = eax

; 1706 :   if (node->leaf()) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0

; 1707 :     assert(position <= -1);
; 1708 :     self_type save(*this);

  00005	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00008	74 35		 je	 SHORT $LN7@decrement_
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 1709 :     while (position < 0 && !node->is_root()) {

  0000d	85 d2		 test	 edx, edx
  0000f	79 21		 jns	 SHORT $LN5@decrement_
  00011	57		 push	 edi
$LL6@decrement_:
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0001a	75 15		 jne	 SHORT $LN39@decrement_

; 1710 :       assert(node->parent()->child(node->position()) == node);
; 1711 :       position = node->position() - 1;

  0001c	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  00020	49		 dec	 ecx
  00021	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1712 :       node = node->parent();

  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00029	89 08		 mov	 DWORD PTR [eax], ecx
  0002b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002f	7c e1		 jl	 SHORT $LL6@decrement_
$LN39@decrement_:
  00031	5f		 pop	 edi
$LN5@decrement_:

; 1713 :     }
; 1714 :     if (position < 0) {

  00032	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00036	7d 05		 jge	 SHORT $LN38@decrement_

; 1715 :       *this = save;

  00038	89 30		 mov	 DWORD PTR [eax], esi
  0003a	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN38@decrement_:
  0003d	5e		 pop	 esi

; 1724 :   }
; 1725 : }

  0003e	c3		 ret	 0
$LN7@decrement_:

; 1716 :     }
; 1717 :   } else {
; 1718 :     assert(position >= 0);
; 1719 :     node = node->child(position);

  0003f	8b 8c 91 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+edx*4+256]
  00046	89 08		 mov	 DWORD PTR [eax], ecx

; 1720 :     while (!node->leaf()) {

  00048	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0004b	75 17		 jne	 SHORT $LN1@decrement_
  0004d	8d 49 00	 npad	 3
$LL2@decrement_:

; 1721 :       node = node->child(node->count());

  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00056	8b 8c 91 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+edx*4+256]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
  0005f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00062	74 ec		 je	 SHORT $LL2@decrement_
$LN1@decrement_:

; 1722 :     }
; 1723 :     position = node->count() - 1;

  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0006a	4a		 dec	 edx
  0006b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1724 :   }
; 1725 : }

  0006e	c3		 ret	 0
?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow, COMDAT
; _this$ = eax

; 1666 :   if (node->leaf()) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0

; 1667 :     assert(position >= node->count());
; 1668 :     self_type save(*this);

  00005	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00008	74 40		 je	 SHORT $LN7@increment_
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 1669 :     while (position == node->count() && !node->is_root()) {

  0000d	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00011	3b d1		 cmp	 edx, ecx
  00013	75 23		 jne	 SHORT $LN5@increment_
  00015	57		 push	 edi
$LL6@increment_:
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0001b	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0001e	75 17		 jne	 SHORT $LN39@increment_

; 1670 :       assert(node->parent()->child(node->position()) == node);
; 1671 :       position = node->position();

  00020	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1672 :       node = node->parent();

  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002c	89 08		 mov	 DWORD PTR [eax], ecx
  0002e	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00032	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00035	74 df		 je	 SHORT $LL6@increment_
$LN39@increment_:
  00037	5f		 pop	 edi
$LN5@increment_:

; 1673 :     }
; 1674 :     if (position == node->count()) {

  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0003e	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00041	75 05		 jne	 SHORT $LN38@increment_

; 1675 :       *this = save;

  00043	89 30		 mov	 DWORD PTR [eax], esi
  00045	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN38@increment_:
  00048	5e		 pop	 esi

; 1684 :   }
; 1685 : }

  00049	c3		 ret	 0
$LN7@increment_:

; 1676 :     }
; 1677 :   } else {
; 1678 :     assert(position < node->count());
; 1679 :     node = node->child(position + 1);

  0004a	8b 8c 91 04 01
	00 00		 mov	 ecx, DWORD PTR [ecx+edx*4+260]
  00051	89 08		 mov	 DWORD PTR [eax], ecx

; 1680 :     while (!node->leaf()) {

  00053	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00056	75 17		 jne	 SHORT $LN1@increment_
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL2@increment_:

; 1681 :       node = node->child(0);

  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b 91 00 01 00
	00		 mov	 edx, DWORD PTR [ecx+256]
  00068	89 10		 mov	 DWORD PTR [eax], edx
  0006a	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0006d	74 f1		 je	 SHORT $LL2@increment_
$LN1@increment_:

; 1682 :     }
; 1683 :     position = 0;

  0006f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1684 :   }
; 1685 : }

  00076	c3		 ret	 0
?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_node$ = 8						; size = 4
?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear, COMDAT
; _this$ = ecx

; 2333 : void btree<P>::internal_clear(node_type *node) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2334 :   if (!node->leaf()) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _node$[ebp]
  00008	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	75 42		 jne	 SHORT $LN7@internal_c

; 2335 :     for (int i = 0; i <= node->count(); ++i) {

  00010	56		 push	 esi
  00011	33 f6		 xor	 esi, esi
  00013	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  00017	72 1f		 jb	 SHORT $LN4@internal_c
  00019	57		 push	 edi
  0001a	8d bb 00 01 00
	00		 lea	 edi, DWORD PTR [ebx+256]
$LL44@internal_c:

; 2336 :       internal_clear(node->child(i));

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
  0002b	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  0002f	46		 inc	 esi
  00030	83 c7 04	 add	 edi, 4
  00033	3b f1		 cmp	 esi, ecx
  00035	7e e9		 jle	 SHORT $LL44@internal_c
  00037	5f		 pop	 edi
$LN4@internal_c:

; 2337 :     }
; 2338 :     if (node == root()) {

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	5e		 pop	 esi
  0003e	3b d8		 cmp	 ebx, eax
  00040	75 10		 jne	 SHORT $LN7@internal_c

; 2339 :       delete_internal_root_node();

  00042	50		 push	 eax

; 2340 :     } else {
; 2341 :       delete_internal_node(node);
; 2342 :     }
; 2343 :   } else {
; 2344 :     delete_leaf_node(node);

  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	83 c4 04	 add	 esp, 4
  0004b	5b		 pop	 ebx

; 2345 :   }
; 2346 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN7@internal_c:

; 2340 :     } else {
; 2341 :       delete_internal_node(node);
; 2342 :     }
; 2343 :   } else {
; 2344 :     delete_leaf_node(node);

  00052	53		 push	 ebx
  00053	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00058	83 c4 04	 add	 esp, 4
  0005b	5b		 pop	 ebx

; 2345 :   }
; 2346 : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::max_size, COMDAT

; 882  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 883  : 		}

  00005	c3		 ret	 0
?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Incsize, COMDAT
; _this$ = ecx

; 1520 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00008	2b d0		 sub	 edx, eax
  0000a	83 fa 01	 cmp	 edx, 1
  0000d	73 0a		 jae	 SHORT $LN1@Incsize

; 1521 : 			_Xlength_error("list<T> too long");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN11@Incsize:
$LN1@Incsize:

; 1522 : 		this->_Mysize += _Count;

  00019	40		 inc	 eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1523 : 		}

  0001d	c3		 ret	 0
$LN10@Incsize:
?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Incsize
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ
_TEXT	SEGMENT
tv137 = -4						; size = 4
tv133 = -4						; size = 4
?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::load_factor, COMDAT
; _this$ = eax

; 479  : 		{	// return elements per bucket

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 480  : 		return ((float)size() / (float)bucket_count());

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	db 40 08	 fild	 DWORD PTR [eax+8]
  0000a	85 c9		 test	 ecx, ecx
  0000c	79 06		 jns	 SHORT $LN9@load_facto
  0000e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN9@load_facto:
  00014	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00017	db 40 24	 fild	 DWORD PTR [eax+36]
  0001a	85 d2		 test	 edx, edx
  0001c	79 06		 jns	 SHORT $LN10@load_facto
  0001e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN10@load_facto:
  00024	de f9		 fdivp	 ST(1), ST(0)

; 481  : 		}

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::load_factor
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement, COMDAT
; _this$ = eax

; 787  :     if (node->leaf() && --position >= 0) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00005	74 05		 je	 SHORT $LN1@decrement
  00007	ff 48 04	 dec	 DWORD PTR [eax+4]
  0000a	79 05		 jns	 SHORT $LN2@decrement
$LN1@decrement:

; 788  :       return;
; 789  :     }
; 790  :     decrement_slow();

  0000c	e9 00 00 00 00	 jmp	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
$LN2@decrement:

; 791  :   }

  00011	c3		 ret	 0
?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same, COMDAT
; _this$ = edx
; __Right$ = ecx

; 1467 : 		{	// splice _Right [_First, _Last) before _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1468 : 		if (this != &_Right)

  00003	3b d1		 cmp	 edx, ecx
  00005	74 22		 je	 SHORT $LN1@Splice_sam

; 1469 : 			{	// splicing from another list, adjust counts
; 1470 : 			_Incsize(_Count);

  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	56		 push	 esi
  0000b	be fe ff ff 1f	 mov	 esi, 536870910		; 1ffffffeH
  00010	2b f0		 sub	 esi, eax
  00012	83 fe 01	 cmp	 esi, 1
  00015	5e		 pop	 esi
  00016	73 0a		 jae	 SHORT $LN4@Splice_sam
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0001d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN63@Splice_sam:
$LN4@Splice_sam:
  00022	40		 inc	 eax
  00023	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1471 : 			_Right._Mysize -= _Count;

  00026	ff 49 04	 dec	 DWORD PTR [ecx+4]
$LN1@Splice_sam:

; 1472 : 			}
; 1473 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1474 : 			_Last._Mynode();

  00029	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0002c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002f	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00032	89 11		 mov	 DWORD PTR [ecx], edx

; 1475 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1476 : 			_Where._Mynode();

  00034	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 1477 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1478 : 			_First._Mynode();

  0003f	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00048	89 11		 mov	 DWORD PTR [ecx], edx

; 1479 : 
; 1480 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());

  0004a	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]

; 1481 : 		this->_Prevnode(_Where._Mynode()) =
; 1482 : 			this->_Prevnode(_Last._Mynode());

  0004d	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00050	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1483 : 		this->_Prevnode(_Last._Mynode()) =
; 1484 : 			this->_Prevnode(_First._Mynode());

  00059	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0005c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005f	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00062	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1485 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

  00065	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00068	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1486 : 		}

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
$LN62@Splice_sam:
?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ
_TEXT	SEGMENT
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--, COMDAT
; _this$ = esi

; 817  :     decrement();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	80 38 00	 cmp	 BYTE PTR [eax], 0
  00005	74 05		 je	 SHORT $LN3@operator@4
  00007	ff 4e 04	 dec	 DWORD PTR [esi+4]
  0000a	79 07		 jns	 SHORT $LN8@operator@4
$LN3@operator@4:
  0000c	8b c6		 mov	 eax, esi
  0000e	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
$LN8@operator@4:

; 818  :     return *this;

  00013	8b c6		 mov	 eax, esi

; 819  :   }

  00015	c3		 ret	 0
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment, COMDAT
; _this$ = eax

; 778  :     if (node->leaf() && ++position < node->count()) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00005	74 0c		 je	 SHORT $LN1@increment
  00007	ff 40 04	 inc	 DWORD PTR [eax+4]
  0000a	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0000e	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00011	7c 05		 jl	 SHORT $LN2@increment
$LN1@increment:

; 779  :       return;
; 780  :     }
; 781  :     increment_slow();

  00013	e9 00 00 00 00	 jmp	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
$LN2@increment:

; 782  :   }

  00018	c3		 ret	 0
?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z
_TEXT	SEGMENT
?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z PROC ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::swap, COMDAT
; _a$ = ecx
; _b$ = eax

; 326  :     btree_swap_helper(a->first, b->first);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx

; 327  :     btree_swap_helper(a->second, b->second);

  00009	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00012	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00015	5e		 pop	 esi

; 328  :   }

  00016	c3		 ret	 0
?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z ENDP ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::swap
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue::operator(), COMDAT
; ___$ReturnUdt$ = eax
; _key$ = ecx

; 139  :       return STL_NAMESPACE::make_pair(key, T());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 140  :     }

  0000b	c3		 ret	 0
??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue::operator()
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::operator*, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 242  :       return std::make_pair(key, data_type());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 243  :     }

  0000d	c3		 ret	 0
??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::operator*
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>, COMDAT
; _this$ = eax
; _d$ = ecx

; 888  :           data(d) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 889  :     }

  00004	c3		 ret	 0
??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z
_TEXT	SEGMENT
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 826  :     self_type tmp = *this;

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]

; 827  :     --*this;

  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00005	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00008	89 0e		 mov	 DWORD PTR [esi], ecx
  0000a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0000d	74 0a		 je	 SHORT $LN7@operator@5
  0000f	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00015	85 c9		 test	 ecx, ecx
  00017	79 05		 jns	 SHORT $LN12@operator@5
$LN7@operator@5:
  00019	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
$LN12@operator@5:

; 828  :     return tmp;

  0001e	8b c6		 mov	 eax, esi

; 829  :   }

  00020	c3		 ret	 0
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ
_TEXT	SEGMENT
??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator++, COMDAT
; _this$ = esi

; 813  :     increment();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	80 38 00	 cmp	 BYTE PTR [eax], 0
  00005	74 0c		 je	 SHORT $LN3@operator@6
  00007	ff 46 04	 inc	 DWORD PTR [esi+4]
  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0000e	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  00011	7c 07		 jl	 SHORT $LN10@operator@6
$LN3@operator@6:
  00013	8b c6		 mov	 eax, esi
  00015	e8 00 00 00 00	 call	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
$LN10@operator@6:

; 814  :     return *this;

  0001a	8b c6		 mov	 eax, esi

; 815  :   }

  0001c	c3		 ret	 0
??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_i$ = 12						; size = 4
?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_swap, COMDAT
; _x$ = ecx
; _j$ = eax

; 567  :   void value_swap(int i, btree_node *x, int j) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00006	53		 push	 ebx

; 568  :     params_type::swap(mutable_value(i), x->mutable_value(j));

  00007	8b 5c c1 08	 mov	 ebx, DWORD PTR [ecx+eax*8+8]
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000f	57		 push	 edi
  00010	8b 7c d6 08	 mov	 edi, DWORD PTR [esi+edx*8+8]
  00014	89 5c d6 08	 mov	 DWORD PTR [esi+edx*8+8], ebx
  00018	89 7c c1 08	 mov	 DWORD PTR [ecx+eax*8+8], edi
  0001c	8d 44 c1 0c	 lea	 eax, DWORD PTR [ecx+eax*8+12]
  00020	8d 4c d6 0c	 lea	 ecx, DWORD PTR [esi+edx*8+12]
  00024	8b 30		 mov	 esi, DWORD PTR [eax]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	5f		 pop	 edi
  00029	89 31		 mov	 DWORD PTR [ecx], esi
  0002b	5e		 pop	 esi
  0002c	89 10		 mov	 DWORD PTR [eax], edx
  0002e	5b		 pop	 ebx

; 569  :   }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_swap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ
_TEXT	SEGMENT
?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size, COMDAT
; _this$ = eax

; 1231 :   size_type* mutable_size() { return root()->mutable_size(); }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	05 84 01 00 00	 add	 eax, 388		; 00000184H
  00007	c3		 ret	 0
?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty, COMDAT
; _this$ = ecx

; 1141 :   bool empty() const { return root() == NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 94 c0	 sete	 al
  00007	c3		 ret	 0
?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z
_TEXT	SEGMENT
?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::compare_keys, COMDAT
; _x$ = eax
; _y$ = edx

; 1120 :     return btree_compare_keys(key_comp(), x, y);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 1121 :   }

  00008	c3		 ret	 0
?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::compare_keys
_TEXT	ENDS
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z
_TEXT	SEGMENT
$T167299 = -16						; size = 12
$T167307 = -4						; size = 4
??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z PROC ; std::_Allocate<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000b	77 11		 ja	 SHORT $LN1@Allocate
  0000d	03 c0		 add	 eax, eax
  0000f	03 c0		 add	 eax, eax
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001c	75 28		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0001e	8d 4d fc	 lea	 ecx, DWORD PTR $T167307[ebp]
  00021	51		 push	 ecx
  00022	8d 4d f0	 lea	 ecx, DWORD PTR $T167299[ebp]
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T167307[ebp], 0
  0002c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 55 f0	 lea	 edx, DWORD PTR $T167299[ebp]
  00039	52		 push	 edx
  0003a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T167299[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00041	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate:
$LN7@Allocate:

; 40   : 	}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN13@Allocate:
??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z ENDP ; std::_Allocate<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$167316 = -4					; size = 1
__Count$ = 8						; size = 4
??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; __First$ = ecx
; __Pval$ = edx

; 606  : 	{	// copy _Count * *_Pval to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 607  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 608  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$167316[ebp]
  00007	50		 push	 eax
  00008	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00011	83 c4 08	 add	 esp, 8

; 609  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z
_TEXT	SEGMENT
__Cat$167335 = 8					; size = 1
__Ptr$ = 8						; size = 4
??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Umove<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Cat$167335[ebp]
  00006	50		 push	 eax
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00010	83 c4 08	 add	 esp, 8

; 1326 : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Umove<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T167341 = -16						; size = 12
$T167349 = -4						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	83 f8 ff	 cmp	 eax, -1
  00009	77 0d		 ja	 SHORT $LN1@Allocate@2
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4
  00014	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00016	75 28		 jne	 SHORT $LN7@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00018	8d 45 fc	 lea	 eax, DWORD PTR $T167349[ebp]
  0001b	50		 push	 eax
  0001c	8d 4d f0	 lea	 ecx, DWORD PTR $T167341[ebp]
  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T167349[ebp], 0
  00026	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0002b	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00030	8d 4d f0	 lea	 ecx, DWORD PTR $T167341[ebp]
  00033	51		 push	 ecx
  00034	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T167341[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0003b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@2:
$LN7@Allocate@2:

; 40   : 	}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN13@Allocate@2:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z
_TEXT	SEGMENT
$T167354 = -16						; size = 12
$T167362 = -4						; size = 4
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  0000b	77 10		 ja	 SHORT $LN1@Allocate@3
  0000d	c1 e0 04	 shl	 eax, 4
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001b	75 28		 jne	 SHORT $LN7@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0001d	8d 45 fc	 lea	 eax, DWORD PTR $T167362[ebp]
  00020	50		 push	 eax
  00021	8d 4d f0	 lea	 ecx, DWORD PTR $T167354[ebp]
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T167362[ebp], 0
  0002b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00030	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00035	8d 4d f0	 lea	 ecx, DWORD PTR $T167354[ebp]
  00038	51		 push	 ecx
  00039	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T167354[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00040	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@3:
$LN7@Allocate@3:

; 40   : 	}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN13@Allocate@3:
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T167367 = -16						; size = 12
$T167375 = -4						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0000b	77 16		 ja	 SHORT $LN1@Allocate@4
  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	03 c0		 add	 eax, eax
  00012	03 c0		 add	 eax, eax
  00014	03 c0		 add	 eax, eax
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00021	75 28		 jne	 SHORT $LN7@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00023	8d 4d fc	 lea	 ecx, DWORD PTR $T167375[ebp]
  00026	51		 push	 ecx
  00027	8d 4d f0	 lea	 ecx, DWORD PTR $T167367[ebp]
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T167375[ebp], 0
  00031	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 55 f0	 lea	 edx, DWORD PTR $T167367[ebp]
  0003e	52		 push	 edx
  0003f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T167367[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@4:
$LN7@Allocate@4:

; 40   : 	}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN13@Allocate@4:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z
_TEXT	SEGMENT
??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z PROC		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int &,unsigned int const &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 248  : 		}

  0000b	c3		 ret	 0
??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z ENDP		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int &,unsigned int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z
_TEXT	SEGMENT
??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z PROC		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int const &,unsigned int &>, COMDAT
; _this$ = eax
; __Val2$ = ecx

; 247  : 		{	// construct from moved values

  00000	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 248  : 		}

  0000b	c3		 ret	 0
??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z ENDP		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int const &,unsigned int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z
_TEXT	SEGMENT
__Cat$167428 = -4					; size = 1
__Last$ = 8						; size = 4
??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z PROC ; std::uninitialized_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >, COMDAT
; __First$ = ecx
; __Val$ = edx

; 504  : 	{	// copy _Val throughout raw [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 505  : 	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$167428[ebp]
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  00011	83 c4 08	 add	 esp, 8

; 506  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z ENDP ; std::uninitialized_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ
_TEXT	SEGMENT
?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::clear, COMDAT
; _this$ = esi

; 1959 :   if (root() != NULL) {

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN10@clear

; 1960 :     internal_clear(root());

  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN10@clear:

; 1961 :   }
; 1962 :   *mutable_root() = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1963 : }

  00014	c3		 ret	 0
?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >, COMDAT
; _this$ = eax

; 1732 :       root_(alloc, NULL) {

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1733 : }

  00006	c3		 ret	 0
??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  00002	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
$T167484 = -16						; size = 12
$T167476 = -4						; size = 4
?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 44		 je	 SHORT $LN1@allocate
  0000c	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00012	77 14		 ja	 SHORT $LN3@allocate
  00014	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00028	8d 4d fc	 lea	 ecx, DWORD PTR $T167476[ebp]
  0002b	51		 push	 ecx
  0002c	8d 4d f0	 lea	 ecx, DWORD PTR $T167484[ebp]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T167476[ebp], 0
  00036	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003b	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00040	8d 55 f0	 lea	 edx, DWORD PTR $T167484[ebp]
  00043	52		 push	 edx
  00044	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T167484[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN12@allocate:
?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z
_TEXT	SEGMENT
__Cat$167508 = -4					; size = 1
?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Pval$ = edx

; 1420 : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1421 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Alval);

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$167508[ebp]
  00007	50		 push	 eax
  00008	57		 push	 edi
  00009	8b c6		 mov	 eax, esi
  0000b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00010	83 c4 08	 add	 esp, 8

; 1422 : 		return (_Ptr + _Count);

  00013	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]

; 1423 : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Ufill
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z
_TEXT	SEGMENT
?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Grow_to, COMDAT
; _this$ = ecx
; __Count$ = edx

; 1275 : 		size_type _Capacity = capacity();

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	c1 f8 02	 sar	 eax, 2

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00009	8b c8		 mov	 ecx, eax
  0000b	d1 e9		 shr	 ecx, 1
  0000d	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00012	2b f1		 sub	 esi, ecx
  00014	3b f0		 cmp	 esi, eax
  00016	5e		 pop	 esi
  00017	73 04		 jae	 SHORT $LN4@Grow_to
  00019	33 c0		 xor	 eax, eax
  0001b	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001d	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  0001f	3b c2		 cmp	 eax, edx
  00021	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx
$LN1@Grow_to:

; 1282 : 		}

  00025	c3		 ret	 0
?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Grow_to
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  00002	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$0
__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$2
__tryblocktable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$5
__ehfuncinfo$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Tmp$153898 = -24					; size = 4
__Tmp$153884 = -24					; size = 4
__Newvec$153865 = -24					; size = 4
__Capacity$167612 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$167846 = 8					; size = 1
__Cat$167787 = 8					; size = 1
__Cat$167755 = 8					; size = 1
__Cat$167712 = 8					; size = 1
__Cat$167683 = 8					; size = 1
__Cat$167654 = 8					; size = 1
__Where$ = 8						; size = 4
tv642 = 12						; size = 4
__Val$ = 12						; size = 4
?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n, COMDAT
; _this$ = edx
; __Count$ = ecx

; 1330 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b f9		 mov	 edi, ecx
  00020	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00023	8b f2		 mov	 esi, edx

; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_VICONT(_Where) != this
; 1333 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1334 : 			|| this->_Mylast < _VIPTR(_Where))
; 1335 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		if (_Count == 0)

  00025	85 ff		 test	 edi, edi
  00027	0f 84 04 02 00
	00		 je	 $LN143@Insert_n

; 1339 : 			;
; 1340 : 		else if (max_size() - size() < _Count)

  0002d	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00032	8b c3		 mov	 eax, ebx
  00034	2b c1		 sub	 eax, ecx
  00036	c1 f8 02	 sar	 eax, 2
  00039	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0003e	2b d0		 sub	 edx, eax
  00040	3b d7		 cmp	 edx, edi
  00042	73 0a		 jae	 SHORT $LN11@Insert_n

; 1341 : 			_Xlen();	// result too long

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00049	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN159@Insert_n:
$LN11@Insert_n:

; 1342 : 		else if (capacity() < size() + _Count)

  0004e	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00051	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00054	2b c1		 sub	 eax, ecx
  00056	c1 f8 02	 sar	 eax, 2
  00059	3b c2		 cmp	 eax, edx
  0005b	0f 83 da 00 00
	00		 jae	 $LN9@Insert_n

; 1343 : 			{	// not enough room, reallocate
; 1344 : 			size_type _Capacity = _Grow_to(size() + _Count);

  00061	8b c8		 mov	 ecx, eax
  00063	d1 e9		 shr	 ecx, 1
  00065	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  0006a	2b d9		 sub	 ebx, ecx
  0006c	3b d8		 cmp	 ebx, eax
  0006e	73 0c		 jae	 SHORT $LN44@Insert_n
  00070	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$167612[ebp], 0
  00077	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$167612[ebp]
  0007a	eb 05		 jmp	 SHORT $LN45@Insert_n
$LN44@Insert_n:
  0007c	03 c1		 add	 eax, ecx
  0007e	89 45 ec	 mov	 DWORD PTR __Capacity$167612[ebp], eax
$LN45@Insert_n:
  00081	3b c2		 cmp	 eax, edx
  00083	73 05		 jae	 SHORT $LN41@Insert_n
  00085	89 55 ec	 mov	 DWORD PTR __Capacity$167612[ebp], edx
  00088	8b c2		 mov	 eax, edx
$LN41@Insert_n:

; 1345 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0008a	8b c8		 mov	 ecx, eax
  0008c	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate

; 1346 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

  00091	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  00094	2b 1e		 sub	 ebx, DWORD PTR [esi]

; 1347 : 			int _Ncopied = 0;
; 1348 : 
; 1349 : 			_TRY_BEGIN
; 1350 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1351 : 				_STD addressof(_Val));	// add new stuff

  00096	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00099	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$167654[ebp]
  000a3	89 45 e8	 mov	 DWORD PTR __Newvec$153865[ebp], eax
  000a6	c1 fb 02	 sar	 ebx, 2
  000a9	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8b c7		 mov	 eax, edi
  000b0	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1352 : 			++_Ncopied;
; 1353 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1354 : 				_Newvec);	// copy prefix

  000b5	8b 55 08	 mov	 edx, DWORD PTR __Cat$167683[ebp]
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	83 c4 08	 add	 esp, 8
  000bd	52		 push	 edx
  000be	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  000c1	50		 push	 eax
  000c2	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$153865[ebp]
  000c5	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1355 : 			++_Ncopied;
; 1356 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1357 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

  000ca	8b 45 08	 mov	 eax, DWORD PTR __Cat$167712[ebp]
  000cd	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000d0	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]
  000d3	8b 5d e8	 mov	 ebx, DWORD PTR __Newvec$153865[ebp]
  000d6	83 c4 08	 add	 esp, 8
  000d9	50		 push	 eax
  000da	8d 04 8b	 lea	 eax, DWORD PTR [ebx+ecx*4]
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1365 : 			_CATCH_END
; 1366 : 
; 1367 : 			_Count += size();

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]
  000e8	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000eb	2b d0		 sub	 edx, eax
  000ed	c1 fa 02	 sar	 edx, 2
  000f0	83 c4 08	 add	 esp, 8
  000f3	03 fa		 add	 edi, edx

; 1368 : 			if (this->_Myfirst != 0)

  000f5	85 c0		 test	 eax, eax
  000f7	74 09		 je	 SHORT $LN84@Insert_n

; 1369 : 				{	// destroy and deallocate old array
; 1370 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1371 : 				this->_Alval.deallocate(this->_Myfirst,
; 1372 : 					this->_Myend - this->_Myfirst);

  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ff	83 c4 04	 add	 esp, 4
$LN84@Insert_n:

; 1373 : 				}
; 1374 : 
; 1375 : 			this->_Orphan_all();
; 1376 : 			this->_Myend = _Newvec + _Capacity;

  00102	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$167612[ebp]
  00105	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]

; 1377 : 			this->_Mylast = _Newvec + _Count;

  00108	8d 14 bb	 lea	 edx, DWORD PTR [ebx+edi*4]
  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0010e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1378 : 			this->_Myfirst = _Newvec;

  00111	89 1e		 mov	 DWORD PTR [esi], ebx

; 1416 : 			}
; 1417 : 		}

  00113	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00116	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 08 00	 ret	 8
__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$0:

; 1358 : 			_CATCH_ALL
; 1359 : 			if (1 < _Ncopied)
; 1360 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1361 : 			if (0 < _Ncopied)
; 1362 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1363 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00126	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$153865[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012f	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$2:

; 1364 : 			_RERAISE;

  00132	6a 00		 push	 0
  00134	6a 00		 push	 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN160@Insert_n:
$LN9@Insert_n:

; 1379 : 			}
; 1380 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1381 : 			< _Count)

  0013b	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0013e	8b d3		 mov	 edx, ebx
  00140	2b d1		 sub	 edx, ecx
  00142	c1 fa 02	 sar	 edx, 2
  00145	3b d7		 cmp	 edx, edi
  00147	73 7b		 jae	 SHORT $LN3@Insert_n

; 1382 : 			{	// new stuff spills off end
; 1383 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00149	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0014c	8b 10		 mov	 edx, DWORD PTR [eax]
  0014e	89 55 e8	 mov	 DWORD PTR __Tmp$153884[ebp], edx

; 1384 : 
; 1385 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1386 : 				_VIPTR(_Where) + _Count);	// copy suffix

  00151	8b 55 08	 mov	 edx, DWORD PTR __Cat$167755[ebp]
  00154	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  0015b	52		 push	 edx
  0015c	89 45 0c	 mov	 DWORD PTR tv642[ebp], eax
  0015f	03 c1		 add	 eax, ecx
  00161	51		 push	 ecx
  00162	8b d3		 mov	 edx, ebx
  00164	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1387 : 
; 1388 : 			_TRY_BEGIN

  00169	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1389 : 			_Ufill(this->_Mylast,
; 1390 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1391 : 				_STD addressof(_Tmp));	// insert new stuff off end

  00170	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00173	8b 55 08	 mov	 edx, DWORD PTR __Cat$167787[ebp]
  00176	8b c1		 mov	 eax, ecx
  00178	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  0017b	52		 push	 edx
  0017c	c1 f8 02	 sar	 eax, 2
  0017f	2b f8		 sub	 edi, eax
  00181	8b c7		 mov	 eax, edi
  00183	51		 push	 ecx
  00184	8d 55 e8	 lea	 edx, DWORD PTR __Tmp$153884[ebp]
  00187	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1392 : 			_CATCH_ALL
; 1393 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1394 : 				this->_Mylast + _Count);
; 1395 : 			_RERAISE;
; 1396 : 			_CATCH_END
; 1397 : 
; 1398 : 			this->_Mylast += _Count;

  0018c	8b 45 0c	 mov	 eax, DWORD PTR tv642[ebp]
  0018f	01 46 04	 add	 DWORD PTR [esi+4], eax
  00192	8b 76 04	 mov	 esi, DWORD PTR [esi+4]

; 1399 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1400 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1401 : 				_Tmp);	// insert up to old end

  00195	2b f0		 sub	 esi, eax
  00197	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0019a	83 c4 10	 add	 esp, 16			; 00000010H
  0019d	3b c6		 cmp	 eax, esi
  0019f	0f 84 8c 00 00
	00		 je	 $LN143@Insert_n
$LL116@Insert_n:
  001a5	8b 4d e8	 mov	 ecx, DWORD PTR __Tmp$153884[ebp]
  001a8	89 08		 mov	 DWORD PTR [eax], ecx
  001aa	83 c0 04	 add	 eax, 4
  001ad	3b c6		 cmp	 eax, esi
  001af	75 f4		 jne	 SHORT $LL116@Insert_n

; 1416 : 			}
; 1417 : 		}

  001b1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx
  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c2 08 00	 ret	 8
$LN3@Insert_n:

; 1402 : 			}
; 1403 : 		else
; 1404 : 			{	// new stuff can all be assigned
; 1405 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  001c4	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  001c7	8b 02		 mov	 eax, DWORD PTR [edx]

; 1406 : 
; 1407 : 			pointer _Oldend = this->_Mylast;
; 1408 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1409 : 				this->_Mylast);	// copy suffix

  001c9	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$167846[ebp]
  001cc	89 45 e8	 mov	 DWORD PTR __Tmp$153898[ebp], eax
  001cf	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  001d6	8b fb		 mov	 edi, ebx
  001d8	2b f8		 sub	 edi, eax
  001da	51		 push	 ecx
  001db	89 45 0c	 mov	 DWORD PTR tv642[ebp], eax
  001de	57		 push	 edi
  001df	8b c3		 mov	 eax, ebx
  001e1	8b d3		 mov	 edx, ebx
  001e3	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1410 : 
; 1411 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1412 : 			_STD _Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1413 : 				_Oldend);	// copy hole

  001e8	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  001eb	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001ee	8b c7		 mov	 eax, edi
  001f0	83 c4 08	 add	 esp, 8
  001f3	3b c8		 cmp	 ecx, eax
  001f5	74 19		 je	 SHORT $LN133@Insert_n
  001f7	2b df		 sub	 ebx, edi
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL134@Insert_n:
  00200	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00203	83 e8 04	 sub	 eax, 4
  00206	89 14 03	 mov	 DWORD PTR [ebx+eax], edx
  00209	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0020c	3b c8		 cmp	 ecx, eax
  0020e	75 f0		 jne	 SHORT $LL134@Insert_n
$LN133@Insert_n:

; 1414 : 			_STD fill(_VIPTR(_Where),
; 1415 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

  00210	8b 55 0c	 mov	 edx, DWORD PTR tv642[ebp]
  00213	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]
  00216	8b c1		 mov	 eax, ecx
  00218	3b ce		 cmp	 ecx, esi
  0021a	74 15		 je	 SHORT $LN143@Insert_n
  0021c	8d 64 24 00	 npad	 4
$LL145@Insert_n:
  00220	8b 4d e8	 mov	 ecx, DWORD PTR __Tmp$153898[ebp]
  00223	89 08		 mov	 DWORD PTR [eax], ecx
  00225	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00228	83 c0 04	 add	 eax, 4
  0022b	03 ca		 add	 ecx, edx
  0022d	3b c1		 cmp	 eax, ecx
  0022f	75 ef		 jne	 SHORT $LL145@Insert_n
$LN143@Insert_n:

; 1416 : 			}
; 1417 : 		}

  00231	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023d	5b		 pop	 ebx
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c2 08 00	 ret	 8
$LN158@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Make_iter, COMDAT
; ___$ReturnUdt$ = eax

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Make_iter
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::erase, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = eax

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First_arg$[ebp]

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last_arg$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx
  0000b	3b d1		 cmp	 edx, ecx
  0000d	74 1c		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0000f	56		 push	 esi
  00010	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00013	3b ce		 cmp	 ecx, esi
  00015	74 10		 je	 SHORT $LN30@erase
  00017	53		 push	 ebx
$LL32@erase:
  00018	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0001a	89 1a		 mov	 DWORD PTR [edx], ebx
  0001c	83 c1 04	 add	 ecx, 4
  0001f	83 c2 04	 add	 edx, 4
  00022	3b ce		 cmp	 ecx, esi
  00024	75 f2		 jne	 SHORT $LL32@erase
  00026	5b		 pop	 ebx
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00027	89 57 04	 mov	 DWORD PTR [edi+4], edx
  0002a	5e		 pop	 esi
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::insert, COMDAT
; _this$ = edx
; __Val$ = eax

; 1058 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1059 : 		_Insert_n(_Where, _Count, _Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 1060 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::insert
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 792  : 		return (iterator(this->_Mylast, this));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 10		 mov	 DWORD PTR [eax], edx

; 793  : 		}

  00005	c3		 ret	 0
?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 782  : 		return (iterator(this->_Myfirst, this));

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 783  : 		}

  00004	c3		 ret	 0
?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T168099 = -16						; size = 12
$T168091 = -4						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 3a		 je	 SHORT $LN1@allocate@2
  0000c	83 f9 ff	 cmp	 ecx, -1
  0000f	77 0d		 ja	 SHORT $LN3@allocate@2
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0001e	8d 45 fc	 lea	 eax, DWORD PTR $T168091[ebp]
  00021	50		 push	 eax
  00022	8d 4d f0	 lea	 ecx, DWORD PTR $T168099[ebp]
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T168091[ebp], 0
  0002c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 4d f0	 lea	 ecx, DWORD PTR $T168099[ebp]
  00039	51		 push	 ecx
  0003a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T168099[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00041	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN12@allocate@2:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);
; 43   : 		}

  00002	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Assign_n, COMDAT
; _this$ = edx
; __Val$ = eax

; 1243 : 		{	// assign _Count * _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1244 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1245 : 		erase(begin(), end());

  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx
  0000f	3b f0		 cmp	 esi, eax
  00011	74 1f		 je	 SHORT $LN19@Assign_n
  00013	8b c8		 mov	 ecx, eax
  00015	3b c0		 cmp	 eax, eax
  00017	74 16		 je	 SHORT $LN48@Assign_n
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL50@Assign_n:
  00020	8b 39		 mov	 edi, DWORD PTR [ecx]
  00022	89 3e		 mov	 DWORD PTR [esi], edi
  00024	83 c1 04	 add	 ecx, 4
  00027	83 c6 04	 add	 esi, 4
  0002a	3b c8		 cmp	 ecx, eax
  0002c	75 f2		 jne	 SHORT $LL50@Assign_n
  0002e	5f		 pop	 edi
$LN48@Assign_n:
  0002f	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN19@Assign_n:

; 1246 : 		insert(begin(), _Count, _Tmp);

  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00037	51		 push	 ecx
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
  00041	5e		 pop	 esi

; 1247 : 		}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Assign_n
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z
_TEXT	SEGMENT
$T168357 = -16						; size = 12
$T168349 = -4						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocate, COMDAT

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	6a 10		 push	 16			; 00000010H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 24		 jne	 SHORT $LN1@allocate@3
  00014	89 45 fc	 mov	 DWORD PTR $T168349[ebp], eax
  00017	8d 45 fc	 lea	 eax, DWORD PTR $T168349[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR $T168357[ebp]
  0001e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00023	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00028	8d 4d f0	 lea	 ecx, DWORD PTR $T168357[ebp]
  0002b	51		 push	 ecx
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T168357[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00033	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN13@allocate@3:
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = eax

; 439  : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 1e		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));
; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e2		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z
_TEXT	SEGMENT
?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::equals, COMDAT
; _a$ = eax
; _b$ = edx

; 1199 :       return key_equal::operator()(a, b);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 1200 :     }

  00009	c3		 ret	 0
?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::equals
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--, COMDAT
; _this$ = eax

; 250  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 251  : 		if (this->_Getcont() == 0
; 252  : 			|| this->_Ptr == 0
; 253  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 254  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("list iterator not decrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 263  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 264  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 265  : 
; 266  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 267  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00005	89 10		 mov	 DWORD PTR [eax], edx

; 268  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 269  : 
; 270  : 		return (*this);
; 271  : 		}

  00007	c3		 ret	 0
??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++, COMDAT
; _this$ = eax

; 222  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 223  : 		if (this->_Getcont() == 0
; 224  : 			|| this->_Ptr == 0
; 225  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 226  : 			{	// report error
; 227  : 			_DEBUG_ERROR("list iterator not incrementable");
; 228  : 			_SCL_SECURE_OUT_OF_RANGE;
; 229  : 			}
; 230  : 
; 231  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 232  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 233  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 234  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 235  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 236  : 
; 237  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 11		 mov	 edx, DWORD PTR [ecx]
  00004	89 10		 mov	 DWORD PTR [eax], edx

; 238  : 		return (*this);
; 239  : 		}

  00006	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 		}

  00002	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  00002	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Tmp$168662 = -4					; size = 4
__Count$ = 8						; size = 4
?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::assign, COMDAT
; _this$ = edx
; __Val$ = eax

; 1046 : 		{	// assign _Count * _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1047 : 		_Assign_n(_Count, _Val);

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	89 4d fc	 mov	 DWORD PTR __Tmp$168662[ebp], ecx
  0000f	3b f0		 cmp	 esi, eax
  00011	74 1f		 je	 SHORT $LN21@assign
  00013	8b c8		 mov	 ecx, eax
  00015	3b c0		 cmp	 eax, eax
  00017	74 16		 je	 SHORT $LN50@assign
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL52@assign:
  00020	8b 39		 mov	 edi, DWORD PTR [ecx]
  00022	89 3e		 mov	 DWORD PTR [esi], edi
  00024	83 c1 04	 add	 ecx, 4
  00027	83 c6 04	 add	 esi, 4
  0002a	3b c8		 cmp	 ecx, eax
  0002c	75 f2		 jne	 SHORT $LL52@assign
  0002e	5f		 pop	 edi
$LN50@assign:
  0002f	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN21@assign:
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$168662[ebp]
  00037	51		 push	 ecx
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
  00041	5e		 pop	 esi

; 1048 : 		}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T168790 = -16						; size = 12
$T168767 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 493  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

  00006	6a 10		 push	 16			; 00000010H
  00008	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 11		 je	 SHORT $LN13@List_val
  0001b	89 06		 mov	 DWORD PTR [esi], eax

; 496  : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  0001d	89 00		 mov	 DWORD PTR [eax], eax

; 497  : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 498  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN13@List_val:
  0002c	8d 45 fc	 lea	 eax, DWORD PTR $T168767[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f0	 lea	 ecx, DWORD PTR $T168790[ebp]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T168767[ebp], 0
  0003a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T168790[ebp]
  00047	51		 push	 ecx
  00048	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T168790[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@List_val:
$LN28@List_val:
  00054	cc		 int	 3
??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::clear, COMDAT
; _this$ = esi

; 1097 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1098 : 		this->_Orphan_ptr(*this, 0);
; 1099 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1100 : 
; 1101 : 		_Nodeptr _Pnext;
; 1102 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1103 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00004	89 09		 mov	 DWORD PTR [ecx], ecx

; 1104 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx

; 1105 : 		this->_Mysize = 0;

  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1106 : 
; 1107 : 		for (; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00012	3b 06		 cmp	 eax, DWORD PTR [esi]
  00014	74 13		 je	 SHORT $LN1@clear@2
  00016	57		 push	 edi
$LL3@clear@2:

; 1108 : 			{	// delete an element
; 1109 : 			_Pnext = this->_Nextnode(_Pnode);

  00017	8b 38		 mov	 edi, DWORD PTR [eax]

; 1110 : 
; 1111 : 			_Dest_val(this->_Alnod, _Pnode);
; 1112 : 			this->_Alnod.deallocate(_Pnode, 1);

  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	83 c4 04	 add	 esp, 4
  00022	8b c7		 mov	 eax, edi
  00024	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00026	75 ef		 jne	 SHORT $LL3@clear@2
  00028	5f		 pop	 edi
$LN1@clear@2:

; 1113 : 			}
; 1114 : 		}

  00029	c3		 ret	 0
?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T168842 = -16						; size = 12
$T168834 = -4						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocate, COMDAT

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	6a 18		 push	 24			; 00000018H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 24		 jne	 SHORT $LN1@allocate@4
  00014	89 45 fc	 mov	 DWORD PTR $T168834[ebp], eax
  00017	8d 45 fc	 lea	 eax, DWORD PTR $T168834[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR $T168842[ebp]
  0001e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00023	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00028	8d 4d f0	 lea	 ecx, DWORD PTR $T168842[ebp]
  0002b	51		 push	 ecx
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T168842[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00033	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@allocate@4:
$LN1@allocate@4:

; 188  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN13@allocate@4:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = eax

; 483  : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear, COMDAT
; _this$ = edi

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00000	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00003	53		 push	 ebx
  00004	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00007	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  0000b	56		 push	 esi
  0000c	8b f3		 mov	 esi, ebx
  0000e	75 1e		 jne	 SHORT $LN7@clear@3
$LL9@clear@3:
  00010	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00013	51		 push	 ecx
  00014	8b cf		 mov	 ecx, edi
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase
  0001b	8b 36		 mov	 esi, DWORD PTR [esi]
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	83 c4 04	 add	 esp, 4
  00026	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  0002a	8b de		 mov	 ebx, esi
  0002c	74 e2		 je	 SHORT $LL9@clear@3
$LN7@clear@3:

; 1416 : 		_Root() = this->_Myhead;

  0002e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00031	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00034	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00037	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  00039	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003c	5e		 pop	 esi
  0003d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00040	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00047	5b		 pop	 ebx

; 1420 : 		}

  00048	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z
_TEXT	SEGMENT
?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::equals, COMDAT
; _a$ = eax
; _b$ = edx

; 1212 :     return key_info.equals(a, b);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 1213 :   }

  00009	c3		 ret	 0
?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::equals
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z
_TEXT	SEGMENT
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty, COMDAT
; _this$ = eax
; _bucknum$ = esi

; 461  :     assert(settings.use_empty());  // we always need to know what's empty!
; 462  :     return equals(get_key(val_info.emptyval), get_key(table[bucknum]));

  00000	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00003	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00006	33 c0		 xor	 eax, eax
  00008	3b 14 f1	 cmp	 edx, DWORD PTR [ecx+esi*8]
  0000b	0f 94 c0	 sete	 al

; 463  :   }

  0000e	c3		 ret	 0
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax
  00000	c3		 ret	 0
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--, COMDAT
; _this$ = eax

; 383  : 		--(*(_Mybase *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00005	89 10		 mov	 DWORD PTR [eax], edx

; 384  : 		return (*this);
; 385  : 		}

  00007	c3		 ret	 0
??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++, COMDAT
; _this$ = eax

; 370  : 		++(*(_Mybase *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 11		 mov	 edx, DWORD PTR [ecx]
  00004	89 10		 mov	 DWORD PTR [eax], edx

; 371  : 		return (*this);
; 372  : 		}

  00006	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z
_TEXT	SEGMENT
??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 342  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 343  : 		}

  00002	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 243  : 		_Myiter _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx

; 244  : 		++*this;

  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 0a		 mov	 DWORD PTR [edx], ecx

; 245  : 		return (_Tmp);
; 246  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*, COMDAT
; _this$ = eax

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  00002	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00015	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1312 : 		}

  00023	c3		 ret	 0
?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Tidy, COMDAT
; _this$ = esi

; 1497 : 		clear();

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]
  00004	89 09		 mov	 DWORD PTR [ecx], ecx
  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	3b 06		 cmp	 eax, DWORD PTR [esi]
  00014	74 13		 je	 SHORT $LN3@Tidy@2
  00016	57		 push	 edi
$LL5@Tidy@2:
  00017	8b 38		 mov	 edi, DWORD PTR [eax]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	83 c4 04	 add	 esp, 4
  00022	8b c7		 mov	 eax, edi
  00024	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00026	75 ef		 jne	 SHORT $LL5@Tidy@2
  00028	5f		 pop	 edi
$LN3@Tidy@2:

; 1498 : 		}

  00029	c3		 ret	 0
?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T169221 = -16						; size = 12
$T169167 = -4						; size = 4
??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 612  : 		{	// construct empty list, allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	6a 10		 push	 16			; 00000010H
  00008	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 0f		 je	 SHORT $LN18@list
  0001b	89 06		 mov	 DWORD PTR [esi], eax
  0001d	89 00		 mov	 DWORD PTR [eax], eax
  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 613  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0

; 612  : 		{	// construct empty list, allocator

$LN18@list:
  0002a	8d 45 fc	 lea	 eax, DWORD PTR $T169167[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d f0	 lea	 ecx, DWORD PTR $T169221[ebp]
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T169167[ebp], 0
  00038	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00042	8d 4d f0	 lea	 ecx, DWORD PTR $T169221[ebp]
  00045	51		 push	 ecx
  00046	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T169221[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN35@list:
$LN34@list:
  00052	cc		 int	 3
??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 717  : 		{	// return begin iterator for bucket _Bucket

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 718  : 		return (_Vec_lo(_Bucket));

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Bucket$[ebp]
  00009	8b 14 ca	 mov	 edx, DWORD PTR [edx+ecx*8]
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 719  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T169292 = -16						; size = 12
$T169276 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = esi

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00006	6a 18		 push	 24			; 00000018H
  00008	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 27		 je	 SHORT $LN15@Tree_val
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  0001e	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002f	b0 01		 mov	 al, 1
  00031	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	88 42 15	 mov	 BYTE PTR [edx+21], al

; 551  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00042	8d 45 fc	 lea	 eax, DWORD PTR $T169276[ebp]
  00045	50		 push	 eax
  00046	8d 4d f0	 lea	 ecx, DWORD PTR $T169292[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T169276[ebp], 0
  00050	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00055	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005a	8d 4d f0	 lea	 ecx, DWORD PTR $T169292[ebp]
  0005d	51		 push	 ecx
  0005e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T169292[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00065	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006a	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1742 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 18		 jne	 SHORT $LN3@Lbound
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
  0000e	8b ff		 npad	 2
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00010	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00013	73 05		 jae	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00015	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  00018	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001a	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  0001e	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00022	74 ec		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00024	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lbound
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost, COMDAT
; _this$ = eax

; 1219 :     return (!root() || root()->leaf()) ? root() : root()->rightmost();

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	85 c0		 test	 eax, eax
  00004	74 0b		 je	 SHORT $LN15@rightmost
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 06		 jne	 SHORT $LN15@rightmost
  0000b	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
$LN15@rightmost:

; 1220 :   }

  00011	c3		 ret	 0
?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z
_TEXT	SEGMENT
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 1138 :     alloc_impl(const libc_allocator_with_realloc<A>& a)

  00000	c3		 ret	 0
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z
_TEXT	SEGMENT
tv134 = -12						; size = 8
tv68 = -12						; size = 8
tv143 = -8						; size = 4
tv136 = -8						; size = 4
tv70 = -8						; size = 4
tv139 = -2						; size = 2
tv131 = -2						; size = 2
?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::reset_thresholds, COMDAT
; _this$ = ecx
; _num_buckets$ = eax

; 130  :   void reset_thresholds(size_type num_buckets) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 131  :     set_enlarge_threshold(enlarge_size(num_buckets));

  00006	89 45 f8	 mov	 DWORD PTR tv143[ebp], eax
  00009	db 45 f8	 fild	 DWORD PTR tv143[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN13@reset_thre
  00010	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN13@reset_thre:
  00016	d9 41 08	 fld	 DWORD PTR [ecx+8]

; 132  :     set_shrink_threshold(shrink_size(num_buckets));
; 133  :     // whatever caused us to reset already considered
; 134  :     set_consider_shrink(false);

  00019	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0
  0001d	d9 7d fe	 fnstcw	 WORD PTR tv139[ebp]
  00020	0f b7 45 fe	 movzx	 eax, WORD PTR tv139[ebp]
  00024	d8 c9		 fmul	 ST(0), ST(1)
  00026	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0002b	89 45 f8	 mov	 DWORD PTR tv136[ebp], eax
  0002e	d9 6d f8	 fldcw	 WORD PTR tv136[ebp]
  00031	df 7d f4	 fistp	 QWORD PTR tv134[ebp]
  00034	8b 55 f4	 mov	 edx, DWORD PTR tv134[ebp]
  00037	89 11		 mov	 DWORD PTR [ecx], edx
  00039	d9 6d fe	 fldcw	 WORD PTR tv139[ebp]
  0003c	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  0003f	d9 7d fe	 fnstcw	 WORD PTR tv131[ebp]
  00042	0f b7 45 fe	 movzx	 eax, WORD PTR tv131[ebp]
  00046	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0004b	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  0004e	d9 6d f8	 fldcw	 WORD PTR tv70[ebp]
  00051	df 7d f4	 fistp	 QWORD PTR tv68[ebp]
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00057	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005a	d9 6d fe	 fldcw	 WORD PTR tv131[ebp]

; 135  :   }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::reset_thresholds
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z
_TEXT	SEGMENT
__Cat$169425 = 8					; size = 1
_table_end$ = 8						; size = 4
?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::fill_range_with_empty, COMDAT
; _this$ = edx
; _table_start$ = ecx

; 474  :   void fill_range_with_empty(pointer table_start, pointer table_end) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 475  :     STL_NAMESPACE::uninitialized_fill(table_start, table_end, val_info.emptyval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Cat$169425[ebp]
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _table_end$[ebp]
  0000b	83 c2 2c	 add	 edx, 44			; 0000002cH
  0000e	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  00013	83 c4 08	 add	 esp, 8

; 476  :   }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::fill_range_with_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z
_TEXT	SEGMENT
?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_value, COMDAT
; _dst$ = eax
; _src$ = ecx

; 353  :     dst->~value_type();   // delete the old value, if any
; 354  :     new(dst) value_type(src);

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN3@set_value
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@set_value:

; 355  :   }

  0000e	c3		 ret	 0
?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*, COMDAT
; _this$ = eax

; 360  : 		return ((reference)**(_Mybase *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 361  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*, COMDAT
; _this$ = eax

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00002	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = eax

; 49   : 		return (_Mytree::_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 50   : 		}

  00005	c3		 ret	 0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 09		 je	 SHORT $LN8@vector
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
$LN8@vector:
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00015	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 706  : 		}

  00023	c3		 ret	 0
??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Make_iter, COMDAT
; ___$ReturnUdt$ = eax

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Make_iter
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 792  : 		return (iterator(this->_Myhead, this));

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 793  : 		}

  00004	c3		 ret	 0
?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 770  : 		_Tidy();

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]
  00004	89 09		 mov	 DWORD PTR [ecx], ecx
  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	3b 06		 cmp	 eax, DWORD PTR [esi]
  00014	74 13		 je	 SHORT $LN5@list@2
  00016	57		 push	 edi
$LL7@list@2:
  00017	8b 38		 mov	 edi, DWORD PTR [eax]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	83 c4 04	 add	 esp, 4
  00022	8b c7		 mov	 eax, edi
  00024	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00026	75 ef		 jne	 SHORT $LL7@list@2
  00028	5f		 pop	 edi
$LN5@list@2:

; 771  : 		}

  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	59		 pop	 ecx
  00032	c3		 ret	 0
??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	75 0a		 jne	 SHORT $LN1@Min
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00008	8b c1		 mov	 eax, ecx
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00010	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  00012	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Min
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00007	75 12		 jne	 SHORT $LN1@Max
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00005	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000d	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00011	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00013	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  0001c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00022	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00025	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00027	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1810 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00034	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00037	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003a	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0003f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00042	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1810 : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00049	89 02		 mov	 DWORD PTR [edx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0004e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1810 : 		}

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00009	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000d	75 1b		 jne	 SHORT $LN36@lower_boun
  0000f	56		 push	 esi
  00010	8b 75 08	 mov	 esi, DWORD PTR __Keyval$[ebp]
  00013	8b 36		 mov	 esi, DWORD PTR [esi]
$LL6@lower_boun:
  00015	39 71 0c	 cmp	 DWORD PTR [ecx+12], esi
  00018	73 05		 jae	 SHORT $LN4@lower_boun
  0001a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001d	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001f	8b d1		 mov	 edx, ecx
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN3@lower_boun:
  00023	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00027	74 ec		 je	 SHORT $LL6@lower_boun
  00029	5e		 pop	 esi
$LN36@lower_boun:
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 1451 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T169930 = -16						; size = 12
$T169864 = -4						; size = 4
??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = esi

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	6a 18		 push	 24			; 00000018H
  00008	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 25		 je	 SHORT $LN20@Tree
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001e	89 00		 mov	 DWORD PTR [eax], eax
  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002f	b0 01		 mov	 al, 1
  00031	88 41 14	 mov	 BYTE PTR [ecx+20], al
  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	88 42 15	 mov	 BYTE PTR [edx+21], al

; 699  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00040	8d 45 fc	 lea	 eax, DWORD PTR $T169864[ebp]
  00043	50		 push	 eax
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T169930[ebp]
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T169864[ebp], 0
  0004e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00053	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00058	8d 4d f0	 lea	 ecx, DWORD PTR $T169930[ebp]
  0005b	51		 push	 ecx
  0005c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T169930[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  00068	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ
_TEXT	SEGMENT
?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 951  :     return iterator(rightmost(), rightmost() ? rightmost()->count() : 0);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 0d		 je	 SHORT $LN7@end
  00006	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00009	75 08		 jne	 SHORT $LN7@end
  0000b	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00011	eb 02		 jmp	 SHORT $LN19@end
$LN7@end:
  00013	8b d1		 mov	 edx, ecx
$LN19@end:
  00015	85 d2		 test	 edx, edx
  00017	74 1d		 je	 SHORT $LN3@end
  00019	85 c9		 test	 ecx, ecx
  0001b	74 11		 je	 SHORT $LN23@end
  0001d	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00020	75 0c		 jne	 SHORT $LN23@end
  00022	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00028	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  0002c	eb 0a		 jmp	 SHORT $LN4@end
$LN23@end:
  0002e	8b d1		 mov	 edx, ecx
  00030	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  00034	eb 02		 jmp	 SHORT $LN4@end
$LN3@end:
  00036	33 d2		 xor	 edx, edx
$LN4@end:
  00038	85 c9		 test	 ecx, ecx
  0003a	74 0b		 je	 SHORT $LN41@end
  0003c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0003f	75 06		 jne	 SHORT $LN41@end
  00041	8b 89 80 01 00
	00		 mov	 ecx, DWORD PTR [ecx+384]
$LN41@end:
  00047	89 08		 mov	 DWORD PTR [eax], ecx
  00049	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 952  :   }

  0004c	c3		 ret	 0
?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
__Cat$170146 = 8					; size = 1
_this$ = 8						; size = 4
?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key, COMDAT
; _val$ = eax

; 481  :   void set_empty_key(const_reference val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 482  :     // Once you set the empty key, you can't change it
; 483  :     assert(!settings.use_empty() && "Calling set_empty_key multiple times");
; 484  :     // The deleted indicator (if specified) and the empty indicator
; 485  :     // must be different.
; 486  :     assert((!settings.use_deleted() || !equals(get_key(val), key_info.delkey))
; 487  :            && "Setting the empty key the same as the deleted key");
; 488  :     settings.set_use_empty(true);
; 489  :     set_value(&val_info.emptyval, val);

  00009	8d 7b 2c	 lea	 edi, DWORD PTR [ebx+44]
  0000c	c6 43 11 01	 mov	 BYTE PTR [ebx+17], 1
  00010	85 ff		 test	 edi, edi
  00012	74 0a		 je	 SHORT $LN7@set_empty_
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	89 0f		 mov	 DWORD PTR [edi], ecx
  00018	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001b	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN7@set_empty_:

; 490  : 
; 491  :     assert(!table);                  // must set before first use
; 492  :     // num_buckets was set in constructor even though table was NULL
; 493  :     table = val_info.allocate(num_buckets);

  0001e	8b 73 28	 mov	 esi, DWORD PTR [ebx+40]
  00021	03 f6		 add	 esi, esi
  00023	03 f6		 add	 esi, esi
  00025	03 f6		 add	 esi, esi
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 _malloc

; 494  :     assert(table);
; 495  :     fill_range_with_empty(table, table + num_buckets);

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$170146[ebp]
  00030	51		 push	 ecx
  00031	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00034	50		 push	 eax
  00035	8b d7		 mov	 edx, edi
  00037	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  0003a	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 496  :   }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
  00000	c3		 ret	 0
??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ
_TEXT	SEGMENT
??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::~ValInfo, COMDAT
  00000	c3		 ret	 0
??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::~ValInfo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator->, COMDAT
; _this$ = eax

; 365  : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 366  : 		}

  00005	c3		 ret	 0
??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 300  : 		return (!(*this == _Right));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 301  : 		}

  00009	c3		 ret	 0
??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator!=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator->, COMDAT
; _this$ = eax

; 401  : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator->, COMDAT
; _this$ = eax

; 54   : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 55   : 		}

  00005	c3		 ret	 0
??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 335  : 		return (!(*this == _Right));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 336  : 		}

  00009	c3		 ret	 0
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator!=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 337  : 		return (_List.end());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 10		 mov	 DWORD PTR [eax], edx

; 338  : 		}

  00005	c3		 ret	 0
?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = esi

; 316  : 		}

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	57		 push	 edi
  00004	33 ff		 xor	 edi, edi
  00006	3b c7		 cmp	 eax, edi
  00008	74 09		 je	 SHORT $LN10@Hash
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN10@Hash:
  00013	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00016	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00019	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	89 09		 mov	 DWORD PTR [ecx], ecx
  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00029	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002c	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0002f	74 12		 je	 SHORT $LN18@Hash
$LL20@Hash:
  00031	8b 38		 mov	 edi, DWORD PTR [eax]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	8b c7		 mov	 eax, edi
  0003e	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00041	75 ee		 jne	 SHORT $LL20@Hash
$LN18@Hash:
  00043	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	83 c4 04	 add	 esp, 4
  0004f	5f		 pop	 edi
  00050	c3		 ret	 0
??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 817  : 		return (iterator(this->_Myhead, this));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 10		 mov	 DWORD PTR [eax], edx

; 818  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::~btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >, COMDAT
; _this$ = esi

; 940  :     clear();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN12@btree
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN12@btree:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 941  :   }

  00014	c3		 ret	 0
??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::~btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ
_TEXT	SEGMENT
?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::end, COMDAT
; ___$ReturnUdt$ = eax

; 62   :   iterator end() { return tree_.end(); }

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 0d		 je	 SHORT $LN9@end@2
  0000c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0000f	75 08		 jne	 SHORT $LN9@end@2
  00011	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00017	eb 02		 jmp	 SHORT $LN21@end@2
$LN9@end@2:
  00019	8b d1		 mov	 edx, ecx
$LN21@end@2:
  0001b	85 d2		 test	 edx, edx
  0001d	74 1d		 je	 SHORT $LN5@end@2
  0001f	85 c9		 test	 ecx, ecx
  00021	74 11		 je	 SHORT $LN25@end@2
  00023	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00026	75 0c		 jne	 SHORT $LN25@end@2
  00028	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  0002e	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  00032	eb 0a		 jmp	 SHORT $LN6@end@2
$LN25@end@2:
  00034	8b d1		 mov	 edx, ecx
  00036	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  0003a	eb 02		 jmp	 SHORT $LN6@end@2
$LN5@end@2:
  0003c	33 d2		 xor	 edx, edx
$LN6@end@2:
  0003e	85 c9		 test	 ecx, ecx
  00040	74 0b		 je	 SHORT $LN43@end@2
  00042	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00045	75 06		 jne	 SHORT $LN43@end@2
  00047	8b 89 80 01 00
	00		 mov	 ecx, DWORD PTR [ecx+384]
$LN43@end@2:
  0004d	89 08		 mov	 DWORD PTR [eax], ecx
  0004f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00052	c3		 ret	 0
?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 727  :     if (table) {

  00000	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN9@dense_hash

; 728  :       destroy_buckets(0, num_buckets);
; 729  :       val_info.deallocate(table, num_buckets);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _free
  0000d	59		 pop	 ecx
$LN9@dense_hash:

; 730  :     }
; 731  :   }

  0000e	c3		 ret	 0
??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z
_TEXT	SEGMENT
__Cat$170763 = -4					; size = 1
?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key, COMDAT
; _key$ = eax

; 294  :   void set_empty_key(const key_type& key)   {           // YOU MUST CALL THIS!

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 295  :     rep.set_empty_key(value_type(key, data_type()));    // rep wants a value

  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0000e	8d 5e 2c	 lea	 ebx, DWORD PTR [esi+44]
  00011	57		 push	 edi
  00012	c6 46 11 01	 mov	 BYTE PTR [esi+17], 1
  00016	85 db		 test	 ebx, ebx
  00018	74 09		 je	 SHORT $LN17@set_empty_@2
  0001a	89 03		 mov	 DWORD PTR [ebx], eax
  0001c	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
$LN17@set_empty_@2:
  00023	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]
  00026	03 ff		 add	 edi, edi
  00028	03 ff		 add	 edi, edi
  0002a	03 ff		 add	 edi, edi
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 _malloc
  00032	8b 4d fc	 mov	 ecx, DWORD PTR __Cat$170763[ebp]
  00035	51		 push	 ecx
  00036	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00039	50		 push	 eax
  0003a	8b d3		 mov	 edx, ebx
  0003c	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0003f	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  :   }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
_TEXT	ENDS
PUBLIC	?test_cache_miss@@YAXXZ				; test_cache_miss
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark.cc
;	COMDAT ?test_cache_miss@@YAXXZ
_TEXT	SEGMENT
_t$170778 = -64						; size = 8
_stop$150584 = -56					; size = 8
_t$170772 = -48						; size = 8
tv293 = -40						; size = 8
tv302 = -32						; size = 8
_start$150583 = -24					; size = 8
_result$ = -16						; size = 8
tv248 = -8						; size = 4
_DATA$ = -4						; size = 4
?test_cache_miss@@YAXXZ PROC				; test_cache_miss, COMDAT

; 2185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2186 : 	unsigned size = 512*1024*1024;
; 2187 : 	unsigned char* DATA = (unsigned char*)malloc(size);

  00009	68 00 00 00 20	 push	 536870912		; 20000000H
  0000e	e8 00 00 00 00	 call	 _malloc
  00013	83 c4 04	 add	 esp, 4

; 2188 : 	unsigned delta = 512;
; 2189 : 	tommy_uint64_t miss_time;
; 2190 : 	unsigned i, j;
; 2191 : 	tommy_uint64_t result = 0;
; 2192 : 
; 2193 : 	memset(DATA, 0, size);

  00016	68 00 00 00 20	 push	 536870912		; 20000000H
  0001b	8b f0		 mov	 esi, eax
  0001d	6a 00		 push	 0
  0001f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00023	56		 push	 esi
  00024	89 75 fc	 mov	 DWORD PTR _DATA$[ebp], esi
  00027	66 0f 13 45 f0	 movlpd	 QWORD PTR _result$[ebp], xmm0
  0002c	e8 00 00 00 00	 call	 _memset
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR tv248[ebp], 8
  0003b	eb 06		 jmp	 SHORT $LN8@test_cache
  0003d	8d 49 00	 npad	 3
$LL22@test_cache:

; 2186 : 	unsigned size = 512*1024*1024;
; 2187 : 	unsigned char* DATA = (unsigned char*)malloc(size);

  00040	8b 75 fc	 mov	 esi, DWORD PTR _DATA$[ebp]
$LN8@test_cache:

; 2196 : 		tommy_uint64_t start, stop;
; 2197 : 		start = nano();

  00043	8d 45 d0	 lea	 eax, DWORD PTR _t$170772[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0004d	85 c0		 test	 eax, eax
  0004f	75 0e		 jne	 SHORT $LN11@test_cache
  00051	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00055	66 0f 13 45 e8	 movlpd	 QWORD PTR _start$150583[ebp], xmm0
  0005a	8b 7d e8	 mov	 edi, DWORD PTR _start$150583[ebp]
  0005d	eb 5a		 jmp	 SHORT $LN12@test_cache
$LN11@test_cache:
  0005f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00065	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0006b	8b 4d d4	 mov	 ecx, DWORD PTR _t$170772[ebp+4]
  0006e	8b 55 d0	 mov	 edx, DWORD PTR _t$170772[ebp]
  00071	57		 push	 edi
  00072	56		 push	 esi
  00073	51		 push	 ecx
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 __alldvrm
  0007a	6a 00		 push	 0
  0007c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00081	53		 push	 ebx
  00082	51		 push	 ecx
  00083	89 45 e0	 mov	 DWORD PTR tv302[ebp], eax
  00086	89 55 e4	 mov	 DWORD PTR tv302[ebp+4], edx
  00089	e8 00 00 00 00	 call	 __allmul
  0008e	57		 push	 edi
  0008f	56		 push	 esi
  00090	52		 push	 edx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 __alldiv
  00097	8b 4d e0	 mov	 ecx, DWORD PTR tv302[ebp]
  0009a	6a 00		 push	 0
  0009c	8b f8		 mov	 edi, eax
  0009e	8b 45 e4	 mov	 eax, DWORD PTR tv302[ebp+4]
  000a1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  000a6	50		 push	 eax
  000a7	51		 push	 ecx
  000a8	8b da		 mov	 ebx, edx
  000aa	e8 00 00 00 00	 call	 __allmul
  000af	8b 75 fc	 mov	 esi, DWORD PTR _DATA$[ebp]
  000b2	03 f8		 add	 edi, eax
  000b4	13 da		 adc	 ebx, edx
  000b6	89 5d ec	 mov	 DWORD PTR _start$150583[ebp+4], ebx
$LN12@test_cache:

; 2198 : 		for(i=0;i<size;i += delta) {

  000b9	33 c0		 xor	 eax, eax
  000bb	eb 03 8d 49 00	 npad	 5
$LL5@test_cache:

; 2199 : 			++DATA[i];

  000c0	fe 04 30	 inc	 BYTE PTR [eax+esi]
  000c3	05 00 02 00 00	 add	 eax, 512		; 00000200H
  000c8	3d 00 00 00 20	 cmp	 eax, 536870912		; 20000000H
  000cd	72 f1		 jb	 SHORT $LL5@test_cache

; 2200 : 		}
; 2201 : 		stop = nano();

  000cf	8d 55 c0	 lea	 edx, DWORD PTR _t$170778[ebp]
  000d2	52		 push	 edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  000d9	85 c0		 test	 eax, eax
  000db	75 11		 jne	 SHORT $LN14@test_cache
  000dd	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000e1	66 0f 13 45 c8	 movlpd	 QWORD PTR _stop$150584[ebp], xmm0
  000e6	8b 5d cc	 mov	 ebx, DWORD PTR _stop$150584[ebp+4]
  000e9	8b 75 c8	 mov	 esi, DWORD PTR _stop$150584[ebp]
  000ec	eb 59		 jmp	 SHORT $LN15@test_cache
$LN14@test_cache:
  000ee	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _win_frequency
  000f9	8b 4d c4	 mov	 ecx, DWORD PTR _t$170778[ebp+4]
  000fc	8b 55 c0	 mov	 edx, DWORD PTR _t$170778[ebp]
  000ff	56		 push	 esi
  00100	50		 push	 eax
  00101	51		 push	 ecx
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 __alldvrm
  00108	6a 00		 push	 0
  0010a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0010f	53		 push	 ebx
  00110	51		 push	 ecx
  00111	89 45 d8	 mov	 DWORD PTR tv293[ebp], eax
  00114	89 55 dc	 mov	 DWORD PTR tv293[ebp+4], edx
  00117	e8 00 00 00 00	 call	 __allmul
  0011c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _win_frequency
  00122	56		 push	 esi
  00123	51		 push	 ecx
  00124	52		 push	 edx
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 __alldiv
  0012b	6a 00		 push	 0
  0012d	8b da		 mov	 ebx, edx
  0012f	8b 55 dc	 mov	 edx, DWORD PTR tv293[ebp+4]
  00132	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00137	8b f0		 mov	 esi, eax
  00139	8b 45 d8	 mov	 eax, DWORD PTR tv293[ebp]
  0013c	52		 push	 edx
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 __allmul
  00143	03 f0		 add	 esi, eax
  00145	13 da		 adc	 ebx, edx
$LN15@test_cache:

; 2202 : 
; 2203 : 		if (!result || result > stop - start)

  00147	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  0014a	8b 55 f4	 mov	 edx, DWORD PTR _result$[ebp+4]
  0014d	0b ca		 or	 ecx, edx
  0014f	74 14		 je	 SHORT $LN21@test_cache
  00151	8b ce		 mov	 ecx, esi
  00153	2b cf		 sub	 ecx, edi
  00155	8b c3		 mov	 eax, ebx
  00157	1b 45 ec	 sbb	 eax, DWORD PTR _start$150583[ebp+4]
  0015a	3b d0		 cmp	 edx, eax
  0015c	72 12		 jb	 SHORT $LN7@test_cache
  0015e	77 05		 ja	 SHORT $LN21@test_cache
  00160	39 4d f0	 cmp	 DWORD PTR _result$[ebp], ecx
  00163	76 0b		 jbe	 SHORT $LN7@test_cache
$LN21@test_cache:

; 2204 : 			result = stop - start;

  00165	2b f7		 sub	 esi, edi
  00167	1b 5d ec	 sbb	 ebx, DWORD PTR _start$150583[ebp+4]
  0016a	89 75 f0	 mov	 DWORD PTR _result$[ebp], esi
  0016d	89 5d f4	 mov	 DWORD PTR _result$[ebp+4], ebx
$LN7@test_cache:

; 2194 : 
; 2195 : 	for(j=0;j<8;++j) {

  00170	ff 4d f8	 dec	 DWORD PTR tv248[ebp]
  00173	0f 85 c7 fe ff
	ff		 jne	 $LL22@test_cache

; 2205 : 	}
; 2206 : 
; 2207 : 	free(DATA);

  00179	8b 55 fc	 mov	 edx, DWORD PTR _DATA$[ebp]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 _free

; 2208 : 
; 2209 : 	miss_time = result * delta / size;

  00182	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  00185	8b 4d f4	 mov	 ecx, DWORD PTR _result$[ebp+4]
  00188	0f a4 c1 09	 shld	 ecx, eax, 9
  0018c	c1 e0 09	 shl	 eax, 9
  0018f	0f ac c8 1d	 shrd	 eax, ecx, 29
  00193	83 c4 04	 add	 esp, 4

; 2210 : 
; 2211 : 	printf("Cache miss %d [ns]\n", (unsigned)miss_time);

  00196	50		 push	 eax
  00197	68 00 00 00 00	 push	 OFFSET $SG-128
  0019c	c1 e9 1d	 shr	 ecx, 29			; 0000001dH
  0019f	e8 00 00 00 00	 call	 _printf
  001a4	83 c4 08	 add	 esp, 8

; 2212 : }

  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
?test_cache_miss@@YAXXZ ENDP				; test_cache_miss
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN15@btree_cont
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN15@btree_cont:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN18@btree_uniq
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN18@btree_uniq:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN21@btree_map_
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN21@btree_map_:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi
  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	57		 push	 edi
  00004	33 ff		 xor	 edi, edi
  00006	3b c7		 cmp	 eax, edi
  00008	74 09		 je	 SHORT $LN12@unordered_
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN12@unordered_:
  00013	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00016	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00019	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	89 09		 mov	 DWORD PTR [ecx], ecx
  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00029	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002c	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0002f	74 12		 je	 SHORT $LN20@unordered_
$LL22@unordered_:
  00031	8b 38		 mov	 edi, DWORD PTR [eax]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	8b c7		 mov	 eax, edi
  0003e	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00041	75 ee		 jne	 SHORT $LL22@unordered_
$LN20@unordered_:
  00043	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	83 c4 04	 add	 esp, 4
  0004f	5f		 pop	 edi
  00050	c3		 ret	 0
??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ PROC ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::~btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN24@btree_map
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN24@btree_map:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ ENDP ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::~btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax
  00000	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN11@dense_hash@2
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _free
  0000d	59		 pop	 ecx
$LN11@dense_hash@2:
  0000e	c3		 ret	 0
??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	57		 push	 edi
  00004	33 ff		 xor	 edi, edi
  00006	3b c7		 cmp	 eax, edi
  00008	74 09		 je	 SHORT $LN15@scalar@2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN15@scalar@2:
  00013	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00016	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00019	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	89 09		 mov	 DWORD PTR [ecx], ecx
  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00029	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002c	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0002f	74 12		 je	 SHORT $LN23@scalar@2
$LL25@scalar@2:
  00031	8b 38		 mov	 edi, DWORD PTR [eax]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	8b c7		 mov	 eax, edi
  0003e	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00041	75 ee		 jne	 SHORT $LL25@scalar@2
$LN23@scalar@2:
  00043	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00052	83 c4 08	 add	 esp, 8
  00055	8b c6		 mov	 eax, esi
  00057	5f		 pop	 edi
  00058	c3		 ret	 0
??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z PROC ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN18@scalar@3
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN18@scalar@3:
  0000e	56		 push	 esi
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00015	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b c6		 mov	 eax, esi
  0001f	c3		 ret	 0
??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z ENDP ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN14@scalar@4
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _free
  0000d	83 c4 04	 add	 esp, 4
$LN14@scalar@4:
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
  00019	8b c6		 mov	 eax, esi
  0001b	c3		 ret	 0
??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?order_init@@YAXHH@Z				; order_init
; Function compile flags: /Ogtp
;	COMDAT ?order_init@@YAXHH@Z
_TEXT	SEGMENT
tv431 = -8						; size = 4
tv195 = -8						; size = 4
tv181 = -4						; size = 4
tv71 = -4						; size = 4
_t$144390 = -4						; size = 4
tv297 = 8						; size = 4
_i$ = 8							; size = 4
_sparse$ = 8						; size = 4
?order_init@@YAXHH@Z PROC				; order_init, COMDAT

; 660  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 661  : 	int i;
; 662  : 
; 663  : 	FORWARD = (unsigned*)malloc(max * sizeof(unsigned));

  0000f	8d 34 9d 00 00
	00 00		 lea	 esi, DWORD PTR [ebx*4]
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _malloc
  0001c	83 c4 04	 add	 esp, 4

; 664  : 	RAND0 = (unsigned*)malloc(max * sizeof(unsigned));

  0001f	56		 push	 esi
  00020	a3 00 00 00 00	 mov	 DWORD PTR ?FORWARD@@3PAIA, eax ; FORWARD
  00025	e8 00 00 00 00	 call	 _malloc
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b f8		 mov	 edi, eax

; 665  : 	RAND1 = (unsigned*)malloc(max * sizeof(unsigned));

  0002f	56		 push	 esi
  00030	89 3d 00 00 00
	00		 mov	 DWORD PTR ?RAND0@@3PAIA, edi ; RAND0
  00036	e8 00 00 00 00	 call	 _malloc
  0003b	83 c4 04	 add	 esp, 4

; 666  : 
; 667  : 	/* generated forward orders */
; 668  : 	if (sparse) {

  0003e	83 7d 08 00	 cmp	 DWORD PTR _sparse$[ebp], 0
  00042	8b c8		 mov	 ecx, eax
  00044	89 0d 00 00 00
	00		 mov	 DWORD PTR ?RAND1@@3PAIA, ecx ; RAND1
  0004a	74 3c		 je	 SHORT $LN11@order_init

; 669  : 		for(i=0;i<max;++i) {

  0004c	85 db		 test	 ebx, ebx
  0004e	7e 6f		 jle	 SHORT $LN4@order_init
  00050	83 c8 ff	 or	 eax, -1
  00053	33 d2		 xor	 edx, edx
  00055	f7 f3		 div	 ebx
  00057	33 f6		 xor	 esi, esi
  00059	8b d7		 mov	 edx, edi
  0005b	89 5d fc	 mov	 DWORD PTR tv181[ebp], ebx
  0005e	89 45 f8	 mov	 DWORD PTR tv195[ebp], eax
  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00066	2b c7		 sub	 eax, edi
  00068	2b cf		 sub	 ecx, edi
  0006a	89 4d 08	 mov	 DWORD PTR tv297[ebp], ecx
  0006d	8d 49 00	 npad	 3
$LL10@order_init:

; 670  : 			FORWARD[i] = 0xffffffff / max * i;
; 671  : 			RAND0[i] = FORWARD[i];
; 672  : 			RAND1[i] = FORWARD[i];

  00070	8b 4d 08	 mov	 ecx, DWORD PTR tv297[ebp]
  00073	89 34 10	 mov	 DWORD PTR [eax+edx], esi
  00076	89 32		 mov	 DWORD PTR [edx], esi
  00078	89 34 11	 mov	 DWORD PTR [ecx+edx], esi
  0007b	03 75 f8	 add	 esi, DWORD PTR tv195[ebp]
  0007e	83 c2 04	 add	 edx, 4
  00081	ff 4d fc	 dec	 DWORD PTR tv181[ebp]
  00084	75 ea		 jne	 SHORT $LL10@order_init

; 673  : 		}

  00086	eb 31		 jmp	 SHORT $LN20@order_init
$LN11@order_init:

; 674  : 	} else {
; 675  : 		for(i=0;i<max;++i) {

  00088	85 db		 test	 ebx, ebx
  0008a	7e 33		 jle	 SHORT $LN4@order_init
  0008c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00092	2b f7		 sub	 esi, edi
  00094	2b cf		 sub	 ecx, edi
  00096	8b d7		 mov	 edx, edi
  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	89 4d 08	 mov	 DWORD PTR tv297[ebp], ecx
  000a0	89 5d fc	 mov	 DWORD PTR tv71[ebp], ebx
$LL6@order_init:

; 676  : 			FORWARD[i] = 0x80000000 + i * 2;
; 677  : 			RAND0[i] = FORWARD[i];
; 678  : 			RAND1[i] = FORWARD[i];

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR tv297[ebp]
  000a6	89 04 32	 mov	 DWORD PTR [edx+esi], eax
  000a9	89 02		 mov	 DWORD PTR [edx], eax
  000ab	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  000ae	83 c0 02	 add	 eax, 2
  000b1	83 c2 04	 add	 edx, 4
  000b4	ff 4d fc	 dec	 DWORD PTR tv71[ebp]
  000b7	75 ea		 jne	 SHORT $LL6@order_init
$LN20@order_init:

; 674  : 	} else {
; 675  : 		for(i=0;i<max;++i) {

  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RAND1@@3PAIA ; RAND1
$LN4@order_init:

; 679  : 		}
; 680  : 	}
; 681  : 
; 682  : 	/* randomize using the Fisher-Yates shuffle, http://en.wikipedia.org/wiki/Fisher-Yates_shuffle */
; 683  : 	for(i=max-1;i>=0;--i) {

  000bf	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000c2	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
  000c5	85 c0		 test	 eax, eax
  000c7	78 59		 js	 SHORT $LN1@order_init
  000c9	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  000cc	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  000cf	8b c7		 mov	 eax, edi
  000d1	2b c1		 sub	 eax, ecx
  000d3	89 45 f8	 mov	 DWORD PTR tv431[ebp], eax
$LL3@order_init:

; 684  : 		unsigned j, t;
; 685  : 		j = rnd(i+1);

  000d6	53		 push	 ebx
  000d7	e8 00 00 00 00	 call	 ?rnd@@YAII@Z		; rnd

; 686  : 		t = RAND0[i];

  000dc	8b 4d f8	 mov	 ecx, DWORD PTR tv431[ebp]
  000df	8b 14 31	 mov	 edx, DWORD PTR [ecx+esi]
  000e2	89 55 fc	 mov	 DWORD PTR _t$144390[ebp], edx

; 687  : 		RAND0[i] = RAND0[j];

  000e5	8b 14 87	 mov	 edx, DWORD PTR [edi+eax*4]
  000e8	89 14 31	 mov	 DWORD PTR [ecx+esi], edx

; 688  : 		RAND0[j] = t;

  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _t$144390[ebp]
  000ee	83 c4 04	 add	 esp, 4

; 689  : 
; 690  : 		j = rnd(i+1);

  000f1	53		 push	 ebx
  000f2	89 0c 87	 mov	 DWORD PTR [edi+eax*4], ecx
  000f5	e8 00 00 00 00	 call	 ?rnd@@YAII@Z		; rnd

; 691  : 		t = RAND1[i];
; 692  : 		RAND1[i] = RAND1[j];

  000fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  00100	8b 14 82	 mov	 edx, DWORD PTR [edx+eax*4]
  00103	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00105	89 16		 mov	 DWORD PTR [esi], edx

; 693  : 		RAND1[j] = t;

  00107	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  0010d	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  00110	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00113	48		 dec	 eax
  00114	83 c4 04	 add	 esp, 4
  00117	4b		 dec	 ebx
  00118	83 ee 04	 sub	 esi, 4
  0011b	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
  0011e	85 c0		 test	 eax, eax
  00120	79 b4		 jns	 SHORT $LL3@order_init
$LN1@order_init:

; 694  : 	}
; 695  : }

  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
?order_init@@YAXHH@Z ENDP				; order_init
_TEXT	ENDS
PUBLIC	?stop@@YAXXZ					; stop
; Function compile flags: /Ogtp
;	COMDAT ?stop@@YAXXZ
_TEXT	SEGMENT
?stop@@YAXXZ PROC					; stop, COMDAT

; 590  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 591  : 	tommy_uint64_t elapsed = nano() - the_time;

  00003	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00008	8b f0		 mov	 esi, eax
  0000a	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA

; 592  : 
; 593  : 	if (!is_select(the_start_data))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00015	8b fa		 mov	 edi, edx
  00017	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  0001d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00023	75 66		 jne	 SHORT $LN3@stop

; 594  : 		return;
; 595  : 
; 596  : 	if (!the_log) {

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0002c	75 1e		 jne	 SHORT $LN1@stop

; 597  : 		printf("%4u [ns]\n", (unsigned)(elapsed / the_max));

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00034	6a 00		 push	 0
  00036	51		 push	 ecx
  00037	57		 push	 edi
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 __aulldiv
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET $SG-101
  00044	e8 00 00 00 00	 call	 _printf
  00049	83 c4 08	 add	 esp, 8
$LN1@stop:

; 598  : 	} 
; 599  : 
; 600  : 	LOG[the_retry][the_data][the_order][the_operation] = (unsigned)(elapsed / the_max);

  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00052	6a 00		 push	 0
  00054	52		 push	 edx
  00055	57		 push	 edi
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 __aulldiv
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00062	8b d1		 mov	 edx, ecx
  00064	c1 e2 04	 shl	 edx, 4
  00067	2b d1		 sub	 edx, ecx
  00069	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?the_data@@3IA ; the_data
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00075	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  00078	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00081	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00084	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2P@15IA[edx*4], eax
$LN3@stop:

; 601  : }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	59		 pop	 ecx
  0008e	c3		 ret	 0
?stop@@YAXXZ ENDP					; stop
_TEXT	ENDS
PUBLIC	?start@@YAHI@Z					; start
; Function compile flags: /Ogtp
;	COMDAT ?start@@YAHI@Z
_TEXT	SEGMENT
?start@@YAHI@Z PROC					; start, COMDAT
; _data$ = eax

; 576  : {

  00000	51		 push	 ecx

; 577  : 	the_start_data = data;

  00001	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data

; 578  : 
; 579  : 	if (!is_select(the_start_data))

  00006	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0000c	74 04		 je	 SHORT $LN2@start

; 580  : 		return 0;

  0000e	33 c0		 xor	 eax, eax
  00010	59		 pop	 ecx

; 587  : }

  00011	c3		 ret	 0
$LN2@start:

; 581  : 
; 582  : 	if (!the_log)

  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00019	75 30		 jne	 SHORT $LN1@start

; 583  : 		printf("%10s, %10s, %12s, ", ORDER_NAME[the_order], OPERATION_NAME[the_operation], DATA_NAME[data]);

  0001b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA[eax*4]
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00028	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0002f	50		 push	 eax
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00035	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0003c	52		 push	 edx
  0003d	51		 push	 ecx
  0003e	68 00 00 00 00	 push	 OFFSET $SG-100
  00043	e8 00 00 00 00	 call	 _printf
  00048	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@start:

; 584  : 
; 585  : 	the_time = nano();

  0004b	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00050	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00055	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx

; 586  : 	return 1;

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	59		 pop	 ecx

; 587  : }

  00061	c3		 ret	 0
?start@@YAHI@Z ENDP					; start
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??Rcpp_tommy_inthash_u32@@QBEII@Z
_TEXT	SEGMENT
??Rcpp_tommy_inthash_u32@@QBEII@Z PROC			; cpp_tommy_inthash_u32::operator(), COMDAT
; _key$ = ecx

; 302  : 	unsigned operator()(unsigned key) const { return tommy_inthash_u32(key); }

  00000	8b c1		 mov	 eax, ecx
  00002	c1 e0 06	 shl	 eax, 6
  00005	2b c8		 sub	 ecx, eax
  00007	8b d1		 mov	 edx, ecx
  00009	c1 ea 11	 shr	 edx, 17			; 00000011H
  0000c	33 ca		 xor	 ecx, edx
  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e0 09	 shl	 eax, 9
  00013	2b c8		 sub	 ecx, eax
  00015	8b d1		 mov	 edx, ecx
  00017	c1 e2 04	 shl	 edx, 4
  0001a	33 ca		 xor	 ecx, edx
  0001c	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00023	2b c8		 sub	 ecx, eax
  00025	8b d1		 mov	 edx, ecx
  00027	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0002a	33 ca		 xor	 ecx, edx
  0002c	8b c1		 mov	 eax, ecx
  0002e	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00031	33 c1		 xor	 eax, ecx
  00033	c3		 ret	 0
??Rcpp_tommy_inthash_u32@@QBEII@Z ENDP			; cpp_tommy_inthash_u32::operator()
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z
_TEXT	SEGMENT
_last$144140 = -20					; size = 4
_inc$144136 = -16					; size = 4
tv344 = -12						; size = 4
_site$144139 = -8					; size = 4
_x$ = -4						; size = 4
_key$ = 8						; size = 4
_ret$ = 12						; size = 4
?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z PROC		; kh_put_word, COMDAT

; 286  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00015	72 18		 jb	 SHORT $LN17@kh_put_wor
  00017	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001a	8b 07		 mov	 eax, DWORD PTR [edi]
  0001c	03 c9		 add	 ecx, ecx
  0001e	3b c1		 cmp	 eax, ecx
  00020	76 03		 jbe	 SHORT $LN18@kh_put_wor
  00022	48		 dec	 eax
  00023	eb 01		 jmp	 SHORT $LN29@kh_put_wor
$LN18@kh_put_wor:
  00025	40		 inc	 eax
$LN29@kh_put_wor:
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?kh_resize_word@@YAXPAUkh_word_t@@I@Z ; kh_resize_word
  0002c	83 c4 04	 add	 esp, 4
$LN17@kh_put_wor:
  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00031	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00034	33 d2		 xor	 edx, edx
  00036	f7 f1		 div	 ecx
  00038	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0003b	89 4d f8	 mov	 DWORD PTR _site$144139[ebp], ecx
  0003e	89 4d fc	 mov	 DWORD PTR _x$[ebp], ecx
  00041	8b da		 mov	 ebx, edx
  00043	8b f3		 mov	 esi, ebx
  00045	c1 ee 04	 shr	 esi, 4
  00048	03 f6		 add	 esi, esi
  0004a	03 f6		 add	 esi, esi
  0004c	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  0004f	83 e2 0f	 and	 edx, 15			; 0000000fH
  00052	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  00055	d3 e8		 shr	 eax, cl
  00057	89 4d f4	 mov	 DWORD PTR tv344[ebp], ecx
  0005a	a8 02		 test	 al, 2
  0005c	74 07		 je	 SHORT $LN16@kh_put_wor
  0005e	8b f3		 mov	 esi, ebx
  00060	e9 a8 00 00 00	 jmp	 $LN5@kh_put_wor
$LN16@kh_put_wor:
  00065	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00067	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0006a	8d 49 ff	 lea	 ecx, DWORD PTR [ecx-1]
  0006d	33 d2		 xor	 edx, edx
  0006f	f7 f1		 div	 ecx
  00071	8b 4d f4	 mov	 ecx, DWORD PTR tv344[ebp]
  00074	89 5d ec	 mov	 DWORD PTR _last$144140[ebp], ebx
  00077	42		 inc	 edx
  00078	89 55 f0	 mov	 DWORD PTR _inc$144136[ebp], edx
  0007b	eb 06		 jmp	 SHORT $LN14@kh_put_wor
  0007d	8d 49 00	 npad	 3
$LL28@kh_put_wor:
  00080	8b 55 f0	 mov	 edx, DWORD PTR _inc$144136[ebp]
$LN14@kh_put_wor:
  00083	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00086	8b 34 30	 mov	 esi, DWORD PTR [eax+esi]
  00089	d3 ee		 shr	 esi, cl
  0008b	83 e6 01	 and	 esi, 1
  0008e	75 0b		 jne	 SHORT $LN24@kh_put_wor
  00090	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00093	8b 0c 98	 mov	 ecx, DWORD PTR [eax+ebx*4]
  00096	3b 4d 08	 cmp	 ecx, DWORD PTR _key$[ebp]
  00099	74 43		 je	 SHORT $LN26@kh_put_wor
$LN24@kh_put_wor:
  0009b	85 f6		 test	 esi, esi
  0009d	74 03		 je	 SHORT $LN25@kh_put_wor
  0009f	89 5d f8	 mov	 DWORD PTR _site$144139[ebp], ebx
$LN25@kh_put_wor:
  000a2	8b 07		 mov	 eax, DWORD PTR [edi]
  000a4	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  000a7	3b c8		 cmp	 ecx, eax
  000a9	72 06		 jb	 SHORT $LN10@kh_put_wor
  000ab	2b d0		 sub	 edx, eax
  000ad	03 da		 add	 ebx, edx
  000af	eb 02		 jmp	 SHORT $LN9@kh_put_wor
$LN10@kh_put_wor:
  000b1	8b d9		 mov	 ebx, ecx
$LN9@kh_put_wor:
  000b3	3b 5d ec	 cmp	 ebx, DWORD PTR _last$144140[ebp]
  000b6	74 20		 je	 SHORT $LN23@kh_put_wor
  000b8	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000bb	8b f3		 mov	 esi, ebx
  000bd	c1 ee 04	 shr	 esi, 4
  000c0	03 f6		 add	 esi, esi
  000c2	8b d3		 mov	 edx, ebx
  000c4	83 e2 0f	 and	 edx, 15			; 0000000fH
  000c7	03 f6		 add	 esi, esi
  000c9	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  000cc	8b 14 06	 mov	 edx, DWORD PTR [esi+eax]
  000cf	d3 ea		 shr	 edx, cl
  000d1	f6 c2 02	 test	 dl, 2
  000d4	74 aa		 je	 SHORT $LL28@kh_put_wor
  000d6	eb 06		 jmp	 SHORT $LN26@kh_put_wor
$LN23@kh_put_wor:
  000d8	8b 45 f8	 mov	 eax, DWORD PTR _site$144139[ebp]
  000db	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN26@kh_put_wor:
  000de	8b 37		 mov	 esi, DWORD PTR [edi]
  000e0	39 75 fc	 cmp	 DWORD PTR _x$[ebp], esi
  000e3	75 25		 jne	 SHORT $LN27@kh_put_wor
  000e5	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000e8	8b d3		 mov	 edx, ebx
  000ea	8b cb		 mov	 ecx, ebx
  000ec	c1 ea 04	 shr	 edx, 4
  000ef	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  000f2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000f5	03 c9		 add	 ecx, ecx
  000f7	d3 e8		 shr	 eax, cl
  000f9	a8 02		 test	 al, 2
  000fb	74 0a		 je	 SHORT $LN6@kh_put_wor
  000fd	8b 45 f8	 mov	 eax, DWORD PTR _site$144139[ebp]
  00100	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
  00103	3b c6		 cmp	 eax, esi
  00105	75 03		 jne	 SHORT $LN27@kh_put_wor
$LN6@kh_put_wor:
  00107	89 5d fc	 mov	 DWORD PTR _x$[ebp], ebx
$LN27@kh_put_wor:
  0010a	8b 75 fc	 mov	 esi, DWORD PTR _x$[ebp]
$LN5@kh_put_wor:
  0010d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00110	8b d6		 mov	 edx, esi
  00112	c1 ea 04	 shr	 edx, 4
  00115	03 d2		 add	 edx, edx
  00117	8b ce		 mov	 ecx, esi
  00119	03 d2		 add	 edx, edx
  0011b	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0011e	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00121	03 c9		 add	 ecx, ecx
  00123	d3 e8		 shr	 eax, cl
  00125	a8 02		 test	 al, 2
  00127	74 30		 je	 SHORT $LN4@kh_put_wor
  00129	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0012c	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
  0012f	89 1c b0	 mov	 DWORD PTR [eax+esi*4], ebx
  00132	03 57 10	 add	 edx, DWORD PTR [edi+16]
  00135	b8 03 00 00 00	 mov	 eax, 3
  0013a	d3 e0		 shl	 eax, cl
  0013c	8b 4d 0c	 mov	 ecx, DWORD PTR _ret$[ebp]
  0013f	f7 d0		 not	 eax
  00141	21 02		 and	 DWORD PTR [edx], eax
  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	01 47 04	 add	 DWORD PTR [edi+4], eax
  0014b	01 47 08	 add	 DWORD PTR [edi+8], eax
  0014e	5f		 pop	 edi
  0014f	89 01		 mov	 DWORD PTR [ecx], eax
  00151	8b c6		 mov	 eax, esi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
$LN4@kh_put_wor:
  00159	a8 01		 test	 al, 1
  0015b	74 2e		 je	 SHORT $LN2@kh_put_wor
  0015d	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00160	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
  00163	89 1c b0	 mov	 DWORD PTR [eax+esi*4], ebx
  00166	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00169	03 c2		 add	 eax, edx
  0016b	ba 03 00 00 00	 mov	 edx, 3
  00170	d3 e2		 shl	 edx, cl
  00172	f7 d2		 not	 edx
  00174	21 10		 and	 DWORD PTR [eax], edx
  00176	8b 45 0c	 mov	 eax, DWORD PTR _ret$[ebp]
  00179	ff 47 04	 inc	 DWORD PTR [edi+4]
  0017c	5f		 pop	 edi
  0017d	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
  00183	8b c6		 mov	 eax, esi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
$LN2@kh_put_wor:
  0018b	8b 4d 0c	 mov	 ecx, DWORD PTR _ret$[ebp]
  0018e	5f		 pop	 edi
  0018f	8b c6		 mov	 eax, esi
  00191	5e		 pop	 esi
  00192	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00198	5b		 pop	 ebx
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z ENDP		; kh_put_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z
_TEXT	SEGMENT
_bitpos$171640 = -4					; size = 4
?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z PROC ; nedtrie_t_NEDTRIE_FIND, COMDAT
; _r$ = eax

; 284  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, 0
  0000b	56		 push	 esi
  0000c	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0000f	74 4b		 je	 SHORT $LN22@nedtrie_t_
  00011	8b ce		 mov	 ecx, esi
  00013	83 c9 01	 or	 ecx, 1
  00016	0f bd d1	 bsr	 edx, ecx
  00019	8b ca		 mov	 ecx, edx
  0001b	8b 04 8d 04 00
	00 00		 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  00022	89 55 fc	 mov	 DWORD PTR _bitpos$171640[ebp], edx
  00025	85 c0		 test	 eax, eax
  00027	74 33		 je	 SHORT $LN22@nedtrie_t_
  00029	ba 01 00 00 00	 mov	 edx, 1
  0002e	d3 e2		 shl	 edx, cl
  00030	39 70 14	 cmp	 DWORD PTR [eax+20], esi
  00033	74 19		 je	 SHORT $end$143884
$LL6@nedtrie_t_:
  00035	d1 ea		 shr	 edx, 1
  00037	8b ca		 mov	 ecx, edx
  00039	23 ce		 and	 ecx, esi
  0003b	f7 d9		 neg	 ecx
  0003d	1b c9		 sbb	 ecx, ecx
  0003f	f7 d9		 neg	 ecx
  00041	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  00045	85 c0		 test	 eax, eax
  00047	74 13		 je	 SHORT $LN22@nedtrie_t_
  00049	39 70 14	 cmp	 DWORD PTR [eax+20], esi
  0004c	75 e7		 jne	 SHORT $LL6@nedtrie_t_
$end$143884:
  0004e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN9@nedtrie_t_
  00055	8b c1		 mov	 eax, ecx
  00057	5e		 pop	 esi
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN22@nedtrie_t_:
  0005c	33 c0		 xor	 eax, eax
$LN9@nedtrie_t_:
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z ENDP ; nedtrie_t_NEDTRIE_FIND
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z
_TEXT	SEGMENT
?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z PROC ; nedtrie_t_NEDTRIE_REMOVE, COMDAT
; _r$ = edx

; 284  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00003	85 c0		 test	 eax, eax
  00005	74 18		 je	 SHORT $LN15@nedtrie_t_@2
  00007	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  0000a	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0000d	85 d2		 test	 edx, edx
  0000f	0f 84 90 00 00
	00		 je	 $LN24@nedtrie_t_@2
  00015	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00018	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
$functexit$143837:
  0001e	c3		 ret	 0
$LN15@nedtrie_t_@2:
  0001f	56		 push	 esi
  00020	8b 32		 mov	 esi, DWORD PTR [edx]
  00022	8b c6		 mov	 eax, esi
  00024	83 e0 03	 and	 eax, 3
  00027	57		 push	 edi
  00028	3c 03		 cmp	 al, 3
  0002a	75 0e		 jne	 SHORT $LN12@nedtrie_t_@2
  0002c	8b ce		 mov	 ecx, esi
  0002e	c1 e9 02	 shr	 ecx, 2
  00031	8d 3c 8d 04 00
	00 00		 lea	 edi, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  00038	eb 0b		 jmp	 SHORT $LN19@nedtrie_t_@2
$LN12@nedtrie_t_@2:
  0003a	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0003d	39 56 04	 cmp	 DWORD PTR [esi+4], edx
  00040	74 03		 je	 SHORT $LN19@nedtrie_t_@2
  00042	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
$LN19@nedtrie_t_@2:
  00045	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00048	33 c0		 xor	 eax, eax
  0004a	85 c9		 test	 ecx, ecx
  0004c	74 0b		 je	 SHORT $LN10@nedtrie_t_@2
  0004e	8b c1		 mov	 eax, ecx
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00057	eb 2a		 jmp	 SHORT $end$143850
$LN10@nedtrie_t_@2:
  00059	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  0005c	75 05		 jne	 SHORT $LN8@nedtrie_t_@2
  0005e	39 42 08	 cmp	 DWORD PTR [edx+8], eax
  00061	74 3e		 je	 SHORT $LN1@nedtrie_t_@2
$LN8@nedtrie_t_@2:
  00063	8b cf		 mov	 ecx, edi
$LL6@nedtrie_t_@2:
  00065	8b 01		 mov	 eax, DWORD PTR [ecx]
  00067	83 c0 04	 add	 eax, 4
  0006a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006d	75 08		 jne	 SHORT $LN4@nedtrie_t_@2
  0006f	83 c0 04	 add	 eax, 4
  00072	83 38 00	 cmp	 DWORD PTR [eax], 0
  00075	74 04		 je	 SHORT $LN5@nedtrie_t_@2
$LN4@nedtrie_t_@2:
  00077	8b c8		 mov	 ecx, eax
  00079	eb ea		 jmp	 SHORT $LL6@nedtrie_t_@2
$LN5@nedtrie_t_@2:
  0007b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$end$143850:
  00083	85 c0		 test	 eax, eax
  00085	74 1a		 je	 SHORT $LN1@nedtrie_t_@2
  00087	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0008a	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0008d	89 30		 mov	 DWORD PTR [eax], esi
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00092	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00095	85 c9		 test	 ecx, ecx
  00097	74 02		 je	 SHORT $LN2@nedtrie_t_@2
  00099	89 01		 mov	 DWORD PTR [ecx], eax
$LN2@nedtrie_t_@2:
  0009b	85 d2		 test	 edx, edx
  0009d	74 02		 je	 SHORT $LN1@nedtrie_t_@2
  0009f	89 02		 mov	 DWORD PTR [edx], eax
$LN1@nedtrie_t_@2:
  000a1	89 07		 mov	 DWORD PTR [edi], eax
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
$LN24@nedtrie_t_@2:
  000a5	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
$functexit_1$143837:
  000ab	c3		 ret	 0
?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ENDP ; nedtrie_t_NEDTRIE_REMOVE
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z
_TEXT	SEGMENT
_bitpos$171668 = -4					; size = 4
?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z PROC ; nedtrie_t_NEDTRIE_INSERT, COMDAT
; _r$ = esi

; 284  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00008	57		 push	 edi
  00009	8b c3		 mov	 eax, ebx
  0000b	bf 01 00 00 00	 mov	 edi, 1
  00010	0b c7		 or	 eax, edi
  00012	0f bd c8	 bsr	 ecx, eax
  00015	8b 14 8d 04 00
	00 00		 mov	 edx, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  0001c	66 0f ef c0	 pxor	 xmm0, xmm0
  00020	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00024	66 0f d6 46 08	 movq	 QWORD PTR [esi+8], xmm0
  00029	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00030	89 4d fc	 mov	 DWORD PTR _bitpos$171668[ebp], ecx
  00033	85 d2		 test	 edx, edx
  00035	75 1f		 jne	 SHORT $LN8@nedtrie_t_@3
  00037	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0003e	83 ca 03	 or	 edx, 3
  00041	01 3d 00 00 00
	00		 add	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, edi
  00047	5f		 pop	 edi
  00048	89 16		 mov	 DWORD PTR [esi], edx
  0004a	89 34 8d 04 00
	00 00		 mov	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4], esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN8@nedtrie_t_@3:
  00056	d3 e7		 shl	 edi, cl
  00058	39 5a 14	 cmp	 DWORD PTR [edx+20], ebx
  0005b	74 1e		 je	 SHORT $LN19@nedtrie_t_@3
  0005d	8d 49 00	 npad	 3
$LL6@nedtrie_t_@3:
  00060	d1 ef		 shr	 edi, 1
  00062	8b c7		 mov	 eax, edi
  00064	23 c3		 and	 eax, ebx
  00066	f7 d8		 neg	 eax
  00068	1b c0		 sbb	 eax, eax
  0006a	f7 d8		 neg	 eax
  0006c	8b 4c 82 04	 mov	 ecx, DWORD PTR [edx+eax*4+4]
  00070	85 c9		 test	 ecx, ecx
  00072	74 2c		 je	 SHORT $LN20@nedtrie_t_@3
  00074	8b d1		 mov	 edx, ecx
  00076	39 59 14	 cmp	 DWORD PTR [ecx+20], ebx
  00079	75 e5		 jne	 SHORT $LL6@nedtrie_t_@3
$LN19@nedtrie_t_@3:
  0007b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0007e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00084	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00087	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0008a	89 72 10	 mov	 DWORD PTR [edx+16], esi
  0008d	85 c0		 test	 eax, eax
  0008f	74 15		 je	 SHORT $LN22@nedtrie_t_@3
  00091	5f		 pop	 edi
  00092	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00095	ff 05 00 00 00
	00		 inc	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN20@nedtrie_t_@3:
  000a0	89 16		 mov	 DWORD PTR [esi], edx
  000a2	89 74 82 04	 mov	 DWORD PTR [edx+eax*4+4], esi
$LN22@nedtrie_t_@3:
  000a6	ff 05 00 00 00
	00		 inc	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  000ac	5f		 pop	 edi
$end$143818:
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ENDP ; nedtrie_t_NEDTRIE_INSERT
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z
_TEXT	SEGMENT
_path$ = -520						; size = 512
_nodep$ = -4						; size = 4
?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z PROC	; rbt_remove, COMDAT
; _node$ = edx

; 275  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?tree@@3Urbtree_t@@A
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nodep$[ebp], 0
  00019	89 8d f8 fd ff
	ff		 mov	 DWORD PTR _path$[ebp], ecx
  0001f	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00025	bb 01 00 00 00	 mov	 ebx, 1
  0002a	81 f9 04 00 00
	00		 cmp	 ecx, OFFSET ?tree@@3Urbtree_t@@A+4
  00030	74 77		 je	 SHORT $LN274@rbt_remove
  00032	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
$LL282@rbt_remove:
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0003a	3b fe		 cmp	 edi, esi
  0003c	7d 05		 jge	 SHORT $LN286@rbt_remove
  0003e	83 c9 ff	 or	 ecx, -1
  00041	eb 07		 jmp	 SHORT $LN285@rbt_remove
$LN286@rbt_remove:
  00043	33 c9		 xor	 ecx, ecx
  00045	3b fe		 cmp	 edi, esi
  00047	0f 9f c1	 setg	 cl
$LN285@rbt_remove:
  0004a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0004d	85 c9		 test	 ecx, ecx
  0004f	79 09		 jns	 SHORT $LN279@rbt_remove
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00055	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00058	eb 0f		 jmp	 SHORT $LN281@rbt_remove
$LN279@rbt_remove:
  0005a	8b 30		 mov	 esi, DWORD PTR [eax]
  0005c	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0005f	83 e6 fe	 and	 esi, -2			; fffffffeH
  00062	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00065	85 c9		 test	 ecx, ecx
  00067	74 0d		 je	 SHORT $LN292@rbt_remove
$LN281@rbt_remove:
  00069	83 c0 08	 add	 eax, 8
  0006c	81 38 04 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  00072	75 c1		 jne	 SHORT $LL282@rbt_remove
  00074	eb 33		 jmp	 SHORT $LN274@rbt_remove
$LN292@rbt_remove:
  00076	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00079	89 45 fc	 mov	 DWORD PTR _nodep$[ebp], eax
  0007c	83 c0 08	 add	 eax, 8
  0007f	81 38 04 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  00085	74 22		 je	 SHORT $LN274@rbt_remove
  00087	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL276@rbt_remove:
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00094	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  0009b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0009e	83 c0 08	 add	 eax, 8
  000a1	81 38 04 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  000a7	75 e7		 jne	 SHORT $LL276@rbt_remove
$LN274@rbt_remove:
  000a9	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ac	83 e8 08	 sub	 eax, 8
  000af	3b ca		 cmp	 ecx, edx
  000b1	0f 84 88 00 00
	00		 je	 $LN273@rbt_remove
  000b7	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000ba	8b fe		 mov	 edi, esi
  000bc	23 fb		 and	 edi, ebx
  000be	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  000c1	33 de		 xor	 ebx, esi
  000c3	83 e3 01	 and	 ebx, 1
  000c6	33 de		 xor	 ebx, esi
  000c8	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  000cb	8b 32		 mov	 esi, DWORD PTR [edx]
  000cd	89 31		 mov	 DWORD PTR [ecx], esi
  000cf	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000d2	33 71 04	 xor	 esi, DWORD PTR [ecx+4]
  000d5	bb 01 00 00 00	 mov	 ebx, 1
  000da	23 f3		 and	 esi, ebx
  000dc	33 72 04	 xor	 esi, DWORD PTR [edx+4]
  000df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000e2	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000e5	83 e6 fe	 and	 esi, -2			; fffffffeH
  000e8	0b f7		 or	 esi, edi
  000ea	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000ed	8b 75 fc	 mov	 esi, DWORD PTR _nodep$[ebp]
  000f0	89 0e		 mov	 DWORD PTR [esi], ecx
  000f2	89 10		 mov	 DWORD PTR [eax], edx
  000f4	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  000fa	3b f2		 cmp	 esi, edx
  000fc	75 23		 jne	 SHORT $LN260@rbt_remove
  000fe	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00100	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, ecx
$LN234@rbt_remove:
  00106	8b 08		 mov	 ecx, DWORD PTR [eax]
  00108	84 59 04	 test	 BYTE PTR [ecx+4], bl
  0010b	0f 84 83 00 00
	00		 je	 $LN233@rbt_remove
  00111	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00114	c7 02 04 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ?tree@@3Urbtree_t@@A+4
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
$LN260@rbt_remove:
  00121	83 7e fc 00	 cmp	 DWORD PTR [esi-4], 0
  00125	7d 09		 jge	 SHORT $LN253@rbt_remove
  00127	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  0012a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012c	89 0a		 mov	 DWORD PTR [edx], ecx
  0012e	eb d6		 jmp	 SHORT $LN234@rbt_remove
$LN253@rbt_remove:
  00130	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  00133	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00136	23 d3		 and	 edx, ebx
  00138	0b 16		 or	 edx, DWORD PTR [esi]
  0013a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0013d	eb c7		 jmp	 SHORT $LN234@rbt_remove
$LN273@rbt_remove:
  0013f	8b 12		 mov	 edx, DWORD PTR [edx]
  00141	81 fa 04 00 00
	00		 cmp	 edx, OFFSET ?tree@@3Urbtree_t@@A+4
  00147	74 30		 je	 SHORT $LN249@rbt_remove
  00149	83 62 04 fe	 and	 DWORD PTR [edx+4], -2	; fffffffeH
$LN75@rbt_remove:
  0014d	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00153	3b c1		 cmp	 eax, ecx
  00155	0f 85 1b 01 00
	00		 jne	 $LN245@rbt_remove
  0015b	89 15 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, edx
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
$LN238@rbt_remove:
  00168	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016b	23 cb		 and	 ecx, ebx
  0016d	0b ca		 or	 ecx, edx
  0016f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
$LN249@rbt_remove:
  00179	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  0017f	3b c2		 cmp	 eax, edx
  00181	75 83		 jne	 SHORT $LN234@rbt_remove
  00183	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, OFFSET ?tree@@3Urbtree_t@@A+4
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5b		 pop	 ebx
  00190	8b e5		 mov	 esp, ebp
  00192	5d		 pop	 ebp
  00193	c3		 ret	 0
$LN233@rbt_remove:
  00194	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  0019a	83 e8 08	 sub	 eax, 8
  0019d	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  001a3	3b c1		 cmp	 eax, ecx
  001a5	72 77		 jb	 SHORT $LN227@rbt_remove
$LN229@rbt_remove:
  001a7	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  001ab	8b 10		 mov	 edx, DWORD PTR [eax]
  001ad	7d 32		 jge	 SHORT $LN128@rbt_remove
  001af	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001b2	89 0a		 mov	 DWORD PTR [edx], ecx
  001b4	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001b7	84 cb		 test	 cl, bl
  001b9	75 75		 jne	 SHORT $LN293@rbt_remove
  001bb	83 e1 fe	 and	 ecx, -2			; fffffffeH
  001be	8b 31		 mov	 esi, DWORD PTR [ecx]
  001c0	84 5e 04	 test	 BYTE PTR [esi+4], bl
  001c3	0f 85 c3 00 00
	00		 jne	 $LN294@rbt_remove
  001c9	09 5a 04	 or	 DWORD PTR [edx+4], ebx
  001cc	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001cf	8b f1		 mov	 esi, ecx
  001d1	83 e6 fe	 and	 esi, -2			; fffffffeH
  001d4	23 cb		 and	 ecx, ebx
  001d6	0b 0e		 or	 ecx, DWORD PTR [esi]
  001d8	89 30		 mov	 DWORD PTR [eax], esi
  001da	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001dd	89 16		 mov	 DWORD PTR [esi], edx
  001df	eb 30		 jmp	 SHORT $LN1@rbt_remove
$LN128@rbt_remove:
  001e1	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001e4	23 cb		 and	 ecx, ebx
  001e6	0b 48 08	 or	 ecx, DWORD PTR [eax+8]
  001e9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001ec	8b 32		 mov	 esi, DWORD PTR [edx]
  001ee	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  001f1	84 d3		 test	 dl, bl
  001f3	0f 85 ff 00 00
	00		 jne	 $LN295@rbt_remove
  001f9	84 cb		 test	 cl, bl
  001fb	0f 85 6d 01 00
	00		 jne	 $LN296@rbt_remove
  00201	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00203	84 59 04	 test	 BYTE PTR [ecx+4], bl
  00206	0f 85 c2 01 00
	00		 jne	 $LN297@rbt_remove
  0020c	0b d3		 or	 edx, ebx
  0020e	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN1@rbt_remove:
  00211	83 e8 08	 sub	 eax, 8
  00214	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  0021a	3b c2		 cmp	 eax, edx
  0021c	73 89		 jae	 SHORT $LN229@rbt_remove
$LN227@rbt_remove:
  0021e	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  00224	a3 00 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, eax
  00229	5f		 pop	 edi
  0022a	5e		 pop	 esi
  0022b	5b		 pop	 ebx
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
$LN293@rbt_remove:
  00230	8b ca		 mov	 ecx, edx
  00232	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00235	83 e2 fe	 and	 edx, -2			; fffffffeH
  00238	8b 32		 mov	 esi, DWORD PTR [edx]
  0023a	84 5e 04	 test	 BYTE PTR [esi+4], bl
  0023d	74 26		 je	 SHORT $LN195@rbt_remove
  0023f	83 61 04 fe	 and	 DWORD PTR [ecx+4], -2	; fffffffeH
  00243	8b 32		 mov	 esi, DWORD PTR [edx]
  00245	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00248	83 e7 fe	 and	 edi, -2			; fffffffeH
  0024b	89 3a		 mov	 DWORD PTR [edx], edi
  0024d	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00250	23 fb		 and	 edi, ebx
  00252	0b fa		 or	 edi, edx
  00254	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00257	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0025a	23 d3		 and	 edx, ebx
  0025c	0b d6		 or	 edx, esi
  0025e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00261	8b f2		 mov	 esi, edx
  00263	eb 03		 jmp	 SHORT $LN304@rbt_remove
$LN195@rbt_remove:
  00265	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
$LN304@rbt_remove:
  00268	8b d6		 mov	 edx, esi
  0026a	83 e2 fe	 and	 edx, -2			; fffffffeH
  0026d	23 f3		 and	 esi, ebx
  0026f	0b 32		 or	 esi, DWORD PTR [edx]
  00271	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00274	89 0a		 mov	 DWORD PTR [edx], ecx
$LN245@rbt_remove:
  00276	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  0027a	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0027d	0f 8d e5 fe ff
	ff		 jge	 $LN238@rbt_remove
  00283	89 10		 mov	 DWORD PTR [eax], edx
  00285	5f		 pop	 edi
  00286	5e		 pop	 esi
  00287	5b		 pop	 ebx
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
$LN294@rbt_remove:
  0028c	83 66 04 fe	 and	 DWORD PTR [esi+4], -2	; fffffffeH
  00290	8b 31		 mov	 esi, DWORD PTR [ecx]
  00292	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00295	83 e2 fe	 and	 edx, -2			; fffffffeH
  00298	89 11		 mov	 DWORD PTR [ecx], edx
  0029a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0029d	23 d3		 and	 edx, ebx
  0029f	0b d1		 or	 edx, ecx
  002a1	89 56 04	 mov	 DWORD PTR [esi+4], edx
  002a4	8b 10		 mov	 edx, DWORD PTR [eax]
  002a6	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  002a9	23 cb		 and	 ecx, ebx
  002ab	0b ce		 or	 ecx, esi
  002ad	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002b0	8b f1		 mov	 esi, ecx
  002b2	83 e6 fe	 and	 esi, -2			; fffffffeH
  002b5	23 cb		 and	 ecx, ebx
  002b7	0b 0e		 or	 ecx, DWORD PTR [esi]
  002b9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002bc	89 16		 mov	 DWORD PTR [esi], edx
  002be	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  002c4	3b c2		 cmp	 eax, edx
  002c6	75 0d		 jne	 SHORT $LN152@rbt_remove
  002c8	89 35 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, esi
  002ce	5f		 pop	 edi
  002cf	5e		 pop	 esi
  002d0	5b		 pop	 ebx
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c3		 ret	 0
$LN152@rbt_remove:
  002d5	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  002d9	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  002dc	7d 09		 jge	 SHORT $LN145@rbt_remove
  002de	89 30		 mov	 DWORD PTR [eax], esi
  002e0	5f		 pop	 edi
  002e1	5e		 pop	 esi
  002e2	5b		 pop	 ebx
  002e3	8b e5		 mov	 esp, ebp
  002e5	5d		 pop	 ebp
  002e6	c3		 ret	 0
$LN145@rbt_remove:
  002e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ea	23 cb		 and	 ecx, ebx
  002ec	0b ce		 or	 ecx, esi
  002ee	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  002f1	5f		 pop	 edi
  002f2	5e		 pop	 esi
  002f3	5b		 pop	 ebx
  002f4	8b e5		 mov	 esp, ebp
  002f6	5d		 pop	 ebp
  002f7	c3		 ret	 0
$LN295@rbt_remove:
  002f8	8b f2		 mov	 esi, edx
  002fa	83 e6 fe	 and	 esi, -2			; fffffffeH
  002fd	8b 16		 mov	 edx, DWORD PTR [esi]
  002ff	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00302	84 cb		 test	 cl, bl
  00304	74 4e		 je	 SHORT $LN89@rbt_remove
  00306	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00309	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0030c	8b 10		 mov	 edx, DWORD PTR [eax]
  0030e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00310	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00313	83 e6 fe	 and	 esi, -2			; fffffffeH
  00316	89 32		 mov	 DWORD PTR [edx], esi
  00318	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0031b	23 f3		 and	 esi, ebx
  0031d	0b f2		 or	 esi, edx
  0031f	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00322	8b 32		 mov	 esi, DWORD PTR [edx]
  00324	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00327	83 e7 fe	 and	 edi, -2			; fffffffeH
  0032a	89 3a		 mov	 DWORD PTR [edx], edi
  0032c	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0032f	23 fb		 and	 edi, ebx
  00331	0b fa		 or	 edi, edx
  00333	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00336	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00339	23 d3		 and	 edx, ebx
  0033b	0b d6		 or	 edx, esi
  0033d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00340	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00343	83 e2 fe	 and	 edx, -2			; fffffffeH
  00346	23 f3		 and	 esi, ebx
  00348	0b 32		 or	 esi, DWORD PTR [edx]
  0034a	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0034d	89 0a		 mov	 DWORD PTR [edx], ecx
  0034f	e9 f9 fd ff ff	 jmp	 $LN75@rbt_remove
$LN89@rbt_remove:
  00354	09 5e 04	 or	 DWORD PTR [esi+4], ebx
  00357	8b 08		 mov	 ecx, DWORD PTR [eax]
  00359	8b 11		 mov	 edx, DWORD PTR [ecx]
  0035b	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0035e	83 e6 fe	 and	 esi, -2			; fffffffeH
  00361	89 31		 mov	 DWORD PTR [ecx], esi
  00363	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00366	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00369	e9 df fd ff ff	 jmp	 $LN75@rbt_remove
$LN296@rbt_remove:
  0036e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00370	84 5f 04	 test	 BYTE PTR [edi+4], bl
  00373	74 49		 je	 SHORT $LN34@rbt_remove
  00375	8b 10		 mov	 edx, DWORD PTR [eax]
  00377	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0037a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0037d	09 5e 04	 or	 DWORD PTR [esi+4], ebx
  00380	83 67 04 fe	 and	 DWORD PTR [edi+4], -2	; fffffffeH
  00384	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00386	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00389	83 e6 fe	 and	 esi, -2			; fffffffeH
  0038c	89 32		 mov	 DWORD PTR [edx], esi
  0038e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00391	23 f3		 and	 esi, ebx
  00393	0b f2		 or	 esi, edx
  00395	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  00399	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0039c	7d 0c		 jge	 SHORT $LN38@rbt_remove
  0039e	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  003a1	89 0a		 mov	 DWORD PTR [edx], ecx
  003a3	5f		 pop	 edi
  003a4	5e		 pop	 esi
  003a5	5b		 pop	 ebx
  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c3		 ret	 0
$LN38@rbt_remove:
  003aa	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
$LN7@rbt_remove:
  003ad	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003b0	23 d3		 and	 edx, ebx
  003b2	0b d1		 or	 edx, ecx
  003b4	89 50 04	 mov	 DWORD PTR [eax+4], edx
  003b7	5f		 pop	 edi
  003b8	5e		 pop	 esi
  003b9	5b		 pop	 ebx
  003ba	8b e5		 mov	 esp, ebp
  003bc	5d		 pop	 ebp
  003bd	c3		 ret	 0
$LN34@rbt_remove:
  003be	8b 00		 mov	 eax, DWORD PTR [eax]
  003c0	09 5e 04	 or	 DWORD PTR [esi+4], ebx
  003c3	83 60 04 fe	 and	 DWORD PTR [eax+4], -2	; fffffffeH
  003c7	5f		 pop	 edi
  003c8	5e		 pop	 esi
  003c9	5b		 pop	 ebx
  003ca	8b e5		 mov	 esp, ebp
  003cc	5d		 pop	 ebp
  003cd	c3		 ret	 0
$LN297@rbt_remove:
  003ce	83 61 04 fe	 and	 DWORD PTR [ecx+4], -2	; fffffffeH
  003d2	8b 10		 mov	 edx, DWORD PTR [eax]
  003d4	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003d6	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  003d9	83 e6 fe	 and	 esi, -2			; fffffffeH
  003dc	89 32		 mov	 DWORD PTR [edx], esi
  003de	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  003e1	23 f3		 and	 esi, ebx
  003e3	0b f2		 or	 esi, edx
  003e5	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  003eb	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  003ee	3b c2		 cmp	 eax, edx
  003f0	75 0d		 jne	 SHORT $LN14@rbt_remove
  003f2	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, ecx
  003f8	5f		 pop	 edi
  003f9	5e		 pop	 esi
  003fa	5b		 pop	 ebx
  003fb	8b e5		 mov	 esp, ebp
  003fd	5d		 pop	 ebp
  003fe	c3		 ret	 0
$LN14@rbt_remove:
  003ff	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  00403	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  00406	7d a5		 jge	 SHORT $LN7@rbt_remove
  00408	5f		 pop	 edi
  00409	5e		 pop	 esi
  0040a	89 08		 mov	 DWORD PTR [eax], ecx
  0040c	5b		 pop	 ebx
  0040d	8b e5		 mov	 esp, ebp
  0040f	5d		 pop	 ebp
  00410	c3		 ret	 0
?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ENDP	; rbt_remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z
_TEXT	SEGMENT
_path$ = -512						; size = 512
?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z PROC	; rbt_insert, COMDAT
; _node$ = eax

; 275  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f8		 mov	 edi, eax
  0000e	b8 04 00 00 00	 mov	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00013	83 c8 01	 or	 eax, 1
  00016	c7 07 04 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ?tree@@3Urbtree_t@@A+4
  0001c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A
  00024	89 85 00 fe ff
	ff		 mov	 DWORD PTR _path$[ebp], eax
  0002a	8d b5 00 fe ff
	ff		 lea	 esi, DWORD PTR _path$[ebp]
  00030	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00035	74 41		 je	 SHORT $LN60@rbt_insert
  00037	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL62@rbt_insert:
  00040	8b 16		 mov	 edx, DWORD PTR [esi]
  00042	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00045	3b c8		 cmp	 ecx, eax
  00047	7d 05		 jge	 SHORT $LN78@rbt_insert
  00049	83 c8 ff	 or	 eax, -1
  0004c	eb 09		 jmp	 SHORT $LN77@rbt_insert
$LN78@rbt_insert:
  0004e	33 d2		 xor	 edx, edx
  00050	3b c8		 cmp	 ecx, eax
  00052	0f 9f c2	 setg	 dl
  00055	8b c2		 mov	 eax, edx
$LN77@rbt_insert:
  00057	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005a	85 c0		 test	 eax, eax
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	79 04		 jns	 SHORT $LN59@rbt_insert
  00060	8b 10		 mov	 edx, DWORD PTR [eax]
  00062	eb 06		 jmp	 SHORT $LN86@rbt_insert
$LN59@rbt_insert:
  00064	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00067	83 e2 fe	 and	 edx, -2			; fffffffeH
$LN86@rbt_insert:
  0006a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006d	83 c6 08	 add	 esi, 8
  00070	81 3e 04 00 00
	00		 cmp	 DWORD PTR [esi], OFFSET ?tree@@3Urbtree_t@@A+4
  00076	75 c8		 jne	 SHORT $LL62@rbt_insert
$LN60@rbt_insert:
  00078	89 3e		 mov	 DWORD PTR [esi], edi
  0007a	83 ee 08	 sub	 esi, 8
  0007d	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00083	3b f0		 cmp	 esi, eax
  00085	0f 82 a1 00 00
	00		 jb	 $LN55@rbt_insert
$LN57@rbt_insert:
  0008b	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0008f	8b 06		 mov	 eax, DWORD PTR [esi]
  00091	7d 36		 jge	 SHORT $LN54@rbt_insert
  00093	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00096	89 08		 mov	 DWORD PTR [eax], ecx
  00098	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  0009c	0f 84 99 00 00
	00		 je	 $LN1@rbt_insert
  000a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a4	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000a7	f6 c1 01	 test	 cl, 1
  000aa	74 6d		 je	 SHORT $LN20@rbt_insert
  000ac	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000af	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b7	83 e2 fe	 and	 edx, -2			; fffffffeH
  000ba	89 10		 mov	 DWORD PTR [eax], edx
  000bc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000bf	83 e2 01	 and	 edx, 1
  000c2	0b d0		 or	 edx, eax
  000c4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000c7	eb 4e		 jmp	 SHORT $LN87@rbt_insert
$LN54@rbt_insert:
  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  000cf	83 e1 01	 and	 ecx, 1
  000d2	0b cf		 or	 ecx, edi
  000d4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000d7	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  000db	74 5e		 je	 SHORT $LN1@rbt_insert
  000dd	8b 18		 mov	 ebx, DWORD PTR [eax]
  000df	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000e2	f6 c2 01	 test	 dl, 1
  000e5	74 10		 je	 SHORT $LN30@rbt_insert
  000e7	83 e2 fe	 and	 edx, -2			; fffffffeH
  000ea	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000ed	83 67 04 fe	 and	 DWORD PTR [edi+4], -2	; fffffffeH
  000f1	83 48 04 01	 or	 DWORD PTR [eax+4], 1
  000f5	eb 22		 jmp	 SHORT $LN20@rbt_insert
$LN30@rbt_insert:
  000f7	8b d1		 mov	 edx, ecx
  000f9	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000fc	8b 39		 mov	 edi, DWORD PTR [ecx]
  000fe	83 e2 01	 and	 edx, 1
  00101	0b fa		 or	 edi, edx
  00103	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00106	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00109	83 e7 fe	 and	 edi, -2			; fffffffeH
  0010c	0b fa		 or	 edi, edx
  0010e	89 01		 mov	 DWORD PTR [ecx], eax
  00110	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00113	83 48 04 01	 or	 DWORD PTR [eax+4], 1
$LN87@rbt_insert:
  00117	8b c1		 mov	 eax, ecx
$LN20@rbt_insert:
  00119	89 06		 mov	 DWORD PTR [esi], eax
  0011b	83 ee 08	 sub	 esi, 8
  0011e	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00124	3b f0		 cmp	 esi, eax
  00126	0f 83 5f ff ff
	ff		 jae	 $LN57@rbt_insert
$LN55@rbt_insert:
  0012c	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  00132	a3 00 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, eax
  00137	83 60 04 fe	 and	 DWORD PTR [eax+4], -2	; fffffffeH
$LN1@rbt_insert:
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ENDP	; rbt_insert
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_search@@YAPAUrbt_object@@PAUrbtree_t@@PAU1@@Z
_TEXT	SEGMENT
?rbt_search@@YAPAUrbt_object@@PAUrbtree_t@@PAU1@@Z PROC	; rbt_search, COMDAT
; _key$ = ecx

; 275  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A
  00005	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  0000a	74 28		 je	 SHORT $LN15@rbt_search
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	90		 npad	 1
$LL5@rbt_search:
  00010	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00013	3b d1		 cmp	 edx, ecx
  00015	7c 12		 jl	 SHORT $LN14@rbt_search
  00017	7e 14		 jle	 SHORT $LN8@rbt_search
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	83 e0 fe	 and	 eax, -2			; fffffffeH
$LN2@rbt_search:
  0001f	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00024	75 ea		 jne	 SHORT $LL5@rbt_search
  00026	33 c0		 xor	 eax, eax
  00028	c3		 ret	 0
$LN14@rbt_search:
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	eb f2		 jmp	 SHORT $LN2@rbt_search
$LN8@rbt_search:
  0002d	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00032	75 02		 jne	 SHORT $LN1@rbt_search
$LN15@rbt_search:
  00034	33 c0		 xor	 eax, eax
$LN1@rbt_search:
  00036	c3		 ret	 0
?rbt_search@@YAPAUrbt_object@@PAUrbtree_t@@PAU1@@Z ENDP	; rbt_search
_TEXT	ENDS
PUBLIC	?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z		; judy_splitspan
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z
_TEXT	SEGMENT
_node$ = -4						; size = 4
_judy$ = 8						; size = 4
_cnt$ = 12						; size = 4
_base$ = 12						; size = 4
?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z PROC		; judy_splitspan, COMDAT
; _next$ = eax

; 1262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _base$[ebp]
  00008	56		 push	 esi
  00009	8b f0		 mov	 esi, eax

; 1263 : JudySlot *node = (JudySlot *)(base + JudySize[JUDY_span]);

  0000b	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?JudySize@@3PAHA+28
  00010	03 c3		 add	 eax, ebx
  00012	57		 push	 edi
  00013	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 1264 : uint cnt = JUDY_span_bytes;

  00016	c7 45 0c 1c 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 28 ; 0000001cH

; 1265 : uchar *newbase;
; 1266 : uint off = 0;

  0001d	33 ff		 xor	 edi, edi
  0001f	90		 npad	 1
$LL6@judy_split:

; 1267 : #if BYTE_ORDER != BIG_ENDIAN
; 1268 : int i;
; 1269 : #endif
; 1270 : 
; 1271 : 	do {
; 1272 : 		newbase = (uchar*)judy_alloc (judy, JUDY_1);

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  00023	51		 push	 ecx
  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1273 : 		*next = (JudySlot)newbase | JUDY_1;

  0002e	8b d0		 mov	 edx, eax
  00030	83 c4 04	 add	 esp, 4
  00033	83 ca 01	 or	 edx, 1
  00036	89 16		 mov	 DWORD PTR [esi], edx

; 1274 : 
; 1275 : #if BYTE_ORDER != BIG_ENDIAN
; 1276 : 		i = JUDY_key_size;

  00038	b9 04 00 00 00	 mov	 ecx, 4

; 1277 : 		while( i-- )

  0003d	8d 34 1f	 lea	 esi, DWORD PTR [edi+ebx]
$LL3@judy_split:

; 1278 : 			*newbase++ = base[off + i];

  00040	8a 54 0e ff	 mov	 dl, BYTE PTR [esi+ecx-1]
  00044	49		 dec	 ecx
  00045	88 10		 mov	 BYTE PTR [eax], dl
  00047	40		 inc	 eax
  00048	85 c9		 test	 ecx, ecx
  0004a	75 f4		 jne	 SHORT $LL3@judy_split

; 1279 : #else
; 1280 : 		memcpy (newbase, base + off, JUDY_key_size);
; 1281 : 		newbase += JUDY_key_size;
; 1282 : #endif
; 1283 : 		next = (JudySlot *)newbase;
; 1284 : 
; 1285 : 		off += JUDY_key_size;

  0004c	83 c7 04	 add	 edi, 4

; 1286 : 		cnt -= JUDY_key_size;

  0004f	83 6d 0c 04	 sub	 DWORD PTR _cnt$[ebp], 4
  00053	8b f0		 mov	 esi, eax

; 1287 : 	} while( cnt && base[off - 1] );

  00055	74 06		 je	 SHORT $LN1@judy_split
  00057	38 4c 1f ff	 cmp	 BYTE PTR [edi+ebx-1], cl
  0005b	75 c3		 jne	 SHORT $LL6@judy_split
$LN1@judy_split:

; 1288 : 
; 1289 : 	*next = node[-1];

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  00060	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00063	89 10		 mov	 DWORD PTR [eax], edx

; 1290 : 	judy_free (judy, base, JUDY_span);

  00065	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  00068	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0006b	5f		 pop	 edi
  0006c	89 0b		 mov	 DWORD PTR [ebx], ecx
  0006e	5e		 pop	 esi
  0006f	89 58 10	 mov	 DWORD PTR [eax+16], ebx
  00072	5b		 pop	 ebx

; 1291 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z ENDP		; judy_splitspan
_TEXT	ENDS
PUBLIC	?judy_prv@@YAPAIPAUJudy@@@Z			; judy_prv
; Function compile flags: /Ogtp
;	COMDAT ?judy_prv@@YAPAIPAUJudy@@@Z
_TEXT	SEGMENT
_node$ = -12						; size = 4
_depth$ = -8						; size = 4
_off$ = -4						; size = 4
?judy_prv@@YAPAIPAUJudy@@@Z PROC			; judy_prv, COMDAT
; _judy$ = ecx

; 1074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1075 : int slot, size, keysize;
; 1076 : JudySlot *table, *inner;
; 1077 : JudySlot *node, next;
; 1078 : uchar *base;
; 1079 : uint depth;
; 1080 : uint off;
; 1081 : 
; 1082 : 	if( !judy->level )

  00006	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0000a	75 12		 jne	 SHORT $LN42@judy_prv

; 1083 : 		return judy_last (judy, *judy->root, 0, 0);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	e8 00 00 00 00	 call	 ?judy_last@@YAPAIPAUJudy@@III@Z ; judy_last
  00017	83 c4 08	 add	 esp, 8

; 1148 : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN42@judy_prv:
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
$LL22@judy_prv:

; 1086 : 		next = judy->stack[judy->level].next;

  00021	8b 79 28	 mov	 edi, DWORD PTR [ecx+40]
  00024	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00027	8b 74 81 34	 mov	 esi, DWORD PTR [ecx+eax*4+52]
  0002b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1087 : 		slot = judy->stack[judy->level].slot;
; 1088 : 		off = judy->stack[judy->level].off;

  0002e	8b 40 38	 mov	 eax, DWORD PTR [eax+56]

; 1089 : 		size = JudySize[next & 0x07];
; 1090 : 		depth = off / JUDY_key_size;

  00031	8b d8		 mov	 ebx, eax
  00033	89 45 fc	 mov	 DWORD PTR _off$[ebp], eax

; 1091 : 
; 1092 : 		switch( next & 0x07 ) {

  00036	8b c6		 mov	 eax, esi
  00038	c1 eb 02	 shr	 ebx, 2
  0003b	83 e0 07	 and	 eax, 7
  0003e	8d 54 7f 0f	 lea	 edx, DWORD PTR [edi+edi*2+15]
  00042	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00045	89 5d f8	 mov	 DWORD PTR _depth$[ebp], ebx
  00048	83 f8 07	 cmp	 eax, 7
  0004b	77 2c		 ja	 SHORT $LN41@judy_prv
  0004d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN49@judy_prv[eax*4]
$LN18@judy_prv:

; 1093 : 		case JUDY_1:
; 1094 : 		case JUDY_2:
; 1095 : 		case JUDY_4:
; 1096 : 		case JUDY_8:
; 1097 : 		case JUDY_16:
; 1098 : 		case JUDY_32:
; 1099 : #ifdef ASKITIS
; 1100 : 		case JUDY_64:
; 1101 : #endif
; 1102 : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00054	8b de		 mov	 ebx, esi
  00056	83 e3 f8	 and	 ebx, -8			; fffffff8H
  00059	03 1c 85 00 00
	00 00		 add	 ebx, DWORD PTR ?JudySize@@3PAHA[eax*4]
  00060	89 5d f4	 mov	 DWORD PTR _node$[ebp], ebx

; 1103 : 			if( !slot || !node[-slot] ) {

  00063	85 d2		 test	 edx, edx
  00065	74 0e		 je	 SHORT $LN1@judy_prv
  00067	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  0006e	2b d8		 sub	 ebx, eax
  00070	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00073	75 5a		 jne	 SHORT $LN17@judy_prv
$LN1@judy_prv:

; 1139 : 
; 1140 : #ifndef ASKITIS
; 1141 : 		case JUDY_span:
; 1142 : 			judy->level--;

  00075	4f		 dec	 edi
  00076	89 79 28	 mov	 DWORD PTR [ecx+40], edi
$LN41@judy_prv:

; 1084 : 	
; 1085 : 	while( judy->level ) {

  00079	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0007d	75 a2		 jne	 SHORT $LL22@judy_prv

; 1143 : 			continue;
; 1144 : #endif
; 1145 : 		}
; 1146 : 	}
; 1147 : 	return NULL;

  0007f	33 c0		 xor	 eax, eax
$LN44@judy_prv:
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 1148 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN12@judy_prv:

; 1119 : 
; 1120 : 		case JUDY_radix:
; 1121 : 			table = (JudySlot *)(next & JUDY_mask);

  00088	83 e6 f8	 and	 esi, -8			; fffffff8H

; 1122 : 
; 1123 : 			if( judy->depth )

  0008b	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0008f	74 09		 je	 SHORT $LN38@judy_prv

; 1124 : 			  if( !((off + 1) & JUDY_key_mask) )

  00091	8b 45 fc	 mov	 eax, DWORD PTR _off$[ebp]
  00094	40		 inc	 eax
  00095	a8 03		 test	 al, 3
  00097	75 01		 jne	 SHORT $LN38@judy_prv

; 1125 : 				depth++;

  00099	43		 inc	 ebx
$LN38@judy_prv:

; 1126 : 
; 1127 : 			while( slot-- ) {

  0009a	85 d2		 test	 edx, edx
  0009c	74 2c		 je	 SHORT $LN40@judy_prv
  0009e	8b ff		 npad	 2
$LL9@judy_prv:

; 1128 : 			  judy->stack[judy->level].slot--;

  000a0	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  000a3	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  000a7	ff 0c 81	 dec	 DWORD PTR [ecx+eax*4]
  000aa	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000ad	4a		 dec	 edx

; 1129 : 			  if( (inner = (JudySlot *)(table[slot >> 4] & JUDY_mask)) )

  000ae	8b c2		 mov	 eax, edx
  000b0	c1 f8 04	 sar	 eax, 4
  000b3	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000b6	83 e0 f8	 and	 eax, -8			; fffffff8H
  000b9	74 0b		 je	 SHORT $LN2@judy_prv

; 1130 : 				if( inner[slot & 0x0F] )

  000bb	8b fa		 mov	 edi, edx
  000bd	83 e7 0f	 and	 edi, 15			; 0000000fH
  000c0	83 3c b8 00	 cmp	 DWORD PTR [eax+edi*4], 0
  000c4	75 7c		 jne	 SHORT $LN31@judy_prv
$LN2@judy_prv:

; 1126 : 
; 1127 : 			while( slot-- ) {

  000c6	85 d2		 test	 edx, edx
  000c8	75 d6		 jne	 SHORT $LL9@judy_prv
$LN40@judy_prv:

; 1135 : 			}
; 1136 : 
; 1137 : 			judy->level--;

  000ca	ff 49 28	 dec	 DWORD PTR [ecx+40]

; 1138 : 			continue;

  000cd	eb aa		 jmp	 SHORT $LN41@judy_prv
$LN17@judy_prv:

; 1104 : 				judy->level--;
; 1105 : 				continue;
; 1106 : 			}
; 1107 : 
; 1108 : 			base = (uchar *)(next & JUDY_mask);
; 1109 : 			judy->stack[judy->level].slot--;

  000cf	8b c7		 mov	 eax, edi
  000d1	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  000d5	ff 0c 81	 dec	 DWORD PTR [ecx+eax*4]
  000d8	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1111 : 
; 1112 : #if BYTE_ORDER != BIG_ENDIAN
; 1113 : 			if( !judy->depth && !base[(slot - 1) * keysize] || judy->depth && ++depth == judy->depth )

  000db	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  000de	85 c0		 test	 eax, eax
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _off$[ebp]
  000e3	75 1b		 jne	 SHORT $LN37@judy_prv

; 1110 : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  000e5	8b f8		 mov	 edi, eax
  000e7	83 e7 03	 and	 edi, 3
  000ea	bb 04 00 00 00	 mov	 ebx, 4
  000ef	2b df		 sub	 ebx, edi

; 1111 : 
; 1112 : #if BYTE_ORDER != BIG_ENDIAN
; 1113 : 			if( !judy->depth && !base[(slot - 1) * keysize] || judy->depth && ++depth == judy->depth )

  000f1	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
  000f4	0f af df	 imul	 ebx, edi
  000f7	83 e6 f8	 and	 esi, -8			; fffffff8H
  000fa	80 3c 33 00	 cmp	 BYTE PTR [ebx+esi], 0
  000fe	74 0f		 je	 SHORT $LN14@judy_prv
$LN37@judy_prv:
  00100	8b 79 30	 mov	 edi, DWORD PTR [ecx+48]
  00103	8b 75 f8	 mov	 esi, DWORD PTR _depth$[ebp]
  00106	85 ff		 test	 edi, edi
  00108	74 18		 je	 SHORT $LN15@judy_prv
  0010a	46		 inc	 esi
  0010b	3b f7		 cmp	 esi, edi
  0010d	75 13		 jne	 SHORT $LN15@judy_prv
$LN14@judy_prv:

; 1114 : #else
; 1115 : 			if( !judy->depth && !base[(slot - 1) * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
; 1116 : #endif
; 1117 : 				return &node[-slot];

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00112	5f		 pop	 edi
  00113	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*4]
  0011a	5e		 pop	 esi
  0011b	2b c1		 sub	 eax, ecx
  0011d	5b		 pop	 ebx

; 1148 : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN15@judy_prv:

; 1118 : 			return judy_last (judy, node[-slot], (off | JUDY_key_mask) + 1, depth);

  00122	83 c8 03	 or	 eax, 3
  00125	40		 inc	 eax
  00126	56		 push	 esi
  00127	50		 push	 eax
  00128	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0012b	03 d2		 add	 edx, edx
  0012d	03 d2		 add	 edx, edx
  0012f	2b c2		 sub	 eax, edx
  00131	8b 00		 mov	 eax, DWORD PTR [eax]
  00133	e8 00 00 00 00	 call	 ?judy_last@@YAPAIPAUJudy@@III@Z ; judy_last
  00138	83 c4 08	 add	 esp, 8
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 1148 : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN31@judy_prv:

; 1131 : 				  if( !judy->depth && !slot || judy->depth && depth == judy->depth )

  00142	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  00145	85 f6		 test	 esi, esi
  00147	75 0c		 jne	 SHORT $LN48@judy_prv
  00149	85 d2		 test	 edx, edx
  0014b	0f 84 30 ff ff
	ff		 je	 $LN44@judy_prv
  00151	85 f6		 test	 esi, esi
  00153	74 08		 je	 SHORT $LN5@judy_prv
$LN48@judy_prv:
  00155	3b de		 cmp	 ebx, esi

; 1132 : 					return &inner[0];

  00157	0f 84 24 ff ff
	ff		 je	 $LN44@judy_prv
$LN5@judy_prv:

; 1133 : 				  else
; 1134 : 				    return judy_last(judy, inner[slot & 0x0F], off + 1, depth);

  0015d	8b 75 fc	 mov	 esi, DWORD PTR _off$[ebp]
  00160	83 e2 0f	 and	 edx, 15			; 0000000fH
  00163	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00166	53		 push	 ebx
  00167	46		 inc	 esi
  00168	56		 push	 esi
  00169	e8 00 00 00 00	 call	 ?judy_last@@YAPAIPAUJudy@@III@Z ; judy_last
  0016e	83 c4 08	 add	 esp, 8
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx

; 1148 : }

  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
$LN49@judy_prv:
  00178	00 00 00 00	 DD	 $LN12@judy_prv
  0017c	00 00 00 00	 DD	 $LN18@judy_prv
  00180	00 00 00 00	 DD	 $LN18@judy_prv
  00184	00 00 00 00	 DD	 $LN18@judy_prv
  00188	00 00 00 00	 DD	 $LN18@judy_prv
  0018c	00 00 00 00	 DD	 $LN18@judy_prv
  00190	00 00 00 00	 DD	 $LN18@judy_prv
  00194	00 00 00 00	 DD	 $LN1@judy_prv
?judy_prv@@YAPAIPAUJudy@@@Z ENDP			; judy_prv
_TEXT	ENDS
PUBLIC	?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z		; judy_radix
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z
_TEXT	SEGMENT
_base$ = -20						; size = 4
tv526 = -16						; size = 4
tv257 = -16						; size = 4
_cnt$ = -12						; size = 4
_oldnode$ = -8						; size = 4
tv524 = -4						; size = 4
_table$ = -4						; size = 4
tv449 = 8						; size = 4
_judy$ = 8						; size = 4
_old$ = 12						; size = 4
tv588 = 16						; size = 4
_start$ = 16						; size = 4
tv520 = 20						; size = 4
_size$ = 20						; size = 4
_key$ = 20						; size = 1
_depth$ = 24						; size = 4
?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z PROC		; judy_radix, COMDAT
; _radix$ = edx
; _slot$ = eax
; _keysize$ = edi

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 728  : int size, idx, cnt = slot - start, newcnt;

  00006	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]

; 729  : JudySlot *node, *oldnode;
; 730  : uint type = JUDY_1 - 1;
; 731  : JudySlot *table;
; 732  : uchar *base;
; 733  : 
; 734  : 	//	if necessary, setup inner radix node
; 735  : 
; 736  : 	if( !(table = (JudySlot *)(radix[key >> 4] & JUDY_mask)) ) {

  00009	0f b6 4d 14	 movzx	 ecx, BYTE PTR _key$[ebp]
  0000d	89 45 f4	 mov	 DWORD PTR _cnt$[ebp], eax
  00010	53		 push	 ebx
  00011	8b c1		 mov	 eax, ecx
  00013	c1 e8 04	 shr	 eax, 4
  00016	56		 push	 esi
  00017	8d 34 82	 lea	 esi, DWORD PTR [edx+eax*4]
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	33 db		 xor	 ebx, ebx
  0001e	83 e0 f8	 and	 eax, -8			; fffffff8H
  00021	89 4d f0	 mov	 DWORD PTR tv257[ebp], ecx
  00024	89 45 fc	 mov	 DWORD PTR _table$[ebp], eax
  00027	75 16		 jne	 SHORT $LN18@judy_radix

; 737  : 		table = (JudySlot*)judy_alloc (judy, JUDY_radix);

  00029	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  0002c	50		 push	 eax
  0002d	33 c9		 xor	 ecx, ecx
  0002f	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 738  : 		radix[key >> 4] = (JudySlot)table | JUDY_radix;

  00034	8b 4d f0	 mov	 ecx, DWORD PTR tv257[ebp]
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 fc	 mov	 DWORD PTR _table$[ebp], eax
  0003d	89 06		 mov	 DWORD PTR [esi], eax
$LN18@judy_radix:

; 739  : 	}
; 740  : 
; 741  : 	oldnode = (JudySlot *)(old + JudySize[JUDY_max]);

  0003f	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?JudySize@@3PAHA+24

; 742  : 
; 743  : 	// is this slot a leaf?
; 744  : 
; 745  : 	if( !judy->depth && (!key || !keysize) || judy->depth && !keysize && depth == judy->depth) {

  00045	8b 75 08	 mov	 esi, DWORD PTR _judy$[ebp]
  00048	03 55 0c	 add	 edx, DWORD PTR _old$[ebp]
  0004b	8b 76 30	 mov	 esi, DWORD PTR [esi+48]
  0004e	89 55 f8	 mov	 DWORD PTR _oldnode$[ebp], edx
  00051	85 f6		 test	 esi, esi
  00053	75 0d		 jne	 SHORT $LN21@judy_radix
  00055	38 5d 14	 cmp	 BYTE PTR _key$[ebp], bl
  00058	74 11		 je	 SHORT $LN9@judy_radix
  0005a	85 ff		 test	 edi, edi
  0005c	74 0d		 je	 SHORT $LN9@judy_radix
  0005e	85 f6		 test	 esi, esi
  00060	74 23		 je	 SHORT $LN14@judy_radix
$LN21@judy_radix:
  00062	85 ff		 test	 edi, edi
  00064	75 1f		 jne	 SHORT $LN14@judy_radix
  00066	39 75 18	 cmp	 DWORD PTR _depth$[ebp], esi
  00069	75 1a		 jne	 SHORT $LN14@judy_radix
$LN9@judy_radix:

; 746  : 		table[key & 0x0F] = oldnode[-start-1];

  0006b	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0006e	8d 34 b5 04 00
	00 00		 lea	 esi, DWORD PTR [esi*4+4]
  00075	2b d6		 sub	 edx, esi
  00077	8b 12		 mov	 edx, DWORD PTR [edx]
  00079	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0007c	5e		 pop	 esi
  0007d	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  00080	5b		 pop	 ebx

; 774  : 	}
; 775  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN14@judy_radix:
  00085	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00088	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL7@judy_radix:

; 747  : 		return;
; 748  : 	}
; 749  : 
; 750  : 	//	calculate new node big enough to contain slots
; 751  : 
; 752  : 	do {
; 753  : 		type++;
; 754  : 		size = JudySize[type];

  00090	8b 04 9d 04 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[ebx*4+4]
  00097	43		 inc	 ebx

; 755  : 		newcnt = size / (sizeof(JudySlot) + keysize);

  00098	33 d2		 xor	 edx, edx
  0009a	89 45 14	 mov	 DWORD PTR _size$[ebp], eax
  0009d	f7 f1		 div	 ecx
  0009f	8b f0		 mov	 esi, eax

; 756  : 	} while( cnt > newcnt && type < JUDY_max );

  000a1	39 75 f4	 cmp	 DWORD PTR _cnt$[ebp], esi
  000a4	7e 05		 jle	 SHORT $LN4@judy_radix
  000a6	83 fb 06	 cmp	 ebx, 6
  000a9	72 e5		 jb	 SHORT $LL7@judy_radix
$LN4@judy_radix:

; 757  : 
; 758  : 	//	store new node pointer in inner table
; 759  : 
; 760  : 	base = (uchar*)judy_alloc (judy, type);

  000ab	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  000ae	50		 push	 eax
  000af	8b cb		 mov	 ecx, ebx
  000b1	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 761  : 	node = (JudySlot *)(base + size);

  000b6	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  000b9	03 c8		 add	 ecx, eax

; 762  : 	table[key & 0x0F] = (JudySlot)base | type;

  000bb	8b d0		 mov	 edx, eax
  000bd	89 45 ec	 mov	 DWORD PTR _base$[ebp], eax
  000c0	8b 45 f0	 mov	 eax, DWORD PTR tv257[ebp]
  000c3	0b d3		 or	 edx, ebx
  000c5	8b 5d fc	 mov	 ebx, DWORD PTR _table$[ebp]
  000c8	83 e0 0f	 and	 eax, 15			; 0000000fH
  000cb	89 14 83	 mov	 DWORD PTR [ebx+eax*4], edx

; 763  : 
; 764  : 	//	allocate node and copy old contents
; 765  : 	//	shorten keys by 1 byte during copy
; 766  : 
; 767  : 	for( idx = 0; idx < cnt; idx++ ) {

  000ce	8b 5d f4	 mov	 ebx, DWORD PTR _cnt$[ebp]
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 db		 test	 ebx, ebx
  000d6	7e 76		 jle	 SHORT $LN1@judy_radix

; 757  : 
; 758  : 	//	store new node pointer in inner table
; 759  : 
; 760  : 	base = (uchar*)judy_alloc (judy, type);

  000d8	8b d7		 mov	 edx, edi
  000da	f7 da		 neg	 edx
  000dc	89 55 fc	 mov	 DWORD PTR tv524[ebp], edx
  000df	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000e2	8b d0		 mov	 edx, eax
  000e4	f7 da		 neg	 edx
  000e6	89 55 f0	 mov	 DWORD PTR tv526[ebp], edx
  000e9	8d 14 b5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*4]
  000f0	2b ca		 sub	 ecx, edx
  000f2	89 4d 08	 mov	 DWORD PTR tv449[ebp], ecx
  000f5	8b 4d 10	 mov	 ecx, DWORD PTR _start$[ebp]
  000f8	03 cb		 add	 ecx, ebx
  000fa	8b 5d f8	 mov	 ebx, DWORD PTR _oldnode$[ebp]
  000fd	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  00104	0f af c8	 imul	 ecx, eax
  00107	8b 45 0c	 mov	 eax, DWORD PTR _old$[ebp]
  0010a	4e		 dec	 esi
  0010b	0f af f7	 imul	 esi, edi
  0010e	03 75 ec	 add	 esi, DWORD PTR _base$[ebp]
  00111	2b da		 sub	 ebx, edx
  00113	8b 55 f4	 mov	 edx, DWORD PTR _cnt$[ebp]
  00116	2b cf		 sub	 ecx, edi
  00118	8d 4c 01 ff	 lea	 ecx, DWORD PTR [ecx+eax-1]
  0011c	89 4d 14	 mov	 DWORD PTR tv520[ebp], ecx
  0011f	89 55 10	 mov	 DWORD PTR tv588[ebp], edx
$LL17@judy_radix:

; 768  : #if BYTE_ORDER != BIG_ENDIAN
; 769  : 		memcpy (base + (newcnt - idx - 1) * keysize, old + (start + cnt - idx - 1) * (keysize + 1), keysize);

  00122	8b 45 14	 mov	 eax, DWORD PTR tv520[ebp]
  00125	57		 push	 edi
  00126	50		 push	 eax
  00127	56		 push	 esi
  00128	e8 00 00 00 00	 call	 _memcpy

; 770  : #else
; 771  : 		memcpy (base + (newcnt - idx - 1) * keysize, old + (start + cnt - idx - 1) * (keysize + 1) + 1, keysize);
; 772  : #endif
; 773  : 		node[-(newcnt - idx)] = oldnode[-(start + cnt - idx)];

  0012d	8b 45 08	 mov	 eax, DWORD PTR tv449[ebp]
  00130	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00132	8b 55 f0	 mov	 edx, DWORD PTR tv526[ebp]
  00135	01 55 14	 add	 DWORD PTR tv520[ebp], edx
  00138	03 75 fc	 add	 esi, DWORD PTR tv524[ebp]
  0013b	89 08		 mov	 DWORD PTR [eax], ecx
  0013d	83 c0 04	 add	 eax, 4
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
  00143	83 c3 04	 add	 ebx, 4
  00146	ff 4d 10	 dec	 DWORD PTR tv588[ebp]
  00149	89 45 08	 mov	 DWORD PTR tv449[ebp], eax
  0014c	75 d4		 jne	 SHORT $LL17@judy_radix
$LN1@judy_radix:
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx

; 774  : 	}
; 775  : }

  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z ENDP		; judy_radix
_TEXT	ENDS
PUBLIC	?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z		; judy_promote
; Function compile flags: /Ogtp
;	COMDAT ?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z
_TEXT	SEGMENT
_result$ = -40						; size = 4
tv338 = -36						; size = 4
tv356 = -32						; size = 4
tv339 = -32						; size = 4
_node$ = -28						; size = 4
tv357 = -24						; size = 4
tv221 = -24						; size = 4
tv322 = -20						; size = 4
_newnode$ = -16						; size = 4
_slot$ = -12						; size = 4
_newcnt$ = -8						; size = 4
_oldcnt$ = -4						; size = 4
_judy$ = 8						; size = 4
_next$ = 12						; size = 4
tv347 = 16						; size = 4
_idx$ = 16						; size = 4
_value$ = 20						; size = 4
?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z PROC		; judy_promote, COMDAT
; _keysize$ = eax

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax

; 667  : uchar *base = (uchar *)(*next & JUDY_mask);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _next$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8b c8		 mov	 ecx, eax

; 668  : int oldcnt, newcnt, slot;
; 669  : #if BYTE_ORDER == BIG_ENDIAN
; 670  : 	int i;
; 671  : #endif
; 672  : JudySlot *newnode, *node;
; 673  : JudySlot *result;
; 674  : uchar *newbase;
; 675  : uint type;
; 676  : 
; 677  : 	type = (*next & 0x07) + 1;

  00011	83 e0 07	 and	 eax, 7
  00014	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00017	57		 push	 edi
  00018	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 678  : 	node = (JudySlot *)((*next & JUDY_mask) + JudySize[type-1]);

  0001b	8b 04 bd fc ff
	ff ff		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4-4]
  00022	89 4d ec	 mov	 DWORD PTR tv322[ebp], ecx
  00025	03 c8		 add	 ecx, eax

; 679  : 	oldcnt = JudySize[type-1] / (sizeof(JudySlot) + keysize);

  00027	33 d2		 xor	 edx, edx
  00029	89 4d e4	 mov	 DWORD PTR _node$[ebp], ecx
  0002c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002f	f7 f1		 div	 ecx

; 680  : 	newcnt = JudySize[type] / (sizeof(JudySlot) + keysize);

  00031	33 d2		 xor	 edx, edx
  00033	89 45 fc	 mov	 DWORD PTR _oldcnt$[ebp], eax
  00036	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4]
  0003d	f7 f1		 div	 ecx

; 681  : 
; 682  : 	// promote node to next larger size
; 683  : 
; 684  : 	newbase = (uchar*)judy_alloc (judy, type);

  0003f	8b 55 08	 mov	 edx, DWORD PTR _judy$[ebp]
  00042	52		 push	 edx
  00043	8b cf		 mov	 ecx, edi
  00045	89 45 f8	 mov	 DWORD PTR _newcnt$[ebp], eax
  00048	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 685  : 	newnode = (JudySlot *)(newbase + JudySize[type]);
; 686  : 	*next = (JudySlot)newbase | type;

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _next$[ebp]
  00050	8b d8		 mov	 ebx, eax
  00052	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4]

; 687  : 
; 688  : 	//	open up slot at idx
; 689  : 
; 690  : 	memcpy(newbase + (newcnt - oldcnt - 1) * keysize, base, idx * keysize);	// copy keys

  00059	8b 55 ec	 mov	 edx, DWORD PTR tv322[ebp]
  0005c	03 c3		 add	 eax, ebx
  0005e	89 45 f0	 mov	 DWORD PTR _newnode$[ebp], eax
  00061	8b c3		 mov	 eax, ebx
  00063	0b c7		 or	 eax, edi
  00065	89 01		 mov	 DWORD PTR [ecx], eax
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _newcnt$[ebp]
  0006a	2b 4d fc	 sub	 ecx, DWORD PTR _oldcnt$[ebp]
  0006d	8b 45 10	 mov	 eax, DWORD PTR _idx$[ebp]
  00070	89 4d e0	 mov	 DWORD PTR tv339[ebp], ecx
  00073	0f af c6	 imul	 eax, esi
  00076	49		 dec	 ecx
  00077	0f af ce	 imul	 ecx, esi
  0007a	50		 push	 eax
  0007b	52		 push	 edx
  0007c	03 cb		 add	 ecx, ebx
  0007e	51		 push	 ecx
  0007f	89 45 dc	 mov	 DWORD PTR tv338[ebp], eax
  00082	e8 00 00 00 00	 call	 _memcpy
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 691  : 
; 692  : 	for( slot = 0; slot < idx; slot++ )

  0008a	83 7d 10 00	 cmp	 DWORD PTR _idx$[ebp], 0
  0008e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _slot$[ebp], 0
  00095	7e 2a		 jle	 SHORT $LN4@judy_promo

; 667  : uchar *base = (uchar *)(*next & JUDY_mask);

  00097	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _oldcnt$[ebp]
  0009d	8b 55 f0	 mov	 edx, DWORD PTR _newnode$[ebp]
  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	2b 4d f8	 sub	 ecx, DWORD PTR _newcnt$[ebp]
  000a6	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  000a9	8b 55 10	 mov	 edx, DWORD PTR _idx$[ebp]
  000ac	89 55 e8	 mov	 DWORD PTR tv221[ebp], edx

; 691  : 
; 692  : 	for( slot = 0; slot < idx; slot++ )

  000af	89 55 f4	 mov	 DWORD PTR _slot$[ebp], edx
$LL6@judy_promo:

; 693  : 		newnode[-(slot + newcnt - oldcnt)] = node[-(slot + 1)];	// copy ptr

  000b2	8b 10		 mov	 edx, DWORD PTR [eax]
  000b4	89 11		 mov	 DWORD PTR [ecx], edx
  000b6	83 e8 04	 sub	 eax, 4
  000b9	83 e9 04	 sub	 ecx, 4
  000bc	ff 4d e8	 dec	 DWORD PTR tv221[ebp]
  000bf	75 f1		 jne	 SHORT $LL6@judy_promo
$LN4@judy_promo:

; 694  : 
; 695  : 	//	fill in new node
; 696  : 
; 697  : #if BYTE_ORDER != BIG_ENDIAN
; 698  : 	memcpy(newbase + (idx + newcnt - oldcnt - 1) * keysize, &value, keysize);	// copy key

  000c1	8b 45 e0	 mov	 eax, DWORD PTR tv339[ebp]
  000c4	03 45 10	 add	 eax, DWORD PTR _idx$[ebp]
  000c7	56		 push	 esi
  000c8	89 45 e0	 mov	 DWORD PTR tv356[ebp], eax
  000cb	48		 dec	 eax
  000cc	89 45 e8	 mov	 DWORD PTR tv357[ebp], eax
  000cf	0f af c6	 imul	 eax, esi
  000d2	8d 55 14	 lea	 edx, DWORD PTR _value$[ebp]
  000d5	52		 push	 edx
  000d6	03 c3		 add	 eax, ebx
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _memcpy

; 699  : #else
; 700  : 	i = keysize;
; 701  : 
; 702  : 	while( i-- )
; 703  : 	  newbase[(idx + newcnt - oldcnt - 1) * keysize + i] = value, value >>= 8;
; 704  : #endif
; 705  : 	result = &newnode[-(idx + newcnt - oldcnt)];

  000de	8b 45 fc	 mov	 eax, DWORD PTR _oldcnt$[ebp]
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _newnode$[ebp]
  000e4	8b c8		 mov	 ecx, eax

; 706  : 
; 707  : 	//	copy rest of old node
; 708  : 
; 709  : 	memcpy(newbase + (idx + newcnt - oldcnt) * keysize, base + (idx * keysize), (oldcnt - slot) * keysize);	// copy keys

  000e6	2b 45 f4	 sub	 eax, DWORD PTR _slot$[ebp]
  000e9	2b 4d f8	 sub	 ecx, DWORD PTR _newcnt$[ebp]
  000ec	2b 4d 10	 sub	 ecx, DWORD PTR _idx$[ebp]
  000ef	89 45 10	 mov	 DWORD PTR tv347[ebp], eax
  000f2	0f af c6	 imul	 eax, esi
  000f5	50		 push	 eax
  000f6	8b 45 e0	 mov	 eax, DWORD PTR tv356[ebp]
  000f9	0f af c6	 imul	 eax, esi
  000fc	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  000ff	8b 55 dc	 mov	 edx, DWORD PTR tv338[ebp]
  00102	03 55 ec	 add	 edx, DWORD PTR tv322[ebp]
  00105	03 c3		 add	 eax, ebx
  00107	52		 push	 edx
  00108	50		 push	 eax
  00109	89 4d d8	 mov	 DWORD PTR _result$[ebp], ecx
  0010c	e8 00 00 00 00	 call	 _memcpy

; 710  : 
; 711  : 	for( ; slot < oldcnt; slot++ )

  00111	8b 45 f4	 mov	 eax, DWORD PTR _slot$[ebp]
  00114	83 c4 18	 add	 esp, 24			; 00000018H
  00117	3b 45 fc	 cmp	 eax, DWORD PTR _oldcnt$[ebp]
  0011a	7d 28		 jge	 SHORT $LN1@judy_promo

; 694  : 
; 695  : 	//	fill in new node
; 696  : 
; 697  : #if BYTE_ORDER != BIG_ENDIAN
; 698  : 	memcpy(newbase + (idx + newcnt - oldcnt - 1) * keysize, &value, keysize);	// copy key

  0011c	8b 55 10	 mov	 edx, DWORD PTR tv347[ebp]
  0011f	8b 75 f0	 mov	 esi, DWORD PTR _newnode$[ebp]
  00122	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  00129	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0012c	2b c1		 sub	 eax, ecx
  0012e	8b ca		 mov	 ecx, edx
  00130	2b 4d f8	 sub	 ecx, DWORD PTR _newcnt$[ebp]
  00133	8d 4c 8e fc	 lea	 ecx, DWORD PTR [esi+ecx*4-4]
$LL3@judy_promo:

; 712  : 		newnode[-(slot + newcnt - oldcnt + 1)] = node[-(slot + 1)];	// copy ptr

  00137	8b 30		 mov	 esi, DWORD PTR [eax]
  00139	89 31		 mov	 DWORD PTR [ecx], esi
  0013b	83 e8 04	 sub	 eax, 4
  0013e	83 e9 04	 sub	 ecx, 4
  00141	4a		 dec	 edx
  00142	75 f3		 jne	 SHORT $LL3@judy_promo
$LN1@judy_promo:

; 713  : 
; 714  : #ifndef ASKITIS
; 715  : 	judy->stack[judy->level].next = *next;
; 716  : 	judy->stack[judy->level].slot = idx + newcnt - oldcnt - 1;
; 717  : #endif
; 718  : 	judy_free (judy, (void **)base, type - 1);

  00144	4f		 dec	 edi
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  00148	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0014b	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0014e	8b 45 0c	 mov	 eax, DWORD PTR _next$[ebp]
  00151	8b 00		 mov	 eax, DWORD PTR [eax]
  00153	89 44 91 34	 mov	 DWORD PTR [ecx+edx*4+52], eax
  00157	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0015a	8d 54 40 0f	 lea	 edx, DWORD PTR [eax+eax*2+15]
  0015e	8b 45 e8	 mov	 eax, DWORD PTR tv357[ebp]
  00161	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  00164	75 07		 jne	 SHORT $LN10@judy_promo
  00166	bf 04 00 00 00	 mov	 edi, 4
  0016b	eb 0a		 jmp	 SHORT $LN9@judy_promo
$LN10@judy_promo:
  0016d	83 ff 07	 cmp	 edi, 7
  00170	75 05		 jne	 SHORT $LN9@judy_promo
  00172	bf 03 00 00 00	 mov	 edi, 3
$LN9@judy_promo:
  00177	8b 54 b9 04	 mov	 edx, DWORD PTR [ecx+edi*4+4]
  0017b	8b 45 ec	 mov	 eax, DWORD PTR tv322[ebp]
  0017e	89 10		 mov	 DWORD PTR [eax], edx
  00180	89 44 b9 04	 mov	 DWORD PTR [ecx+edi*4+4], eax

; 719  : 	return result;

  00184	8b 45 d8	 mov	 eax, DWORD PTR _result$[ebp]
  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx

; 720  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z ENDP		; judy_promote
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashlin.c
_TEXT	ENDS
;	COMDAT ?tommy_hashlin_pos@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z
_TEXT	SEGMENT
_count$171816 = -4					; size = 4
?tommy_hashlin_pos@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z PROC ; tommy_hashlin_pos, COMDAT
; _pos$ = eax

; 72   : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 73   : 	unsigned bsr;  
; 74   :  
; 75   : 	/* special case for the first bucket */
; 76   : 	if (pos < (1 << TOMMY_HASHLIN_BIT)) {

  00004	83 f8 40	 cmp	 eax, 64			; 00000040H
  00007	73 0d		 jae	 SHORT $LN1@tommy_hash

; 77   : 		return &hashlin->bucket[0][pos];

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A

; 85   : 
; 86   : 	return &hashlin->bucket[bsr - TOMMY_HASHLIN_BIT + 1][pos];

  0000f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 87   : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN1@tommy_hash:

; 78   : 	}
; 79   : 
; 80   : 	/* get the highest bit set */
; 81   : 	bsr = tommy_ilog2_u32(pos);

  00016	0f bd d0	 bsr	 edx, eax
  00019	89 55 fc	 mov	 DWORD PTR _count$171816[ebp], edx

; 82   : 
; 83   : 	/* clear the highest bit */
; 84   : 	pos -= 1 << bsr;

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _count$171816[ebp]
  0001f	ba 01 00 00 00	 mov	 edx, 1
  00024	d3 e2		 shl	 edx, cl

; 85   : 
; 86   : 	return &hashlin->bucket[bsr - TOMMY_HASHLIN_BIT + 1][pos];

  00026	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  0002d	2b c2		 sub	 eax, edx
  0002f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 87   : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?tommy_hashlin_pos@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ENDP ; tommy_hashlin_pos
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashdyn.c
;	COMDAT _tommy_hashdyn_memory_usage
_TEXT	SEGMENT
_tommy_hashdyn_memory_usage PROC			; COMDAT

; 189  : 	return hashdyn->bucket_max * (tommy_size_t)sizeof(hashdyn->bucket[0])
; 190  : 		+ tommy_hashdyn_count(hashdyn) * (tommy_size_t)sizeof(tommy_hashdyn_node);

  00000	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  00005	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000e	03 c0		 add	 eax, eax
  00010	03 c0		 add	 eax, eax

; 191  : }

  00012	c3		 ret	 0
_tommy_hashdyn_memory_usage ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashtbl.c
;	COMDAT _tommy_hashtable_memory_usage
_TEXT	SEGMENT
_tommy_hashtable_memory_usage PROC			; COMDAT

; 101  : 	return hashtable->bucket_max * (tommy_size_t)sizeof(hashtable->bucket[0])
; 102  : 		+ tommy_hashtable_count(hashtable) * (tommy_size_t)sizeof(tommy_hashtable_node);

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  00005	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+4
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000e	03 c0		 add	 eax, eax
  00010	03 c0		 add	 eax, eax

; 103  : }

  00012	c3		 ret	 0
_tommy_hashtable_memory_usage ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashtable_init
_TEXT	SEGMENT
_tommy_hashtable_init PROC				; COMDAT
; _bucket_max$ = eax

; 37   : 	if (bucket_max < 16) {

  00000	83 f8 10	 cmp	 eax, 16			; 00000010H
  00003	73 07		 jae	 SHORT $LN2@tommy_hash@2

; 38   : 		bucket_max = 16;

  00005	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H

; 39   : 	} else {

  0000a	eb 24		 jmp	 SHORT $LN1@tommy_hash@2
$LN2@tommy_hash@2:

; 40   : 		bucket_max = tommy_roundup_pow2_u32(bucket_max);

  0000c	48		 dec	 eax
  0000d	8b c8		 mov	 ecx, eax
  0000f	d1 e9		 shr	 ecx, 1
  00011	0b c1		 or	 eax, ecx
  00013	8b d0		 mov	 edx, eax
  00015	c1 ea 02	 shr	 edx, 2
  00018	0b c2		 or	 eax, edx
  0001a	8b c8		 mov	 ecx, eax
  0001c	c1 e9 04	 shr	 ecx, 4
  0001f	0b c1		 or	 eax, ecx
  00021	8b d0		 mov	 edx, eax
  00023	c1 ea 08	 shr	 edx, 8
  00026	0b c2		 or	 eax, edx
  00028	8b c8		 mov	 ecx, eax
  0002a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0002d	0b c8		 or	 ecx, eax
  0002f	41		 inc	 ecx
$LN1@tommy_hash@2:

; 41   : 	}
; 42   : 
; 43   : 	hashtable->bucket_max = bucket_max;
; 44   : 	hashtable->bucket_mask = hashtable->bucket_max - 1;
; 45   : 	hashtable->bucket = tommy_cast(tommy_hashtable_node**, tommy_malloc(hashtable->bucket_max * sizeof(tommy_hashtable_node*)));

  00030	56		 push	 esi
  00031	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00038	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0003b	56		 push	 esi
  0003c	89 0d 04 00 00
	00		 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+4, ecx
  00042	a3 08 00 00 00	 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8, eax
  00047	e8 00 00 00 00	 call	 _malloc

; 46   : 	memset(hashtable->bucket, 0, hashtable->bucket_max * sizeof(tommy_hashtable_node*));

  0004c	56		 push	 esi
  0004d	6a 00		 push	 0
  0004f	50		 push	 eax
  00050	a3 00 00 00 00	 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A, eax
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 10	 add	 esp, 16			; 00000010H

; 47   : 
; 48   : 	hashtable->count = 0;

  0005d	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12, 0
  00067	5e		 pop	 esi

; 49   : }

  00068	c3		 ret	 0
_tommy_hashtable_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrieinp.c
;	COMDAT _tommy_trie_inplace_memory_usage
_TEXT	SEGMENT
_tommy_trie_inplace_memory_usage PROC			; COMDAT

; 268  : 	return tommy_trie_inplace_count(trie_inplace) * (tommy_size_t)sizeof(tommy_trie_inplace_node);

  00000	a1 00 01 00 00	 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00005	c1 e0 05	 shl	 eax, 5

; 269  : }

  00008	c3		 ret	 0
_tommy_trie_inplace_memory_usage ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z
_TEXT	SEGMENT
_let_ptr$ = 8						; size = 4
?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z PROC ; trie_inplace_bucket_remove, COMDAT
; _key$ = edx

; 146  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _let_ptr$[ebp]

; 147  : 	tommy_trie_inplace_node* node;
; 148  : 	int i;
; 149  : 	tommy_trie_inplace_node** leaf_let_ptr;
; 150  : 	tommy_trie_inplace_node* leaf;
; 151  : 
; 152  : 	node = *let_ptr;

  00007	8b 03		 mov	 eax, DWORD PTR [ebx]
  00009	56		 push	 esi
  0000a	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH

; 153  : 	while (node && node->key != key) {

  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $LN43@trie_inpla
$LL15@trie_inpla:
  00013	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00016	74 1a		 je	 SHORT $LN44@trie_inpla

; 154  : 		let_ptr = &node->map[(key >> shift) & TOMMY_TRIE_INPLACE_TREE_MASK];

  00018	8b f2		 mov	 esi, edx
  0001a	d3 ee		 shr	 esi, cl

; 155  : 		node = *let_ptr;
; 156  : 		shift -= TOMMY_TRIE_INPLACE_TREE_BIT;

  0001c	83 e9 02	 sub	 ecx, 2
  0001f	83 e6 03	 and	 esi, 3
  00022	8d 5c b0 10	 lea	 ebx, DWORD PTR [eax+esi*4+16]
  00026	8b 03		 mov	 eax, DWORD PTR [ebx]
  00028	85 c0		 test	 eax, eax
  0002a	75 e7		 jne	 SHORT $LL15@trie_inpla
$LN43@trie_inpla:
  0002c	5e		 pop	 esi

; 157  : 	}
; 158  : 
; 159  : 	if (!node)
; 160  : 		return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	5b		 pop	 ebx

; 211  : 
; 212  : 	return remove;
; 213  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN44@trie_inpla:

; 161  : 
; 162  : 	/* if the node to remove is not specified */
; 163  : 	if (!remove) {
; 164  : 		/* remove the first */
; 165  : 		remove = node;
; 166  : 	}
; 167  : 
; 168  : 	tommy_trie_inplace_list_remove(let_ptr, remove);

  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 13		 mov	 edx, DWORD PTR [ebx]
  00036	85 c9		 test	 ecx, ecx
  00038	74 08		 je	 SHORT $LN21@trie_inpla
  0003a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0003d	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00040	eb 06		 jmp	 SHORT $LN20@trie_inpla
$LN21@trie_inpla:
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN20@trie_inpla:
  00048	3b d0		 cmp	 edx, eax
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	75 04		 jne	 SHORT $LN19@trie_inpla
  0004e	89 13		 mov	 DWORD PTR [ebx], edx
  00050	eb 05		 jmp	 SHORT $LN18@trie_inpla
$LN19@trie_inpla:
  00052	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00055	89 11		 mov	 DWORD PTR [ecx], edx
$LN18@trie_inpla:

; 169  : 
; 170  : 	/* if we have a substitute */
; 171  : 	if (*let_ptr != 0) {

  00057	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00059	85 c9		 test	 ecx, ecx
  0005b	74 1c		 je	 SHORT $LN11@trie_inpla

; 172  : 		/* copy the child pointers to the new one */
; 173  : 		node = *let_ptr;
; 174  : 		for(i=0;i<TOMMY_TRIE_INPLACE_TREE_MAX;++i) {
; 175  : 			node->map[i] = remove->map[i];

  0005d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00060	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00063	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00066	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00069	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0006c	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  0006f	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00072	5e		 pop	 esi
  00073	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  00076	5b		 pop	 ebx

; 211  : 
; 212  : 	return remove;
; 213  : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN11@trie_inpla:

; 176  : 		}
; 177  : 		return remove;
; 178  : 	}
; 179  : 
; 180  : 	/* find a leaf */
; 181  : 	leaf_let_ptr = 0;

  00079	33 f6		 xor	 esi, esi

; 182  : 	leaf = remove;

  0007b	8b c8		 mov	 ecx, eax
  0007d	57		 push	 edi
$LN45@trie_inpla:

; 183  : 
; 184  : 	/* search backward, statistically we have more zeros than ones */
; 185  : 	i = TOMMY_TRIE_INPLACE_TREE_MAX-1;

  0007e	ba 03 00 00 00	 mov	 edx, 3
$LL7@trie_inpla:

; 187  : 		if (leaf->map[i]) {

  00083	83 7c 91 10 00	 cmp	 DWORD PTR [ecx+edx*4+16], 0
  00088	8d 7c 91 10	 lea	 edi, DWORD PTR [ecx+edx*4+16]
  0008c	74 06		 je	 SHORT $LN5@trie_inpla

; 188  : 			leaf_let_ptr = &leaf->map[i];

  0008e	8b f7		 mov	 esi, edi

; 189  : 			leaf = *leaf_let_ptr;

  00090	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 190  : 			i = TOMMY_TRIE_INPLACE_TREE_MAX-1;
; 191  : 			continue;

  00092	eb ea		 jmp	 SHORT $LN45@trie_inpla
$LN5@trie_inpla:

; 192  : 		}
; 193  : 		--i;

  00094	4a		 dec	 edx

; 186  : 	while (i >= 0) {

  00095	79 ec		 jns	 SHORT $LL7@trie_inpla

; 194  : 	}
; 195  : 
; 196  : 	/* if it's itself a leaf */
; 197  : 	if (!leaf_let_ptr) {

  00097	5f		 pop	 edi
  00098	85 f6		 test	 esi, esi

; 198  : 		return remove;

  0009a	74 20		 je	 SHORT $LN16@trie_inpla

; 199  : 	}
; 200  : 
; 201  : 	/* remove the leaf */
; 202  : 	*leaf_let_ptr = 0;

  0009c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 203  : 
; 204  : 	/* copy the child pointers */
; 205  : 	for(i=0;i<TOMMY_TRIE_INPLACE_TREE_MAX;++i) {
; 206  : 		leaf->map[i] = remove->map[i];

  000a2	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  000a5	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  000a8	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000ab	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  000ae	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b1	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  000b4	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000b7	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 207  : 	}
; 208  : 
; 209  : 	/* put it in place */
; 210  : 	*let_ptr = leaf;

  000ba	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN16@trie_inpla:
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx

; 211  : 
; 212  : 	return remove;
; 213  : }

  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ENDP ; trie_inplace_bucket_remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?trie_inplace_bucket_insert@@YAXIPAPAUtommy_trie_inplace_node_struct@@PAU1@I@Z
_TEXT	SEGMENT
?trie_inplace_bucket_insert@@YAXIPAPAUtommy_trie_inplace_node_struct@@PAU1@I@Z PROC ; trie_inplace_bucket_insert, COMDAT
; _let_ptr$ = edx
; _insert$ = edi
; _key$ = esi

; 108  : 	tommy_trie_inplace_node* node;
; 109  : 
; 110  : 	node = *let_ptr;

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH

; 111  : 	while (node && node->key != key) {

  00007	85 c0		 test	 eax, eax
  00009	74 1e		 je	 SHORT $LN13@trie_inpla@2
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@trie_inpla@2:
  00010	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00013	74 20		 je	 SHORT $LN2@trie_inpla@2

; 112  : 		let_ptr = &node->map[(key >> shift) & TOMMY_TRIE_INPLACE_TREE_MASK];

  00015	8b d6		 mov	 edx, esi
  00017	d3 ea		 shr	 edx, cl

; 113  : 		node = *let_ptr;
; 114  : 		shift -= TOMMY_TRIE_INPLACE_TREE_BIT;

  00019	83 e9 02	 sub	 ecx, 2
  0001c	83 e2 03	 and	 edx, 3
  0001f	8d 54 90 10	 lea	 edx, DWORD PTR [eax+edx*4+16]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	85 c0		 test	 eax, eax
  00027	75 e7		 jne	 SHORT $LL4@trie_inpla@2
$LN13@trie_inpla@2:

; 115  : 	}
; 116  : 
; 117  : 	/* if null, just insert the node */
; 118  : 	if (!node) {
; 119  : 		/* setup the node as a list */
; 120  : 		*let_ptr = tommy_trie_inplace_list_insert_first(insert);

  00029	89 7f 04	 mov	 DWORD PTR [edi+4], edi

; 121  : 	} else {
; 122  : 		/* if it's the same key, insert in the list */
; 123  : 		tommy_trie_inplace_list_insert_tail_not_empty(node, insert);

  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00032	89 3a		 mov	 DWORD PTR [edx], edi

; 124  : 	}
; 125  : }

  00034	c3		 ret	 0
$LN2@trie_inpla@2:

; 121  : 	} else {
; 122  : 		/* if it's the same key, insert in the list */
; 123  : 		tommy_trie_inplace_list_insert_tail_not_empty(node, insert);

  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0003b	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0003e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00041	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00047	89 3a		 mov	 DWORD PTR [edx], edi

; 124  : 	}
; 125  : }

  00049	c3		 ret	 0
?trie_inplace_bucket_insert@@YAXIPAPAUtommy_trie_inplace_node_struct@@PAU1@I@Z ENDP ; trie_inplace_bucket_insert
_TEXT	ENDS
PUBLIC	_tommy_trie_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrie.c
;	COMDAT _tommy_trie_memory_usage
_TEXT	SEGMENT
_tommy_trie_memory_usage PROC				; COMDAT

; 326  : 	return tommy_trie_count(trie) * (tommy_size_t)sizeof(tommy_trie_node)
; 327  : 		+ trie->node_count * (tommy_size_t)TOMMY_TRIE_BLOCK_SIZE;

  00000	a1 84 00 00 00	 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A+132
  00005	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+128
  0000b	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0000e	c1 e0 04	 shl	 eax, 4

; 328  : }

  00011	c3		 ret	 0
_tommy_trie_memory_usage ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_shift$ = -4						; size = 4
_let_ptr$ = 8						; size = 4
_insert$ = 12						; size = 4
_key$ = 16						; size = 4
?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z PROC ; trie_bucket_insert, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 55 08	 mov	 edx, DWORD PTR _let_ptr$[ebp]
  00009	8b 45 0c	 mov	 eax, DWORD PTR _insert$[ebp]
  0000c	53		 push	 ebx

; 98   : 	tommy_trie_tree* tree;
; 99   : 	tommy_trie_node* node;
; 100  : 	void* ptr;
; 101  : 	unsigned i, j;
; 102  : 
; 103  : recurse:
; 104  : 	ptr = *let_ptr;

  0000d	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0000f	56		 push	 esi
  00010	8b 75 10	 mov	 esi, DWORD PTR _key$[ebp]
  00013	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  00018	89 5d f8	 mov	 DWORD PTR _ptr$[ebp], ebx

; 105  : 
; 106  : 	/* if null, just insert the node */
; 107  : 	if (!ptr) {

  0001b	85 db		 test	 ebx, ebx
  0001d	74 1d		 je	 SHORT $LN27@trie_bucke
  0001f	90		 npad	 1
$recurse$86435:

; 110  : 		return;
; 111  : 	}
; 112  : 
; 113  : 	if (trie_get_type(ptr) == TOMMY_TRIE_TYPE_TREE) {

  00020	f6 c3 01	 test	 bl, 1
  00023	74 28		 je	 SHORT $LN6@trie_bucke

; 114  : 		/* repeat the process one level down */
; 115  : 		let_ptr = &trie_get_tree(ptr)->map[(key >> shift) & TOMMY_TRIE_TREE_MASK];

  00025	8b d6		 mov	 edx, esi
  00027	d3 ea		 shr	 edx, cl

; 116  : 		shift -= TOMMY_TRIE_TREE_BIT;

  00029	83 e9 03	 sub	 ecx, 3
  0002c	83 e2 07	 and	 edx, 7
  0002f	8d 54 93 ff	 lea	 edx, DWORD PTR [ebx+edx*4-1]
  00033	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00035	85 db		 test	 ebx, ebx
  00037	75 e7		 jne	 SHORT $recurse$86435

; 98   : 	tommy_trie_tree* tree;
; 99   : 	tommy_trie_node* node;
; 100  : 	void* ptr;
; 101  : 	unsigned i, j;
; 102  : 
; 103  : recurse:
; 104  : 	ptr = *let_ptr;

  00039	89 5d f8	 mov	 DWORD PTR _ptr$[ebp], ebx
$LN27@trie_bucke:
  0003c	5e		 pop	 esi

; 108  : 		/* setup the node as a list */
; 109  : 		tommy_list_insert_first(let_ptr, insert);

  0003d	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	5b		 pop	 ebx

; 157  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN6@trie_bucke:

; 98   : 	tommy_trie_tree* tree;
; 99   : 	tommy_trie_node* node;
; 100  : 	void* ptr;
; 101  : 	unsigned i, j;
; 102  : 
; 103  : recurse:
; 104  : 	ptr = *let_ptr;

  0004d	89 5d f8	 mov	 DWORD PTR _ptr$[ebp], ebx

; 116  : 		shift -= TOMMY_TRIE_TREE_BIT;

  00050	89 4d fc	 mov	 DWORD PTR _shift$[ebp], ecx
  00053	89 55 08	 mov	 DWORD PTR _let_ptr$[ebp], edx

; 117  : 		goto recurse;
; 118  : 	}
; 119  : 
; 120  : 	node = tommy_cast(tommy_trie_node*, ptr);
; 121  : 
; 122  : 	/* if it's the same key, insert in the list */
; 123  : 	if (node->key == key) {

  00056	39 73 0c	 cmp	 DWORD PTR [ebx+12], esi
  00059	75 1a		 jne	 SHORT $LN42@trie_bucke

; 124  : 		tommy_list_insert_tail_not_empty(node, insert);

  0005b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0005e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00061	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00064	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00067	5e		 pop	 esi
  00068	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0006e	89 02		 mov	 DWORD PTR [edx], eax
  00070	5b		 pop	 ebx

; 157  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN42@trie_bucke:
  00075	57		 push	 edi
  00076	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$expand$86443:

; 125  : 		return;
; 126  : 	}
; 127  : 
; 128  : expand:
; 129  : 	/* convert to a tree */
; 130  : 	tree = tommy_cast(tommy_trie_tree*, tommy_allocator_alloc(trie->alloc));

  00080	8b 35 88 00 00
	00		 mov	 esi, DWORD PTR ?trie@@3Utommy_trie_struct@@A+136
  00086	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00089	75 55		 jne	 SHORT $LN14@trie_bucke
  0008b	bf c0 0f 00 00	 mov	 edi, 4032		; 00000fc0H
  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 _malloc
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b c8		 mov	 ecx, eax
  0009b	89 11		 mov	 DWORD PTR [ecx], edx
  0009d	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000a0	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000a3	83 c1 04	 add	 ecx, 4
  000a6	33 d2		 xor	 edx, edx
  000a8	8b c1		 mov	 eax, ecx
  000aa	f7 f3		 div	 ebx
  000ac	83 c4 04	 add	 esp, 4
  000af	85 d2		 test	 edx, edx
  000b1	74 0e		 je	 SHORT $LN40@trie_bucke
  000b3	8b c3		 mov	 eax, ebx
  000b5	2b c2		 sub	 eax, edx
  000b7	03 c8		 add	 ecx, eax
  000b9	2b d3		 sub	 edx, ebx
  000bb	8d ba c0 0f 00
	00		 lea	 edi, DWORD PTR [edx+4032]
$LN40@trie_bucke:
  000c1	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  000c4	72 11		 jb	 SHORT $LN41@trie_bucke
$LL15@trie_bucke:
  000c6	8b 16		 mov	 edx, DWORD PTR [esi]
  000c8	89 11		 mov	 DWORD PTR [ecx], edx
  000ca	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000cd	89 0e		 mov	 DWORD PTR [esi], ecx
  000cf	2b f8		 sub	 edi, eax
  000d1	03 c8		 add	 ecx, eax
  000d3	3b f8		 cmp	 edi, eax
  000d5	73 ef		 jae	 SHORT $LL15@trie_bucke
$LN41@trie_bucke:
  000d7	8b 5d f8	 mov	 ebx, DWORD PTR _ptr$[ebp]
  000da	8b 4d fc	 mov	 ecx, DWORD PTR _shift$[ebp]
  000dd	8b 55 08	 mov	 edx, DWORD PTR _let_ptr$[ebp]
$LN14@trie_bucke:
  000e0	8b 06		 mov	 eax, DWORD PTR [esi]
  000e2	8b 38		 mov	 edi, DWORD PTR [eax]
  000e4	89 3e		 mov	 DWORD PTR [esi], edi
  000e6	bf 01 00 00 00	 mov	 edi, 1
  000eb	01 7e 10	 add	 DWORD PTR [esi+16], edi

; 131  : 	++trie->node_count;

  000ee	01 3d 84 00 00
	00		 add	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+132, edi

; 132  : 	*let_ptr = tommy_cast(tommy_trie_node*, trie_set_tree(tree));

  000f4	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  000f7	89 32		 mov	 DWORD PTR [edx], esi

; 133  : 
; 134  : 	/* initialize it */
; 135  : 	for(i=0;i<TOMMY_TRIE_TREE_MAX;++i) {
; 136  : 		tree->map[i] = 0;
; 137  : 	}
; 138  : 
; 139  : 	/* get the position of the two elements */
; 140  : 	i = (node->key >> shift) & TOMMY_TRIE_TREE_MASK;
; 141  : 	j = (key >> shift) & TOMMY_TRIE_TREE_MASK;

  000f9	8b 75 10	 mov	 esi, DWORD PTR _key$[ebp]
  000fc	66 0f ef c0	 pxor	 xmm0, xmm0
  00100	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00104	66 0f d6 40 08	 movq	 QWORD PTR [eax+8], xmm0
  00109	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0010e	66 0f d6 40 18	 movq	 QWORD PTR [eax+24], xmm0
  00113	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00116	d3 ea		 shr	 edx, cl
  00118	d3 ee		 shr	 esi, cl
  0011a	83 e2 07	 and	 edx, 7
  0011d	83 e6 07	 and	 esi, 7

; 142  : 
; 143  : 	/* if they don't collied */
; 144  : 	if (i != j) {

  00120	3b d6		 cmp	 edx, esi
  00122	75 11		 jne	 SHORT $LN28@trie_bucke

; 150  : 		return;
; 151  : 	}
; 152  : 
; 153  : 	/* expand one more level */
; 154  : 	let_ptr = &tree->map[i];

  00124	8d 14 90	 lea	 edx, DWORD PTR [eax+edx*4]

; 155  : 	shift -= TOMMY_TRIE_TREE_BIT;

  00127	83 e9 03	 sub	 ecx, 3
  0012a	89 55 08	 mov	 DWORD PTR _let_ptr$[ebp], edx
  0012d	89 4d fc	 mov	 DWORD PTR _shift$[ebp], ecx

; 156  : 	goto expand;

  00130	e9 4b ff ff ff	 jmp	 $expand$86443
$LN28@trie_bucke:

; 145  : 		/* insert the already existing element */
; 146  : 		tree->map[i] = node;
; 147  : 
; 148  : 		/* insert the new node */
; 149  : 		tommy_list_insert_first(&tree->map[j], insert);

  00135	8b 4d 0c	 mov	 ecx, DWORD PTR _insert$[ebp]
  00138	89 1c 90	 mov	 DWORD PTR [eax+edx*4], ebx
  0013b	5f		 pop	 edi
  0013c	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0013f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00145	89 0c b0	 mov	 DWORD PTR [eax+esi*4], ecx
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx

; 157  : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ENDP ; trie_bucket_insert
_TEXT	ENDS
PUBLIC	_tommy_allocator_done
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyalloc.c
;	COMDAT _tommy_allocator_done
_TEXT	SEGMENT
_tommy_allocator_done PROC				; COMDAT

; 78   : 	allocator_reset(alloc);

  00000	e9 00 00 00 00	 jmp	 ?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z ; allocator_reset
_tommy_allocator_done ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashdyn.h
_TEXT	ENDS
;	COMDAT _tommy_hashdyn_search
_TEXT	SEGMENT
_tommy_hashdyn_search PROC				; COMDAT
; _cmp_arg$ = edx
; _hash$ = ecx

; 218  : 	tommy_hashdyn_node* i = tommy_hashdyn_bucket(hashdyn, hash);

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  00005	56		 push	 esi
  00006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  0000c	23 c1		 and	 eax, ecx
  0000e	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00011	57		 push	 edi

; 219  : 	while (i) {

  00012	85 c0		 test	 eax, eax
  00014	74 15		 je	 SHORT $LN2@tommy_hash@3
$LL3@tommy_hash@3:

; 220  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 221  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0)

  00016	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00019	75 0a		 jne	 SHORT $LN1@tommy_hash@3
  0001b	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0001e	8b 3a		 mov	 edi, DWORD PTR [edx]
  00020	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00023	74 0b		 je	 SHORT $LN12@tommy_hash@3
$LN1@tommy_hash@3:

; 223  : 		i = i->next;

  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	85 c0		 test	 eax, eax
  00029	75 eb		 jne	 SHORT $LL3@tommy_hash@3
$LN2@tommy_hash@3:
  0002b	5f		 pop	 edi

; 224  : 	}
; 225  : 	return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 226  : }

  0002f	c3		 ret	 0
$LN12@tommy_hash@3:
  00030	5f		 pop	 edi

; 222  : 			return i->data;

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 226  : }

  00034	c3		 ret	 0
_tommy_hashdyn_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashtbl.h
_TEXT	ENDS
;	COMDAT _tommy_hashtable_search
_TEXT	SEGMENT
_tommy_hashtable_search PROC				; COMDAT
; _cmp_arg$ = edx
; _hash$ = ecx

; 203  : 	tommy_hashtable_node* i = tommy_hashtable_bucket(hashtable, hash);

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00005	56		 push	 esi
  00006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0000c	23 c1		 and	 eax, ecx
  0000e	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00011	57		 push	 edi

; 204  : 	while (i) {

  00012	85 c0		 test	 eax, eax
  00014	74 15		 je	 SHORT $LN2@tommy_hash@4
$LL3@tommy_hash@4:

; 205  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 206  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0)

  00016	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00019	75 0a		 jne	 SHORT $LN1@tommy_hash@4
  0001b	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0001e	8b 3a		 mov	 edi, DWORD PTR [edx]
  00020	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00023	74 0b		 je	 SHORT $LN12@tommy_hash@4
$LN1@tommy_hash@4:

; 208  : 		i = i->next;

  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	85 c0		 test	 eax, eax
  00029	75 eb		 jne	 SHORT $LL3@tommy_hash@4
$LN2@tommy_hash@4:
  0002b	5f		 pop	 edi

; 209  : 	}
; 210  : 	return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 211  : }

  0002f	c3		 ret	 0
$LN12@tommy_hash@4:
  00030	5f		 pop	 edi

; 207  : 			return i->data;

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 211  : }

  00034	c3		 ret	 0
_tommy_hashtable_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommylist.h
_TEXT	ENDS
;	COMDAT _tommy_list_empty
_TEXT	SEGMENT
_tommy_list_empty PROC					; COMDAT
; _list$ = ecx

; 305  : 	return tommy_list_head(list) == 0;

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 94 c0	 sete	 al

; 306  : }

  00007	c3		 ret	 0
_tommy_list_empty ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_remove_existing
_TEXT	SEGMENT
_tommy_list_remove_existing PROC			; COMDAT
; _list$ = esi
; _node$ = eax

; 264  : 	tommy_node* head = tommy_list_head(list);
; 265  : 
; 266  : 	/* remove from the "circular" prev list */
; 267  : 	if (node->next) { 

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 16		 mov	 edx, DWORD PTR [esi]
  00004	85 c9		 test	 ecx, ecx
  00006	74 0a		 je	 SHORT $LN4@tommy_list

; 268  : 		node->next->prev = node->prev;

  00008	57		 push	 edi
  00009	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000c	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0000f	5f		 pop	 edi

; 269  : 	} else {

  00010	eb 06		 jmp	 SHORT $LN3@tommy_list
$LN4@tommy_list:

; 270  : 		head->prev = node->prev; /* the last */

  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN3@tommy_list:

; 271  : 	}
; 272  : 
; 273  : 	/* remove from the "0 terminated" next list */
; 274  : 	if (head == node) {

  00018	3b d0		 cmp	 edx, eax

; 275  : 		*list = node->next; /* the new head, in case 0 */

  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	75 06		 jne	 SHORT $LN2@tommy_list
  0001e	89 16		 mov	 DWORD PTR [esi], edx

; 278  : 	}
; 279  : 
; 280  : 	return node->data;

  00020	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 281  : }

  00023	c3		 ret	 0
$LN2@tommy_list:

; 276  : 	} else {
; 277  : 		node->prev->next = node->next;

  00024	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00027	89 11		 mov	 DWORD PTR [ecx], edx

; 278  : 	}
; 279  : 
; 280  : 	return node->data;

  00029	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 281  : }

  0002c	c3		 ret	 0
_tommy_list_remove_existing ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_insert_tail
_TEXT	SEGMENT
_tommy_list_insert_tail PROC				; COMDAT
; _list$ = edx
; _node$ = eax
; _data$ = esi

; 225  : 	tommy_node* head = tommy_list_head(list);

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 226  : 
; 227  : 	if (head) {

  00002	85 c9		 test	 ecx, ecx
  00004	74 18		 je	 SHORT $LN2@tommy_list@2

; 228  : 		tommy_list_insert_tail_not_empty(head, node);

  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00018	89 01		 mov	 DWORD PTR [ecx], eax

; 231  : 	}
; 232  : 
; 233  : 	node->data = data;

  0001a	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 234  : }

  0001d	c3		 ret	 0
$LN2@tommy_list@2:

; 229  : 	} else {
; 230  : 		tommy_list_insert_first(list, node);

  0001e	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00021	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00027	89 02		 mov	 DWORD PTR [edx], eax

; 231  : 	}
; 232  : 
; 233  : 	node->data = data;

  00029	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 234  : }

  0002c	c3		 ret	 0
_tommy_list_insert_tail ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_tail
_TEXT	SEGMENT
_tommy_list_tail PROC					; COMDAT
; _list$ = eax

; 139  : 	tommy_node* head = tommy_list_head(list);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 140  : 
; 141  : 	if (!head)

  00002	85 c0		 test	 eax, eax
  00004	75 01		 jne	 SHORT $LN1@tommy_list@3

; 145  : }

  00006	c3		 ret	 0
$LN1@tommy_list@3:

; 142  : 		return 0;
; 143  : 
; 144  : 	return head->prev;

  00007	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 145  : }

  0000a	c3		 ret	 0
_tommy_list_tail ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN10@scalar@5
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN10@scalar@5:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T172049 = 8						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@PBD@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx

; 114  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 4d 08	 lea	 ecx, DWORD PTR $T172049[ebp]
  0000c	51		 push	 ecx
  0000d	8b ce		 mov	 ecx, esi
  0000f	89 45 08	 mov	 DWORD PTR $T172049[ebp], eax
  00012	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 115  : 		}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0length_error@std@@QAE@PBD@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar@6
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar@6:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::linear_search_plain_compare<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >, COMDAT
; _k$ = ecx
; _e$ = edx

; 594  :   int linear_search_plain_compare(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	33 c0		 xor	 eax, eax

; 595  :       const key_type &k, int s, int e, const Compare &comp) const {
; 596  :     while (s < e) {

  00005	85 d2		 test	 edx, edx
  00007	7e 16		 jle	 SHORT $LN17@linear_sea

; 597  :       if (!btree_compare_keys(comp, key(s), k)) {

  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 08	 add	 ecx, 8
$LL3@linear_sea:
  00012	39 31		 cmp	 DWORD PTR [ecx], esi
  00014	73 08		 jae	 SHORT $LN21@linear_sea

; 598  :         break;
; 599  :       }
; 600  :       ++s;

  00016	40		 inc	 eax
  00017	83 c1 08	 add	 ecx, 8
  0001a	3b c2		 cmp	 eax, edx
  0001c	7c f4		 jl	 SHORT $LL3@linear_sea
$LN21@linear_sea:
  0001e	5e		 pop	 esi
$LN17@linear_sea:

; 601  :     }
; 602  :     return s;
; 603  :   }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::linear_search_plain_compare<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
_comp$ = 12						; size = 1
?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z PROC ; btree::btree_linear_search_plain_compare<unsigned int,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >::lower_bound, COMDAT
; _n$ = ecx

; 376  :   static int lower_bound(const K &k, const N &n, Compare comp)  {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  :     return n.linear_search_plain_compare(k, 0, n.count(), comp);

  00003	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00007	33 c0		 xor	 eax, eax
  00009	85 d2		 test	 edx, edx
  0000b	7e 16		 jle	 SHORT $LN21@lower_boun@2
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _k$[ebp]
  00011	8b 36		 mov	 esi, DWORD PTR [esi]
  00013	83 c1 08	 add	 ecx, 8
$LL7@lower_boun@2:
  00016	39 31		 cmp	 DWORD PTR [ecx], esi
  00018	73 08		 jae	 SHORT $LN25@lower_boun@2
  0001a	40		 inc	 eax
  0001b	83 c1 08	 add	 ecx, 8
  0001e	3b c2		 cmp	 eax, edx
  00020	7c f4		 jl	 SHORT $LL7@lower_boun@2
$LN25@lower_boun@2:
  00022	5e		 pop	 esi
$LN21@lower_boun@2:

; 378  :   }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z ENDP ; btree::btree_linear_search_plain_compare<unsigned int,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >::lower_bound
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::lower_bound<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >, COMDAT
; _this$ = ecx

; 582  :   int lower_bound(const key_type &k, const Compare &comp) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 583  :     return search_type::lower_bound(k, *this, comp);

  00003	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00007	33 c0		 xor	 eax, eax
  00009	85 d2		 test	 edx, edx
  0000b	7e 16		 jle	 SHORT $LN25@lower_boun@3
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _k$[ebp]
  00011	8b 36		 mov	 esi, DWORD PTR [esi]
  00013	83 c1 08	 add	 ecx, 8
$LL11@lower_boun@3:
  00016	39 31		 cmp	 DWORD PTR [ecx], esi
  00018	73 08		 jae	 SHORT $LN29@lower_boun@3
  0001a	40		 inc	 eax
  0001b	83 c1 08	 add	 ecx, 8
  0001e	3b c2		 cmp	 eax, edx
  00020	7c f4		 jl	 SHORT $LL11@lower_boun@3
$LN29@lower_boun@3:
  00022	5e		 pop	 esi
$LN25@lower_boun@3:

; 584  :   }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::lower_bound<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
$T172252 = -12						; size = 12
$T172229 = 8						; size = 4
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = esi

; 541  : 		_Nodeptr _Buynode(_Nodeptr _Next,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 542  : 		_Nodeptr _Prev, _Valty&& _Val)
; 543  : 		{	// allocate a node and set links and value
; 544  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00006	6a 10		 push	 16			; 00000010H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 22		 je	 SHORT $LN10@Buynode

; 545  : 
; 546  : 		_TRY_BEGIN
; 547  : 		this->_Nextnode(_Pnode) = _Next;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]

; 548  : 		this->_Prevnode(_Pnode) = _Prev;

  00017	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
  0001a	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Pnode)),
; 550  : 			_STD forward<_Valty>(_Val));

  0001c	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00022	85 c9		 test	 ecx, ecx
  00024	74 0a		 je	 SHORT $LN2@Buynode
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	89 11		 mov	 DWORD PTR [ecx], edx
  0002a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN2@Buynode:

; 551  : 		_CATCH_ALL
; 552  : 		this->_Alnod.deallocate(_Pnode, 1);
; 553  : 		_RERAISE;
; 554  : 		_CATCH_END
; 555  : 
; 556  : 		return (_Pnode);
; 557  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8

; 542  : 		_Nodeptr _Prev, _Valty&& _Val)
; 543  : 		{	// allocate a node and set links and value
; 544  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

$LN10@Buynode:
  00036	8d 45 08	 lea	 eax, DWORD PTR $T172229[ebp]
  00039	50		 push	 eax
  0003a	8d 4d f4	 lea	 ecx, DWORD PTR $T172252[ebp]
  0003d	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T172229[ebp], 0
  00044	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00049	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004e	8d 4d f4	 lea	 ecx, DWORD PTR $T172252[ebp]
  00051	51		 push	 ecx
  00052	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T172252[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00059	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN59@Buynode:
$LN58@Buynode:
  0005e	cc		 int	 3
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_iter$ = 12						; size = 8
??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = eax

; 2238 :     const key_type &key, IterType iter) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 7d 0c	 mov	 edi, DWORD PTR _iter$[ebp]
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL3@internal_l@2:

; 2239 :   for (;;) {
; 2240 :     iter.position = iter.node->lower_bound(key, key_comp());

  00010	0f b6 77 03	 movzx	 esi, BYTE PTR [edi+3]
  00014	33 c9		 xor	 ecx, ecx
  00016	85 f6		 test	 esi, esi
  00018	7e 14		 jle	 SHORT $LN61@internal_l@2
  0001a	8b 55 08	 mov	 edx, DWORD PTR _key$[ebp]
  0001d	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0001f	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
$LL18@internal_l@2:
  00022	39 1a		 cmp	 DWORD PTR [edx], ebx
  00024	73 08		 jae	 SHORT $LN61@internal_l@2
  00026	41		 inc	 ecx
  00027	83 c2 08	 add	 edx, 8
  0002a	3b ce		 cmp	 ecx, esi
  0002c	7c f4		 jl	 SHORT $LL18@internal_l@2
$LN61@internal_l@2:
  0002e	89 4d 10	 mov	 DWORD PTR _iter$[ebp+4], ecx

; 2241 :     if (iter.node->leaf()) {

  00031	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00034	75 0c		 jne	 SHORT $LN59@internal_l@2

; 2242 :       break;
; 2243 :     }
; 2244 :     iter.node = iter.node->child(iter.position);

  00036	8b bc 8f 00 01
	00 00		 mov	 edi, DWORD PTR [edi+ecx*4+256]
  0003d	89 7d 0c	 mov	 DWORD PTR _iter$[ebp], edi

; 2245 :   }

  00040	eb ce		 jmp	 SHORT $LL3@internal_l@2
$LN59@internal_l@2:

; 2246 :   return std::make_pair(iter, 0);

  00042	89 38		 mov	 DWORD PTR [eax], edi
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00049	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00050	5b		 pop	 ebx

; 2247 : }

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z
_TEXT	SEGMENT
?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_root, COMDAT
; _f$ = eax
; _parent$ = ecx

; 707  :     btree_node *n = init_internal(f, parent);

  00000	32 d2		 xor	 dl, dl
  00002	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00008	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 708  :     f->rightmost = parent;

  00010	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx

; 709  :     f->size = parent->count();

  00016	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0001a	89 88 84 01 00
	00		 mov	 DWORD PTR [eax+388], ecx

; 710  :     return n;
; 711  :   }

  00020	c3		 ret	 0
?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z
_TEXT	SEGMENT
$T172613 = -12						; size = 12
$T172590 = 8						; size = 4
_parent$ = 8						; size = 4
?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_node, COMDAT

; 1252 :   node_type* new_leaf_node(node_type *parent) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1253 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1254 :         mutable_internal_allocator()->allocate(sizeof(leaf_fields)));

  00006	68 00 01 00 00	 push	 256			; 00000100H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 12		 je	 SHORT $LN7@new_leaf_n

; 1255 :     return node_type::init_leaf(p, parent, kNodeValues);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  0001c	c7 00 01 00 1f
	00		 mov	 DWORD PTR [eax], 2031617 ; 001f0001H
  00022	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1256 :   }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4

; 1253 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1254 :         mutable_internal_allocator()->allocate(sizeof(leaf_fields)));

$LN7@new_leaf_n:
  0002b	8d 55 08	 lea	 edx, DWORD PTR $T172590[ebp]
  0002e	89 4d 08	 mov	 DWORD PTR $T172590[ebp], ecx
  00031	52		 push	 edx
  00032	8d 4d f4	 lea	 ecx, DWORD PTR $T172613[ebp]
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 45 f4	 lea	 eax, DWORD PTR $T172613[ebp]
  00042	50		 push	 eax
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T172613[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@new_leaf_n:
$LN21@new_leaf_n:
  0004f	cc		 int	 3
?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
$T172659 = -12						; size = 12
$T172636 = 8						; size = 4
_this$ = 8						; size = 4
?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_root_node, COMDAT

; 1247 :   node_type* new_internal_root_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1248 :     root_fields *p = reinterpret_cast<root_fields*>(
; 1249 :         mutable_internal_allocator()->allocate(sizeof(root_fields)));

  00006	68 88 01 00 00	 push	 392			; 00000188H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 d2		 xor	 edx, edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c2		 cmp	 eax, edx
  00017	74 2c		 je	 SHORT $LN7@new_intern

; 1250 :     return node_type::init_root(p, root()->parent());

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00021	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00027	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0002a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0002d	88 10		 mov	 BYTE PTR [eax], dl
  0002f	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx
  00035	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00039	89 90 84 01 00
	00		 mov	 DWORD PTR [eax+388], edx

; 1251 :   }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4

; 1248 :     root_fields *p = reinterpret_cast<root_fields*>(
; 1249 :         mutable_internal_allocator()->allocate(sizeof(root_fields)));

$LN7@new_intern:
  00045	8d 45 08	 lea	 eax, DWORD PTR $T172636[ebp]
  00048	50		 push	 eax
  00049	8d 4d f4	 lea	 ecx, DWORD PTR $T172659[ebp]
  0004c	89 55 08	 mov	 DWORD PTR $T172636[ebp], edx
  0004f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00054	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00059	8d 4d f4	 lea	 ecx, DWORD PTR $T172659[ebp]
  0005c	51		 push	 ecx
  0005d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T172659[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@new_intern:
$LN32@new_intern:
  00069	cc		 int	 3
?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_root_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z
_TEXT	SEGMENT
$T172739 = -12						; size = 12
$T172716 = 8						; size = 4
_parent$ = 8						; size = 4
?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_node, COMDAT

; 1242 :   node_type* new_internal_node(node_type *parent) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1243 :     internal_fields *p = reinterpret_cast<internal_fields*>(
; 1244 :         mutable_internal_allocator()->allocate(sizeof(internal_fields)));

  00006	68 80 01 00 00	 push	 384			; 00000180H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 17		 je	 SHORT $LN7@new_intern@2

; 1245 :     return node_type::init_internal(p, parent);

  00019	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  0001c	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00022	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00025	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00028	88 08		 mov	 BYTE PTR [eax], cl

; 1246 :   }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4

; 1243 :     internal_fields *p = reinterpret_cast<internal_fields*>(
; 1244 :         mutable_internal_allocator()->allocate(sizeof(internal_fields)));

$LN7@new_intern@2:
  00030	8d 45 08	 lea	 eax, DWORD PTR $T172716[ebp]
  00033	89 4d 08	 mov	 DWORD PTR $T172716[ebp], ecx
  00036	50		 push	 eax
  00037	8d 4d f4	 lea	 ecx, DWORD PTR $T172739[ebp]
  0003a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00044	8d 4d f4	 lea	 ecx, DWORD PTR $T172739[ebp]
  00047	51		 push	 ecx
  00048	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T172739[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN25@new_intern@2:
$LN24@new_intern@2:
  00054	cc		 int	 3
?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_node
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 4
??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Insert_rv<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = esi

; 746  : 		void _Insert_rv(const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		_Valty&& _Val)
; 748  : 		{	// insert _Val at _Where
; 749  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 750  : 		if (_Where._Getcont() != this)
; 751  : 			_DEBUG_ERROR("list insert iterator outside range");
; 752  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 753  : 
; 754  : 		_Nodeptr _Pnode = _Where._Mynode();
; 755  : 		_Nodeptr _Newnode =
; 756  : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 757  : 				_STD forward<_Valty>(_Val));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000d	57		 push	 edi
  0000e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >

; 758  : 		_Incsize(1);

  00018	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001b	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00020	2b d1		 sub	 edx, ecx
  00022	83 fa 01	 cmp	 edx, 1
  00025	73 0a		 jae	 SHORT $LN9@Insert_rv
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN26@Insert_rv:
$LN9@Insert_rv:
  00031	41		 inc	 ecx
  00032	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 759  : 		this->_Prevnode(_Pnode) = _Newnode;

  00035	89 07		 mov	 DWORD PTR [edi], eax

; 760  : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	5f		 pop	 edi
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	5b		 pop	 ebx

; 761  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN25@Insert_rv:
??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Insert_rv<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
_iter$ = 12						; size = 8
??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree_internal_locate_plain_compare::dispatch<unsigned int,btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = esi

; 840  :   static std::pair<Iter, int> dispatch(const K &k, const T &t, Iter iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 841  :     return t.internal_locate_plain_compare(k, iter);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iter$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	8b c4		 mov	 eax, esp
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	8b 55 10	 mov	 edx, DWORD PTR _iter$[ebp+4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00016	50		 push	 eax
  00017	8b c6		 mov	 eax, esi
  00019	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  0001e	8b c6		 mov	 eax, esi

; 842  :   }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree_internal_locate_plain_compare::dispatch<unsigned int,btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z
_TEXT	SEGMENT
_n$ = -12						; size = 4
__Tmp$173024 = -8					; size = 4
__Tmp$173013 = -8					; size = 4
$T172821 = -8						; size = 4
tv276 = -4						; size = 4
tv203 = -4						; size = 4
$T172820 = -4						; size = 4
?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap, COMDAT
; _this$ = edx
; _x$ = edi

; 1624 : void btree_node<P>::swap(btree_node *x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1625 :   assert(leaf() == x->leaf());
; 1626 : 
; 1627 :   // Swap the values.
; 1628 :   for (int i = count(); i < x->count(); ++i) {

  00003	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00007	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	3b c1		 cmp	 eax, ecx
  00012	7d 21		 jge	 SHORT $LN154@swap
  00014	8d 4c c2 08	 lea	 ecx, DWORD PTR [edx+eax*8+8]
$LL25@swap:

; 1629 :     value_init(i);

  00018	85 c9		 test	 ecx, ecx
  0001a	74 0d		 je	 SHORT $LN34@swap
  0001c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00022	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN34@swap:

; 1625 :   assert(leaf() == x->leaf());
; 1626 : 
; 1627 :   // Swap the values.
; 1628 :   for (int i = count(); i < x->count(); ++i) {

  00029	0f b6 77 03	 movzx	 esi, BYTE PTR [edi+3]
  0002d	40		 inc	 eax
  0002e	83 c1 08	 add	 ecx, 8
  00031	3b c6		 cmp	 eax, esi
  00033	7c e3		 jl	 SHORT $LL25@swap
$LN154@swap:

; 1630 :   }
; 1631 :   for (int i = x->count(); i < count(); ++i) {

  00035	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00039	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  0003d	3b c1		 cmp	 eax, ecx
  0003f	7d 21		 jge	 SHORT $LN155@swap
  00041	8d 4c c7 08	 lea	 ecx, DWORD PTR [edi+eax*8+8]
$LL22@swap:

; 1632 :     x->value_init(i);

  00045	85 c9		 test	 ecx, ecx
  00047	74 0d		 je	 SHORT $LN48@swap
  00049	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN48@swap:

; 1630 :   }
; 1631 :   for (int i = x->count(); i < count(); ++i) {

  00056	0f b6 72 03	 movzx	 esi, BYTE PTR [edx+3]
  0005a	40		 inc	 eax
  0005b	83 c1 08	 add	 ecx, 8
  0005e	3b c6		 cmp	 eax, esi
  00060	7c e3		 jl	 SHORT $LL22@swap
$LN155@swap:

; 1633 :   }
; 1634 :   int n = std::max(count(), x->count());

  00062	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00066	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  0006a	89 45 fc	 mov	 DWORD PTR $T172820[ebp], eax
  0006d	3b c8		 cmp	 ecx, eax
  0006f	89 4d f8	 mov	 DWORD PTR $T172821[ebp], ecx
  00072	8d 45 fc	 lea	 eax, DWORD PTR $T172820[ebp]
  00075	7c 03		 jl	 SHORT $LN63@swap
  00077	8d 45 f8	 lea	 eax, DWORD PTR $T172821[ebp]
$LN63@swap:
  0007a	8b 18		 mov	 ebx, DWORD PTR [eax]
  0007c	89 5d f4	 mov	 DWORD PTR _n$[ebp], ebx

; 1635 :   for (int i = 0; i < n; ++i) {

  0007f	85 db		 test	 ebx, ebx
  00081	7e 3b		 jle	 SHORT $LN17@swap
  00083	8b f7		 mov	 esi, edi
  00085	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00088	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0008b	2b f2		 sub	 esi, edx
  0008d	89 5d fc	 mov	 DWORD PTR tv276[ebp], ebx
$LL19@swap:

; 1636 :     value_swap(i, x, i);

  00090	8b 58 fc	 mov	 ebx, DWORD PTR [eax-4]
  00093	89 5d f8	 mov	 DWORD PTR __Tmp$173013[ebp], ebx
  00096	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00098	89 58 fc	 mov	 DWORD PTR [eax-4], ebx
  0009b	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$173013[ebp]
  0009e	89 19		 mov	 DWORD PTR [ecx], ebx
  000a0	8b 18		 mov	 ebx, DWORD PTR [eax]
  000a2	89 5d f8	 mov	 DWORD PTR __Tmp$173024[ebp], ebx
  000a5	8b 1c 06	 mov	 ebx, DWORD PTR [esi+eax]
  000a8	89 18		 mov	 DWORD PTR [eax], ebx
  000aa	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$173024[ebp]
  000ad	89 1c 06	 mov	 DWORD PTR [esi+eax], ebx
  000b0	83 c1 08	 add	 ecx, 8
  000b3	83 c0 08	 add	 eax, 8
  000b6	ff 4d fc	 dec	 DWORD PTR tv276[ebp]
  000b9	75 d5		 jne	 SHORT $LL19@swap

; 1635 :   for (int i = 0; i < n; ++i) {

  000bb	8b 5d f4	 mov	 ebx, DWORD PTR _n$[ebp]
$LN17@swap:

; 1637 :   }
; 1638 :   for (int i = count(); i < x->count(); ++i) {
; 1639 :     x->value_destroy(i);
; 1640 :   }
; 1641 :   for (int i = x->count(); i < count(); ++i) {
; 1642 :     value_destroy(i);
; 1643 :   }
; 1644 : 
; 1645 :   if (!leaf()) {

  000be	80 3a 00	 cmp	 BYTE PTR [edx], 0
  000c1	75 60		 jne	 SHORT $LN1@swap

; 1646 :     // Swap the child pointers.
; 1647 :     for (int i = 0; i <= n; ++i) {

  000c3	85 db		 test	 ebx, ebx
  000c5	78 20		 js	 SHORT $LN156@swap
  000c7	8b cf		 mov	 ecx, edi
  000c9	2b ca		 sub	 ecx, edx
  000cb	43		 inc	 ebx
  000cc	8d 82 00 01 00
	00		 lea	 eax, DWORD PTR [edx+256]
  000d2	89 5d fc	 mov	 DWORD PTR tv203[ebp], ebx
$LL9@swap:

; 1648 :       btree_swap_helper(*mutable_child(i), *x->mutable_child(i));

  000d5	8b 1c 08	 mov	 ebx, DWORD PTR [eax+ecx]
  000d8	8b 30		 mov	 esi, DWORD PTR [eax]
  000da	89 18		 mov	 DWORD PTR [eax], ebx
  000dc	89 34 08	 mov	 DWORD PTR [eax+ecx], esi
  000df	83 c0 04	 add	 eax, 4
  000e2	ff 4d fc	 dec	 DWORD PTR tv203[ebp]
  000e5	75 ee		 jne	 SHORT $LL9@swap
$LN156@swap:

; 1649 :     }
; 1650 :     for (int i = 0; i <= count(); ++i) {

  000e7	33 c0		 xor	 eax, eax
  000e9	38 42 03	 cmp	 BYTE PTR [edx+3], al
  000ec	72 17		 jb	 SHORT $LN157@swap
  000ee	8d 8f 00 01 00
	00		 lea	 ecx, DWORD PTR [edi+256]
$LL6@swap:

; 1651 :       x->child(i)->fields_.parent = x;

  000f4	8b 31		 mov	 esi, DWORD PTR [ecx]
  000f6	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000f9	0f b6 72 03	 movzx	 esi, BYTE PTR [edx+3]
  000fd	40		 inc	 eax
  000fe	83 c1 04	 add	 ecx, 4
  00101	3b c6		 cmp	 eax, esi
  00103	7e ef		 jle	 SHORT $LL6@swap
$LN157@swap:

; 1652 :     }
; 1653 :     for (int i = 0; i <= x->count(); ++i) {

  00105	33 c0		 xor	 eax, eax
  00107	38 47 03	 cmp	 BYTE PTR [edi+3], al
  0010a	72 17		 jb	 SHORT $LN1@swap
  0010c	8d 8a 00 01 00
	00		 lea	 ecx, DWORD PTR [edx+256]
$LL3@swap:

; 1654 :       child(i)->fields_.parent = this;

  00112	8b 31		 mov	 esi, DWORD PTR [ecx]
  00114	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00117	0f b6 77 03	 movzx	 esi, BYTE PTR [edi+3]
  0011b	40		 inc	 eax
  0011c	83 c1 04	 add	 ecx, 4
  0011f	3b c6		 cmp	 eax, esi
  00121	7e ef		 jle	 SHORT $LL3@swap
$LN1@swap:

; 1655 :     }
; 1656 :   }
; 1657 : 
; 1658 :   // Swap the counts.
; 1659 :   btree_swap_helper(fields_.count, x->fields_.count);

  00123	8a 4f 03	 mov	 cl, BYTE PTR [edi+3]
  00126	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00129	5e		 pop	 esi
  0012a	88 4a 03	 mov	 BYTE PTR [edx+3], cl
  0012d	88 47 03	 mov	 BYTE PTR [edi+3], al
  00130	5b		 pop	 ebx

; 1660 : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z
_TEXT	SEGMENT
tv987 = -12						; size = 4
__Tmp$173731 = -12					; size = 4
__Tmp$173727 = -12					; size = 4
__Tmp$173592 = -12					; size = 4
__Tmp$173588 = -12					; size = 4
__Tmp$173324 = -12					; size = 4
__Tmp$173313 = -12					; size = 4
tv1096 = -8						; size = 4
_i$157726 = -8						; size = 4
_i$157717 = -8						; size = 4
tv1045 = -4						; size = 4
?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right, COMDAT
; _this$ = esi
; _dest$ = eax
; _to_move$ = ecx

; 1506 : void btree_node<P>::rebalance_left_to_right(btree_node *dest, int to_move) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1507 :   assert(parent() == dest->parent());
; 1508 :   assert(position() + 1 == dest->position());
; 1509 :   assert(count() >= dest->count());
; 1510 :   assert(to_move >= 1);
; 1511 :   assert(to_move <= count());
; 1512 : 
; 1513 :   // Make room in the right node for the new values.
; 1514 :   for (int i = 0; i < to_move; ++i) {

  00007	33 db		 xor	 ebx, ebx
  00009	33 d2		 xor	 edx, edx
  0000b	57		 push	 edi
  0000c	3b cb		 cmp	 ecx, ebx
  0000e	7e 18		 jle	 SHORT $LN14@rebalance_
$LL16@rebalance_:

; 1515 :     dest->value_init(i + dest->count());

  00010	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  00014	03 fa		 add	 edi, edx
  00016	8d 7c f8 08	 lea	 edi, DWORD PTR [eax+edi*8+8]
  0001a	3b fb		 cmp	 edi, ebx
  0001c	74 05		 je	 SHORT $LN23@rebalance_
  0001e	89 1f		 mov	 DWORD PTR [edi], ebx
  00020	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN23@rebalance_:

; 1507 :   assert(parent() == dest->parent());
; 1508 :   assert(position() + 1 == dest->position());
; 1509 :   assert(count() >= dest->count());
; 1510 :   assert(to_move >= 1);
; 1511 :   assert(to_move <= count());
; 1512 : 
; 1513 :   // Make room in the right node for the new values.
; 1514 :   for (int i = 0; i < to_move; ++i) {

  00023	42		 inc	 edx
  00024	3b d1		 cmp	 edx, ecx
  00026	7c e8		 jl	 SHORT $LL16@rebalance_
$LN14@rebalance_:

; 1516 :   }
; 1517 :   for (int i = dest->count() - 1; i >= 0; --i) {

  00028	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0002c	4a		 dec	 edx
  0002d	89 55 f8	 mov	 DWORD PTR _i$157717[ebp], edx
  00030	78 3f		 js	 SHORT $LN11@rebalance_
  00032	8d 7c d0 08	 lea	 edi, DWORD PTR [eax+edx*8+8]
  00036	03 d1		 add	 edx, ecx
  00038	8d 54 d0 08	 lea	 edx, DWORD PTR [eax+edx*8+8]
  0003c	8d 64 24 00	 npad	 4
$LL13@rebalance_:

; 1518 :     dest->value_swap(i, dest, i + to_move);

  00040	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00042	89 5d f4	 mov	 DWORD PTR __Tmp$173313[ebp], ebx
  00045	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00047	89 1f		 mov	 DWORD PTR [edi], ebx
  00049	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$173313[ebp]
  0004c	89 1a		 mov	 DWORD PTR [edx], ebx
  0004e	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00051	89 5d f4	 mov	 DWORD PTR __Tmp$173324[ebp], ebx
  00054	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00057	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0005a	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$173324[ebp]
  0005d	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
  00060	8b 5d f8	 mov	 ebx, DWORD PTR _i$157717[ebp]
  00063	4b		 dec	 ebx
  00064	83 ea 08	 sub	 edx, 8
  00067	83 ef 08	 sub	 edi, 8
  0006a	89 5d f8	 mov	 DWORD PTR _i$157717[ebp], ebx
  0006d	85 db		 test	 ebx, ebx
  0006f	79 cf		 jns	 SHORT $LL13@rebalance_
$LN11@rebalance_:

; 1519 :   }
; 1520 : 
; 1521 :   // Move the delimiting value to the right node and the new delimiting value
; 1522 :   // from the left node.
; 1523 :   dest->value_swap(to_move - 1, parent(), position());

  00071	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  00075	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00078	8b 5c d7 08	 mov	 ebx, DWORD PTR [edi+edx*8+8]
  0007c	8d 54 d7 08	 lea	 edx, DWORD PTR [edi+edx*8+8]
  00080	8b 3c c8	 mov	 edi, DWORD PTR [eax+ecx*8]
  00083	89 1c c8	 mov	 DWORD PTR [eax+ecx*8], ebx
  00086	89 3a		 mov	 DWORD PTR [edx], edi
  00088	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  0008b	8b 7c c8 04	 mov	 edi, DWORD PTR [eax+ecx*8+4]
  0008f	89 5c c8 04	 mov	 DWORD PTR [eax+ecx*8+4], ebx
  00093	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1524 :   parent()->value_swap(position(), this, count() - to_move);

  00096	0f b6 7e 01	 movzx	 edi, BYTE PTR [esi+1]
  0009a	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  0009e	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  000a1	8d 7c fb 08	 lea	 edi, DWORD PTR [ebx+edi*8+8]
  000a5	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000a7	2b d1		 sub	 edx, ecx
  000a9	8d 54 d6 08	 lea	 edx, DWORD PTR [esi+edx*8+8]
  000ad	89 5d f4	 mov	 DWORD PTR __Tmp$173588[ebp], ebx
  000b0	8b 1a		 mov	 ebx, DWORD PTR [edx]
  000b2	89 1f		 mov	 DWORD PTR [edi], ebx
  000b4	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$173588[ebp]
  000b7	89 1a		 mov	 DWORD PTR [edx], ebx
  000b9	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000bc	89 5d f4	 mov	 DWORD PTR __Tmp$173592[ebp], ebx
  000bf	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  000c2	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000c5	8b 7d f4	 mov	 edi, DWORD PTR __Tmp$173592[ebp]
  000c8	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1525 :   value_destroy(count() - to_move);
; 1526 : 
; 1527 :   // Move the values from the left to the right node.
; 1528 :   for (int i = 1; i < to_move; ++i) {

  000cb	ba 01 00 00 00	 mov	 edx, 1
  000d0	3b ca		 cmp	 ecx, edx
  000d2	7e 37		 jle	 SHORT $LN209@rebalance_
$LL10@rebalance_:

; 1529 :     value_swap(count() - to_move + i, dest, i - 1);

  000d4	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  000d8	2b f9		 sub	 edi, ecx
  000da	03 fa		 add	 edi, edx
  000dc	8b 5c fe 08	 mov	 ebx, DWORD PTR [esi+edi*8+8]
  000e0	8d 7c fe 08	 lea	 edi, DWORD PTR [esi+edi*8+8]
  000e4	89 5d f4	 mov	 DWORD PTR __Tmp$173727[ebp], ebx
  000e7	8b 1c d0	 mov	 ebx, DWORD PTR [eax+edx*8]
  000ea	89 1f		 mov	 DWORD PTR [edi], ebx
  000ec	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$173727[ebp]
  000ef	89 1c d0	 mov	 DWORD PTR [eax+edx*8], ebx
  000f2	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000f5	89 5d f4	 mov	 DWORD PTR __Tmp$173731[ebp], ebx
  000f8	8b 5c d0 04	 mov	 ebx, DWORD PTR [eax+edx*8+4]
  000fc	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000ff	8b 7d f4	 mov	 edi, DWORD PTR __Tmp$173731[ebp]
  00102	89 7c d0 04	 mov	 DWORD PTR [eax+edx*8+4], edi
  00106	42		 inc	 edx
  00107	3b d1		 cmp	 edx, ecx
  00109	7c c9		 jl	 SHORT $LL10@rebalance_
$LN209@rebalance_:

; 1530 :     value_destroy(count() - to_move + i);
; 1531 :   }
; 1532 : 
; 1533 :   if (!leaf()) {

  0010b	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0010e	0f 85 97 00 00
	00		 jne	 $LN208@rebalance_

; 1534 :     // Move the child pointers from the left to the right node.
; 1535 :     for (int i = dest->count(); i >= 0; --i) {

  00114	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  00118	89 55 f8	 mov	 DWORD PTR _i$157726[ebp], edx
  0011b	85 d2		 test	 edx, edx
  0011d	78 41		 js	 SHORT $LN4@rebalance_
  0011f	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]
  00122	89 7d f4	 mov	 DWORD PTR tv987[ebp], edi
  00125	8d bc b8 00 01
	00 00		 lea	 edi, DWORD PTR [eax+edi*4+256]
  0012c	8d 94 90 00 01
	00 00		 lea	 edx, DWORD PTR [eax+edx*4+256]
  00133	89 7d fc	 mov	 DWORD PTR tv1045[ebp], edi
$LL6@rebalance_:

; 1536 :       dest->set_child(i + to_move, dest->child(i));

  00136	8b 3a		 mov	 edi, DWORD PTR [edx]
  00138	8b 5d fc	 mov	 ebx, DWORD PTR tv1045[ebp]
  0013b	ff 4d f8	 dec	 DWORD PTR _i$157726[ebp]
  0013e	83 6d fc 04	 sub	 DWORD PTR tv1045[ebp], 4
  00142	89 3b		 mov	 DWORD PTR [ebx], edi
  00144	8b 5d f4	 mov	 ebx, DWORD PTR tv987[ebp]
  00147	88 5f 01	 mov	 BYTE PTR [edi+1], bl
  0014a	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1537 :       *dest->mutable_child(i) = NULL;

  0014d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00153	4b		 dec	 ebx
  00154	83 ea 04	 sub	 edx, 4
  00157	83 7d f8 00	 cmp	 DWORD PTR _i$157726[ebp], 0
  0015b	89 5d f4	 mov	 DWORD PTR tv987[ebp], ebx
  0015e	7d d6		 jge	 SHORT $LL6@rebalance_
$LN4@rebalance_:

; 1538 :     }
; 1539 :     for (int i = 1; i <= to_move; ++i) {

  00160	ba 01 00 00 00	 mov	 edx, 1
  00165	3b ca		 cmp	 ecx, edx
  00167	7c 42		 jl	 SHORT $LN208@rebalance_
  00169	8d b8 00 01 00
	00		 lea	 edi, DWORD PTR [eax+256]
  0016f	89 7d f8	 mov	 DWORD PTR tv1096[ebp], edi
$LL3@rebalance_:

; 1540 :       dest->set_child(i - 1, child(count() - to_move + i));

  00172	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  00176	8b 5d f8	 mov	 ebx, DWORD PTR tv1096[ebp]
  00179	83 45 f8 04	 add	 DWORD PTR tv1096[ebp], 4
  0017d	2b f9		 sub	 edi, ecx
  0017f	03 fa		 add	 edi, edx
  00181	8b bc be 00 01
	00 00		 mov	 edi, DWORD PTR [esi+edi*4+256]
  00188	89 3b		 mov	 DWORD PTR [ebx], edi
  0018a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0018d	8d 5a ff	 lea	 ebx, DWORD PTR [edx-1]
  00190	88 5f 01	 mov	 BYTE PTR [edi+1], bl

; 1541 :       *mutable_child(count() - to_move + i) = NULL;

  00193	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  00197	2b f9		 sub	 edi, ecx
  00199	03 fa		 add	 edi, edx
  0019b	42		 inc	 edx
  0019c	c7 84 be 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edi*4+256], 0
  001a7	3b d1		 cmp	 edx, ecx
  001a9	7e c7		 jle	 SHORT $LL3@rebalance_
$LN208@rebalance_:

; 1542 :     }
; 1543 :   }
; 1544 : 
; 1545 :   // Fixup the counts on the src and dest nodes.
; 1546 :   set_count(count() - to_move);

  001ab	28 4e 03	 sub	 BYTE PTR [esi+3], cl

; 1547 :   dest->set_count(dest->count() + to_move);

  001ae	00 48 03	 add	 BYTE PTR [eax+3], cl
  001b1	5f		 pop	 edi
  001b2	5b		 pop	 ebx

; 1548 : }

  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z
_TEXT	SEGMENT
tv916 = -8						; size = 4
__Tmp$174386 = -8					; size = 4
__Tmp$174378 = -8					; size = 4
$T174418 = -8						; size = 4
_i$157696 = -8						; size = 4
tv984 = -4						; size = 4
$T174425 = -4						; size = 4
tv1040 = 8						; size = 4
__Tmp$174257 = 8					; size = 4
__Tmp$174246 = 8					; size = 4
$T174406 = 8						; size = 4
__Tmp$173983 = 8					; size = 4
__Tmp$173979 = 8					; size = 4
_i$157683 = 8						; size = 4
_this$ = 8						; size = 4
?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left, COMDAT
; _src$ = eax
; _to_move$ = edx

; 1459 : void btree_node<P>::rebalance_right_to_left(btree_node *src, int to_move) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1460 :   assert(parent() == src->parent());
; 1461 :   assert(position() + 1 == src->position());
; 1462 :   assert(src->count() >= count());
; 1463 :   assert(to_move >= 1);
; 1464 :   assert(to_move <= src->count());
; 1465 : 
; 1466 :   // Make room in the left node for the new values.
; 1467 :   for (int i = 0; i < to_move; ++i) {

  0000b	33 db		 xor	 ebx, ebx
  0000d	33 f6		 xor	 esi, esi
  0000f	57		 push	 edi
  00010	3b d3		 cmp	 edx, ebx
  00012	7e 18		 jle	 SHORT $LN17@rebalance_@2
$LL19@rebalance_@2:

; 1468 :     value_init(i + count());

  00014	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00018	03 fe		 add	 edi, esi
  0001a	8d 7c f9 08	 lea	 edi, DWORD PTR [ecx+edi*8+8]
  0001e	3b fb		 cmp	 edi, ebx
  00020	74 05		 je	 SHORT $LN26@rebalance_@2
  00022	89 1f		 mov	 DWORD PTR [edi], ebx
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN26@rebalance_@2:

; 1460 :   assert(parent() == src->parent());
; 1461 :   assert(position() + 1 == src->position());
; 1462 :   assert(src->count() >= count());
; 1463 :   assert(to_move >= 1);
; 1464 :   assert(to_move <= src->count());
; 1465 : 
; 1466 :   // Make room in the left node for the new values.
; 1467 :   for (int i = 0; i < to_move; ++i) {

  00027	46		 inc	 esi
  00028	3b f2		 cmp	 esi, edx
  0002a	7c e8		 jl	 SHORT $LL19@rebalance_@2
$LN17@rebalance_@2:

; 1469 :   }
; 1470 : 
; 1471 :   // Move the delimiting value to the left node and the new delimiting value
; 1472 :   // from the right node.
; 1473 :   value_swap(count(), parent(), position());

  0002c	0f b6 71 01	 movzx	 esi, BYTE PTR [ecx+1]
  00030	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00033	8d 74 f7 08	 lea	 esi, DWORD PTR [edi+esi*8+8]
  00037	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  0003b	8b 5c f9 08	 mov	 ebx, DWORD PTR [ecx+edi*8+8]
  0003f	8d 7c f9 08	 lea	 edi, DWORD PTR [ecx+edi*8+8]
  00043	89 5d 08	 mov	 DWORD PTR __Tmp$173979[ebp], ebx
  00046	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00048	89 1f		 mov	 DWORD PTR [edi], ebx
  0004a	8b 5d 08	 mov	 ebx, DWORD PTR __Tmp$173979[ebp]
  0004d	89 1e		 mov	 DWORD PTR [esi], ebx
  0004f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00052	89 5d 08	 mov	 DWORD PTR __Tmp$173983[ebp], ebx
  00055	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00058	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0005b	8b 7d 08	 mov	 edi, DWORD PTR __Tmp$173983[ebp]
  0005e	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 1474 :   parent()->value_swap(position(), src, to_move - 1);

  00061	0f b6 71 01	 movzx	 esi, BYTE PTR [ecx+1]
  00065	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00068	8b 1c d0	 mov	 ebx, DWORD PTR [eax+edx*8]
  0006b	8d 74 f7 08	 lea	 esi, DWORD PTR [edi+esi*8+8]
  0006f	8b 3e		 mov	 edi, DWORD PTR [esi]
  00071	89 1e		 mov	 DWORD PTR [esi], ebx
  00073	89 3c d0	 mov	 DWORD PTR [eax+edx*8], edi
  00076	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00079	8b 5c d0 04	 mov	 ebx, DWORD PTR [eax+edx*8+4]
  0007d	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 1475 : 
; 1476 :   // Move the values from the right to the left node.
; 1477 :   for (int i = 1; i < to_move; ++i) {

  00080	be 01 00 00 00	 mov	 esi, 1
  00085	89 7c d0 04	 mov	 DWORD PTR [eax+edx*8+4], edi
  00089	3b d6		 cmp	 edx, esi
  0008b	7e 38		 jle	 SHORT $LN208@rebalance_@2
  0008d	8d 49 00	 npad	 3
$LL16@rebalance_@2:

; 1478 :     value_swap(count() + i, src, i - 1);

  00090	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00094	03 fe		 add	 edi, esi
  00096	8b 5c f9 08	 mov	 ebx, DWORD PTR [ecx+edi*8+8]
  0009a	8d 7c f9 08	 lea	 edi, DWORD PTR [ecx+edi*8+8]
  0009e	89 5d 08	 mov	 DWORD PTR __Tmp$174246[ebp], ebx
  000a1	8b 1c f0	 mov	 ebx, DWORD PTR [eax+esi*8]
  000a4	89 1f		 mov	 DWORD PTR [edi], ebx
  000a6	8b 5d 08	 mov	 ebx, DWORD PTR __Tmp$174246[ebp]
  000a9	89 1c f0	 mov	 DWORD PTR [eax+esi*8], ebx
  000ac	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000af	89 5d 08	 mov	 DWORD PTR __Tmp$174257[ebp], ebx
  000b2	8b 5c f0 04	 mov	 ebx, DWORD PTR [eax+esi*8+4]
  000b6	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000b9	8b 7d 08	 mov	 edi, DWORD PTR __Tmp$174257[ebp]
  000bc	89 7c f0 04	 mov	 DWORD PTR [eax+esi*8+4], edi
  000c0	46		 inc	 esi
  000c1	3b f2		 cmp	 esi, edx
  000c3	7c cb		 jl	 SHORT $LL16@rebalance_@2
$LN208@rebalance_@2:

; 1479 :   }
; 1480 :   // Shift the values in the right node to their correct position.
; 1481 :   for (int i = to_move; i < src->count(); ++i) {

  000c5	0f b6 70 03	 movzx	 esi, BYTE PTR [eax+3]
  000c9	89 55 08	 mov	 DWORD PTR _i$157683[ebp], edx
  000cc	3b d6		 cmp	 edx, esi
  000ce	7d 4b		 jge	 SHORT $LN11@rebalance_@2
  000d0	8d 74 d0 08	 lea	 esi, DWORD PTR [eax+edx*8+8]
  000d4	8d 78 08	 lea	 edi, DWORD PTR [eax+8]
  000d7	eb 0a		 jmp	 SHORT $LN13@rebalance_@2
  000d9	8d a4 24 00 00
	00 00		 npad	 7
$LL207@rebalance_@2:
  000e0	8b 7d f8	 mov	 edi, DWORD PTR tv916[ebp]
$LN13@rebalance_@2:

; 1482 :     src->value_swap(i - to_move, src, i);

  000e3	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000e5	89 5d f8	 mov	 DWORD PTR __Tmp$174378[ebp], ebx
  000e8	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000ea	89 1f		 mov	 DWORD PTR [edi], ebx
  000ec	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$174378[ebp]
  000ef	89 1e		 mov	 DWORD PTR [esi], ebx
  000f1	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000f4	89 5d f8	 mov	 DWORD PTR __Tmp$174386[ebp], ebx
  000f7	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  000fa	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000fd	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$174386[ebp]
  00100	83 c7 08	 add	 edi, 8
  00103	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00106	8b 5d 08	 mov	 ebx, DWORD PTR _i$157683[ebp]
  00109	89 7d f8	 mov	 DWORD PTR tv916[ebp], edi
  0010c	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  00110	43		 inc	 ebx
  00111	83 c6 08	 add	 esi, 8
  00114	89 5d 08	 mov	 DWORD PTR _i$157683[ebp], ebx
  00117	3b df		 cmp	 ebx, edi
  00119	7c c5		 jl	 SHORT $LL207@rebalance_@2
$LN11@rebalance_@2:

; 1483 :   }
; 1484 :   for (int i = 1; i <= to_move; ++i) {
; 1485 :     src->value_destroy(src->count() - i);
; 1486 :   }
; 1487 : 
; 1488 :   if (!leaf()) {

  0011b	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0011e	0f 85 8b 00 00
	00		 jne	 $LN205@rebalance_@2

; 1489 :     // Move the child pointers from the right to the left node.
; 1490 :     for (int i = 0; i < to_move; ++i) {

  00124	33 f6		 xor	 esi, esi
  00126	85 d2		 test	 edx, edx
  00128	7e 38		 jle	 SHORT $LN4@rebalance_@2
  0012a	8d b8 00 01 00
	00		 lea	 edi, DWORD PTR [eax+256]
  00130	89 7d fc	 mov	 DWORD PTR tv984[ebp], edi
$LL6@rebalance_@2:

; 1491 :       set_child(1 + count() + i, src->child(i));

  00133	8b 7d fc	 mov	 edi, DWORD PTR tv984[ebp]
  00136	8b 3f		 mov	 edi, DWORD PTR [edi]
  00138	83 45 fc 04	 add	 DWORD PTR tv984[ebp], 4
  0013c	89 7d 08	 mov	 DWORD PTR $T174406[ebp], edi
  0013f	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00143	8d 7c 37 01	 lea	 edi, DWORD PTR [edi+esi+1]
  00147	89 7d f8	 mov	 DWORD PTR $T174418[ebp], edi
  0014a	8b 7d 08	 mov	 edi, DWORD PTR $T174406[ebp]
  0014d	8b 5d f8	 mov	 ebx, DWORD PTR $T174418[ebp]
  00150	46		 inc	 esi
  00151	89 bc 99 00 01
	00 00		 mov	 DWORD PTR [ecx+ebx*4+256], edi
  00158	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0015b	88 5f 01	 mov	 BYTE PTR [edi+1], bl
  0015e	3b f2		 cmp	 esi, edx
  00160	7c d1		 jl	 SHORT $LL6@rebalance_@2
$LN4@rebalance_@2:

; 1492 :     }
; 1493 :     for (int i = 0; i <= src->count() - to_move; ++i) {

  00162	0f b6 70 03	 movzx	 esi, BYTE PTR [eax+3]
  00166	2b f2		 sub	 esi, edx
  00168	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$157696[ebp], 0
  0016f	78 3e		 js	 SHORT $LN205@rebalance_@2
  00171	8d b8 00 01 00
	00		 lea	 edi, DWORD PTR [eax+256]
  00177	8d b4 90 00 01
	00 00		 lea	 esi, DWORD PTR [eax+edx*4+256]
  0017e	89 7d 08	 mov	 DWORD PTR tv1040[ebp], edi
$LL206@rebalance_@2:

; 1494 :       assert(i + to_move <= src->max_count());
; 1495 :       src->set_child(i, src->child(i + to_move));

  00181	8b 3e		 mov	 edi, DWORD PTR [esi]
  00183	8b 5d 08	 mov	 ebx, DWORD PTR tv1040[ebp]
  00186	83 45 08 04	 add	 DWORD PTR tv1040[ebp], 4
  0018a	89 3b		 mov	 DWORD PTR [ebx], edi
  0018c	8b 5d f8	 mov	 ebx, DWORD PTR _i$157696[ebp]
  0018f	88 5f 01	 mov	 BYTE PTR [edi+1], bl
  00192	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00195	89 7d fc	 mov	 DWORD PTR $T174425[ebp], edi

; 1496 :       *src->mutable_child(i + to_move) = NULL;

  00198	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0019e	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  001a2	43		 inc	 ebx
  001a3	2b fa		 sub	 edi, edx
  001a5	83 c6 04	 add	 esi, 4
  001a8	89 5d f8	 mov	 DWORD PTR _i$157696[ebp], ebx
  001ab	3b df		 cmp	 ebx, edi
  001ad	7e d2		 jle	 SHORT $LL206@rebalance_@2
$LN205@rebalance_@2:

; 1497 :     }
; 1498 :   }
; 1499 : 
; 1500 :   // Fixup the counts on the src and dest nodes.
; 1501 :   set_count(count() + to_move);

  001af	00 51 03	 add	 BYTE PTR [ecx+3], dl

; 1502 :   src->set_count(src->count() - to_move);

  001b2	28 50 03	 sub	 BYTE PTR [eax+3], dl
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx

; 1503 : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c2 04 00	 ret	 4
?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value, COMDAT
; _this$ = esi
; _i$ = eax
; _x$ = ecx

; 1422 : inline void btree_node<P>::insert_value(int i, const value_type &x) {

  00000	57		 push	 edi
  00001	8b f8		 mov	 edi, eax

; 1423 :   assert(i <= count());
; 1424 :   value_init(count(), x);

  00003	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00007	8d 44 c6 08	 lea	 eax, DWORD PTR [esi+eax*8+8]
  0000b	85 c0		 test	 eax, eax
  0000d	74 0a		 je	 SHORT $LN14@insert_val
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 10		 mov	 DWORD PTR [eax], edx
  00013	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN14@insert_val:

; 1425 :   for (int j = count(); j > i; --j) {

  00019	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0001d	3b cf		 cmp	 ecx, edi
  0001f	7e 24		 jle	 SHORT $LN5@insert_val
  00021	8d 44 ce 08	 lea	 eax, DWORD PTR [esi+ecx*8+8]
  00025	2b cf		 sub	 ecx, edi
  00027	53		 push	 ebx
$LL7@insert_val:

; 1426 :     value_swap(j, this, j - 1);

  00028	8b 58 f8	 mov	 ebx, DWORD PTR [eax-8]
  0002b	8b 10		 mov	 edx, DWORD PTR [eax]
  0002d	89 18		 mov	 DWORD PTR [eax], ebx
  0002f	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  00032	8b 58 fc	 mov	 ebx, DWORD PTR [eax-4]
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0003b	89 50 fc	 mov	 DWORD PTR [eax-4], edx
  0003e	83 c0 f8	 add	 eax, -8			; fffffff8H
  00041	49		 dec	 ecx
  00042	75 e4		 jne	 SHORT $LL7@insert_val
  00044	5b		 pop	 ebx
$LN5@insert_val:

; 1427 :   }
; 1428 :   set_count(count() + 1);

  00045	fe 46 03	 inc	 BYTE PTR [esi+3]

; 1429 : 
; 1430 :   if (!leaf()) {

  00048	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0004b	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  0004e	75 2b		 jne	 SHORT $LN4@insert_val

; 1432 :     for (int j = count(); j > i; --j) {

  00050	0f b6 c0	 movzx	 eax, al
  00053	47		 inc	 edi
  00054	3b c7		 cmp	 eax, edi
  00056	7e 18		 jle	 SHORT $LN1@insert_val

; 1431 :     ++i;

  00058	8d 8c 86 00 01
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+256]
  0005f	90		 npad	 1
$LL3@insert_val:

; 1433 :       *mutable_child(j) = child(j - 1);

  00060	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00063	89 11		 mov	 DWORD PTR [ecx], edx

; 1434 :       child(j)->set_position(j);

  00065	88 42 01	 mov	 BYTE PTR [edx+1], al
  00068	48		 dec	 eax
  00069	83 e9 04	 sub	 ecx, 4
  0006c	3b c7		 cmp	 eax, edi
  0006e	7f f0		 jg	 SHORT $LL3@insert_val
$LN1@insert_val:

; 1435 :     }
; 1436 :     *mutable_child(i) = NULL;

  00070	c7 84 be 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edi*4+256], 0
$LN4@insert_val:
  0007b	5f		 pop	 edi

; 1437 :   }
; 1438 : }

  0007c	c3		 ret	 0
?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T174693 = -16						; size = 12
$T174677 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode, COMDAT
; _this$ = esi

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00006	6a 18		 push	 24			; 00000018H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	33 c9		 xor	 ecx, ecx
  0000f	83 c4 04	 add	 esp, 4
  00012	3b c1		 cmp	 eax, ecx
  00014	74 19		 je	 SHORT $LN5@Buynode@2

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00016	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00027	66 89 48 14	 mov	 WORD PTR [eax+20], cx

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode@2:
  0002f	8d 45 fc	 lea	 eax, DWORD PTR $T174677[ebp]
  00032	89 4d fc	 mov	 DWORD PTR $T174677[ebp], ecx
  00035	50		 push	 eax
  00036	8d 4d f0	 lea	 ecx, DWORD PTR $T174693[ebp]
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 4d f0	 lea	 ecx, DWORD PTR $T174693[ebp]
  00046	51		 push	 ecx
  00047	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T174693[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode@2:
$LN26@Buynode@2:
  00053	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
$T174780 = -16						; size = 12
$T174735 = -4						; size = 4
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = esi
; __Val$ = edi

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  00006	6a 18		 push	 24			; 00000018H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	33 d2		 xor	 edx, edx
  0000f	83 c4 04	 add	 esp, 4
  00012	3b c2		 cmp	 eax, edx
  00014	74 2a		 je	 SHORT $LN12@Buynode@3
  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00021	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00024	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00027	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0002a	66 89 50 14	 mov	 WORD PTR [eax+20], dx
  0002e	3b ca		 cmp	 ecx, edx
  00030	74 0a		 je	 SHORT $LN2@Buynode@3
  00032	8b 17		 mov	 edx, DWORD PTR [edi]
  00034	89 11		 mov	 DWORD PTR [ecx], edx
  00036	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00039	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN2@Buynode@3:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);
; 595  : 		_RERAISE;
; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);
; 599  : 		}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@3:
  00040	8d 45 fc	 lea	 eax, DWORD PTR $T174735[ebp]
  00043	50		 push	 eax
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T174780[ebp]
  00047	89 55 fc	 mov	 DWORD PTR $T174735[ebp], edx
  0004a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0004f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00054	8d 4d f0	 lea	 ecx, DWORD PTR $T174780[ebp]
  00057	51		 push	 ecx
  00058	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T174780[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0005f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN68@Buynode@3:
$LN67@Buynode@3:
  00064	cc		 int	 3
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_iter$ = 12						; size = 8
??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = esi

; 2232 :     const key_type &key, IterType iter) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2233 :   return internal_locate_type::dispatch(key, *this, iter);

  00004	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00007	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp]
  0000a	83 ec 08	 sub	 esp, 8
  0000d	8b c4		 mov	 eax, esp
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00014	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00017	50		 push	 eax
  00018	8b c6		 mov	 eax, esi
  0001a	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  0001f	8b c6		 mov	 eax, esi
  00021	59		 pop	 ecx

; 2234 : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z
_TEXT	SEGMENT
?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value, COMDAT
; _this$ = ecx
; _i$ = eax

; 1442 :   if (!leaf()) {

  00000	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f8		 mov	 edi, eax
  00007	75 3a		 jne	 SHORT $LN7@remove_val

; 1443 :     assert(child(i + 1)->count() == 0);
; 1444 :     for (int j = i + 1; j < count(); ++j) {

  00009	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0000d	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00010	3b c2		 cmp	 eax, edx
  00012	7d 20		 jge	 SHORT $LN4@remove_val
  00014	8d 94 81 00 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax*4+256]
  0001b	eb 03 8d 49 00	 npad	 5
$LL6@remove_val:

; 1445 :       *mutable_child(j) = child(j + 1);

  00020	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00023	89 32		 mov	 DWORD PTR [edx], esi

; 1446 :       child(j)->set_position(j);

  00025	88 46 01	 mov	 BYTE PTR [esi+1], al
  00028	0f b6 71 03	 movzx	 esi, BYTE PTR [ecx+3]
  0002c	40		 inc	 eax
  0002d	83 c2 04	 add	 edx, 4
  00030	3b c6		 cmp	 eax, esi
  00032	7c ec		 jl	 SHORT $LL6@remove_val
$LN4@remove_val:

; 1447 :     }
; 1448 :     *mutable_child(count()) = NULL;

  00034	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00038	c7 84 81 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+256], 0
$LN7@remove_val:

; 1449 :   }
; 1450 : 
; 1451 :   set_count(count() - 1);

  00043	fe 49 03	 dec	 BYTE PTR [ecx+3]

; 1452 :   for (; i < count(); ++i) {

  00046	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0004a	3b fa		 cmp	 edi, edx
  0004c	7d 26		 jge	 SHORT $LN1@remove_val

; 1449 :   }
; 1450 : 
; 1451 :   set_count(count() - 1);

  0004e	8d 44 f9 0c	 lea	 eax, DWORD PTR [ecx+edi*8+12]
$LL3@remove_val:

; 1453 :     value_swap(i, this, i + 1);

  00052	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00055	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00058	89 70 fc	 mov	 DWORD PTR [eax-4], esi
  0005b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0005e	8b 10		 mov	 edx, DWORD PTR [eax]
  00060	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00063	89 30		 mov	 DWORD PTR [eax], esi
  00065	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00068	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0006c	47		 inc	 edi
  0006d	83 c0 08	 add	 eax, 8
  00070	3b fa		 cmp	 edi, edx
  00072	7c de		 jl	 SHORT $LL3@remove_val
$LN1@remove_val:
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi

; 1454 :   }
; 1455 :   value_destroy(i);
; 1456 : }

  00076	c3		 ret	 0
?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink, COMDAT

; 2161 : void btree<P>::try_shrink() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00007	57		 push	 edi

; 2162 :   if (root()->count() > 0) {

  00008	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0000a	80 7f 03 00	 cmp	 BYTE PTR [edi+3], 0
  0000e	77 54		 ja	 SHORT $LN56@try_shrink

; 2163 :     return;
; 2164 :   }
; 2165 :   // Deleted the last item on the root node, shrink the height of the tree.
; 2166 :   if (root()->leaf()) {

  00010	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00013	74 15		 je	 SHORT $LN4@try_shrink

; 2167 :     assert(size() == 0);
; 2168 :     delete_leaf_node(root());

  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	83 c4 04	 add	 esp, 4
  0001e	5f		 pop	 edi

; 2169 :     *mutable_root() = NULL;

  0001f	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00025	5b		 pop	 ebx

; 2183 :     }
; 2184 :   }
; 2185 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN4@try_shrink:
  0002a	56		 push	 esi

; 2170 :   } else {
; 2171 :     node_type *child = root()->child(0);

  0002b	8b b7 00 01 00
	00		 mov	 esi, DWORD PTR [edi+256]

; 2172 :     if (child->leaf()) {

  00031	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00034	74 1d		 je	 SHORT $LN2@try_shrink

; 2173 :       // The child is a leaf node so simply make it the root node in the tree.
; 2174 :       child->make_root();

  00036	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2175 :       delete_internal_root_node();

  0003f	8b 13		 mov	 edx, DWORD PTR [ebx]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 2182 :       delete_internal_node(child);

  00047	83 c4 04	 add	 esp, 4
  0004a	89 33		 mov	 DWORD PTR [ebx], esi
  0004c	5e		 pop	 esi
  0004d	5f		 pop	 edi
  0004e	5b		 pop	 ebx

; 2183 :     }
; 2184 :   }
; 2185 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN2@try_shrink:

; 2176 :       *mutable_root() = child;
; 2177 :     } else {
; 2178 :       // The child is an internal node. We want to keep the existing root node
; 2179 :       // so we move all of the values from the child node into the existing
; 2180 :       // (empty) root node.
; 2181 :       child->swap(root());

  00053	8b d6		 mov	 edx, esi
  00055	e8 00 00 00 00	 call	 ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap

; 2182 :       delete_internal_node(child);

  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
  00063	5e		 pop	 esi
$LN56@try_shrink:
  00064	5f		 pop	 edi
  00065	5b		 pop	 ebx

; 2183 :     }
; 2184 :   }
; 2185 : }

  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = eax

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	74 06		 je	 SHORT $LN8@operator@7

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000d	c3		 ret	 0
$LN8@operator@7:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00014	75 18		 jne	 SHORT $LN40@operator@7

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00016	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00019	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0001d	75 0c		 jne	 SHORT $LN21@operator@7
  0001f	90		 npad	 1
$LL22@operator@7:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00025	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00029	74 f5		 je	 SHORT $LL22@operator@7
$LN21@operator@7:
  0002b	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002d	c3		 ret	 0
$LN40@operator@7:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00031	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00035	75 11		 jne	 SHORT $LN3@operator@7
$LL4@operator@7:
  00037	8b 10		 mov	 edx, DWORD PTR [eax]
  00039	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003b	75 0b		 jne	 SHORT $LN3@operator@7

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ef		 je	 SHORT $LL4@operator@7
$LN3@operator@7:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00048	8b 10		 mov	 edx, DWORD PTR [eax]
  0004a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0004e	75 02		 jne	 SHORT $LN1@operator@7

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00050	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@operator@7:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00052	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--, COMDAT
; _this$ = esi

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00000	8b c6		 mov	 eax, esi
  00002	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00007	8b c6		 mov	 eax, esi

; 306  : 		}

  00009	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 782  : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  00006	c3		 ret	 0
?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
__Where$ = 12						; size = 4
?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert_bucket, COMDAT
; _this$ = ecx
; __Bucket$ = esi

; 764  : 		{	// fix iterators after inserting _Plist before _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 765  : 		if (_Vec_lo(_Bucket) == end())

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	8b 14 f0	 mov	 edx, DWORD PTR [eax+esi*8]
  00009	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  0000c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000f	75 13		 jne	 SHORT $LN5@Insert_buc

; 766  : 			{	// make bucket non-empty
; 767  : 			_Vec_lo(_Bucket) = _Plist;

  00011	8b 55 08	 mov	 edx, DWORD PTR __Plist$[ebp]
  00014	89 10		 mov	 DWORD PTR [eax], edx

; 768  : 			_Vec_hi(_Bucket) = _Plist;

  00016	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Plist$[ebp]
  0001c	89 4c f0 04	 mov	 DWORD PTR [eax+esi*8+4], ecx

; 774  : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN5@Insert_buc:

; 769  : 			}
; 770  : 		else if (_Vec_lo(_Bucket) == _Where)

  00024	3b 55 0c	 cmp	 edx, DWORD PTR __Where$[ebp]
  00027	75 09		 jne	 SHORT $LN3@Insert_buc

; 771  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

  00029	8b 55 08	 mov	 edx, DWORD PTR __Plist$[ebp]

; 773  : 			--_Vec_hi(_Bucket);	// or not

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 774  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
$LN3@Insert_buc:

; 772  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

  00032	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00035	8b 12		 mov	 edx, DWORD PTR [edx]
  00037	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003a	3b 55 08	 cmp	 edx, DWORD PTR __Plist$[ebp]
  0003d	74 10		 je	 SHORT $LN64@Insert_buc

; 773  : 			--_Vec_hi(_Bucket);	// or not

  0003f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00042	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	8d 44 f0 04	 lea	 eax, DWORD PTR [eax+esi*8+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx
$LN64@Insert_buc:

; 774  : 		}

  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert_bucket
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Addleft$ = 16						; size = 1
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert, COMDAT
; __Wherenode$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00007	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0000a	57		 push	 edi
  0000b	81 fa fe ff ff
	1f		 cmp	 edx, 536870910		; 1ffffffeH
  00011	72 16		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));
; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  00024	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN378@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00029	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0002c	42		 inc	 edx
  0002d	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  00030	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00033	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00036	32 c0		 xor	 al, al
  00038	3b ca		 cmp	 ecx, edx
  0003a	75 0d		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  0003c	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0003f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00042	89 39		 mov	 DWORD PTR [ecx], edi

; 1648 : 			_Rmost() = _Newnode;

  00044	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00047	eb 1d		 jmp	 SHORT $LN376@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00049	38 45 10	 cmp	 BYTE PTR __Addleft$[ebp], al
  0004c	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0004e	89 39		 mov	 DWORD PTR [ecx], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00050	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00053	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00055	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00057	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00059	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0005b	89 79 08	 mov	 DWORD PTR [ecx+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0005e	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00061	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00064	75 03		 jne	 SHORT $LN11@Insert
$LN376@Insert:

; 1660 : 				_Rmost() = _Newnode;

  00066	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00069	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006c	8b cf		 mov	 ecx, edi
  0006e	38 42 14	 cmp	 BYTE PTR [edx+20], al
  00071	0f 85 91 01 00
	00		 jne	 $LN9@Insert
  00077	56		 push	 esi
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00078	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007b	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0007e	3b 16		 cmp	 edx, DWORD PTR [esi]
  00080	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00086	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00089	38 46 14	 cmp	 BYTE PTR [esi+20], al
  0008c	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0008e	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  00092	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  00096	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00099	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0009c	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0009f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000a2	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1677 : 					}
; 1678 : 				else

  000a5	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000aa	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  000ad	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000af	8b ca		 mov	 ecx, edx

; 1683 : 						_Lrotate(_Pnode);

  000b1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000b4	8b 32		 mov	 esi, DWORD PTR [edx]
  000b6	89 71 08	 mov	 DWORD PTR [ecx+8], esi
  000b9	8b 32		 mov	 esi, DWORD PTR [edx]
  000bb	38 46 15	 cmp	 BYTE PTR [esi+21], al
  000be	75 03		 jne	 SHORT $LN110@Insert
  000c0	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN110@Insert:
  000c3	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000c6	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000c9	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000cc	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  000cf	75 05		 jne	 SHORT $LN109@Insert
  000d1	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000d4	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000d6	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d9	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  000db	75 04		 jne	 SHORT $LN107@Insert
  000dd	89 16		 mov	 DWORD PTR [esi], edx
  000df	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000e1	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000e4	89 0a		 mov	 DWORD PTR [edx], ecx
  000e6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000e9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ec	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000f0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000f6	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000f9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ff	8b 32		 mov	 esi, DWORD PTR [edx]
  00101	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00104	89 3a		 mov	 DWORD PTR [edx], edi
  00106	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00109	38 47 15	 cmp	 BYTE PTR [edi+21], al
  0010c	75 03		 jne	 SHORT $LN173@Insert
  0010e	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00111	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00114	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00117	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0011a	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0011d	75 0b		 jne	 SHORT $LN172@Insert
  0011f	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00122	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00125	e9 cb 00 00 00	 jmp	 $LN377@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  0012a	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0012d	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00130	75 0b		 jne	 SHORT $LN170@Insert
  00132	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00135	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00138	e9 b8 00 00 00	 jmp	 $LN377@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  0013d	89 37		 mov	 DWORD PTR [edi], esi
  0013f	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00142	e9 ae 00 00 00	 jmp	 $LN377@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00147	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00149	38 46 14	 cmp	 BYTE PTR [esi+20], al
  0014c	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0014e	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00152	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00156	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00159	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0015c	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0015f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00162	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1703 : 					}
; 1704 : 				else

  00165	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  0016a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0016c	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0016e	8b ca		 mov	 ecx, edx

; 1709 : 						_Rrotate(_Pnode);

  00170	8b 11		 mov	 edx, DWORD PTR [ecx]
  00172	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00175	89 31		 mov	 DWORD PTR [ecx], esi
  00177	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0017a	38 46 15	 cmp	 BYTE PTR [esi+21], al
  0017d	75 03		 jne	 SHORT $LN252@Insert
  0017f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN252@Insert:
  00182	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00185	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00188	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0018b	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  0018e	75 05		 jne	 SHORT $LN251@Insert
  00190	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00193	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  00195	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00198	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0019b	75 05		 jne	 SHORT $LN249@Insert
  0019d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001a0	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001a2	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001a4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  001a7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001aa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ad	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001b1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001b4	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001b7	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001ba	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001bd	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c0	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001c3	8b 3e		 mov	 edi, DWORD PTR [esi]
  001c5	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001c8	8b 3e		 mov	 edi, DWORD PTR [esi]
  001ca	38 47 15	 cmp	 BYTE PTR [edi+21], al
  001cd	75 03		 jne	 SHORT $LN315@Insert
  001cf	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001d2	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001d5	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001d8	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  001db	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001de	75 05		 jne	 SHORT $LN314@Insert
  001e0	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001e3	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001e5	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e8	3b 17		 cmp	 edx, DWORD PTR [edi]
  001ea	75 04		 jne	 SHORT $LN312@Insert
  001ec	89 37		 mov	 DWORD PTR [edi], esi
  001ee	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001f0	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  001f3	89 16		 mov	 DWORD PTR [esi], edx
$LN377@Insert:
  001f5	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  001f8	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  001fb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001fe	38 42 14	 cmp	 BYTE PTR [edx+20], al
  00201	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
  00207	5e		 pop	 esi
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00208	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0020b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0020e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00211	89 38		 mov	 DWORD PTR [eax], edi
  00213	5f		 pop	 edi
  00214	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00218	5b		 pop	 ebx

; 1721 : 		}

  00219	5d		 pop	 ebp
  0021a	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ
_TEXT	SEGMENT
?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::front, COMDAT
; _this$ = eax

; 897  : 		return (*begin());

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]
  00004	83 c0 08	 add	 eax, 8

; 898  : 		}

  00007	c3		 ret	 0
?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::front
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 327  : 		return (_List.begin());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 328  : 		}

  00007	c3		 ret	 0
?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z
_TEXT	SEGMENT
$T176375 = -12						; size = 12
$T176352 = 8						; size = 4
_max_count$ = 8						; size = 4
?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_root_node, COMDAT

; 1257 :   node_type* new_leaf_root_node(int max_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _max_count$[ebp]

; 1258 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1259 :         mutable_internal_allocator()->allocate(
; 1260 :             sizeof(base_fields) + max_count * sizeof(value_type)));

  0000a	8d 0c dd 08 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8+8]
  00011	33 c0		 xor	 eax, eax
  00013	85 c9		 test	 ecx, ecx
  00015	74 12		 je	 SHORT $LN8@new_leaf_r
  00017	83 f9 ff	 cmp	 ecx, -1
  0001a	77 23		 ja	 SHORT $LN7@new_leaf_r
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	74 16		 je	 SHORT $LN7@new_leaf_r
$LN8@new_leaf_r:

; 1261 :     return node_type::init_leaf(p, reinterpret_cast<node_type*>(p), max_count);

  00029	88 58 02	 mov	 BYTE PTR [eax+2], bl
  0002c	66 c7 00 01 00	 mov	 WORD PTR [eax], 1
  00031	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  00035	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00038	5b		 pop	 ebx

; 1262 :   }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4

; 1258 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1259 :         mutable_internal_allocator()->allocate(
; 1260 :             sizeof(base_fields) + max_count * sizeof(value_type)));

$LN7@new_leaf_r:
  0003f	8d 45 08	 lea	 eax, DWORD PTR $T176352[ebp]
  00042	50		 push	 eax
  00043	8d 4d f4	 lea	 ecx, DWORD PTR $T176375[ebp]
  00046	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T176352[ebp], 0
  0004d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00052	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00057	8d 4d f4	 lea	 ecx, DWORD PTR $T176375[ebp]
  0005a	51		 push	 ecx
  0005b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T176375[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00062	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN21@new_leaf_r:
$LN20@new_leaf_r:
  00067	cc		 int	 3
?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_root_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z
_TEXT	SEGMENT
_res$155144 = -20					; size = 12
$T176390 = -8						; size = 8
_iter$ = 8						; size = 8
??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = esi
; _key$ = edi

; 2301 :     const key_type &key, IterType iter) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2302 :   if (iter.node) {

  00003	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	85 d2		 test	 edx, edx
  0000b	74 76		 je	 SHORT $LN1@internal_f

; 2303 :     std::pair<IterType, int> res = internal_locate(key, iter);

  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00010	83 ec 08	 sub	 esp, 8
  00013	8b c4		 mov	 eax, esp
  00015	89 10		 mov	 DWORD PTR [eax], edx
  00017	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001a	57		 push	 edi
  0001b	8d 45 ec	 lea	 eax, DWORD PTR _res$155144[ebp]
  0001e	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >

; 2304 :     if (res.second == kExactMatch) {

  00023	8b 45 f4	 mov	 eax, DWORD PTR _res$155144[ebp+8]
  00026	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0002b	75 13		 jne	 SHORT $LN3@internal_f

; 2305 :       return res.first;

  0002d	8b 45 ec	 mov	 eax, DWORD PTR _res$155144[ebp]
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _res$155144[ebp+4]
  00033	89 06		 mov	 DWORD PTR [esi], eax
  00035	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2311 :       }
; 2312 :     }
; 2313 :   }
; 2314 :   return IterType(NULL, 0);

  00038	8b c6		 mov	 eax, esi

; 2315 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN3@internal_f:

; 2306 :     }
; 2307 :     if (!res.second) {

  00040	85 c0		 test	 eax, eax
  00042	75 3f		 jne	 SHORT $LN1@internal_f

; 2308 :       iter = internal_last(res.first);

  00044	8b 55 ec	 mov	 edx, DWORD PTR _res$155144[ebp]
  00047	8b 4d f0	 mov	 ecx, DWORD PTR _res$155144[ebp+4]
  0004a	83 ec 08	 sub	 esp, 8
  0004d	8b c4		 mov	 eax, esp
  0004f	89 10		 mov	 DWORD PTR [eax], edx
  00051	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00054	8d 45 f8	 lea	 eax, DWORD PTR $T176390[ebp]
  00057	e8 00 00 00 00	 call	 ??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	89 4d 08	 mov	 DWORD PTR _iter$[ebp], ecx
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	83 c4 08	 add	 esp, 8
  00067	89 45 0c	 mov	 DWORD PTR _iter$[ebp+4], eax

; 2309 :       if (iter.node && !compare_keys(key, iter.key())) {

  0006a	85 c9		 test	 ecx, ecx
  0006c	74 15		 je	 SHORT $LN1@internal_f
  0006e	8b 17		 mov	 edx, DWORD PTR [edi]
  00070	3b 54 c1 08	 cmp	 edx, DWORD PTR [ecx+eax*8+8]
  00074	72 0d		 jb	 SHORT $LN1@internal_f

; 2310 :         return iter;

  00076	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00079	89 0e		 mov	 DWORD PTR [esi], ecx

; 2311 :       }
; 2312 :     }
; 2313 :   }
; 2314 :   return IterType(NULL, 0);

  0007b	8b c6		 mov	 eax, esi

; 2315 : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
$LN1@internal_f:

; 2311 :       }
; 2312 :     }
; 2313 :   }
; 2314 :   return IterType(NULL, 0);

  00083	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00089	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00090	8b c6		 mov	 eax, esi

; 2315 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty, COMDAT
; _this$ = edx
; _it$ = eax

; 469  :     assert(settings.use_empty());  // we always need to know what's empty!
; 470  :     return equals(get_key(val_info.emptyval), get_key(*it));

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00006	33 d2		 xor	 edx, edx
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	0f 94 c0	 sete	 al

; 471  :   }

  0000d	c3		 ret	 0
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z
_TEXT	SEGMENT
tv252 = -12						; size = 8
tv244 = -12						; size = 8
tv262 = -8						; size = 4
tv254 = -8						; size = 4
tv246 = -8						; size = 4
__Cat$176595 = -8					; size = 1
tv258 = -2						; size = 2
tv249 = -2						; size = 2
?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size, COMDAT
; _this$ = esi
; _new_num_buckets$ = eax

; 752  :   void clear_to_size(size_type new_num_buckets) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 753  :     if (!table) {

  00007	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax
  0000d	85 db		 test	 ebx, ebx
  0000f	0f 85 91 00 00
	00		 jne	 $LN3@clear_to_s

; 754  :       table = val_info.allocate(new_num_buckets);

  00015	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _malloc
  00022	83 c4 04	 add	 esp, 4

; 758  :         typedef integral_constant<bool,
; 759  :             is_same<value_alloc_type,
; 760  :                     libc_allocator_with_realloc<value_type> >::value>
; 761  :             realloc_ok;
; 762  :         resize_table(num_buckets, new_num_buckets, realloc_ok());

$LN15@clear_to_s:
  00025	89 46 34	 mov	 DWORD PTR [esi+52], eax
$LN13@clear_to_s:

; 763  :       }
; 764  :     }
; 765  :     assert(table);
; 766  :     fill_range_with_empty(table, table + new_num_buckets);

  00028	8b 55 f8	 mov	 edx, DWORD PTR __Cat$176595[ebp]
  0002b	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0002e	52		 push	 edx
  0002f	8d 56 2c	 lea	 edx, DWORD PTR [esi+44]
  00032	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >

; 767  :     num_elements = 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	83 c4 08	 add	 esp, 8

; 768  :     num_deleted = 0;
; 769  :     num_buckets = new_num_buckets;          // our new size
; 770  :     settings.reset_thresholds(bucket_count());

  00040	89 7d f8	 mov	 DWORD PTR tv262[ebp], edi
  00043	db 45 f8	 fild	 DWORD PTR tv262[ebp]
  00046	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00049	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0004c	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  0004f	85 ff		 test	 edi, edi
  00051	79 06		 jns	 SHORT $LN44@clear_to_s
  00053	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN44@clear_to_s:
  00059	d9 46 08	 fld	 DWORD PTR [esi+8]
  0005c	5f		 pop	 edi
  0005d	d9 7d fe	 fnstcw	 WORD PTR tv258[ebp]
  00060	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00064	0f b7 45 fe	 movzx	 eax, WORD PTR tv258[ebp]
  00068	d8 c9		 fmul	 ST(0), ST(1)
  0006a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0006f	89 45 f8	 mov	 DWORD PTR tv254[ebp], eax
  00072	5b		 pop	 ebx
  00073	d9 6d f8	 fldcw	 WORD PTR tv254[ebp]
  00076	df 7d f4	 fistp	 QWORD PTR tv252[ebp]
  00079	8b 45 f4	 mov	 eax, DWORD PTR tv252[ebp]
  0007c	89 06		 mov	 DWORD PTR [esi], eax
  0007e	d9 6d fe	 fldcw	 WORD PTR tv258[ebp]
  00081	d8 4e 0c	 fmul	 DWORD PTR [esi+12]
  00084	d9 7d fe	 fnstcw	 WORD PTR tv249[ebp]
  00087	0f b7 45 fe	 movzx	 eax, WORD PTR tv249[ebp]
  0008b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00090	89 45 f8	 mov	 DWORD PTR tv246[ebp], eax
  00093	d9 6d f8	 fldcw	 WORD PTR tv246[ebp]
  00096	df 7d f4	 fistp	 QWORD PTR tv244[ebp]
  00099	8b 4d f4	 mov	 ecx, DWORD PTR tv244[ebp]
  0009c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0009f	d9 6d fe	 fldcw	 WORD PTR tv249[ebp]

; 771  :   }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN3@clear_to_s:

; 755  :     } else {
; 756  :       destroy_buckets(0, num_buckets);
; 757  :       if (new_num_buckets != num_buckets) {   // resize, if necessary

  000a6	3b 7e 28	 cmp	 edi, DWORD PTR [esi+40]
  000a9	0f 84 79 ff ff
	ff		 je	 $LN13@clear_to_s

; 758  :         typedef integral_constant<bool,
; 759  :             is_same<value_alloc_type,
; 760  :                     libc_allocator_with_realloc<value_type> >::value>
; 761  :             realloc_ok;
; 762  :         resize_table(num_buckets, new_num_buckets, realloc_ok());

  000af	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  000b6	51		 push	 ecx
  000b7	53		 push	 ebx
  000b8	e8 00 00 00 00	 call	 _realloc
  000bd	83 c4 08	 add	 esp, 8
  000c0	85 c0		 test	 eax, eax
  000c2	0f 85 5d ff ff
	ff		 jne	 $LN15@clear_to_s
  000c8	53		 push	 ebx
  000c9	57		 push	 edi
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
  000cf	e8 00 00 00 00	 call	 ___iob_func
  000d4	83 c0 40	 add	 eax, 64			; 00000040H
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _fprintf
  000dd	83 c4 10	 add	 esp, 16			; 00000010H
  000e0	6a 01		 push	 1
  000e2	e8 00 00 00 00	 call	 _exit
$LN46@clear_to_s:
$LN45@clear_to_s:
  000e7	cc		 int	 3
?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo, COMDAT
; _this$ = eax
; _v$ = ecx

; 1167 :         : alloc_impl<value_alloc_type>(v), emptyval(v.emptyval) { }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000a	c3		 ret	 0
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z
_TEXT	SEGMENT
?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::hash, COMDAT
; _v$ = eax

; 65   :     return hasher::operator()(v);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b c1		 mov	 eax, ecx
  00029	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002c	33 c8		 xor	 ecx, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00033	33 c1		 xor	 eax, ecx

; 66   :   }

  00035	c3		 ret	 0
?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::hash
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty, COMDAT
; _this$ = edx
; _it$ = eax

; 465  :     assert(settings.use_empty());  // we always need to know what's empty!
; 466  :     return equals(get_key(val_info.emptyval), get_key(*it));

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00006	33 d2		 xor	 edx, edx
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	0f 94 c0	 sete	 al

; 467  :   }

  0000d	c3		 ret	 0
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z
_TEXT	SEGMENT
?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted_key, COMDAT
; _this$ = eax
; _key$ = ecx

; 378  :     // The num_deleted test is crucial for read(): after read(), the ht values
; 379  :     // are garbage, and we don't want to think some of them are deleted.
; 380  :     // Invariant: !use_deleted implies num_deleted is 0.
; 381  :     assert(settings.use_deleted() || num_deleted == 0);
; 382  :     return num_deleted > 0 && equals(key_info.delkey, key);

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 0d		 jbe	 SHORT $LN3@test_delet
  00006	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00009	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000b	75 06		 jne	 SHORT $LN3@test_delet
  0000d	b8 01 00 00 00	 mov	 eax, 1

; 383  :   }

  00012	c3		 ret	 0
$LN3@test_delet:

; 378  :     // The num_deleted test is crucial for read(): after read(), the ht values
; 379  :     // are garbage, and we don't want to think some of them are deleted.
; 380  :     // Invariant: !use_deleted implies num_deleted is 0.
; 381  :     assert(settings.use_deleted() || num_deleted == 0);
; 382  :     return num_deleted > 0 && equals(key_info.delkey, key);

  00013	33 c0		 xor	 eax, eax

; 383  :   }

  00015	c3		 ret	 0
?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted_key
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = eax

; 50   :   btree_container(const key_compare &comp, const allocator_type &alloc)

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 51   :       : tree_(comp, alloc) {
; 52   :   }

  00006	c3		 ret	 0
??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z
_TEXT	SEGMENT
?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::hash, COMDAT
; _v$ = eax

; 1209 :     return settings.hash(v);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b c1		 mov	 eax, ecx
  00029	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002c	33 c8		 xor	 ecx, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00033	33 c1		 xor	 eax, ecx

; 1210 :   }

  00035	c3		 ret	 0
?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::hash
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z
_TEXT	SEGMENT
tv446 = -16						; size = 8
tv438 = -16						; size = 8
tv426 = -16						; size = 8
tv418 = -16						; size = 8
_tmp$153364 = -16					; size = 8
tv455 = -12						; size = 4
tv448 = -12						; size = 4
tv440 = -12						; size = 4
tv435 = -12						; size = 4
tv428 = -12						; size = 4
tv420 = -12						; size = 4
tv451 = -2						; size = 2
tv443 = -2						; size = 2
tv431 = -2						; size = 2
tv423 = -2						; size = 2
?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap, COMDAT
; _this$ = ecx
; _ht$ = edx

; 734  :   void swap(dense_hashtable& ht) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 735  :     STL_NAMESPACE::swap(settings, ht.settings);

  00006	f3 0f 7e 1a	 movq	 xmm3, QWORD PTR [edx]
  0000a	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  0000e	f3 0f 7e 49 08	 movq	 xmm1, QWORD PTR [ecx+8]
  00013	f3 0f 7e 51 10	 movq	 xmm2, QWORD PTR [ecx+16]
  00018	66 0f d6 19	 movq	 QWORD PTR [ecx], xmm3
  0001c	f3 0f 7e 5a 08	 movq	 xmm3, QWORD PTR [edx+8]
  00021	66 0f d6 59 08	 movq	 QWORD PTR [ecx+8], xmm3
  00026	f3 0f 7e 5a 10	 movq	 xmm3, QWORD PTR [edx+16]
  0002b	66 0f d6 59 10	 movq	 QWORD PTR [ecx+16], xmm3
  00030	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00034	66 0f d6 4a 08	 movq	 QWORD PTR [edx+8], xmm1
  00039	66 0f d6 52 10	 movq	 QWORD PTR [edx+16], xmm2

; 736  :     STL_NAMESPACE::swap(key_info, ht.key_info);

  0003e	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00041	53		 push	 ebx
  00042	56		 push	 esi
  00043	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  00046	57		 push	 edi
  00047	8b 7a 18	 mov	 edi, DWORD PTR [edx+24]
  0004a	89 79 18	 mov	 DWORD PTR [ecx+24], edi
  0004d	8b 7a 1c	 mov	 edi, DWORD PTR [edx+28]
  00050	89 79 1c	 mov	 DWORD PTR [ecx+28], edi
  00053	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00056	89 72 1c	 mov	 DWORD PTR [edx+28], esi

; 737  :     STL_NAMESPACE::swap(num_deleted, ht.num_deleted);

  00059	8b 72 20	 mov	 esi, DWORD PTR [edx+32]
  0005c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0005f	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  00062	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 738  :     STL_NAMESPACE::swap(num_elements, ht.num_elements);

  00065	8b 72 24	 mov	 esi, DWORD PTR [edx+36]
  00068	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0006b	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  0006e	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 739  :     STL_NAMESPACE::swap(num_buckets, ht.num_buckets);

  00071	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  00074	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00077	89 71 28	 mov	 DWORD PTR [ecx+40], esi
  0007a	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 740  :     { value_type tmp;     // for annoying reasons, swap() doesn't work
; 741  :       set_value(&tmp, val_info.emptyval);

  0007d	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  00080	8b 79 2c	 mov	 edi, DWORD PTR [ecx+44]
  00083	8d 41 2c	 lea	 eax, DWORD PTR [ecx+44]
  00086	89 75 f4	 mov	 DWORD PTR _tmp$153364[ebp+4], esi

; 742  :       set_value(&val_info.emptyval, ht.val_info.emptyval);

  00089	8d 72 2c	 lea	 esi, DWORD PTR [edx+44]
  0008c	85 c0		 test	 eax, eax
  0008e	74 0a		 je	 SHORT $LN59@swap@2
  00090	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00092	89 18		 mov	 DWORD PTR [eax], ebx
  00094	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00097	89 58 04	 mov	 DWORD PTR [eax+4], ebx
$LN59@swap@2:

; 743  :       set_value(&ht.val_info.emptyval, tmp);

  0009a	33 db		 xor	 ebx, ebx
  0009c	3b f3		 cmp	 esi, ebx
  0009e	74 08		 je	 SHORT $LN69@swap@2
  000a0	8b 45 f4	 mov	 eax, DWORD PTR _tmp$153364[ebp+4]
  000a3	89 3e		 mov	 DWORD PTR [esi], edi
  000a5	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN69@swap@2:

; 744  :     }
; 745  :     STL_NAMESPACE::swap(table, ht.table);

  000a8	8b 72 34	 mov	 esi, DWORD PTR [edx+52]
  000ab	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  000ae	89 71 34	 mov	 DWORD PTR [ecx+52], esi
  000b1	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 746  :     settings.reset_thresholds(bucket_count());  // this also resets consider_shrink

  000b4	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  000b7	8b c6		 mov	 eax, esi
  000b9	89 45 f4	 mov	 DWORD PTR tv455[ebp], eax
  000bc	db 45 f4	 fild	 DWORD PTR tv455[ebp]
  000bf	85 c0		 test	 eax, eax
  000c1	79 06		 jns	 SHORT $LN113@swap@2
  000c3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN113@swap@2:
  000c9	d9 41 08	 fld	 DWORD PTR [ecx+8]
  000cc	88 59 10	 mov	 BYTE PTR [ecx+16], bl
  000cf	d9 7d fe	 fnstcw	 WORD PTR tv451[ebp]
  000d2	0f b7 45 fe	 movzx	 eax, WORD PTR tv451[ebp]
  000d6	d8 c9		 fmul	 ST(0), ST(1)
  000d8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000dd	89 45 f4	 mov	 DWORD PTR tv448[ebp], eax
  000e0	d9 6d f4	 fldcw	 WORD PTR tv448[ebp]
  000e3	df 7d f0	 fistp	 QWORD PTR tv446[ebp]
  000e6	8b 45 f0	 mov	 eax, DWORD PTR tv446[ebp]
  000e9	89 01		 mov	 DWORD PTR [ecx], eax
  000eb	d9 6d fe	 fldcw	 WORD PTR tv451[ebp]
  000ee	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  000f1	d9 7d fe	 fnstcw	 WORD PTR tv443[ebp]
  000f4	0f b7 45 fe	 movzx	 eax, WORD PTR tv443[ebp]
  000f8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000fd	89 45 f4	 mov	 DWORD PTR tv440[ebp], eax
  00100	d9 6d f4	 fldcw	 WORD PTR tv440[ebp]
  00103	df 7d f0	 fistp	 QWORD PTR tv438[ebp]
  00106	8b 45 f0	 mov	 eax, DWORD PTR tv438[ebp]

; 747  :     ht.settings.reset_thresholds(bucket_count());

  00109	89 75 f4	 mov	 DWORD PTR tv435[ebp], esi
  0010c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0010f	d9 6d fe	 fldcw	 WORD PTR tv443[ebp]
  00112	db 45 f4	 fild	 DWORD PTR tv435[ebp]
  00115	85 f6		 test	 esi, esi
  00117	79 06		 jns	 SHORT $LN114@swap@2
  00119	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN114@swap@2:
  0011f	d9 42 08	 fld	 DWORD PTR [edx+8]

; 748  :     // we purposefully don't swap the allocator, which may not be swap-able
; 749  :   }

  00122	5f		 pop	 edi
  00123	d9 7d fe	 fnstcw	 WORD PTR tv431[ebp]
  00126	5e		 pop	 esi
  00127	0f b7 45 fe	 movzx	 eax, WORD PTR tv431[ebp]
  0012b	d8 c9		 fmul	 ST(0), ST(1)
  0012d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00132	89 45 f4	 mov	 DWORD PTR tv428[ebp], eax
  00135	88 5a 10	 mov	 BYTE PTR [edx+16], bl
  00138	d9 6d f4	 fldcw	 WORD PTR tv428[ebp]
  0013b	5b		 pop	 ebx
  0013c	df 7d f0	 fistp	 QWORD PTR tv426[ebp]
  0013f	8b 4d f0	 mov	 ecx, DWORD PTR tv426[ebp]
  00142	89 0a		 mov	 DWORD PTR [edx], ecx
  00144	d9 6d fe	 fldcw	 WORD PTR tv431[ebp]
  00147	d8 4a 0c	 fmul	 DWORD PTR [edx+12]
  0014a	d9 7d fe	 fnstcw	 WORD PTR tv423[ebp]
  0014d	0f b7 45 fe	 movzx	 eax, WORD PTR tv423[ebp]
  00151	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00156	89 45 f4	 mov	 DWORD PTR tv420[ebp], eax
  00159	d9 6d f4	 fldcw	 WORD PTR tv420[ebp]
  0015c	df 7d f0	 fistp	 QWORD PTR tv418[ebp]
  0015f	8b 45 f0	 mov	 eax, DWORD PTR tv418[ebp]
  00162	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00165	d9 6d fe	 fldcw	 WORD PTR tv423[ebp]
  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c3		 ret	 0
?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted, COMDAT
; _this$ = eax
; _it$ = ecx

; 412  :     return test_deleted_key(get_key(*it));

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 10		 jbe	 SHORT $LN13@test_delet@2
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000e	75 06		 jne	 SHORT $LN13@test_delet@2
  00010	b8 01 00 00 00	 mov	 eax, 1

; 413  :   }

  00015	c3		 ret	 0

; 412  :     return test_deleted_key(get_key(*it));

$LN13@test_delet@2:
  00016	33 c0		 xor	 eax, eax

; 413  :   }

  00018	c3		 ret	 0
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z
_TEXT	SEGMENT
_bucknum$ = 8						; size = 4
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted, COMDAT
; _this$ = eax

; 408  :   bool test_deleted(size_type bucknum) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 409  :     return test_deleted_key(get_key(table[bucknum]));

  00003	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00007	76 17		 jbe	 SHORT $LN11@test_delet@3
  00009	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0000c	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0000f	8b 45 08	 mov	 eax, DWORD PTR _bucknum$[ebp]
  00012	3b 14 c1	 cmp	 edx, DWORD PTR [ecx+eax*8]
  00015	75 09		 jne	 SHORT $LN11@test_delet@3
  00017	b8 01 00 00 00	 mov	 eax, 1

; 410  :   }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 409  :     return test_deleted_key(get_key(table[bucknum]));

$LN11@test_delet@3:
  00020	33 c0		 xor	 eax, eax

; 410  :   }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = eax

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	75 42		 jne	 SHORT $LN3@operator@8

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00008	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000b	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000f	75 1c		 jne	 SHORT $LN34@operator@8

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00011	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00013	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00017	75 11		 jne	 SHORT $LN17@operator@8
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL18@operator@8:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00024	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00028	74 f6		 je	 SHORT $LL18@operator@8
$LN17@operator@8:
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@8:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00034	75 12		 jne	 SHORT $LN1@operator@8
$LL2@operator@8:
  00036	8b 10		 mov	 edx, DWORD PTR [eax]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@8

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ee		 je	 SHORT $LL2@operator@8
$LN1@operator@8:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@operator@8:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z PROC ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval$ = eax

; 154  : 		return ((size_t)_Hashobj(_Keyval));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b c1		 mov	 eax, ecx
  00029	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002c	33 c8		 xor	 ecx, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00033	33 c1		 xor	 eax, ecx

; 155  : 		}

  00035	c3		 ret	 0
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z ENDP ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Tmp$177597 = -4					; size = 4
__Buckets$ = 8						; size = 4
?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Init, COMDAT
; _this$ = edi

; 842  : 		{	// initialize hash table with _Buckets buckets, leave list alone

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 843  : 		_Vec.assign(2 * _Buckets, end());

  00004	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR __Buckets$[ebp]
  0000b	8d 57 10	 lea	 edx, DWORD PTR [edi+16]
  0000e	56		 push	 esi
  0000f	8b 32		 mov	 esi, DWORD PTR [edx]
  00011	89 45 fc	 mov	 DWORD PTR __Tmp$177597[ebp], eax
  00014	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00017	3b f0		 cmp	 esi, eax
  00019	74 1a		 je	 SHORT $LN35@Init
  0001b	8b c8		 mov	 ecx, eax
  0001d	3b c0		 cmp	 eax, eax
  0001f	74 11		 je	 SHORT $LN64@Init
$LL66@Init:
  00021	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00023	89 1e		 mov	 DWORD PTR [esi], ebx
  00025	83 c1 04	 add	 ecx, 4
  00028	83 c6 04	 add	 esi, 4
  0002b	3b c8		 cmp	 ecx, eax
  0002d	75 f2		 jne	 SHORT $LL66@Init
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR __Buckets$[ebp]
$LN64@Init:
  00032	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN35@Init:
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$177597[ebp]
  0003a	51		 push	 ecx
  0003b	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 844  : 		_Mask = _Buckets - 1;

  00044	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  00047	5e		 pop	 esi

; 845  : 		_Maxidx = _Buckets;

  00048	89 5f 24	 mov	 DWORD PTR [edi+36], ebx
  0004b	89 57 20	 mov	 DWORD PTR [edi+32], edx
  0004e	5b		 pop	 ebx

; 846  : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_End, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax
; __Bucket$ = esi

; 728  : 		if (_Vec_lo(_Bucket) == end())

  00000	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00003	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00006	39 14 f1	 cmp	 DWORD PTR [ecx+esi*8], edx
  00009	8d 0c f1	 lea	 ecx, DWORD PTR [ecx+esi*8]
  0000c	75 03		 jne	 SHORT $LN2@End

; 729  : 			return (end());

  0000e	89 10		 mov	 DWORD PTR [eax], edx

; 734  : 			}
; 735  : 		}

  00010	c3		 ret	 0
$LN2@End:

; 730  : 		else
; 731  : 			{	// point past last element
; 732  : 			iterator _Ans = _Vec_hi(_Bucket);

  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 733  : 			return (++_Ans);

  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 734  : 			}
; 735  : 		}

  00018	c3		 ret	 0
?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_End
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 807  : 		return (iterator(_Lmost(), this));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z
_TEXT	SEGMENT
$T177853 = -8						; size = 8
$T177854 = 8						; size = 8
_iter$ = 8						; size = 8
?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 1297 :   iterator internal_end(iterator iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1298 :     return iter.node ? iter : end();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c9		 test	 ecx, ecx
  0000b	74 1c		 je	 SHORT $LN3@internal_e
  0000d	89 4d f8	 mov	 DWORD PTR $T177853[ebp], ecx
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00013	89 4d fc	 mov	 DWORD PTR $T177853[ebp+4], ecx
  00016	8d 4d f8	 lea	 ecx, DWORD PTR $T177853[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001e	89 10		 mov	 DWORD PTR [eax], edx
  00020	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1299 :   }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN3@internal_e:

; 1298 :     return iter.node ? iter : end();

  00029	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 0d		 je	 SHORT $LN13@internal_e
  0002f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00032	75 08		 jne	 SHORT $LN13@internal_e
  00034	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  0003a	eb 02		 jmp	 SHORT $LN25@internal_e
$LN13@internal_e:
  0003c	8b d1		 mov	 edx, ecx
$LN25@internal_e:
  0003e	85 d2		 test	 edx, edx
  00040	74 1d		 je	 SHORT $LN9@internal_e
  00042	85 c9		 test	 ecx, ecx
  00044	74 11		 je	 SHORT $LN29@internal_e
  00046	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00049	75 0c		 jne	 SHORT $LN29@internal_e
  0004b	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00051	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  00055	eb 0a		 jmp	 SHORT $LN10@internal_e
$LN29@internal_e:
  00057	8b d1		 mov	 edx, ecx
  00059	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  0005d	eb 02		 jmp	 SHORT $LN10@internal_e
$LN9@internal_e:
  0005f	33 d2		 xor	 edx, edx
$LN10@internal_e:
  00061	85 c9		 test	 ecx, ecx
  00063	74 0b		 je	 SHORT $LN47@internal_e
  00065	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00068	75 06		 jne	 SHORT $LN47@internal_e
  0006a	8b 89 80 01 00
	00		 mov	 ecx, DWORD PTR [ecx+384]
$LN47@internal_e:
  00070	89 4d 08	 mov	 DWORD PTR $T177854[ebp], ecx
  00073	8d 4d 08	 lea	 ecx, DWORD PTR $T177854[ebp]
  00076	89 55 0c	 mov	 DWORD PTR $T177854[ebp+4], edx
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0007e	89 10		 mov	 DWORD PTR [eax], edx
  00080	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1299 :   }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = eax

; 162  :   btree_unique_container(const key_compare &comp = key_compare(),

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 163  :                          const allocator_type &alloc = allocator_type())
; 164  :       : super_type(comp, alloc) {
; 165  :   }

  00006	c3		 ret	 0
??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z
_TEXT	SEGMENT
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo, COMDAT
; _this$ = eax

; 1165 :         : alloc_impl<value_alloc_type>(a), emptyval() { }

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0000d	c3		 ret	 0
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z
_TEXT	SEGMENT
$T178120 = -24						; size = 12
tv166 = -12						; size = 8
tv173 = -8						; size = 4
tv169 = -8						; size = 4
$T178130 = -8						; size = 4
_enlarge$ = -4						; size = 4
tv172 = -2						; size = 2
?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets, COMDAT
; _this$ = eax
; _num_elts$ = edx
; _min_buckets_wanted$ = esi

; 150  :   size_type min_buckets(size_type num_elts, size_type min_buckets_wanted) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 151  :     float enlarge = enlarge_factor();

  00006	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0000b	f3 0f 11 45 fc	 movss	 DWORD PTR _enlarge$[ebp], xmm0

; 152  :     size_type sz = HT_MIN_BUCKETS;             // min buckets allowed

  00010	d9 45 fc	 fld	 DWORD PTR _enlarge$[ebp]
  00013	b9 04 00 00 00	 mov	 ecx, 4
$LN4@min_bucket:

; 153  :     while ( sz < min_buckets_wanted ||
; 154  :             num_elts >= static_cast<size_type>(sz * enlarge) ) {

  00018	3b ce		 cmp	 ecx, esi
  0001a	72 33		 jb	 SHORT $LN2@min_bucket
  0001c	8b c1		 mov	 eax, ecx
  0001e	89 45 f8	 mov	 DWORD PTR tv173[ebp], eax
  00021	db 45 f8	 fild	 DWORD PTR tv173[ebp]
  00024	85 c0		 test	 eax, eax
  00026	79 06		 jns	 SHORT $LN26@min_bucket
  00028	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN26@min_bucket:
  0002e	d9 7d fe	 fnstcw	 WORD PTR tv172[ebp]
  00031	0f b7 45 fe	 movzx	 eax, WORD PTR tv172[ebp]
  00035	d8 c9		 fmul	 ST(0), ST(1)
  00037	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0003c	89 45 f8	 mov	 DWORD PTR tv169[ebp], eax
  0003f	d9 6d f8	 fldcw	 WORD PTR tv169[ebp]
  00042	df 7d f4	 fistp	 QWORD PTR tv166[ebp]
  00045	8b 45 f4	 mov	 eax, DWORD PTR tv166[ebp]
  00048	d9 6d fe	 fldcw	 WORD PTR tv172[ebp]
  0004b	3b d0		 cmp	 edx, eax
  0004d	72 0b		 jb	 SHORT $LN22@min_bucket
$LN2@min_bucket:

; 155  :       // This just prevents overflowing size_type, since sz can exceed
; 156  :       // max_size() here.
; 157  :       if (static_cast<size_type>(sz * 2) < sz) {

  0004f	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  00052	3b c1		 cmp	 eax, ecx
  00054	72 0c		 jb	 SHORT $LN24@min_bucket

; 159  :       }
; 160  :       sz *= 2;

  00056	8b c8		 mov	 ecx, eax

; 161  :     }

  00058	eb be		 jmp	 SHORT $LN4@min_bucket
$LN22@min_bucket:

; 153  :     while ( sz < min_buckets_wanted ||
; 154  :             num_elts >= static_cast<size_type>(sz * enlarge) ) {

  0005a	dd d8		 fstp	 ST(0)

; 162  :     return sz;

  0005c	8b c1		 mov	 eax, ecx

; 163  :   }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN24@min_bucket:

; 158  :         throw std::length_error("resize overflow");  // protect against overflow

  00062	8d 4d f8	 lea	 ecx, DWORD PTR $T178130[ebp]
  00065	dd d8		 fstp	 ST(0)
  00067	51		 push	 ecx
  00068	8d 4d e8	 lea	 ecx, DWORD PTR $T178120[ebp]
  0006b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T178130[ebp], OFFSET ??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@
  00072	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00077	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0007c	8d 55 e8	 lea	 edx, DWORD PTR $T178120[ebp]
  0007f	52		 push	 edx
  00080	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T178120[ebp], OFFSET ??_7length_error@std@@6B@
  00087	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@min_bucket:
$LN27@min_bucket:
  0008c	cc		 int	 3
?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z
_TEXT	SEGMENT
tv325 = -12						; size = 4
_num_probes$ = -8					; size = 4
_insert_pos$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position, COMDAT
; _this$ = edi
; _key$ = eax

; 807  :   pair<size_type, size_type> find_position(const key_type &key) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 808  :     size_type num_probes = 0;              // how many times we've probed
; 809  :     const size_type bucket_count_minus_one = bucket_count() - 1;
; 810  :     size_type bucknum = hash(key) & bucket_count_minus_one;

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b d1		 mov	 edx, ecx
  0000a	c1 e2 06	 shl	 edx, 6
  0000d	89 4d f4	 mov	 DWORD PTR tv325[ebp], ecx
  00010	2b ca		 sub	 ecx, edx
  00012	8b c1		 mov	 eax, ecx
  00014	c1 e8 11	 shr	 eax, 17			; 00000011H
  00017	33 c8		 xor	 ecx, eax
  00019	8b d1		 mov	 edx, ecx
  0001b	c1 e2 09	 shl	 edx, 9
  0001e	2b ca		 sub	 ecx, edx
  00020	8b c1		 mov	 eax, ecx
  00022	c1 e0 04	 shl	 eax, 4
  00025	33 c8		 xor	 ecx, eax
  00027	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0002e	2b ca		 sub	 ecx, edx
  00030	8b c1		 mov	 eax, ecx
  00032	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00035	33 c8		 xor	 ecx, eax
  00037	53		 push	 ebx

; 811  :     size_type insert_pos = ILLEGAL_BUCKET; // where we would insert
; 812  :     while ( 1 ) {                          // probe until something happens
; 813  :       if ( test_empty(bucknum) ) {         // bucket is empty

  00038	8b 5f 34	 mov	 ebx, DWORD PTR [edi+52]
  0003b	8b d1		 mov	 edx, ecx
  0003d	56		 push	 esi
  0003e	8b 77 28	 mov	 esi, DWORD PTR [edi+40]
  00041	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00044	33 d1		 xor	 edx, ecx
  00046	4e		 dec	 esi
  00047	23 d6		 and	 edx, esi
  00049	8b 0c d3	 mov	 ecx, DWORD PTR [ebx+edx*8]
  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _num_probes$[ebp], 0
  00053	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _insert_pos$[ebp], -1
  0005a	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  0005d	74 37		 je	 SHORT $LN116@find_posit
  0005f	90		 npad	 1
$LL10@find_posit:

; 818  : 
; 819  :       } else if ( test_deleted(bucknum) ) {// keep searching, but mark to insert

  00060	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00064	76 10		 jbe	 SHORT $LN4@find_posit
  00066	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00069	75 0b		 jne	 SHORT $LN4@find_posit

; 820  :         if ( insert_pos == ILLEGAL_BUCKET )

  0006b	83 7d fc ff	 cmp	 DWORD PTR _insert_pos$[ebp], -1
  0006f	75 0a		 jne	 SHORT $LN1@find_posit

; 821  :           insert_pos = bucknum;

  00071	89 55 fc	 mov	 DWORD PTR _insert_pos$[ebp], edx

; 822  : 
; 823  :       } else if ( equals(key, get_key(table[bucknum])) ) {

  00074	eb 05		 jmp	 SHORT $LN1@find_posit
$LN4@find_posit:
  00076	39 4d f4	 cmp	 DWORD PTR tv325[ebp], ecx
  00079	74 43		 je	 SHORT $LN112@find_posit
$LN1@find_posit:

; 825  :       }
; 826  :       ++num_probes;                        // we're doing another probe

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _num_probes$[ebp]
  0007e	40		 inc	 eax

; 827  :       bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one;

  0007f	03 d0		 add	 edx, eax
  00081	23 d6		 and	 edx, esi
  00083	8b 0c d3	 mov	 ecx, DWORD PTR [ebx+edx*8]
  00086	89 45 f8	 mov	 DWORD PTR _num_probes$[ebp], eax
  00089	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  0008c	75 d2		 jne	 SHORT $LL10@find_posit

; 814  :         if ( insert_pos == ILLEGAL_BUCKET )   // found no prior place to insert

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _insert_pos$[ebp]
  00091	83 f9 ff	 cmp	 ecx, -1
  00094	75 14		 jne	 SHORT $LN7@find_posit
$LN116@find_posit:

; 815  :           return pair<size_type,size_type>(ILLEGAL_BUCKET, bucknum);

  00096	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00099	5e		 pop	 esi
  0009a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  000a0	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a3	5b		 pop	 ebx

; 828  :       assert(num_probes < bucket_count()
; 829  :              && "Hashtable is full: an error in key_equal<> or hash<>");
; 830  :     }
; 831  :   }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
$LN7@find_posit:

; 816  :         else
; 817  :           return pair<size_type,size_type>(ILLEGAL_BUCKET, insert_pos);

  000aa	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ad	5e		 pop	 esi
  000ae	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  000b4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000b7	5b		 pop	 ebx

; 828  :       assert(num_probes < bucket_count()
; 829  :              && "Hashtable is full: an error in key_equal<> or hash<>");
; 830  :     }
; 831  :   }

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN112@find_posit:

; 824  :         return pair<size_type,size_type>(bucknum, ILLEGAL_BUCKET);

  000be	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c1	5e		 pop	 esi
  000c2	89 10		 mov	 DWORD PTR [eax], edx
  000c4	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  000cb	5b		 pop	 ebx

; 828  :       assert(num_probes < bucket_count()
; 829  :              && "Hashtable is full: an error in key_equal<> or hash<>");
; 830  :     }
; 831  :   }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 04 00	 ret	 4
?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted, COMDAT
; _this$ = ecx
; _it$ = eax

; 421  :     assert(settings.use_deleted());
; 422  :     bool retval = !test_deleted(it);

  00000	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00004	76 13		 jbe	 SHORT $LN15@set_delete
  00006	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00009	56		 push	 esi
  0000a	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  0000d	3b 32		 cmp	 esi, DWORD PTR [edx]
  0000f	5e		 pop	 esi
  00010	75 07		 jne	 SHORT $LN15@set_delete
  00012	ba 01 00 00 00	 mov	 edx, 1
  00017	eb 02		 jmp	 SHORT $LN16@set_delete
$LN15@set_delete:
  00019	33 d2		 xor	 edx, edx
$LN16@set_delete:

; 423  :     // &* converts from iterator to value-type.
; 424  :     set_key(&(*it), key_info.delkey);

  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00021	84 d2		 test	 dl, dl
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0002c	0f 94 c0	 sete	 al

; 425  :     return retval;
; 426  :   }

  0002f	c3		 ret	 0
?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++, COMDAT
; _this$ = eax

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	75 42		 jne	 SHORT $LN5@operator@9
  00008	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000b	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000f	75 1c		 jne	 SHORT $LN36@operator@9
  00011	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00013	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00017	75 11		 jne	 SHORT $LN19@operator@9
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL20@operator@9:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00024	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00028	74 f6		 je	 SHORT $LL20@operator@9
$LN19@operator@9:
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 266  : 		return (*this);
; 267  : 		}

  0002c	c3		 ret	 0
$LN36@operator@9:

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00034	75 12		 jne	 SHORT $LN3@operator@9
$LL4@operator@9:
  00036	8b 10		 mov	 edx, DWORD PTR [eax]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0b		 jne	 SHORT $LN3@operator@9
  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ee		 je	 SHORT $LL4@operator@9
$LN3@operator@9:
  00048	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@9:

; 266  : 		return (*this);
; 267  : 		}

  0004a	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 1054 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1055 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1056 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1057 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1058 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1059 : 		_Orphan_ptr(*this, _Pnode);
; 1060 : 
; 1061 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1062 : 		_Nodeptr _Pnode = (_Where++)._Mynode();

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	89 4d 08	 mov	 DWORD PTR __Where$[ebp], ecx

; 1063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1064 : 
; 1065 : 		if (_Pnode != this->_Myhead)

  0000b	3b 06		 cmp	 eax, DWORD PTR [esi]
  0000d	74 26		 je	 SHORT $LN36@erase@2

; 1066 : 			{	// not list head, safe to erase
; 1067 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1068 : 				this->_Nextnode(_Pnode);

  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	89 11		 mov	 DWORD PTR [ecx], edx

; 1069 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1070 : 				this->_Prevnode(_Pnode);

  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1071 : 
; 1072 : 			_Dest_val(this->_Alnod, _Pnode);
; 1073 : 			this->_Alnod.deallocate(_Pnode, 1);

  0001b	50		 push	 eax
  0001c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1074 : 
; 1075 : 			--this->_Mysize;
; 1076 : 			}
; 1077 : 		return (_Make_iter(_Where));

  00024	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00027	83 c4 04	 add	 esp, 4
  0002a	ff 4e 04	 dec	 DWORD PTR [esi+4]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
  0002f	8b c7		 mov	 eax, edi

; 1078 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN36@erase@2:

; 1074 : 
; 1075 : 			--this->_Mysize;
; 1076 : 			}
; 1077 : 		return (_Make_iter(_Where));

  00035	89 0f		 mov	 DWORD PTR [edi], ecx
  00037	8b c7		 mov	 eax, edi

; 1078 : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z
_TEXT	SEGMENT
?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hashval, COMDAT
; _this$ = esi
; __Keyval$ = eax

; 835  : 		size_type _Num = this->comp(_Keyval) & _Mask;

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0002a	8b c1		 mov	 eax, ecx
  0002c	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002f	33 c8		 xor	 ecx, eax
  00031	8b c1		 mov	 eax, ecx
  00033	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00036	33 c1		 xor	 eax, ecx
  00038	23 c2		 and	 eax, edx

; 836  : 		if (_Maxidx <= _Num)

  0003a	39 46 24	 cmp	 DWORD PTR [esi+36], eax
  0003d	77 09		 ja	 SHORT $LN1@Hashval

; 837  : 			_Num -= (_Mask >> 1) + 1;

  0003f	d1 ea		 shr	 edx, 1
  00041	83 c9 ff	 or	 ecx, -1
  00044	2b ca		 sub	 ecx, edx
  00046	03 c1		 add	 eax, ecx
$LN1@Hashval:

; 838  : 		return (_Num);
; 839  : 		}

  00048	c3		 ret	 0
?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hashval
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase_bucket, COMDAT
; _this$ = ecx
; __Bucket$ = esi

; 749  : 		{	// fix iterators before erasing _Plist before _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 750  : 		if (_Vec_hi(_Bucket) == _Plist)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Plist$[ebp]
  00009	39 54 f0 04	 cmp	 DWORD PTR [eax+esi*8+4], edx
  0000d	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  00010	75 21		 jne	 SHORT $LN5@Erase_buck

; 751  : 			if (_Vec_lo(_Bucket) == _Plist)

  00012	39 10		 cmp	 DWORD PTR [eax], edx
  00014	75 13		 jne	 SHORT $LN4@Erase_buck

; 752  : 				{	// make bucket empty
; 753  : 				_Vec_lo(_Bucket) = end();

  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 754  : 				_Vec_hi(_Bucket) = end();

  0001b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00021	89 4c f0 04	 mov	 DWORD PTR [eax+esi*8+4], ecx

; 760  : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Erase_buck:

; 755  : 				}
; 756  : 			else
; 757  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

  00029	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0002c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 760  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN5@Erase_buck:

; 758  : 		else if (_Vec_lo(_Bucket) == _Plist)

  00033	39 10		 cmp	 DWORD PTR [eax], edx
  00035	75 04		 jne	 SHORT $LN1@Erase_buck

; 759  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@Erase_buck:

; 760  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase_bucket
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z
_TEXT	SEGMENT
$T178934 = -8						; size = 4
__Where$152697 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound, COMDAT
; _this$ = ecx
; __Keyval$ = eax

; 603  : 		{	// find leftmost not less than _Keyval in mutable hash table

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 604  : 		size_type _Bucket = _Hashval(_Keyval);

  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b c8		 mov	 ecx, eax
  0000e	8b d1		 mov	 edx, ecx
  00010	c1 e2 06	 shl	 edx, 6
  00013	2b ca		 sub	 ecx, edx
  00015	8b d1		 mov	 edx, ecx
  00017	c1 ea 11	 shr	 edx, 17			; 00000011H
  0001a	33 ca		 xor	 ecx, edx
  0001c	8b d1		 mov	 edx, ecx
  0001e	c1 e2 09	 shl	 edx, 9
  00021	2b ca		 sub	 ecx, edx
  00023	8b d1		 mov	 edx, ecx
  00025	c1 e2 04	 shl	 edx, 4
  00028	33 ca		 xor	 ecx, edx
  0002a	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00031	2b ca		 sub	 ecx, edx
  00033	8b d1		 mov	 edx, ecx
  00035	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00038	33 ca		 xor	 ecx, edx
  0003a	8b d1		 mov	 edx, ecx
  0003c	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0003f	57		 push	 edi
  00040	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00043	33 d1		 xor	 edx, ecx
  00045	23 d7		 and	 edx, edi
  00047	39 56 24	 cmp	 DWORD PTR [esi+36], edx
  0004a	77 09		 ja	 SHORT $LN9@lower_boun@4
  0004c	d1 ef		 shr	 edi, 1
  0004e	83 c9 ff	 or	 ecx, -1
  00051	2b cf		 sub	 ecx, edi
  00053	03 d1		 add	 edx, ecx
$LN9@lower_boun@4:

; 605  : 		for (iterator _Where = _Begin(_Bucket);

  00055	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00058	8b 1c d1	 mov	 ebx, DWORD PTR [ecx+edx*8]
  0005b	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0005e	8d 3c d1	 lea	 edi, DWORD PTR [ecx+edx*8]
  00061	8b cb		 mov	 ecx, ebx
  00063	89 4d fc	 mov	 DWORD PTR __Where$152697[ebp], ecx

; 606  : 			_Where != _End(_Bucket); ++_Where)

$LL26@lower_boun@4:
  00066	3b de		 cmp	 ebx, esi
  00068	75 04		 jne	 SHORT $LN31@lower_boun@4
  0006a	8b d6		 mov	 edx, esi
  0006c	eb 05		 jmp	 SHORT $LN30@lower_boun@4
$LN31@lower_boun@4:
  0006e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00071	8b 12		 mov	 edx, DWORD PTR [edx]
$LN30@lower_boun@4:
  00073	3b ca		 cmp	 ecx, edx
  00075	74 3a		 je	 SHORT $LN2@lower_boun@4

; 607  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

  00077	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  0007a	74 04		 je	 SHORT $LN127@lower_boun@4

; 606  : 			_Where != _End(_Bucket); ++_Where)

  0007c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007e	eb e6		 jmp	 SHORT $LL26@lower_boun@4
$LN127@lower_boun@4:
  00080	89 4d fc	 mov	 DWORD PTR __Where$152697[ebp], ecx

; 608  : 				return (this->comp(_Keyval,
; 609  : 					this->_Kfn(*_Where)) ? end() : _Where);

  00083	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00086	74 16		 je	 SHORT $LN7@lower_boun@4
  00088	8d 45 f8	 lea	 eax, DWORD PTR $T178934[ebp]
  0008b	89 75 f8	 mov	 DWORD PTR $T178934[ebp], esi
  0008e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00090	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5b		 pop	 ebx

; 611  : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
$LN7@lower_boun@4:

; 608  : 				return (this->comp(_Keyval,
; 609  : 					this->_Kfn(*_Where)) ? end() : _Where);

  0009e	8d 45 fc	 lea	 eax, DWORD PTR __Where$152697[ebp]
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	89 08		 mov	 DWORD PTR [eax], ecx
  000aa	5b		 pop	 ebx

; 611  : 		}

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
$LN2@lower_boun@4:

; 610  : 		return (end());

  000b1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b4	5f		 pop	 edi
  000b5	89 30		 mov	 DWORD PTR [eax], esi
  000b7	5e		 pop	 esi
  000b8	89 4d fc	 mov	 DWORD PTR __Where$152697[ebp], ecx
  000bb	5b		 pop	 ebx

; 611  : 		}

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	__real@3f800000
;	COMDAT __real@3f800000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
xdata$x	ENDS
;	COMDAT ??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T179463 = -24						; size = 12
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Tmp$179954 = 12					; size = 4
$T179376 = 12						; size = 4
__Parg$ = 12						; size = 4
??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT

; 220  : 		{	// construct empty hash table

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00009	6a ff		 push	 -1
  0000b	68 00 00 00 00	 push	 __ehhandler$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Parg$[ebp]
  0001b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0001e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00025	57		 push	 edi
  00026	66 89 0e	 mov	 WORD PTR [esi], cx
  00029	33 ff		 xor	 edi, edi
  0002b	6a 10		 push	 16			; 00000010H
  0002d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4
  00038	3b c7		 cmp	 eax, edi
  0003a	0f 84 85 00 00
	00		 je	 $LN24@Hash@2
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 00		 mov	 DWORD PTR [eax], eax
  00045	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00048	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004b	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  0004e	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00051	89 3a		 mov	 DWORD PTR [edx], edi
  00053	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  00056	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  00059	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 221  : 		_Init();

  0005d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00060	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00068	f3 0f 11 46 28	 movss	 DWORD PTR [esi+40], xmm0
  0006d	8b 3a		 mov	 edi, DWORD PTR [edx]
  0006f	89 45 0c	 mov	 DWORD PTR __Tmp$179954[ebp], eax
  00072	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00075	3b f8		 cmp	 edi, eax
  00077	74 19		 je	 SHORT $LN84@Hash@2
  00079	8b c8		 mov	 ecx, eax
  0007b	3b c0		 cmp	 eax, eax
  0007d	74 10		 je	 SHORT $LN113@Hash@2
  0007f	53		 push	 ebx
$LL115@Hash@2:
  00080	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00082	89 1f		 mov	 DWORD PTR [edi], ebx
  00084	83 c1 04	 add	 ecx, 4
  00087	83 c7 04	 add	 edi, 4
  0008a	3b c8		 cmp	 ecx, eax
  0008c	75 f2		 jne	 SHORT $LL115@Hash@2
  0008e	5b		 pop	 ebx
$LN113@Hash@2:
  0008f	89 7a 04	 mov	 DWORD PTR [edx+4], edi
$LN84@Hash@2:
  00092	8b 02		 mov	 eax, DWORD PTR [edx]
  00094	8d 4d 0c	 lea	 ecx, DWORD PTR __Tmp$179954[ebp]
  00097	51		 push	 ecx
  00098	50		 push	 eax
  00099	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009e	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 222  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	c7 46 20 07 00
	00 00		 mov	 DWORD PTR [esi+32], 7
  000ad	c7 46 24 08 00
	00 00		 mov	 DWORD PTR [esi+36], 8
  000b4	5f		 pop	 edi
  000b5	8b c6		 mov	 eax, esi
  000b7	5e		 pop	 esi
  000b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8

; 220  : 		{	// construct empty hash table

$LN24@Hash@2:
  000c5	8d 55 0c	 lea	 edx, DWORD PTR $T179376[ebp]
  000c8	52		 push	 edx
  000c9	8d 4d e8	 lea	 ecx, DWORD PTR $T179463[ebp]
  000cc	89 7d 0c	 mov	 DWORD PTR $T179376[ebp], edi
  000cf	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000d9	8d 45 e8	 lea	 eax, DWORD PTR $T179463[ebp]
  000dc	50		 push	 eax
  000dd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T179463[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000e4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN135@Hash@2:
$LN134@Hash@2:
  000e9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$0:
  00000	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00003	83 c6 04	 add	 esi, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$1:
  0000b	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000e	83 c6 10	 add	 esi, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
__ehhandler$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
;	COMDAT ?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::find_unique, COMDAT
; _key$ = edi

; 1065 :   iterator find_unique(const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1066 :     return internal_end(
; 1067 :         internal_find_unique(key, iterator(root(), 0)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	56		 push	 esi
  0000d	83 ec 08	 sub	 esp, 8
  00010	8b f4		 mov	 esi, esp
  00012	83 ec 08	 sub	 esp, 8
  00015	8b c4		 mov	 eax, esp
  00017	89 10		 mov	 DWORD PTR [eax], edx
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00020	e8 00 00 00 00	 call	 ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  00025	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00028	8b c3		 mov	 eax, ebx
  0002a	e8 00 00 00 00	 call	 ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end

; 1068 :   }

  0002f	5e		 pop	 esi
  00030	8b c3		 mov	 eax, ebx
  00032	5b		 pop	 ebx
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::find_unique
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = eax

; 249  :   btree_map_container(const key_compare &comp = key_compare(),

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 250  :                       const allocator_type &alloc = allocator_type())
; 251  :       : super_type(comp, alloc) {
; 252  :   }

  00006	c3		 ret	 0
??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z
_TEXT	SEGMENT
tv237 = -12						; size = 8
tv229 = -12						; size = 8
tv246 = -8						; size = 4
tv239 = -8						; size = 4
tv231 = -8						; size = 4
tv242 = -2						; size = 2
tv234 = -2						; size = 2
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = ecx

; 681  :         table(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0000b	33 d2		 xor	 edx, edx
  0000d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00012	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0001a	c7 41 28 20 00
	00 00		 mov	 DWORD PTR [ecx+40], 32	; 00000020H
  00021	66 89 51 11	 mov	 WORD PTR [ecx+17], dx
  00025	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00028	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002d	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00030	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00033	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00036	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 682  :     // table is NULL until emptyval is set.  However, we set num_buckets
; 683  :     // here so we know how much space to allocate once emptyval is set
; 684  :     settings.reset_thresholds(bucket_count());

  00039	db 41 28	 fild	 DWORD PTR [ecx+40]
  0003c	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0003f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00042	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00045	85 c0		 test	 eax, eax
  00047	79 06		 jns	 SHORT $LN37@dense_hash@3
  00049	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN37@dense_hash@3:
  0004f	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00052	88 51 10	 mov	 BYTE PTR [ecx+16], dl
  00055	d9 7d fe	 fnstcw	 WORD PTR tv242[ebp]
  00058	0f b7 45 fe	 movzx	 eax, WORD PTR tv242[ebp]
  0005c	d8 c9		 fmul	 ST(0), ST(1)
  0005e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00063	89 45 f8	 mov	 DWORD PTR tv239[ebp], eax
  00066	d9 6d f8	 fldcw	 WORD PTR tv239[ebp]
  00069	df 7d f4	 fistp	 QWORD PTR tv237[ebp]
  0006c	8b 45 f4	 mov	 eax, DWORD PTR tv237[ebp]
  0006f	89 01		 mov	 DWORD PTR [ecx], eax
  00071	d9 6d fe	 fldcw	 WORD PTR tv242[ebp]
  00074	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  00077	d9 7d fe	 fnstcw	 WORD PTR tv234[ebp]
  0007a	0f b7 45 fe	 movzx	 eax, WORD PTR tv234[ebp]
  0007e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00083	89 45 f8	 mov	 DWORD PTR tv231[ebp], eax
  00086	d9 6d f8	 fldcw	 WORD PTR tv231[ebp]
  00089	df 7d f4	 fistp	 QWORD PTR tv229[ebp]
  0008c	8b 45 f4	 mov	 eax, DWORD PTR tv229[ebp]
  0008f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 685  :   }

  00092	8b c1		 mov	 eax, ecx
  00094	d9 6d fe	 fldcw	 WORD PTR tv234[ebp]
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z
_TEXT	SEGMENT
?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find, COMDAT
; ___$ReturnUdt$ = esi
; __Keyval$ = eax

; 586  : 		return (lower_bound(_Keyval));

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00006	56		 push	 esi
  00007	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
  0000c	8b c6		 mov	 eax, esi

; 587  : 		}

  0000e	c3		 ret	 0
?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Plist$ = 12						; size = 4
?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase, COMDAT

; 538  : 		{	// erase element at _Plist

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 539  : 		size_type _Bucket = _Hashval(this->_Kfn(*_Plist));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Plist$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	8b c8		 mov	 ecx, eax
  0000b	c1 e1 06	 shl	 ecx, 6
  0000e	2b c1		 sub	 eax, ecx
  00010	8b c8		 mov	 ecx, eax
  00012	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00015	33 c1		 xor	 eax, ecx
  00017	8b c8		 mov	 ecx, eax
  00019	c1 e1 09	 shl	 ecx, 9
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b c8		 mov	 ecx, eax
  00020	c1 e1 04	 shl	 ecx, 4
  00023	33 c1		 xor	 eax, ecx
  00025	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0002c	2b c1		 sub	 eax, ecx
  0002e	8b c8		 mov	 ecx, eax
  00030	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00033	33 c1		 xor	 eax, ecx
  00035	53		 push	 ebx
  00036	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	56		 push	 esi
  0003a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00040	8b c8		 mov	 ecx, eax
  00042	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00045	57		 push	 edi
  00046	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00049	33 c8		 xor	 ecx, eax
  0004b	23 cf		 and	 ecx, edi
  0004d	39 4e 24	 cmp	 DWORD PTR [esi+36], ecx
  00050	77 09		 ja	 SHORT $LN9@erase@3
  00052	d1 ef		 shr	 edi, 1
  00054	83 c8 ff	 or	 eax, -1
  00057	2b c7		 sub	 eax, edi
  00059	03 c8		 add	 ecx, eax
$LN9@erase@3:

; 540  : 
; 541  : 		_Erase_bucket(_List._Make_iter(_Plist), _Bucket);

  0005b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005e	39 54 c8 04	 cmp	 DWORD PTR [eax+ecx*8+4], edx
  00062	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  00065	75 1d		 jne	 SHORT $LN32@erase@3
  00067	39 10		 cmp	 DWORD PTR [eax], edx
  00069	75 11		 jne	 SHORT $LN31@erase@3
  0006b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0006e	89 10		 mov	 DWORD PTR [eax], edx
  00070	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00073	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00076	89 54 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], edx
  0007a	eb 10		 jmp	 SHORT $LN141@erase@3
$LN31@erase@3:
  0007c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0007f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00082	eb 08		 jmp	 SHORT $LN141@erase@3
$LN32@erase@3:
  00084	39 10		 cmp	 DWORD PTR [eax], edx
  00086	75 07		 jne	 SHORT $LN28@erase@3
  00088	8b 12		 mov	 edx, DWORD PTR [edx]
  0008a	89 10		 mov	 DWORD PTR [eax], edx
$LN141@erase@3:
  0008c	8b 55 0c	 mov	 edx, DWORD PTR __Plist$[ebp]
$LN28@erase@3:

; 542  : 		return (_List.erase(_Plist));

  0008f	8b 3a		 mov	 edi, DWORD PTR [edx]
  00091	8b ca		 mov	 ecx, edx
  00093	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  00096	74 1a		 je	 SHORT $LN140@erase@3
  00098	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0009b	8b 10		 mov	 edx, DWORD PTR [eax]
  0009d	89 3a		 mov	 DWORD PTR [edx], edi
  0009f	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	51		 push	 ecx
  000a4	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000a7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ac	83 c4 04	 add	 esp, 4
  000af	ff 4e 08	 dec	 DWORD PTR [esi+8]
$LN140@erase@3:
  000b2	89 3b		 mov	 DWORD PTR [ebx], edi
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	8b c3		 mov	 eax, ebx
  000b8	5b		 pop	 ebx

; 543  : 		}

  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ
_TEXT	SEGMENT
$T180683 = -2						; size = 2
??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 118  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fe	 lea	 eax, DWORD PTR $T180683[ebp]
  00007	50		 push	 eax
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >

; 119  : 		}

  0000e	8b c6		 mov	 eax, esi
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z
_TEXT	SEGMENT
$T180696 = -4						; size = 4
__Where$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find, COMDAT
; ___$ReturnUdt$ = eax

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Keyval$[ebp]
  00008	56		 push	 esi
  00009	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00012	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00015	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00019	75 1a		 jne	 SHORT $LN9@find
  0001b	57		 push	 edi
  0001c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0001e	8b ff		 npad	 2
$LL10@find:
  00020	39 79 0c	 cmp	 DWORD PTR [ecx+12], edi
  00023	73 05		 jae	 SHORT $LN8@find
  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00028	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:
  0002a	8b d1		 mov	 edx, ecx
  0002c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN7@find:
  0002e	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00032	74 ec		 je	 SHORT $LL10@find
  00034	5f		 pop	 edi
$LN9@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  00035	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00038	89 55 08	 mov	 DWORD PTR __Where$[ebp], edx
  0003b	3b d6		 cmp	 edx, esi
  0003d	74 16		 je	 SHORT $LN3@find
  0003f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00041	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00044	72 0f		 jb	 SHORT $LN3@find
  00046	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	5e		 pop	 esi
  0004c	89 10		 mov	 DWORD PTR [eax], edx
  0004e	5b		 pop	 ebx

; 1429 : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN3@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  00055	89 75 fc	 mov	 DWORD PTR $T180696[ebp], esi
  00058	8d 4d fc	 lea	 ecx, DWORD PTR $T180696[ebp]
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	5e		 pop	 esi
  0005e	89 10		 mov	 DWORD PTR [eax], edx
  00060	5b		 pop	 ebx

; 1429 : 		}

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv820 = -8						; size = 4
__Erasednode$ = -4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase, COMDAT

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00003	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000d	74 0a		 je	 SHORT $LN40@erase@4

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN305@erase@4:
$LN40@erase@4:
  00019	53		 push	 ebx
  0001a	56		 push	 esi

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0001b	8b d8		 mov	 ebx, eax
  0001d	57		 push	 edi

; 1207 : 		++_Where;	// save successor iterator for return

  0001e	8d 45 10	 lea	 eax, DWORD PTR __Where$[ebp]
  00021	89 5d fc	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00024	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00029	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002b	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0002f	74 05		 je	 SHORT $LN39@erase@4

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00031	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00034	eb 17		 jmp	 SHORT $LN301@erase@4
$LN39@erase@4:
  00036	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00039	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003d	74 04		 je	 SHORT $LN37@erase@4

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  0003f	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00041	eb 0a		 jmp	 SHORT $LN301@erase@4
$LN37@erase@4:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00043	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00046	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  00049	3b c3		 cmp	 eax, ebx
  0004b	75 7c		 jne	 SHORT $LN35@erase@4
$LN301@erase@4:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004d	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00051	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00054	75 03		 jne	 SHORT $LN34@erase@4

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00056	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@4:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00059	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005f	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00062	75 05		 jne	 SHORT $LN33@erase@4

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00064	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00067	eb 0b		 jmp	 SHORT $LN30@erase@4
$LN33@erase@4:
  00069	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006b	75 04		 jne	 SHORT $LN31@erase@4

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006d	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  0006f	eb 03		 jmp	 SHORT $LN30@erase@4
$LN31@erase@4:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00071	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@4:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00074	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00077	39 18		 cmp	 DWORD PTR [eax], ebx
  00079	75 24		 jne	 SHORT $LN29@erase@4

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007b	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007f	74 04		 je	 SHORT $LN43@erase@4
  00081	8b ce		 mov	 ecx, esi
  00083	eb 15		 jmp	 SHORT $LN95@erase@4
$LN43@erase@4:
  00085	8b 07		 mov	 eax, DWORD PTR [edi]
  00087	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0008b	8b cf		 mov	 ecx, edi
  0008d	75 0b		 jne	 SHORT $LN95@erase@4
  0008f	90		 npad	 1
$LL96@erase@4:
  00090	8b c8		 mov	 ecx, eax
  00092	8b 01		 mov	 eax, DWORD PTR [ecx]
  00094	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00098	74 f6		 je	 SHORT $LL96@erase@4
$LN95@erase@4:
  0009a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@4:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  0009f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000a2	89 4d f8	 mov	 DWORD PTR tv820[ebp], ecx
  000a5	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a8	75 7c		 jne	 SHORT $LN173@erase@4

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000aa	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000ae	74 07		 je	 SHORT $LN45@erase@4
  000b0	8b c6		 mov	 eax, esi
  000b2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000b5	eb 6f		 jmp	 SHORT $LN173@erase@4
$LN45@erase@4:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000b7	8b c7		 mov	 eax, edi
  000b9	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max
  000be	8b 4d f8	 mov	 ecx, DWORD PTR tv820[ebp]
  000c1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000c7	eb 5d		 jmp	 SHORT $LN173@erase@4
$LN35@erase@4:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c9	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000cc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ce	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000d0	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000d3	75 04		 jne	 SHORT $LN26@erase@4

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000d5	8b f0		 mov	 esi, eax

; 1257 : 			else

  000d7	eb 1a		 jmp	 SHORT $LN25@erase@4
$LN26@erase@4:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d9	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000dd	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e0	75 03		 jne	 SHORT $LN24@erase@4

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000e2	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@4:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000e5	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000e7	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000ea	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000ed	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000f0	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@4:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f9	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000fc	75 05		 jne	 SHORT $LN23@erase@4

; 1271 : 				_Root() = _Pnode;	// link down from root

  000fe	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  00101	eb 0e		 jmp	 SHORT $LN20@erase@4
$LN23@erase@4:
  00103	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00106	39 19		 cmp	 DWORD PTR [ecx], ebx
  00108	75 04		 jne	 SHORT $LN21@erase@4

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  0010a	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  0010c	eb 03		 jmp	 SHORT $LN20@erase@4
$LN21@erase@4:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0010e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@4:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00111	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00114	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00117	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0011a	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  0011d	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00120	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00123	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$LN173@erase@4:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  00126	8b 45 fc	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00129	b3 01		 mov	 bl, 1
  0012b	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  0012e	0f 85 ff 00 00
	00		 jne	 $LN19@erase@4

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00134	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00137	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  0013a	0f 84 f0 00 00
	00		 je	 $LN16@erase@4
$LL18@erase@4:
  00140	38 5f 14	 cmp	 BYTE PTR [edi+20], bl
  00143	0f 85 e7 00 00
	00		 jne	 $LN16@erase@4

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00149	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0014b	3b f9		 cmp	 edi, ecx
  0014d	75 69		 jne	 SHORT $LN15@erase@4

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  0014f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00152	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00156	75 15		 jne	 SHORT $LN14@erase@4

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  00158	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  0015b	52		 push	 edx
  0015c	8b ce		 mov	 ecx, esi
  0015e	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00162	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00167	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0016a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN14@erase@4:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  0016d	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00171	75 78		 jne	 SHORT $LN303@erase@4

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00173	8b 01		 mov	 eax, DWORD PTR [ecx]
  00175	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00178	75 08		 jne	 SHORT $LN11@erase@4
  0017a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0017d	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00180	74 65		 je	 SHORT $LN304@erase@4
$LN11@erase@4:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00182	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00185	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00188	75 15		 jne	 SHORT $LN9@erase@4

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0018a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018c	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  0018f	52		 push	 edx
  00190	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  00194	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00199	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0019c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN9@erase@4:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0019f	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  001a2	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  001a5	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001a8	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001ab	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1323 : 						_Lrotate(_Fixnodeparent);

  001ae	52		 push	 edx
  001af	8b ce		 mov	 ecx, esi
  001b1	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001b6	eb 78		 jmp	 SHORT $LN16@erase@4
$LN15@erase@4:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001b8	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001bc	75 14		 jne	 SHORT $LN7@erase@4

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001be	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001c1	52		 push	 edx
  001c2	8b ce		 mov	 ecx, esi
  001c4	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001c8	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001cd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001cf	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN7@erase@4:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001d2	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001d6	75 13		 jne	 SHORT $LN303@erase@4

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001d8	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001db	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  001de	75 1e		 jne	 SHORT $LN4@erase@4
  001e0	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e2	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  001e5	75 17		 jne	 SHORT $LN4@erase@4
$LN304@erase@4:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001e7	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$LN303@erase@4:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001ee	8b fe		 mov	 edi, esi
  001f0	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001f3	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  001f6	0f 85 44 ff ff
	ff		 jne	 $LL18@erase@4

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001fc	eb 32		 jmp	 SHORT $LN16@erase@4
$LN4@erase@4:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  00200	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00203	75 15		 jne	 SHORT $LN2@erase@4

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00205	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00208	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  0020b	52		 push	 edx
  0020c	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  00210	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00215	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00217	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN2@erase@4:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0021a	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  0021d	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00220	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00223	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00225	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1359 : 						_Rrotate(_Fixnodeparent);

  00228	52		 push	 edx
  00229	8b ce		 mov	 ecx, esi
  0022b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate
$LN16@erase@4:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00230	88 5f 14	 mov	 BYTE PTR [edi+20], bl
$LN19@erase@4:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00233	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00236	52		 push	 edx
  00237	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0023f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00242	83 c4 04	 add	 esp, 4
  00245	5f		 pop	 edi
  00246	5e		 pop	 esi
  00247	5b		 pop	 ebx
  00248	85 c0		 test	 eax, eax
  0024a	74 04		 je	 SHORT $LN1@erase@4

; 1373 : 			--this->_Mysize;

  0024c	48		 dec	 eax
  0024d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@4:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00250	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  00253	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00256	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 0c 00	 ret	 12			; 0000000cH
$LN302@erase@4:
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::find, COMDAT
; _key$ = edi

; 182  :   iterator find(const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree

; 183  :     return this->tree_.find_unique(key);

  0000b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0000d	56		 push	 esi
  0000e	83 ec 08	 sub	 esp, 8
  00011	8b f4		 mov	 esi, esp
  00013	83 ec 08	 sub	 esp, 8
  00016	8b c4		 mov	 eax, esp
  00018	89 08		 mov	 DWORD PTR [eax], ecx
  0001a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00021	e8 00 00 00 00	 call	 ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  00026	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00029	8b c6		 mov	 eax, esi
  0002b	8b d3		 mov	 edx, ebx
  0002d	e8 00 00 00 00	 call	 ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end
  00032	8b c6		 mov	 eax, esi

; 184  :   }

  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	59		 pop	 ecx
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::find
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_map.h
_TEXT	ENDS
;	COMDAT ??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>, COMDAT
; _this$ = eax

; 56   :   btree_map(const key_compare &comp = key_compare(),

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 57   :             const allocator_type &alloc = allocator_type())
; 58   :       : super_type(comp, alloc) {
; 59   :   }

  00006	c3		 ret	 0
??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z
_TEXT	SEGMENT
tv269 = -12						; size = 8
tv261 = -12						; size = 8
tv278 = -8						; size = 4
tv271 = -8						; size = 4
tv263 = -8						; size = 4
tv274 = -2						; size = 2
tv266 = -2						; size = 2
??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = ecx

; 190  :   explicit dense_hash_map(size_type expected_max_items_in_table = 0,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0000b	33 d2		 xor	 edx, edx
  0000d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00012	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0001a	c7 41 28 20 00
	00 00		 mov	 DWORD PTR [ecx+40], 32	; 00000020H
  00021	66 89 51 11	 mov	 WORD PTR [ecx+17], dx
  00025	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00028	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002d	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00030	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00033	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00036	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00039	db 41 28	 fild	 DWORD PTR [ecx+40]
  0003c	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0003f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00042	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00045	85 c0		 test	 eax, eax
  00047	79 06		 jns	 SHORT $LN40@dense_hash@4
  00049	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN40@dense_hash@4:
  0004f	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00052	88 51 10	 mov	 BYTE PTR [ecx+16], dl
  00055	d9 7d fe	 fnstcw	 WORD PTR tv274[ebp]
  00058	0f b7 45 fe	 movzx	 eax, WORD PTR tv274[ebp]
  0005c	d8 c9		 fmul	 ST(0), ST(1)
  0005e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00063	89 45 f8	 mov	 DWORD PTR tv271[ebp], eax
  00066	d9 6d f8	 fldcw	 WORD PTR tv271[ebp]
  00069	df 7d f4	 fistp	 QWORD PTR tv269[ebp]
  0006c	8b 45 f4	 mov	 eax, DWORD PTR tv269[ebp]
  0006f	89 01		 mov	 DWORD PTR [ecx], eax
  00071	d9 6d fe	 fldcw	 WORD PTR tv274[ebp]
  00074	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  00077	d9 7d fe	 fnstcw	 WORD PTR tv266[ebp]
  0007a	0f b7 45 fe	 movzx	 eax, WORD PTR tv266[ebp]
  0007e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00083	89 45 f8	 mov	 DWORD PTR tv263[ebp], eax
  00086	d9 6d f8	 fldcw	 WORD PTR tv263[ebp]
  00089	df 7d f4	 fistp	 QWORD PTR tv261[ebp]
  0008c	8b 45 f4	 mov	 eax, DWORD PTR tv261[ebp]
  0008f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 191  :                           const hasher& hf = hasher(),
; 192  :                           const key_equal& eql = key_equal(),
; 193  :                           const allocator_type& alloc = allocator_type())
; 194  :     : rep(expected_max_items_in_table, hf, eql, SelectKey(), SetKey(), alloc) {
; 195  :   }

  00092	8b c1		 mov	 eax, ecx
  00094	d9 6d fe	 fldcw	 WORD PTR tv266[ebp]
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
_TEXT	ENDS
PUBLIC	?test_size@@YAXXZ				; test_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark.cc
;	COMDAT ?test_size@@YAXXZ
_TEXT	SEGMENT
_stats$181730 = -8					; size = 8
?test_size@@YAXXZ PROC					; test_size, COMDAT

; 1998 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1999 : #ifdef USE_JUDY
; 2000 : 	Word_t w;
; 2001 : #endif
; 2002 : 
; 2003 : 	MEM(DATA_TREE, rbt_size(&tree, the_max));

  00006	b8 05 00 00 00	 mov	 eax, 5
  0000b	56		 push	 esi
  0000c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00012	75 11		 jne	 SHORT $LN13@test_size
  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0001a	03 f6		 add	 esi, esi
  0001c	03 f6		 add	 esi, esi
  0001e	03 f6		 add	 esi, esi
  00020	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN13@test_size:

; 2004 : 	MEM(DATA_HASHTABLE, tommy_hashtable_memory_usage(&hashtable));

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_data@@3IA, 0 ; the_data
  0002c	75 19		 jne	 SHORT $LN12@test_size
  0002e	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  00033	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+4
  00039	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  0003c	03 f6		 add	 esi, esi
  0003e	03 f6		 add	 esi, esi
  00040	33 c0		 xor	 eax, eax
  00042	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN12@test_size:

; 2005 : 	MEM(DATA_HASHDYN, tommy_hashdyn_memory_usage(&hashdyn));

  00047	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?the_data@@3IA, 1 ; the_data
  0004e	75 1c		 jne	 SHORT $LN11@test_size
  00050	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00055	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  0005b	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]
  0005e	03 f6		 add	 esi, esi
  00060	03 f6		 add	 esi, esi
  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN11@test_size:

; 2006 : 	MEM(DATA_HASHLIN, tommy_hashlin_memory_usage(&hashlin));

  0006c	b8 02 00 00 00	 mov	 eax, 2
  00071	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00077	75 18		 jne	 SHORT $LN10@test_size
  00079	8b 0d a0 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  0007f	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  00085	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  00088	03 f6		 add	 esi, esi
  0008a	03 f6		 add	 esi, esi
  0008c	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN10@test_size:

; 2007 : 	MEM(DATA_TRIE, tommy_trie_memory_usage(&trie));

  00091	b8 03 00 00 00	 mov	 eax, 3
  00096	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0009c	75 17		 jne	 SHORT $LN9@test_size
  0009e	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+128
  000a4	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+132
  000aa	8d 34 51	 lea	 esi, DWORD PTR [ecx+edx*2]
  000ad	c1 e6 04	 shl	 esi, 4
  000b0	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN9@test_size:

; 2008 : 	MEM(DATA_TRIE_INPLACE, tommy_trie_inplace_memory_usage(&trie_inplace));

  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  000c0	75 0e		 jne	 SHORT $LN8@test_size
  000c2	8b 35 00 01 00
	00		 mov	 esi, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  000c8	c1 e6 05	 shl	 esi, 5
  000cb	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN8@test_size:

; 2009 : 	MEM(DATA_KHASH, khash_size(khash));

  000d0	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR ?the_data@@3IA, 7 ; the_data
  000d7	75 1d		 jne	 SHORT $LN7@test_size
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  000de	8b 00		 mov	 eax, DWORD PTR [eax]
  000e0	8b c8		 mov	 ecx, eax
  000e2	c1 e9 04	 shr	 ecx, 4
  000e5	8d 34 41	 lea	 esi, DWORD PTR [ecx+eax*2]
  000e8	03 f6		 add	 esi, esi
  000ea	03 f6		 add	 esi, esi
  000ec	b8 07 00 00 00	 mov	 eax, 7
  000f1	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN7@test_size:

; 2010 : #ifdef USE_GOOGLEDENSEHASH
; 2011 : 	MEM(DATA_GOOGLEDENSEHASH, googledensehash_size(googledensehash));

  000f6	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000fb	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00101	75 14		 jne	 SHORT $LN6@test_size
  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00109	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  0010c	03 f6		 add	 esi, esi
  0010e	03 f6		 add	 esi, esi
  00110	03 f6		 add	 esi, esi
  00112	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN6@test_size:

; 2012 : #endif
; 2013 : #ifdef USE_GOOGLEBTREE
; 2014 : 	MEM(DATA_GOOGLEBTREE, googlebtree_size(googlebtree));

  00117	83 3d 00 00 00
	00 0c		 cmp	 DWORD PTR ?the_data@@3IA, 12 ; the_data, 0000000cH
  0011e	75 45		 jne	 SHORT $LN5@test_size
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00126	8b 31		 mov	 esi, DWORD PTR [ecx]
  00128	56		 push	 esi
  00129	8d 45 f8	 lea	 eax, DWORD PTR _stats$181730[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00132	8b 45 f8	 mov	 eax, DWORD PTR _stats$181730[ebp]
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _stats$181730[ebp+4]
  00138	83 f8 01	 cmp	 eax, 1
  0013b	75 11		 jne	 SHORT $LN71@test_size
  0013d	85 c9		 test	 ecx, ecx
  0013f	75 0d		 jne	 SHORT $LN71@test_size
  00141	0f b6 76 02	 movzx	 esi, BYTE PTR [esi+2]
  00145	8d 34 f5 0c 00
	00 00		 lea	 esi, DWORD PTR [esi*8+12]
  0014c	eb 0d		 jmp	 SHORT $LN70@test_size
$LN71@test_size:
  0014e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00151	c1 e1 07	 shl	 ecx, 7
  00154	c1 e0 08	 shl	 eax, 8
  00157	8d 74 01 0c	 lea	 esi, DWORD PTR [ecx+eax+12]
$LN70@test_size:
  0015b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00160	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN5@test_size:

; 2015 : #endif
; 2016 : 	MEM(DATA_UTHASH, uthash_size(uthash));

  00165	83 3d 00 00 00
	00 08		 cmp	 DWORD PTR ?the_data@@3IA, 8 ; the_data
  0016c	75 30		 jne	 SHORT $LN4@test_size
  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  00173	85 c0		 test	 eax, eax
  00175	75 04		 jne	 SHORT $LN83@test_size
  00177	33 f6		 xor	 esi, esi
  00179	eb 19		 jmp	 SHORT $LN84@test_size
$LN83@test_size:
  0017b	8b 00		 mov	 eax, DWORD PTR [eax]
  0017d	85 c0		 test	 eax, eax
  0017f	75 04		 jne	 SHORT $LN82@test_size
  00181	33 f6		 xor	 esi, esi
  00183	eb 0f		 jmp	 SHORT $LN84@test_size
$LN82@test_size:
  00185	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	c1 e2 05	 shl	 edx, 5
  0018e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00191	8d 34 82	 lea	 esi, DWORD PTR [edx+eax*4]
$LN84@test_size:
  00194	b8 08 00 00 00	 mov	 eax, 8
  00199	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN4@test_size:

; 2017 : 	MEM(DATA_NEDTRIE, nedtrie_size(&nedtrie));

  0019e	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?the_data@@3IA, 6 ; the_data
  001a5	75 16		 jne	 SHORT $LN3@test_size
  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  001ac	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  001af	03 f6		 add	 esi, esi
  001b1	03 f6		 add	 esi, esi
  001b3	b8 06 00 00 00	 mov	 eax, 6
  001b8	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN3@test_size:

; 2018 : #ifdef USE_JUDY
; 2019 : 	JLMU(w, judy);

  001bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judy@@3PAXA ; judy
  001c3	51		 push	 ecx
  001c4	e8 00 00 00 00	 call	 _JudyLMemUsed
  001c9	83 c4 04	 add	 esp, 4

; 2020 : 	MEM(DATA_JUDY, w);

  001cc	83 3d 00 00 00
	00 09		 cmp	 DWORD PTR ?the_data@@3IA, 9 ; the_data
  001d3	75 0c		 jne	 SHORT $LN2@test_size
  001d5	8b f0		 mov	 esi, eax
  001d7	b8 09 00 00 00	 mov	 eax, 9
  001dc	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN2@test_size:

; 2021 : #endif
; 2022 : #ifdef USE_JUDYARRAY
; 2023 : 	MEM(DATA_JUDYARRAY,judy_size(judyarray));

  001e1	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR ?the_data@@3IA, 10 ; the_data, 0000000aH
  001e8	75 30		 jne	 SHORT $LN1@test_size
  001ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  001f0	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001f3	33 f6		 xor	 esi, esi
  001f5	85 c0		 test	 eax, eax
  001f7	74 17		 je	 SHORT $LN94@test_size
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL95@test_size:
  00200	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00205	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00208	8b 00		 mov	 eax, DWORD PTR [eax]
  0020a	03 f1		 add	 esi, ecx
  0020c	85 c0		 test	 eax, eax
  0020e	75 f0		 jne	 SHORT $LL95@test_size
$LN94@test_size:
  00210	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00215	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN1@test_size:

; 2024 : #endif
; 2025 : }

  0021a	5e		 pop	 esi
  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c3		 ret	 0
?test_size@@YAXXZ ENDP					; test_size
_TEXT	ENDS
PUBLIC	?judy_del@@YAPAIPAUJudy@@@Z			; judy_del
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_del@@YAPAIPAUJudy@@@Z
_TEXT	SEGMENT
tv334 = -28						; size = 4
_cnt$ = -24						; size = 4
tv659 = -20						; size = 4
tv347 = -16						; size = 4
_node$ = -12						; size = 4
_size$ = -12						; size = 4
tv568 = -8						; size = 4
tv587 = -4						; size = 4
?judy_del@@YAPAIPAUJudy@@@Z PROC			; judy_del, COMDAT

; 1154 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00009	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1155 : int slot, off, size, type, high;
; 1156 : JudySlot *table, *inner;
; 1157 : JudySlot next, *node;
; 1158 : int keysize, cnt;
; 1159 : uchar *base;
; 1160 : 
; 1161 : 	while( judy->level ) {

  0000c	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	0f 84 9a 01 00
	00		 je	 $LN15@judy_del
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL16@judy_del:

; 1162 : 		next = judy->stack[judy->level].next;

  00020	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00023	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00026	8d 1c 8a	 lea	 ebx, DWORD PTR [edx+ecx*4]
  00029	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]

; 1163 : 		slot = judy->stack[judy->level].slot;

  0002c	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  00030	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]

; 1165 : 		size = JudySize[next & 0x07];

  00033	8b f9		 mov	 edi, ecx
  00035	83 e7 07	 and	 edi, 7
  00038	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4]
  0003f	89 7d e4	 mov	 DWORD PTR tv334[ebp], edi
  00042	89 45 f4	 mov	 DWORD PTR _size$[ebp], eax

; 1166 : 
; 1167 : 		switch( type = next & 0x07 ) {

  00045	83 ff 07	 cmp	 edi, 7
  00048	0f 87 55 01 00
	00		 ja	 $LN49@judy_del
  0004e	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $LN50@judy_del[edi*4]
$LN12@judy_del:

; 1168 : 		case JUDY_1:
; 1169 : 		case JUDY_2:
; 1170 : 		case JUDY_4:
; 1171 : 		case JUDY_8:
; 1172 : 		case JUDY_16:
; 1173 : 		case JUDY_32:
; 1174 : #ifdef ASKITIS
; 1175 : 		case JUDY_64:
; 1176 : #endif
; 1177 : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  00055	8b 53 38	 mov	 edx, DWORD PTR [ebx+56]
  00058	83 e2 03	 and	 edx, 3
  0005b	bf 04 00 00 00	 mov	 edi, 4
  00060	2b fa		 sub	 edi, edx

; 1178 : 			cnt = size / (sizeof(JudySlot) + keysize);

  00062	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
  00065	33 d2		 xor	 edx, edx
  00067	f7 f3		 div	 ebx

; 1179 : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00069	83 e1 f8	 and	 ecx, -8			; fffffff8H
  0006c	89 4d f0	 mov	 DWORD PTR tv347[ebp], ecx
  0006f	89 45 e8	 mov	 DWORD PTR _cnt$[ebp], eax
  00072	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  00075	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  00078	89 5d f4	 mov	 DWORD PTR _node$[ebp], ebx

; 1180 : 			base = (uchar *)(next & JUDY_mask);
; 1181 : 
; 1182 : 			//	move deleted slot to first slot
; 1183 : 
; 1184 : 			while( slot ) {

  0007b	85 f6		 test	 esi, esi
  0007d	74 52		 je	 SHORT $LN10@judy_del

; 1164 : 		off = judy->stack[judy->level].off;

  0007f	8b c7		 mov	 eax, edi
  00081	f7 d8		 neg	 eax
  00083	89 45 ec	 mov	 DWORD PTR tv659[ebp], eax
  00086	8b d7		 mov	 edx, edi
  00088	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  0008b	0f af d6	 imul	 edx, esi
  0008e	0f af c7	 imul	 eax, edi
  00091	03 d1		 add	 edx, ecx
  00093	03 c1		 add	 eax, ecx
  00095	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  0009c	89 55 f8	 mov	 DWORD PTR tv568[ebp], edx
  0009f	89 45 fc	 mov	 DWORD PTR tv587[ebp], eax
  000a2	2b d9		 sub	 ebx, ecx
  000a4	eb 06		 jmp	 SHORT $LN11@judy_del
$LL48@judy_del:
  000a6	8b 55 f8	 mov	 edx, DWORD PTR tv568[ebp]
  000a9	8b 45 fc	 mov	 eax, DWORD PTR tv587[ebp]
$LN11@judy_del:

; 1185 : 				node[-slot-1] = node[-slot];

  000ac	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1186 : 				memcpy (base + slot * keysize, base + (slot - 1) * keysize, keysize);

  000ae	57		 push	 edi
  000af	50		 push	 eax
  000b0	52		 push	 edx
  000b1	89 4b fc	 mov	 DWORD PTR [ebx-4], ecx
  000b4	e8 00 00 00 00	 call	 _memcpy

; 1187 : 				slot--;

  000b9	8b 45 ec	 mov	 eax, DWORD PTR tv659[ebp]
  000bc	01 45 fc	 add	 DWORD PTR tv587[ebp], eax
  000bf	01 45 f8	 add	 DWORD PTR tv568[ebp], eax
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	83 c3 04	 add	 ebx, 4
  000c8	4e		 dec	 esi
  000c9	75 db		 jne	 SHORT $LL48@judy_del

; 1180 : 			base = (uchar *)(next & JUDY_mask);
; 1181 : 
; 1182 : 			//	move deleted slot to first slot
; 1183 : 
; 1184 : 			while( slot ) {

  000cb	8b 5d f4	 mov	 ebx, DWORD PTR _node$[ebp]
  000ce	8b 4d f0	 mov	 ecx, DWORD PTR tv347[ebp]
$LN10@judy_del:

; 1188 : 			}
; 1189 : 
; 1190 : 			//	zero out first slot
; 1191 : 
; 1192 : 			node[-1] = 0;
; 1193 : 			memset (base, 0, keysize);

  000d1	57		 push	 edi
  000d2	6a 00		 push	 0
  000d4	51		 push	 ecx
  000d5	c7 43 fc 00 00
	00 00		 mov	 DWORD PTR [ebx-4], 0
  000dc	e8 00 00 00 00	 call	 _memset

; 1194 : 
; 1195 : 			if( node[-cnt] ) {	// does node have any slots left?

  000e1	8b 55 e8	 mov	 edx, DWORD PTR _cnt$[ebp]
  000e4	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  000e7	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*4]
  000ee	2b c1		 sub	 eax, ecx
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f3	83 38 00	 cmp	 DWORD PTR [eax], 0
  000f6	0f 85 c6 00 00
	00		 jne	 $LN44@judy_del

; 1198 : 			}
; 1199 : 
; 1200 : 			judy_free (judy, base, type);

  000fc	8b 4d e4	 mov	 ecx, DWORD PTR tv334[ebp]
  000ff	85 c9		 test	 ecx, ecx
  00101	75 07		 jne	 SHORT $LN20@judy_del
  00103	b9 04 00 00 00	 mov	 ecx, 4
  00108	eb 0a		 jmp	 SHORT $LN19@judy_del
$LN20@judy_del:
  0010a	83 f9 07	 cmp	 ecx, 7
  0010d	75 05		 jne	 SHORT $LN19@judy_del
  0010f	b9 03 00 00 00	 mov	 ecx, 3
$LN19@judy_del:
  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00119	8b 74 88 04	 mov	 esi, DWORD PTR [eax+ecx*4+4]
  0011d	8b 55 f0	 mov	 edx, DWORD PTR tv347[ebp]
  00120	89 32		 mov	 DWORD PTR [edx], esi
  00122	89 54 88 04	 mov	 DWORD PTR [eax+ecx*4+4], edx

; 1201 : 			judy->level--;

  00126	ff 48 28	 dec	 DWORD PTR [eax+40]

; 1202 : 			continue;

  00129	eb 78		 jmp	 SHORT $LN49@judy_del
$LN8@judy_del:

; 1203 : 
; 1204 : 		case JUDY_radix:
; 1205 : 			table = (JudySlot  *)(next & JUDY_mask);
; 1206 : 			inner = (JudySlot *)(table[slot >> 4] & JUDY_mask);

  0012b	8b d6		 mov	 edx, esi
  0012d	c1 fa 04	 sar	 edx, 4
  00130	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00133	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00136	8d 3c 91	 lea	 edi, DWORD PTR [ecx+edx*4]
  00139	83 e0 f8	 and	 eax, -8			; fffffff8H

; 1207 : 			inner[slot & 0x0F] = 0;

  0013c	83 e6 0f	 and	 esi, 15			; 0000000fH
  0013f	c7 04 b0 00 00
	00 00		 mov	 DWORD PTR [eax+esi*4], 0

; 1208 : 			high = slot & 0xF0;
; 1209 : 
; 1210 : 			for( cnt = 16; cnt--; )

  00146	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0014b	eb 03 8d 49 00	 npad	 5
$LL7@judy_del:
  00150	4a		 dec	 edx

; 1211 : 				if( inner[cnt] )

  00151	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  00155	0f 85 86 00 00
	00		 jne	 $LN42@judy_del

; 1208 : 			high = slot & 0xF0;
; 1209 : 
; 1210 : 			for( cnt = 16; cnt--; )

  0015b	85 d2		 test	 edx, edx
  0015d	75 f1		 jne	 SHORT $LL7@judy_del

; 1213 : 
; 1214 : 			judy_free (judy, inner, JUDY_radix);

  0015f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00165	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00168	89 30		 mov	 DWORD PTR [eax], esi
  0016a	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1215 : 			table[slot >> 4] = 0;

  0016d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1216 : 
; 1217 : 			for( cnt = 16; cnt--; )

  00173	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
$LL4@judy_del:
  00178	48		 dec	 eax

; 1218 : 				if( table[cnt] )

  00179	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0017d	75 62		 jne	 SHORT $LN42@judy_del

; 1216 : 
; 1217 : 			for( cnt = 16; cnt--; )

  0017f	85 c0		 test	 eax, eax
  00181	75 f5		 jne	 SHORT $LL4@judy_del

; 1219 : 					return judy_prv (judy);
; 1220 : 
; 1221 : 			judy_free (judy, table, JUDY_radix);

  00183	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00188	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0018b	89 11		 mov	 DWORD PTR [ecx], edx
  0018d	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1222 : 			judy->level--;

  00190	ff 48 28	 dec	 DWORD PTR [eax+40]

; 1223 : 			continue;

  00193	eb 0e		 jmp	 SHORT $LN49@judy_del
$LN1@judy_del:

; 1224 : 
; 1225 : #ifndef ASKITIS
; 1226 : 		case JUDY_span:
; 1227 : 			base = (uchar *)(next & JUDY_mask);
; 1228 : 			judy_free (judy, base, type);

  00195	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00198	83 e1 f8	 and	 ecx, -8			; fffffff8H
  0019b	89 01		 mov	 DWORD PTR [ecx], eax
  0019d	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1229 : 			judy->level--;

  001a0	ff 4a 28	 dec	 DWORD PTR [edx+40]
$LN49@judy_del:

; 1155 : int slot, off, size, type, high;
; 1156 : JudySlot *table, *inner;
; 1157 : JudySlot next, *node;
; 1158 : int keysize, cnt;
; 1159 : uchar *base;
; 1160 : 
; 1161 : 	while( judy->level ) {

  001a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  001a9	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  001ad	0f 85 6d fe ff
	ff		 jne	 $LL16@judy_del
$LN15@judy_del:
  001b3	5f		 pop	 edi
  001b4	5e		 pop	 esi

; 1230 : 			continue;
; 1231 : #endif
; 1232 : 		}
; 1233 : 	}
; 1234 : 
; 1235 : 	//	tree is now empty
; 1236 : 
; 1237 : 	*judy->root = 0;

  001b5	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1238 : 	return NULL;

  001bb	33 c0		 xor	 eax, eax
  001bd	5b		 pop	 ebx

; 1239 : }

  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c3		 ret	 0
$LN44@judy_del:

; 1196 : 				judy->stack[judy->level].slot++;

  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  001c8	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  001cb	8d 54 40 0f	 lea	 edx, DWORD PTR [eax+eax*2+15]
  001cf	ff 04 91	 inc	 DWORD PTR [ecx+edx*4]
  001d2	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 1197 : 				return judy_prv (judy);

  001d5	e8 00 00 00 00	 call	 ?judy_prv@@YAPAIPAUJudy@@@Z ; judy_prv
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx

; 1239 : }

  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c3		 ret	 0
$LN42@judy_del:

; 1212 : 					return judy_prv (judy);

  001e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  001e7	e8 00 00 00 00	 call	 ?judy_prv@@YAPAIPAUJudy@@@Z ; judy_prv
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx

; 1239 : }

  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
  001f3	90		 npad	 1
$LN50@judy_del:
  001f4	00 00 00 00	 DD	 $LN8@judy_del
  001f8	00 00 00 00	 DD	 $LN12@judy_del
  001fc	00 00 00 00	 DD	 $LN12@judy_del
  00200	00 00 00 00	 DD	 $LN12@judy_del
  00204	00 00 00 00	 DD	 $LN12@judy_del
  00208	00 00 00 00	 DD	 $LN12@judy_del
  0020c	00 00 00 00	 DD	 $LN12@judy_del
  00210	00 00 00 00	 DD	 $LN1@judy_del
?judy_del@@YAPAIPAUJudy@@@Z ENDP			; judy_del
_TEXT	ENDS
PUBLIC	?judy_splitnode@@YAXPAUJudy@@PAIIII@Z		; judy_splitnode
; Function compile flags: /Ogtp
;	COMDAT ?judy_splitnode@@YAXPAUJudy@@PAIIII@Z
_TEXT	SEGMENT
_newradix$ = -12					; size = 4
_nxt$ = -8						; size = 4
_start$ = -4						; size = 4
_judy$ = 8						; size = 4
tv293 = 12						; size = 4
_next$ = 12						; size = 4
_cnt$ = 16						; size = 4
_size$ = 16						; size = 4
_keysize$ = 20						; size = 4
_depth$ = 24						; size = 4
?judy_splitnode@@YAXPAUJudy@@PAIIII@Z PROC		; judy_splitnode, COMDAT

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 782  : uint key = 0x0100, nxt;
; 783  : JudySlot *newradix;
; 784  : uchar *base;
; 785  : 
; 786  : 	base = (uchar  *)(*next & JUDY_mask);
; 787  : 	cnt = size / (sizeof(JudySlot) + keysize);

  00006	8b 4d 14	 mov	 ecx, DWORD PTR _keysize$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  0000c	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 f1		 div	 ecx

; 788  : 
; 789  : 	//	allocate outer judy_radix node
; 790  : 
; 791  : 	newradix = (JudySlot*)judy_alloc (judy, JUDY_radix);

  00013	8b 55 08	 mov	 edx, DWORD PTR _judy$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _next$[ebp]
  0001a	56		 push	 esi
  0001b	8b 33		 mov	 esi, DWORD PTR [ebx]
  0001d	57		 push	 edi
  0001e	52		 push	 edx
  0001f	33 c9		 xor	 ecx, ecx
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
  00028	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
  0002d	83 e6 f8	 and	 esi, -8			; fffffff8H
  00030	89 45 10	 mov	 DWORD PTR _cnt$[ebp], eax
  00033	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc
  00038	8b d0		 mov	 edx, eax
  0003a	8b 45 14	 mov	 eax, DWORD PTR _keysize$[ebp]

; 792  : 	*next = (JudySlot)newradix | JUDY_radix;

  0003d	89 13		 mov	 DWORD PTR [ebx], edx

; 793  : 
; 794  : 	for( slot = 0; slot < cnt; slot++ ) {

  0003f	33 db		 xor	 ebx, ebx
  00041	83 c4 04	 add	 esp, 4
  00044	89 55 f4	 mov	 DWORD PTR _newradix$[ebp], edx
  00047	39 5d 10	 cmp	 DWORD PTR _cnt$[ebp], ebx
  0004a	7e 50		 jle	 SHORT $LN3@judy_split@2

; 781  : int cnt, slot, start = 0;

  0004c	8d 4c 06 ff	 lea	 ecx, DWORD PTR [esi+eax-1]
  00050	89 4d 0c	 mov	 DWORD PTR tv293[ebp], ecx
$LL15@judy_split@2:

; 795  : #if BYTE_ORDER != BIG_ENDIAN
; 796  : 		nxt = base[slot * keysize + keysize - 1];

  00053	8b 4d 0c	 mov	 ecx, DWORD PTR tv293[ebp]
  00056	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00059	89 4d f8	 mov	 DWORD PTR _nxt$[ebp], ecx

; 797  : #else
; 798  : 		nxt = base[slot * keysize];
; 799  : #endif
; 800  : 
; 801  : 		if( key > 0xFF )

  0005c	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  00062	76 04		 jbe	 SHORT $LN2@judy_split@2

; 802  : 			key = nxt;

  00064	8b f9		 mov	 edi, ecx

; 803  : 		if( nxt == key )

  00066	eb 2b		 jmp	 SHORT $LN4@judy_split@2
$LN2@judy_split@2:
  00068	3b cf		 cmp	 ecx, edi
  0006a	74 27		 je	 SHORT $LN4@judy_split@2

; 804  : 			continue;
; 805  : 
; 806  : 		//	decompose portion of old node into radix nodes
; 807  : 
; 808  : 		judy_radix (judy, newradix, base, start, slot, keysize - 1, (uchar)key, depth);

  0006c	8b 4d 18	 mov	 ecx, DWORD PTR _depth$[ebp]
  0006f	51		 push	 ecx
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  00073	57		 push	 edi
  00074	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
  00077	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0007a	50		 push	 eax
  0007b	56		 push	 esi
  0007c	51		 push	 ecx
  0007d	8b c3		 mov	 eax, ebx
  0007f	e8 00 00 00 00	 call	 ?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z ; judy_radix

; 809  : 		start = slot;
; 810  : 		key = nxt;

  00084	8b 7d f8	 mov	 edi, DWORD PTR _nxt$[ebp]
  00087	8b 55 f4	 mov	 edx, DWORD PTR _newradix$[ebp]
  0008a	8b 45 14	 mov	 eax, DWORD PTR _keysize$[ebp]
  0008d	83 c4 14	 add	 esp, 20			; 00000014H
  00090	89 5d fc	 mov	 DWORD PTR _start$[ebp], ebx
$LN4@judy_split@2:

; 793  : 
; 794  : 	for( slot = 0; slot < cnt; slot++ ) {

  00093	01 45 0c	 add	 DWORD PTR tv293[ebp], eax
  00096	43		 inc	 ebx
  00097	3b 5d 10	 cmp	 ebx, DWORD PTR _cnt$[ebp]
  0009a	7c b7		 jl	 SHORT $LL15@judy_split@2
$LN3@judy_split@2:

; 811  : 	}
; 812  : 
; 813  : 	judy_radix (judy, newradix, base, start, slot, keysize - 1, (uchar)key, depth);

  0009c	8b 4d 18	 mov	 ecx, DWORD PTR _depth$[ebp]
  0009f	51		 push	 ecx
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  000a3	57		 push	 edi
  000a4	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  000aa	50		 push	 eax
  000ab	56		 push	 esi
  000ac	51		 push	 ecx
  000ad	8b c3		 mov	 eax, ebx
  000af	e8 00 00 00 00	 call	 ?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z ; judy_radix

; 814  : 	judy_free (judy, (void **)base, JUDY_max);

  000b4	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  000b7	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000ba	83 c4 14	 add	 esp, 20			; 00000014H
  000bd	89 16		 mov	 DWORD PTR [esi], edx
  000bf	5f		 pop	 edi
  000c0	89 70 1c	 mov	 DWORD PTR [eax+28], esi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx

; 815  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?judy_splitnode@@YAXPAUJudy@@PAIIII@Z ENDP		; judy_splitnode
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashlin.c
_TEXT	ENDS
;	COMDAT ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z
_TEXT	SEGMENT
_split$86834 = -12					; size = 8
_count$181840 = -4					; size = 4
?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z PROC	; hashlin_grow_step, COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 120  : 	/* grow if more than 50% full */
; 121  : 	if (hashlin->state != TOMMY_HASHLIN_STATE_GROW
; 122  : 		&& hashlin->count > hashlin->bucket_max / 2
; 123  : 	) {

  00003	a1 9c 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156
  00008	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 90 00 00
	00		 je	 $LN28@hashlin_gr
  00014	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  0001a	8b ca		 mov	 ecx, edx
  0001c	d1 e9		 shr	 ecx, 1
  0001e	39 0d a0 00 00
	00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160, ecx
  00024	0f 86 71 01 00
	00		 jbe	 $LN6@hashlin_gr

; 124  : 		/* if we are stable, setup a new grow state */
; 125  : 		/* otherwise continue with the already setup shrink one */
; 126  : 		/* but in backward direction */
; 127  : 		if (hashlin->state == TOMMY_HASHLIN_STATE_STABLE) {

  0002a	85 c0		 test	 eax, eax
  0002c	75 65		 jne	 SHORT $LN27@hashlin_gr

; 128  : 			/* set the lower size */
; 129  : 			hashlin->low_max = hashlin->bucket_max;
; 130  : 			hashlin->low_mask = hashlin->bucket_mask;

  0002e	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136

; 131  : 
; 132  : 			/* grow the hash size and allocate */
; 133  : 			++hashlin->bucket_bit;

  00033	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128
  00039	a3 94 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148, eax
  0003e	41		 inc	 ecx

; 134  : 			hashlin->bucket_max = 1 << hashlin->bucket_bit;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	d3 e0		 shl	 eax, cl
  00046	89 0d 80 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, ecx

; 135  : 			hashlin->bucket_mask = hashlin->bucket_max - 1;
; 136  : 			hashlin->bucket[hashlin->bucket_mac] = tommy_cast(tommy_hashlin_node**, tommy_malloc(hashlin->low_max * sizeof(tommy_hashlin_node*)));

  0004c	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*4]
  00053	51		 push	 ecx
  00054	a3 84 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132, eax
  00059	48		 dec	 eax
  0005a	89 15 90 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144, edx
  00060	a3 88 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136, eax
  00065	e8 00 00 00 00	 call	 _malloc
  0006a	8b 15 8c 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  00070	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[edx*4], eax

; 137  : 			++hashlin->bucket_mac;

  00077	ff 05 8c 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  0007d	83 c4 04	 add	 esp, 4

; 138  : 
; 139  : 			/* start from the beginning going forward */
; 140  : 			hashlin->split = 0;

  00080	33 c0		 xor	 eax, eax
  00082	a3 98 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, eax

; 141  : 		}
; 142  : 
; 143  : 		/* grow state */
; 144  : 		hashlin->state = TOMMY_HASHLIN_STATE_GROW;

  00087	c7 05 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 1
  00091	eb 16		 jmp	 SHORT $LN26@hashlin_gr
$LN27@hashlin_gr:

; 138  : 
; 139  : 			/* start from the beginning going forward */
; 140  : 			hashlin->split = 0;

  00093	a1 98 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152

; 141  : 		}
; 142  : 
; 143  : 		/* grow state */
; 144  : 		hashlin->state = TOMMY_HASHLIN_STATE_GROW;

  00098	c7 05 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 1
  000a2	eb 05		 jmp	 SHORT $LN26@hashlin_gr
$LN28@hashlin_gr:
  000a4	a1 98 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
$LN26@hashlin_gr:

; 145  : 	}
; 146  : 
; 147  : 	/* if we are growing */
; 148  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_GROW) {
; 149  : 		/* compute the split target required to finish the reallocation before the next resize */
; 150  : 		unsigned split_target = 2 * hashlin->count;
; 151  : 
; 152  : 		/* reallocate buckets until the split target */
; 153  : 		while (hashlin->split + hashlin->low_max < split_target) {

  000a9	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  000af	57		 push	 edi
  000b0	8b 3d a0 00 00
	00		 mov	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  000b6	03 ff		 add	 edi, edi
  000b8	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  000bb	3b d7		 cmp	 edx, edi
  000bd	0f 83 d7 00 00
	00		 jae	 $LN30@hashlin_gr
  000c3	53		 push	 ebx
  000c4	56		 push	 esi
$LL7@hashlin_gr:

; 154  : 			tommy_hashlin_node** split[2];
; 155  : 			tommy_hashlin_node* j;
; 156  : 			unsigned mask;
; 157  : 
; 158  : 			/* get the low bucket */
; 159  : 			split[0] = tommy_hashlin_pos(hashlin, hashlin->split);

  000c5	83 f8 40	 cmp	 eax, 64			; 00000040H
  000c8	73 0b		 jae	 SHORT $LN13@hashlin_gr
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  000d0	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  000d3	eb 1e		 jmp	 SHORT $LN14@hashlin_gr
$LN13@hashlin_gr:
  000d5	0f bd d0	 bsr	 edx, eax
  000d8	89 55 fc	 mov	 DWORD PTR _count$181840[ebp], edx
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _count$181840[ebp]
  000de	ba 01 00 00 00	 mov	 edx, 1
  000e3	d3 e2		 shl	 edx, cl
  000e5	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  000ec	8b f0		 mov	 esi, eax
  000ee	2b f2		 sub	 esi, edx
  000f0	8d 0c b1	 lea	 ecx, DWORD PTR [ecx+esi*4]
$LN14@hashlin_gr:

; 160  : 
; 161  : 			/* get the high bucket */
; 162  : 			/* it's always in the second half, so we can index it directly */
; 163  : 			/* without calling tommy_hashlin_pos() */
; 164  : 			split[1] = &hashlin->bucket[hashlin->bucket_mac-1][hashlin->split];

  000f3	8b 15 8c 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  000f9	8b 14 95 fc ff
	ff ff		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[edx*4-4]
  00100	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]

; 165  : 
; 166  : 			/* save the low bucket */
; 167  : 			j = *split[0];

  00103	8b 01		 mov	 eax, DWORD PTR [ecx]

; 168  : 
; 169  : 			/* reinitialize the buckets */
; 170  : 			*split[0] = 0;

  00105	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0010b	89 55 f8	 mov	 DWORD PTR _split$86834[ebp+4], edx

; 171  : 			*split[1] = 0;

  0010e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 172  : 
; 173  : 			/* compute the bit to identify the bucket */
; 174  : 			mask = hashlin->bucket_mask & ~hashlin->low_mask;

  00114	8b 15 94 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  0011a	f7 d2		 not	 edx
  0011c	23 15 88 00 00
	00		 and	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00122	89 4d f4	 mov	 DWORD PTR _split$86834[ebp], ecx

; 175  : 
; 176  : 			/* flush the bucket */
; 177  : 			while (j) {

  00125	85 c0		 test	 eax, eax
  00127	74 3e		 je	 SHORT $LN4@hashlin_gr
  00129	8d a4 24 00 00
	00 00		 npad	 7
$LL5@hashlin_gr:

; 178  : 				tommy_hashlin_node* j_next = j->next;
; 179  : 				unsigned index = (j->key & mask) != 0;

  00130	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00133	8b 30		 mov	 esi, DWORD PTR [eax]
  00135	23 ca		 and	 ecx, edx
  00137	f7 d9		 neg	 ecx
  00139	1b c9		 sbb	 ecx, ecx
  0013b	f7 d9		 neg	 ecx

; 180  : 				if (*split[index])

  0013d	8b 4c 8d f4	 mov	 ecx, DWORD PTR _split$86834[ebp+ecx*4]
  00141	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00144	74 10		 je	 SHORT $LN3@hashlin_gr

; 181  : 					tommy_list_insert_tail_not_empty(*split[index], j);

  00146	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00148	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  0014b	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0014e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00151	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 182  : 				else

  00154	eb 03		 jmp	 SHORT $LN33@hashlin_gr
$LN3@hashlin_gr:

; 183  : 					tommy_list_insert_first(split[index], j);

  00156	89 40 04	 mov	 DWORD PTR [eax+4], eax
$LN33@hashlin_gr:
  00159	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0015f	89 01		 mov	 DWORD PTR [ecx], eax

; 184  : 				j = j_next;

  00161	8b c6		 mov	 eax, esi
  00163	85 f6		 test	 esi, esi
  00165	75 c9		 jne	 SHORT $LL5@hashlin_gr
$LN4@hashlin_gr:

; 185  : 			}
; 186  : 
; 187  : 			/* go forward */
; 188  : 			++hashlin->split;

  00167	a1 98 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152

; 189  : 
; 190  : 			/* if we have finished, change the state */
; 191  : 			if (hashlin->split == hashlin->low_max) {

  0016c	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  00172	40		 inc	 eax
  00173	a3 98 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, eax
  00178	3b c1		 cmp	 eax, ecx
  0017a	74 12		 je	 SHORT $LN24@hashlin_gr

; 145  : 	}
; 146  : 
; 147  : 	/* if we are growing */
; 148  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_GROW) {
; 149  : 		/* compute the split target required to finish the reallocation before the next resize */
; 150  : 		unsigned split_target = 2 * hashlin->count;
; 151  : 
; 152  : 		/* reallocate buckets until the split target */
; 153  : 		while (hashlin->split + hashlin->low_max < split_target) {

  0017c	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0017f	3b d7		 cmp	 edx, edi
  00181	0f 82 3e ff ff
	ff		 jb	 $LL7@hashlin_gr
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx
  00189	5f		 pop	 edi

; 193  : 				break;
; 194  : 			}
; 195  : 		}
; 196  : 	}
; 197  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
$LN24@hashlin_gr:
  0018e	5e		 pop	 esi

; 192  : 				hashlin->state = TOMMY_HASHLIN_STATE_STABLE;

  0018f	c7 05 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  00199	5b		 pop	 ebx
$LN30@hashlin_gr:
  0019a	5f		 pop	 edi
$LN6@hashlin_gr:

; 193  : 				break;
; 194  : 			}
; 195  : 		}
; 196  : 	}
; 197  : }

  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ENDP	; hashlin_grow_step
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z
_TEXT	SEGMENT
_count$181890 = -4					; size = 4
_count$181876 = -4					; size = 4
?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z PROC ; tommy_hashlin_bucket_ptr, COMDAT
; _hash$ = ecx

; 93   : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 94   : 	unsigned pos;
; 95   : 
; 96   : 	/* if we are reallocating */
; 97   : 	if (hashlin->state != TOMMY_HASHLIN_STATE_STABLE) {

  00004	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  0000b	74 29		 je	 SHORT $LN1@tommy_hash@5

; 98   : 		/* compute the old position */
; 99   : 		pos = hash & hashlin->low_mask;

  0000d	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  00012	23 c1		 and	 eax, ecx

; 100  : 
; 101  : 		/* if we have not reallocated this position yet */ 
; 102  : 		if (pos >= hashlin->split) {

  00014	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  0001a	72 1a		 jb	 SHORT $LN1@tommy_hash@5

; 103  : 
; 104  : 			/* use it as it was before */
; 105  : 			return tommy_hashlin_pos(hashlin, pos);

  0001c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0001f	73 0d		 jae	 SHORT $LN5@tommy_hash@5
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A

; 111  : 
; 112  : 	return tommy_hashlin_pos(hashlin, pos);

  00027	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 113  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0

; 103  : 
; 104  : 			/* use it as it was before */
; 105  : 			return tommy_hashlin_pos(hashlin, pos);

$LN5@tommy_hash@5:
  0002e	0f bd d0	 bsr	 edx, eax
  00031	89 55 fc	 mov	 DWORD PTR _count$181876[ebp], edx
  00034	eb 1f		 jmp	 SHORT $LN16@tommy_hash@5
$LN1@tommy_hash@5:

; 106  : 		}
; 107  : 	}
; 108  : 
; 109  : 	/* otherwise operates normally */
; 110  : 	pos = hash & hashlin->bucket_mask;

  00036	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  0003b	23 c1		 and	 eax, ecx

; 111  : 
; 112  : 	return tommy_hashlin_pos(hashlin, pos);

  0003d	83 f8 40	 cmp	 eax, 64			; 00000040H
  00040	73 0d		 jae	 SHORT $LN10@tommy_hash@5
  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00048	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 113  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0

; 111  : 
; 112  : 	return tommy_hashlin_pos(hashlin, pos);

$LN10@tommy_hash@5:
  0004f	0f bd c8	 bsr	 ecx, eax
  00052	89 4d fc	 mov	 DWORD PTR _count$181890[ebp], ecx
$LN16@tommy_hash@5:
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _count$181890[ebp]
  00058	ba 01 00 00 00	 mov	 edx, 1
  0005d	d3 e2		 shl	 edx, cl
  0005f	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  00066	2b c2		 sub	 eax, edx
  00068	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 113  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ENDP ; tommy_hashlin_bucket_ptr
_TEXT	ENDS
PUBLIC	_tommy_hashtable_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashtbl.c
;	COMDAT _tommy_hashtable_remove
_TEXT	SEGMENT
_tommy_hashtable_remove PROC				; COMDAT
; _cmp_arg$ = eax
; _hash$ = ecx

; 80   : 	unsigned pos = hash & hashtable->bucket_mask;
; 81   : 	tommy_hashtable_node* i = hashtable->bucket[pos];

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax
  0000a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  0000f	23 c1		 and	 eax, ecx
  00011	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	57		 push	 edi

; 82   : 
; 83   : 	while (i) {

  00017	85 c0		 test	 eax, eax
  00019	74 1a		 je	 SHORT $LN2@tommy_hash@6
  0001b	eb 03 8d 49 00	 npad	 5
$LL3@tommy_hash@6:

; 84   : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 85   : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0) {

  00020	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00023	75 0a		 jne	 SHORT $LN1@tommy_hash@6
  00025	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00028	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0002a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0002d	74 0c		 je	 SHORT $LN18@tommy_hash@6
$LN1@tommy_hash@6:

; 91   : 		}
; 92   : 		/* we assume that i->next is still valid also after removing */
; 93   : 		i = i->next;

  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	85 c0		 test	 eax, eax
  00033	75 eb		 jne	 SHORT $LL3@tommy_hash@6
$LN2@tommy_hash@6:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 94   : 	}
; 95   : 
; 96   : 	return 0;

  00037	33 c0		 xor	 eax, eax
  00039	5b		 pop	 ebx

; 97   : }

  0003a	c3		 ret	 0
$LN18@tommy_hash@6:

; 86   : 			tommy_list_remove_existing(&hashtable->bucket[pos], i);

  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8b 32		 mov	 esi, DWORD PTR [edx]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 08		 je	 SHORT $LN12@tommy_hash@6
  00043	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00046	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00049	eb 06		 jmp	 SHORT $LN11@tommy_hash@6
$LN12@tommy_hash@6:
  0004b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN11@tommy_hash@6:
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	3b f0		 cmp	 esi, eax
  00055	74 03		 je	 SHORT $LN22@tommy_hash@6
  00057	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
$LN22@tommy_hash@6:
  0005a	5f		 pop	 edi
  0005b	89 0a		 mov	 DWORD PTR [edx], ecx

; 87   : 
; 88   : 			--hashtable->count;

  0005d	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 89   : 
; 90   : 			return i->data;

  00063	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 97   : }

  00068	c3		 ret	 0
_tommy_hashtable_remove ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashtable_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_hashtable_insert PROC				; COMDAT
; _node$ = eax
; _hash$ = esi

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   : 	unsigned pos = hash & hashtable->bucket_mask;

  00003	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8

; 59   : 
; 60   : 	tommy_list_insert_tail(&hashtable->bucket[pos], node, data);

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0000f	23 ce		 and	 ecx, esi
  00011	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	85 c9		 test	 ecx, ecx
  00018	74 25		 je	 SHORT $LN4@tommy_hash@7
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00020	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00023	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00026	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002f	89 01		 mov	 DWORD PTR [ecx], eax
  00031	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 61   : 
; 62   : 	node->key = hash;

  00034	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 63   : 
; 64   : 	++hashtable->count;

  00037	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 65   : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0

; 59   : 
; 60   : 	tommy_list_insert_tail(&hashtable->bucket[pos], node, data);

$LN4@tommy_hash@7:
  0003f	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00048	89 02		 mov	 DWORD PTR [edx], eax
  0004a	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 61   : 
; 62   : 	node->key = hash;

  00050	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 63   : 
; 64   : 	++hashtable->count;

  00053	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 65   : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_tommy_hashtable_insert ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrieinp.c
;	COMDAT _tommy_trie_inplace_remove
_TEXT	SEGMENT
_tommy_trie_inplace_remove PROC				; COMDAT
; _key$ = edx

; 217  : 	tommy_trie_inplace_node* ret;
; 218  : 	tommy_trie_inplace_node** let_ptr;
; 219  : 
; 220  : 	let_ptr = &trie_inplace->bucket[key >> TOMMY_TRIE_INPLACE_BUCKET_SHIFT];

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]

; 221  : 
; 222  : 	ret = trie_inplace_bucket_remove(TOMMY_TRIE_INPLACE_BUCKET_SHIFT, let_ptr, 0, key);

  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ; trie_inplace_bucket_remove
  00012	83 c4 04	 add	 esp, 4

; 223  : 
; 224  : 	if (!ret)

  00015	85 c0		 test	 eax, eax
  00017	75 01		 jne	 SHORT $LN1@tommy_trie@6

; 230  : }

  00019	c3		 ret	 0
$LN1@tommy_trie@6:

; 225  : 		return 0;
; 226  : 
; 227  : 	--trie_inplace->count;

  0001a	ff 0d 00 01 00
	00		 dec	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256

; 228  : 
; 229  : 	return ret->data;

  00020	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 230  : }

  00023	c3		 ret	 0
_tommy_trie_inplace_remove ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_inplace_insert
_TEXT	SEGMENT
_tommy_trie_inplace_insert PROC				; COMDAT
; _node$ = eax
; _data$ = ecx
; _key$ = edi

; 129  : 	tommy_trie_inplace_node** let_ptr;
; 130  : 	unsigned i;
; 131  : 
; 132  : 	node->data = data;

  00000	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00003	53		 push	 ebx

; 133  : 	node->key = key;
; 134  : 	/* clear the child pointers */
; 135  : 	for(i=0;i<TOMMY_TRIE_INPLACE_TREE_MAX;++i)
; 136  : 		node->map[i] = 0;

  00004	33 db		 xor	 ebx, ebx
  00006	89 78 0c	 mov	 DWORD PTR [eax+12], edi

; 137  : 
; 138  : 	let_ptr = &trie_inplace->bucket[key >> TOMMY_TRIE_INPLACE_BUCKET_SHIFT];

  00009	8b d7		 mov	 edx, edi
  0000b	c1 ea 1a	 shr	 edx, 26			; 0000001aH
  0000e	56		 push	 esi
  0000f	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[edx*4]
  00016	89 58 10	 mov	 DWORD PTR [eax+16], ebx
  00019	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  0001c	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  0001f	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 139  : 
; 140  : 	trie_inplace_bucket_insert(TOMMY_TRIE_INPLACE_BUCKET_SHIFT, let_ptr, node, key);

  00022	8b 16		 mov	 edx, DWORD PTR [esi]
  00024	8d 4b 1a	 lea	 ecx, DWORD PTR [ebx+26]
  00027	3b d3		 cmp	 edx, ebx
  00029	74 1e		 je	 SHORT $LN25@tommy_trie@7
  0002b	eb 03 8d 49 00	 npad	 5
$LL9@tommy_trie@7:
  00030	39 7a 0c	 cmp	 DWORD PTR [edx+12], edi
  00033	74 24		 je	 SHORT $LN7@tommy_trie@7
  00035	8b f7		 mov	 esi, edi
  00037	d3 ee		 shr	 esi, cl
  00039	83 e9 02	 sub	 ecx, 2
  0003c	83 e6 03	 and	 esi, 3
  0003f	8d 74 b2 10	 lea	 esi, DWORD PTR [edx+esi*4+16]
  00043	8b 16		 mov	 edx, DWORD PTR [esi]
  00045	3b d3		 cmp	 edx, ebx
  00047	75 e7		 jne	 SHORT $LL9@tommy_trie@7
$LN25@tommy_trie@7:
  00049	89 18		 mov	 DWORD PTR [eax], ebx
  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004e	89 06		 mov	 DWORD PTR [esi], eax

; 141  : 
; 142  : 	++trie_inplace->count;

  00050	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx

; 143  : }

  00058	c3		 ret	 0

; 139  : 
; 140  : 	trie_inplace_bucket_insert(TOMMY_TRIE_INPLACE_BUCKET_SHIFT, let_ptr, node, key);

$LN7@tommy_trie@7:
  00059	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0005c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0005f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00062	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00065	89 18		 mov	 DWORD PTR [eax], ebx
  00067	5e		 pop	 esi
  00068	89 02		 mov	 DWORD PTR [edx], eax

; 141  : 
; 142  : 	++trie_inplace->count;

  0006a	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00070	5b		 pop	 ebx

; 143  : }

  00071	c3		 ret	 0
_tommy_trie_inplace_insert ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrie.c
_TEXT	ENDS
;	COMDAT ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z
_TEXT	SEGMENT
_let_back$ = -48					; size = 40
tv239 = -8						; size = 4
_count$ = -4						; size = 4
?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z PROC ; trie_bucket_remove_existing, COMDAT
; _let_ptr$ = edx
; _key$ = eax

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax

; 175  : 	tommy_trie_node* node;
; 176  : 	tommy_trie_tree* tree;
; 177  : 	void* ptr;
; 178  : 	tommy_trie_node** let_back[TOMMY_TRIE_LEVEL_MAX+1];
; 179  : 	unsigned level;
; 180  : 	unsigned i;
; 181  : 	unsigned count;
; 182  : 	unsigned last;
; 183  : 
; 184  : 	level = 0;
; 185  : recurse:
; 186  : 	ptr = *let_ptr;

  0000a	8b 02		 mov	 eax, DWORD PTR [edx]
  0000c	33 f6		 xor	 esi, esi
  0000e	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH

; 187  : 
; 188  : 	if (!ptr)

  00013	85 c0		 test	 eax, eax
  00015	74 1d		 je	 SHORT $LN29@trie_bucke@2
$recurse$86480:

; 190  : 
; 191  : 	if (trie_get_type(ptr) == TOMMY_TRIE_TYPE_TREE) {

  00017	a8 01		 test	 al, 1
  00019	74 21		 je	 SHORT $LN34@trie_bucke@2

; 192  : 		tree = trie_get_tree(ptr);
; 193  : 
; 194  : 		/* save the path */
; 195  : 		let_back[level++] = let_ptr;

  0001b	89 54 b5 d0	 mov	 DWORD PTR _let_back$[ebp+esi*4], edx

; 196  : 
; 197  : 		/* go down one level */
; 198  : 		let_ptr = &tree->map[(key >> shift) & TOMMY_TRIE_TREE_MASK];

  0001f	8b d7		 mov	 edx, edi
  00021	d3 ea		 shr	 edx, cl
  00023	46		 inc	 esi

; 199  : 		shift -= TOMMY_TRIE_TREE_BIT;

  00024	83 e9 03	 sub	 ecx, 3
  00027	83 e2 07	 and	 edx, 7
  0002a	8d 54 90 ff	 lea	 edx, DWORD PTR [eax+edx*4-1]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	85 c0		 test	 eax, eax
  00032	75 e3		 jne	 SHORT $recurse$86480
$LN29@trie_bucke@2:
  00034	5f		 pop	 edi

; 189  : 		return 0;

  00035	33 c0		 xor	 eax, eax
  00037	5e		 pop	 esi

; 253  : 		goto reduce;
; 254  : 
; 255  : 	return remove;
; 256  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN34@trie_bucke@2:

; 200  : 
; 201  : 		goto recurse;
; 202  : 	}
; 203  : 
; 204  : 	node = tommy_cast(tommy_trie_node*, ptr);
; 205  : 
; 206  : 	/* if the node to remove is not specified */
; 207  : 	if (!remove) {
; 208  : 		/* remove the first */
; 209  : 		remove = node;
; 210  : 
; 211  : 		/* check if it's really the element to remove */
; 212  : 		if (remove->key != key)

  0003c	39 78 0c	 cmp	 DWORD PTR [eax+12], edi

; 213  : 			return 0;

  0003f	75 f3		 jne	 SHORT $LN29@trie_bucke@2

; 214  : 	}
; 215  : 
; 216  : 	tommy_list_remove_existing(let_ptr, remove);

  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 3a		 mov	 edi, DWORD PTR [edx]
  00045	53		 push	 ebx
  00046	85 c9		 test	 ecx, ecx
  00048	74 08		 je	 SHORT $LN19@trie_bucke@2
  0004a	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0004d	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00050	eb 06		 jmp	 SHORT $LN18@trie_bucke@2
$LN19@trie_bucke@2:
  00052	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00055	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN18@trie_bucke@2:
  00058	3b f8		 cmp	 edi, eax
  0005a	75 06		 jne	 SHORT $LN17@trie_bucke@2
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	89 0a		 mov	 DWORD PTR [edx], ecx
  00060	eb 07		 jmp	 SHORT $LN16@trie_bucke@2
$LN17@trie_bucke@2:
  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	8b 38		 mov	 edi, DWORD PTR [eax]
  00067	89 39		 mov	 DWORD PTR [ecx], edi
$LN16@trie_bucke@2:

; 217  : 
; 218  : 	/* if the list is not empty, try to reduce */
; 219  : 	if (*let_ptr || !level)

  00069	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0006c	75 5c		 jne	 SHORT $LN36@trie_bucke@2
  0006e	85 f6		 test	 esi, esi
  00070	74 58		 je	 SHORT $LN36@trie_bucke@2
$reduce$86491:

; 220  : 		return remove;
; 221  : 
; 222  : reduce:
; 223  : 	/* go one level up */
; 224  : 	let_ptr = let_back[--level];

  00072	8b 4c b5 cc	 mov	 ecx, DWORD PTR _let_back$[ebp+esi*4-4]

; 225  : 
; 226  : 	tree = trie_get_tree(*let_ptr);

  00076	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00078	4e		 dec	 esi
  00079	49		 dec	 ecx

; 227  : 
; 228  : 	/* check if there is only one child node */
; 229  : 	count = 0;
; 230  : 	last = 0;

  0007a	33 ff		 xor	 edi, edi
  0007c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 231  : 	for(i=0;i<TOMMY_TRIE_TREE_MAX;++i) {

  00083	33 d2		 xor	 edx, edx
$LL7@trie_bucke@2:

; 232  : 		if (tree->map[i]) {

  00085	8b 1c 91	 mov	 ebx, DWORD PTR [ecx+edx*4]
  00088	89 5d f8	 mov	 DWORD PTR tv239[ebp], ebx
  0008b	85 db		 test	 ebx, ebx
  0008d	74 13		 je	 SHORT $LN6@trie_bucke@2

; 233  : 			/* if we have a sub tree, we cannot reduce */
; 234  : 			if (trie_get_type(tree->map[i]) != TOMMY_TRIE_TYPE_NODE)

  0008f	f6 c3 01	 test	 bl, 1
  00092	75 36		 jne	 SHORT $LN36@trie_bucke@2

; 235  : 				return remove;
; 236  : 			/* if more than one node, we cannot reduce */
; 237  : 			if (++count > 1)

  00094	8b 7d fc	 mov	 edi, DWORD PTR _count$[ebp]
  00097	47		 inc	 edi
  00098	89 7d fc	 mov	 DWORD PTR _count$[ebp], edi
  0009b	83 ff 01	 cmp	 edi, 1
  0009e	77 2a		 ja	 SHORT $LN36@trie_bucke@2

; 238  : 				return remove;
; 239  : 			last = i;

  000a0	8b fa		 mov	 edi, edx
$LN6@trie_bucke@2:

; 231  : 	for(i=0;i<TOMMY_TRIE_TREE_MAX;++i) {

  000a2	42		 inc	 edx
  000a3	83 fa 08	 cmp	 edx, 8
  000a6	72 dd		 jb	 SHORT $LL7@trie_bucke@2

; 240  : 		}
; 241  : 	}
; 242  : 
; 243  : 	/* here count is never 0, as we cannot have a tree with only one sub node */
; 244  : 	assert(count == 1);
; 245  : 
; 246  : 	*let_ptr = tree->map[last];

  000a8	8b 3c b9	 mov	 edi, DWORD PTR [ecx+edi*4]
  000ab	8b 54 b5 d0	 mov	 edx, DWORD PTR _let_back$[ebp+esi*4]
  000af	89 3a		 mov	 DWORD PTR [edx], edi

; 247  : 
; 248  : 	tommy_allocator_free(trie->alloc, tree);

  000b1	8b 15 88 00 00
	00		 mov	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+136
  000b7	8b 3a		 mov	 edi, DWORD PTR [edx]
  000b9	89 39		 mov	 DWORD PTR [ecx], edi
  000bb	ff 4a 10	 dec	 DWORD PTR [edx+16]
  000be	89 0a		 mov	 DWORD PTR [edx], ecx

; 249  : 	--trie->node_count;

  000c0	ff 0d 84 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+132

; 250  : 
; 251  : 	/* repeat until more level */
; 252  : 	if (level)

  000c6	85 f6		 test	 esi, esi
  000c8	75 a8		 jne	 SHORT $reduce$86491
$LN36@trie_bucke@2:
  000ca	5b		 pop	 ebx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi

; 253  : 		goto reduce;
; 254  : 
; 255  : 	return remove;
; 256  : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ENDP ; trie_bucket_remove_existing
_TEXT	ENDS
PUBLIC	_tommy_trie_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_trie_insert PROC					; COMDAT
; _node$ = ecx
; _key$ = eax

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 161  : 	tommy_trie_node** let_ptr;
; 162  : 
; 163  : 	node->data = data;

  00003	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]

; 164  : 	node->key = key;
; 165  : 
; 166  : 	let_ptr = &trie->bucket[key >> TOMMY_TRIE_BUCKET_SHIFT];
; 167  : 
; 168  : 	trie_bucket_insert(trie, TOMMY_TRIE_BUCKET_SHIFT, let_ptr, node, key);

  00006	50		 push	 eax
  00007	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000a	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  0000d	51		 push	 ecx
  0000e	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  00015	50		 push	 eax
  00016	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00019	e8 00 00 00 00	 call	 ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ; trie_bucket_insert
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 169  : 
; 170  : 	++trie->count;

  00021	ff 05 80 00 00
	00		 inc	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128

; 171  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_tommy_trie_insert ENDP
_TEXT	ENDS
PUBLIC	_tommy_list_concat
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommylist.c
;	COMDAT _tommy_list_concat
_TEXT	SEGMENT
_tommy_list_concat PROC					; COMDAT
; _first$ = edx
; _second$ = eax

; 33   : 	tommy_node* first_head;
; 34   : 	tommy_node* first_tail;
; 35   : 	tommy_node* second_head;
; 36   : 
; 37   : 	if (tommy_list_empty(second)) {

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	85 c0		 test	 eax, eax
  00004	74 16		 je	 SHORT $LN3@tommy_list@4

; 38   : 		return;
; 39   : 	}
; 40   : 
; 41   : 	if (tommy_list_empty(first)) {

  00006	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00008	85 c9		 test	 ecx, ecx

; 42   : 		*first = *second;
; 43   : 		return;

  0000a	74 0e		 je	 SHORT $LN22@tommy_list@4

; 44   : 	}
; 45   : 
; 46   : 	first_head = tommy_list_head(first);
; 47   : 	second_head = tommy_list_head(second);
; 48   : 	first_tail = tommy_list_tail(first);

  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	56		 push	 esi

; 49   : 
; 50   : 	/* set the "circular" prev list */
; 51   : 	first_head->prev = second_head->prev;

  00010	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00013	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 52   : 	second_head->prev = first_tail;

  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00019	5e		 pop	 esi
$LN22@tommy_list@4:

; 53   : 
; 54   : 	/* set the "0 terminated" next list */
; 55   : 	first_tail->next = second_head;

  0001a	89 02		 mov	 DWORD PTR [edx], eax
$LN3@tommy_list@4:

; 56   : }

  0001c	c3		 ret	 0
_tommy_list_concat ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z
_TEXT	SEGMENT
__Tmp$182396 = 8					; size = 4
__Tmp$182385 = 8					; size = 4
_src$ = 8						; size = 4
?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge, COMDAT
; _this$ = ecx

; 1592 : void btree_node<P>::merge(btree_node *src) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1593 :   assert(parent() == src->parent());
; 1594 :   assert(position() + 1 == src->position());
; 1595 : 
; 1596 :   // Move the delimiting value to the left node.
; 1597 :   value_init(count());

  00003	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _src$[ebp]
  0000b	8d 44 c1 08	 lea	 eax, DWORD PTR [ecx+eax*8+8]
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	85 c0		 test	 eax, eax
  00013	74 0d		 je	 SHORT $LN14@merge
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0001b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN14@merge:

; 1598 :   value_swap(count(), parent(), position());

  00022	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00026	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00029	8b 7c d0 08	 mov	 edi, DWORD PTR [eax+edx*8+8]
  0002d	8d 44 d0 08	 lea	 eax, DWORD PTR [eax+edx*8+8]
  00031	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00035	8b 74 d1 08	 mov	 esi, DWORD PTR [ecx+edx*8+8]
  00039	8d 54 d1 08	 lea	 edx, DWORD PTR [ecx+edx*8+8]
  0003d	89 3a		 mov	 DWORD PTR [edx], edi
  0003f	89 30		 mov	 DWORD PTR [eax], esi
  00041	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00044	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00047	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  0004a	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1599 : 
; 1600 :   // Move the values from the right to the left node.
; 1601 :   for (int i = 0; i < src->count(); ++i) {

  0004d	33 f6		 xor	 esi, esi
  0004f	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  00053	76 5e		 jbe	 SHORT $LN5@merge

; 1598 :   value_swap(count(), parent(), position());

  00055	8d 53 08	 lea	 edx, DWORD PTR [ebx+8]
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL132@merge:

; 1602 :     value_init(1 + count() + i);

  00060	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00064	03 c6		 add	 eax, esi
  00066	8d 44 c1 10	 lea	 eax, DWORD PTR [ecx+eax*8+16]
  0006a	85 c0		 test	 eax, eax
  0006c	74 0d		 je	 SHORT $LN62@merge
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00074	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN62@merge:

; 1603 :     value_swap(1 + count() + i, src, i);

  0007b	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0007f	03 c6		 add	 eax, esi
  00081	8b 7c c1 10	 mov	 edi, DWORD PTR [ecx+eax*8+16]
  00085	8d 44 c1 10	 lea	 eax, DWORD PTR [ecx+eax*8+16]
  00089	89 7d 08	 mov	 DWORD PTR __Tmp$182385[ebp], edi
  0008c	8b 3a		 mov	 edi, DWORD PTR [edx]
  0008e	89 38		 mov	 DWORD PTR [eax], edi
  00090	8b 7d 08	 mov	 edi, DWORD PTR __Tmp$182385[ebp]
  00093	89 3a		 mov	 DWORD PTR [edx], edi
  00095	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00098	89 7d 08	 mov	 DWORD PTR __Tmp$182396[ebp], edi
  0009b	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0009e	89 78 04	 mov	 DWORD PTR [eax+4], edi
  000a1	8b 45 08	 mov	 eax, DWORD PTR __Tmp$182396[ebp]
  000a4	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000a7	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  000ab	46		 inc	 esi
  000ac	83 c2 08	 add	 edx, 8
  000af	3b f0		 cmp	 esi, eax
  000b1	7c ad		 jl	 SHORT $LL132@merge
$LN5@merge:

; 1604 :     src->value_destroy(i);
; 1605 :   }
; 1606 : 
; 1607 :   if (!leaf()) {

  000b3	80 39 00	 cmp	 BYTE PTR [ecx], 0
  000b6	75 37		 jne	 SHORT $LN1@merge

; 1608 :     // Move the child pointers from the right to the left node.
; 1609 :     for (int i = 0; i <= src->count(); ++i) {

  000b8	33 f6		 xor	 esi, esi
  000ba	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  000be	72 2f		 jb	 SHORT $LN1@merge
  000c0	8d bb 00 01 00
	00		 lea	 edi, DWORD PTR [ebx+256]
$LL3@merge:

; 1610 :       set_child(1 + count() + i, src->child(i));

  000c6	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000ca	8b 07		 mov	 eax, DWORD PTR [edi]
  000cc	8d 54 32 01	 lea	 edx, DWORD PTR [edx+esi+1]
  000d0	89 84 91 00 01
	00 00		 mov	 DWORD PTR [ecx+edx*4+256], eax
  000d7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000da	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 1611 :       *src->mutable_child(i) = NULL;

  000dd	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000e3	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  000e7	46		 inc	 esi
  000e8	83 c7 04	 add	 edi, 4
  000eb	3b f0		 cmp	 esi, eax
  000ed	7e d7		 jle	 SHORT $LL3@merge
$LN1@merge:

; 1612 :     }
; 1613 :   }
; 1614 : 
; 1615 :   // Fixup the counts on the src and dest nodes.
; 1616 :   set_count(1 + count() + src->count());

  000ef	8a 53 03	 mov	 dl, BYTE PTR [ebx+3]
  000f2	fe c2		 inc	 dl
  000f4	00 51 03	 add	 BYTE PTR [ecx+3], dl

; 1617 :   src->set_count(0);

  000f7	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0

; 1618 : 
; 1619 :   // Remove the value on the parent node.
; 1620 :   parent()->remove_value(position());

  000fb	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  000ff	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00102	e8 00 00 00 00	 call	 ?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx

; 1621 : }

  0010a	5d		 pop	 ebp
  0010b	c2 04 00	 ret	 4
?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z
_TEXT	SEGMENT
$T182457 = -12						; size = 8
__Tmp$182639 = 8					; size = 4
__Tmp$182635 = 8					; size = 4
_dest$ = 8						; size = 4
?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split, COMDAT
; _this$ = edi
; _insert_position$ = eax

; 1551 : void btree_node<P>::split(btree_node *dest, int insert_position) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _dest$[ebp]
  0000a	56		 push	 esi

; 1552 :   assert(dest->count() == 0);
; 1553 : 
; 1554 :   // We bias the split based on the position being inserted. If we're
; 1555 :   // inserting at the beginning of the left node then bias the split to put
; 1556 :   // more values on the right node. If we're inserting at the end of the
; 1557 :   // right node then bias the split to put more values on the left node.
; 1558 :   if (insert_position == 0) {

  0000b	85 c0		 test	 eax, eax
  0000d	75 0a		 jne	 SHORT $LN11@split

; 1559 :     dest->set_count(count() - 1);

  0000f	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00012	fe c8		 dec	 al
  00014	88 43 03	 mov	 BYTE PTR [ebx+3], al

; 1560 :   } else if (insert_position == max_count()) {

  00017	eb 16		 jmp	 SHORT $LN24@split
$LN11@split:
  00019	0f b6 4f 02	 movzx	 ecx, BYTE PTR [edi+2]
  0001d	3b c1		 cmp	 eax, ecx
  0001f	75 06		 jne	 SHORT $LN9@split

; 1561 :     dest->set_count(0);

  00021	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0

; 1562 :   } else {

  00025	eb 08		 jmp	 SHORT $LN24@split
$LN9@split:

; 1563 :     dest->set_count(count() / 2);

  00027	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  0002a	d0 ea		 shr	 dl, 1
  0002c	88 53 03	 mov	 BYTE PTR [ebx+3], dl
$LN24@split:

; 1564 :   }
; 1565 :   set_count(count() - dest->count());

  0002f	8a 43 03	 mov	 al, BYTE PTR [ebx+3]
  00032	28 47 03	 sub	 BYTE PTR [edi+3], al

; 1566 :   assert(count() >= 1);
; 1567 : 
; 1568 :   // Move values from the left sibling to the right sibling.
; 1569 :   for (int i = 0; i < dest->count(); ++i) {

  00035	33 d2		 xor	 edx, edx
  00037	38 53 03	 cmp	 BYTE PTR [ebx+3], dl
  0003a	76 4c		 jbe	 SHORT $LN5@split

; 1564 :   }
; 1565 :   set_count(count() - dest->count());

  0003c	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
$LN7@split:

; 1570 :     dest->value_init(i);

  0003f	85 c0		 test	 eax, eax
  00041	74 0d		 je	 SHORT $LN36@split
  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00049	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN36@split:

; 1571 :     value_swap(count() + i, dest, i);

  00050	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00054	03 ca		 add	 ecx, edx
  00056	8b 74 cf 08	 mov	 esi, DWORD PTR [edi+ecx*8+8]
  0005a	8d 4c cf 08	 lea	 ecx, DWORD PTR [edi+ecx*8+8]
  0005e	89 75 08	 mov	 DWORD PTR __Tmp$182635[ebp], esi
  00061	8b 30		 mov	 esi, DWORD PTR [eax]
  00063	89 31		 mov	 DWORD PTR [ecx], esi
  00065	8b 75 08	 mov	 esi, DWORD PTR __Tmp$182635[ebp]
  00068	89 30		 mov	 DWORD PTR [eax], esi
  0006a	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0006d	89 75 08	 mov	 DWORD PTR __Tmp$182639[ebp], esi
  00070	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00073	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00076	8b 4d 08	 mov	 ecx, DWORD PTR __Tmp$182639[ebp]
  00079	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0007c	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00080	42		 inc	 edx
  00081	83 c0 08	 add	 eax, 8
  00084	3b d1		 cmp	 edx, ecx
  00086	7c b7		 jl	 SHORT $LN7@split
$LN5@split:

; 1572 :     value_destroy(count() + i);
; 1573 :   }
; 1574 : 
; 1575 :   // The split key is the largest value in the left sibling.
; 1576 :   set_count(count() - 1);
; 1577 :   parent()->insert_value(position(), value_type());

  00088	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0008b	fe 4f 03	 dec	 BYTE PTR [edi+3]
  0008e	33 c0		 xor	 eax, eax
  00090	89 45 f4	 mov	 DWORD PTR $T182457[ebp], eax
  00093	89 45 f8	 mov	 DWORD PTR $T182457[ebp+4], eax
  00096	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0009a	8d 4d f4	 lea	 ecx, DWORD PTR $T182457[ebp]
  0009d	e8 00 00 00 00	 call	 ?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value

; 1578 :   value_swap(count(), parent(), position());

  000a2	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]
  000a6	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  000aa	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ad	8b 74 d0 08	 mov	 esi, DWORD PTR [eax+edx*8+8]
  000b1	8d 44 d0 08	 lea	 eax, DWORD PTR [eax+edx*8+8]
  000b5	8b 54 cf 08	 mov	 edx, DWORD PTR [edi+ecx*8+8]
  000b9	89 74 cf 08	 mov	 DWORD PTR [edi+ecx*8+8], esi
  000bd	89 10		 mov	 DWORD PTR [eax], edx
  000bf	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000c2	8b 54 cf 0c	 mov	 edx, DWORD PTR [edi+ecx*8+12]
  000c6	8d 4c cf 08	 lea	 ecx, DWORD PTR [edi+ecx*8+8]
  000ca	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000cd	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1579 :   value_destroy(count());
; 1580 :   parent()->set_child(position() + 1, dest);

  000d0	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  000d4	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d7	40		 inc	 eax
  000d8	89 9c 81 00 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+256], ebx
  000df	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  000e2	88 43 01	 mov	 BYTE PTR [ebx+1], al

; 1581 : 
; 1582 :   if (!leaf()) {

  000e5	80 3f 00	 cmp	 BYTE PTR [edi], 0
  000e8	75 44		 jne	 SHORT $LN1@split

; 1583 :     for (int i = 0; i <= dest->count(); ++i) {

  000ea	33 c0		 xor	 eax, eax
  000ec	33 f6		 xor	 esi, esi
  000ee	38 43 03	 cmp	 BYTE PTR [ebx+3], al
  000f1	72 3b		 jb	 SHORT $LN1@split
  000f3	8d 93 00 01 00
	00		 lea	 edx, DWORD PTR [ebx+256]
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$LL3@split:

; 1584 :       assert(child(count() + i + 1) != NULL);
; 1585 :       dest->set_child(i, child(count() + i + 1));

  00100	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00104	03 c8		 add	 ecx, eax
  00106	8b 8c 8f 04 01
	00 00		 mov	 ecx, DWORD PTR [edi+ecx*4+260]
  0010d	89 0a		 mov	 DWORD PTR [edx], ecx
  0010f	88 41 01	 mov	 BYTE PTR [ecx+1], al
  00112	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 1586 :       *mutable_child(count() + i + 1) = NULL;

  00115	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00119	03 c8		 add	 ecx, eax
  0011b	89 b4 8f 04 01
	00 00		 mov	 DWORD PTR [edi+ecx*4+260], esi
  00122	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00126	40		 inc	 eax
  00127	83 c2 04	 add	 edx, 4
  0012a	3b c1		 cmp	 eax, ecx
  0012c	7e d2		 jle	 SHORT $LL3@split
$LN1@split:

; 1587 :     }
; 1588 :   }
; 1589 : }

  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 04 00	 ret	 4
?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge_nodes, COMDAT
; _left$ = edi
; _right$ = esi

; 2096 : void btree<P>::merge_nodes(node_type *left, node_type *right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2097 :   left->merge(right);

  00003	56		 push	 esi
  00004	8b cf		 mov	 ecx, edi
  00006	e8 00 00 00 00	 call	 ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge

; 2098 :   if (right->leaf()) {

  0000b	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000e	74 22		 je	 SHORT $LN3@merge_node

; 2099 :     if (rightmost() == right) {

  00010	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	85 c0		 test	 eax, eax
  00017	74 0d		 je	 SHORT $LN10@merge_node
  00019	80 38 00	 cmp	 BYTE PTR [eax], 0
  0001c	75 08		 jne	 SHORT $LN10@merge_node
  0001e	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  00024	eb 02		 jmp	 SHORT $LN22@merge_node
$LN10@merge_node:
  00026	8b c8		 mov	 ecx, eax
$LN22@merge_node:
  00028	3b ce		 cmp	 ecx, esi
  0002a	75 06		 jne	 SHORT $LN3@merge_node

; 2100 :       *mutable_rightmost() = left;

  0002c	89 b8 80 01 00
	00		 mov	 DWORD PTR [eax+384], edi
$LN3@merge_node:

; 2101 :     }
; 2102 :     delete_leaf_node(right);
; 2103 :   } else {
; 2104 :     delete_internal_node(right);

  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00038	83 c4 04	 add	 esp, 4

; 2105 :   }
; 2106 : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge_nodes
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z
_TEXT	SEGMENT
$T183361 = -36						; size = 12
$T183286 = -36						; size = 12
$T183185 = -36						; size = 12
_parent_iter$157626 = -32				; size = 8
tv928 = -28						; size = 4
tv927 = -24						; size = 4
tv1350 = -20						; size = 4
_to_move$157619 = -20					; size = 4
$T182971 = -20						; size = 4
tv897 = -16						; size = 4
$T182972 = -16						; size = 4
_right$157617 = -12					; size = 4
_to_move$157604 = -12					; size = 4
_this$ = -8						; size = 4
$T183324 = 8						; size = 4
$T183231 = 8						; size = 4
$T183105 = 8						; size = 4
_parent$ = 8						; size = 4
_iter$ = 8						; size = 4
?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split, COMDAT
; _this$ = ecx

; 1987 : void btree<P>::rebalance_or_split(iterator *iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx

; 1988 :   node_type *&node = iter->node;
; 1989 :   int &insert_position = iter->position;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iter$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 1990 :   assert(node->count() == node->max_count());
; 1991 : 
; 1992 :   // First try to make room on the node by rebalancing.
; 1993 :   node_type *parent = node->parent();
; 1994 :   if (node != root()) {

  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000f	57		 push	 edi
  00010	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00012	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00015	89 75 f8	 mov	 DWORD PTR _this$[ebp], esi
  00018	89 45 08	 mov	 DWORD PTR _parent$[ebp], eax
  0001b	3b f9		 cmp	 edi, ecx
  0001d	0f 84 65 01 00
	00		 je	 $LN19@rebalance_@3

; 1995 :     if (node->position() > 0) {

  00023	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00026	84 c9		 test	 cl, cl
  00028	0f 84 87 00 00
	00		 je	 $LN16@rebalance_@3

; 1996 :       // Try rebalancing with our left sibling.
; 1997 :       node_type *left = parent->child(node->position() - 1);

  0002e	0f b6 c9	 movzx	 ecx, cl
  00031	8b b4 88 fc 00
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+252]

; 1998 :       if (left->count() < left->max_count()) {

  00038	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  0003b	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  0003e	73 72		 jae	 SHORT $LN239@rebalance_@3

; 1999 :         // We bias rebalancing based on the position being inserted. If we're
; 2000 :         // inserting at the end of the right node then we bias rebalancing to
; 2001 :         // fill up the left node.
; 2002 :         int to_move = (left->max_count() - left->count()) /
; 2003 :             (1 + (insert_position < left->max_count()));

  00040	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00044	0f b6 d1	 movzx	 edx, cl
  00047	33 c9		 xor	 ecx, ecx
  00049	39 43 04	 cmp	 DWORD PTR [ebx+4], eax
  0004c	89 55 f0	 mov	 DWORD PTR tv897[ebp], edx
  0004f	0f 9c c1	 setl	 cl
  00052	2b c2		 sub	 eax, edx
  00054	99		 cdq

; 2004 :         to_move = std::max(1, to_move);

  00055	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T182971[ebp], 1
  0005c	41		 inc	 ecx
  0005d	f7 f9		 idiv	 ecx
  0005f	89 45 f4	 mov	 DWORD PTR _to_move$157604[ebp], eax
  00062	83 f8 01	 cmp	 eax, 1
  00065	8d 45 f4	 lea	 eax, DWORD PTR _to_move$157604[ebp]
  00068	7f 03		 jg	 SHORT $LN45@rebalance_@3
  0006a	8d 45 ec	 lea	 eax, DWORD PTR $T182971[ebp]
$LN45@rebalance_@3:
  0006d	8b 10		 mov	 edx, DWORD PTR [eax]

; 2005 : 
; 2006 :         if (((insert_position - to_move) >= 0) ||
; 2007 :             ((left->count() + to_move) < left->max_count())) {

  0006f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00072	2b c2		 sub	 eax, edx
  00074	89 55 f4	 mov	 DWORD PTR _to_move$157604[ebp], edx
  00077	79 0d		 jns	 SHORT $LN15@rebalance_@3
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv897[ebp]
  0007c	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00080	03 ca		 add	 ecx, edx
  00082	3b c8		 cmp	 ecx, eax
  00084	7d 29		 jge	 SHORT $LN240@rebalance_@3
$LN15@rebalance_@3:

; 2008 :           left->rebalance_right_to_left(node, to_move);

  00086	56		 push	 esi
  00087	8b c7		 mov	 eax, edi
  00089	e8 00 00 00 00	 call	 ?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left

; 2009 : 
; 2010 :           assert(node->max_count() - node->count() == to_move);
; 2011 :           insert_position = insert_position - to_move;

  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _to_move$157604[ebp]
  00091	29 4b 04	 sub	 DWORD PTR [ebx+4], ecx
  00094	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 2012 :           if (insert_position < 0) {

  00097	79 0d		 jns	 SHORT $LN1@rebalance_@3

; 2013 :             insert_position = insert_position + left->count() + 1;

  00099	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  0009d	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]

; 2090 :     insert_position = insert_position - node->count() - 1;

  000a1	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 2091 :     node = split_node;

  000a4	89 33		 mov	 DWORD PTR [ebx], esi
$LN1@rebalance_@3:

; 2092 :   }
; 2093 : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
$LN240@rebalance_@3:

; 2005 : 
; 2006 :         if (((insert_position - to_move) >= 0) ||
; 2007 :             ((left->count() + to_move) < left->max_count())) {

  000af	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
$LN239@rebalance_@3:
  000b2	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
$LN16@rebalance_@3:

; 2014 :             node = left;
; 2015 :           }
; 2016 : 
; 2017 :           assert(node->count() < node->max_count());
; 2018 :           return;
; 2019 :         }
; 2020 :       }
; 2021 :     }
; 2022 : 
; 2023 :     if (node->position() < parent->count()) {

  000b5	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000b8	3a 48 03	 cmp	 cl, BYTE PTR [eax+3]
  000bb	0f 83 9e 00 00
	00		 jae	 $LN11@rebalance_@3

; 2024 :       // Try rebalancing with our right sibling.
; 2025 :       node_type *right = parent->child(node->position() + 1);

  000c1	0f b6 c9	 movzx	 ecx, cl
  000c4	8b 8c 88 04 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+260]
  000cb	89 4d f4	 mov	 DWORD PTR _right$157617[ebp], ecx

; 2026 :       if (right->count() < right->max_count()) {

  000ce	8b 55 f4	 mov	 edx, DWORD PTR _right$157617[ebp]
  000d1	8a 49 03	 mov	 cl, BYTE PTR [ecx+3]
  000d4	8a 52 02	 mov	 dl, BYTE PTR [edx+2]
  000d7	3a ca		 cmp	 cl, dl
  000d9	0f 83 80 00 00
	00		 jae	 $LN11@rebalance_@3

; 2027 :         // We bias rebalancing based on the position being inserted. If we're
; 2028 :         // inserting at the beginning of the left node then we bias rebalancing
; 2029 :         // to fill up the right node.
; 2030 :         int to_move = (right->max_count() - right->count()) /
; 2031 :             (1 + (insert_position > 0));

  000df	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000e2	0f b6 c2	 movzx	 eax, dl
  000e5	33 d2		 xor	 edx, edx
  000e7	85 f6		 test	 esi, esi
  000e9	0f 9f c2	 setg	 dl
  000ec	0f b6 c9	 movzx	 ecx, cl
  000ef	89 45 e4	 mov	 DWORD PTR tv928[ebp], eax
  000f2	2b c1		 sub	 eax, ecx
  000f4	89 4d e8	 mov	 DWORD PTR tv927[ebp], ecx
  000f7	42		 inc	 edx
  000f8	89 55 ec	 mov	 DWORD PTR tv1350[ebp], edx
  000fb	99		 cdq
  000fc	f7 7d ec	 idiv	 DWORD PTR tv1350[ebp]

; 2032 :         to_move = std::max(1, to_move);

  000ff	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T182972[ebp], 1
  00106	89 45 ec	 mov	 DWORD PTR _to_move$157619[ebp], eax
  00109	83 f8 01	 cmp	 eax, 1
  0010c	8d 45 ec	 lea	 eax, DWORD PTR _to_move$157619[ebp]
  0010f	7f 03		 jg	 SHORT $LN71@rebalance_@3
  00111	8d 45 f0	 lea	 eax, DWORD PTR $T182972[ebp]
$LN71@rebalance_@3:
  00114	8b 08		 mov	 ecx, DWORD PTR [eax]

; 2033 : 
; 2034 :         if ((insert_position <= (node->count() - to_move)) ||
; 2035 :             ((right->count() + to_move) < right->max_count())) {

  00116	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0011a	2b c1		 sub	 eax, ecx
  0011c	3b f0		 cmp	 esi, eax
  0011e	7e 0a		 jle	 SHORT $LN10@rebalance_@3
  00120	8b 55 e8	 mov	 edx, DWORD PTR tv927[ebp]
  00123	03 d1		 add	 edx, ecx
  00125	3b 55 e4	 cmp	 edx, DWORD PTR tv928[ebp]
  00128	7d 2f		 jge	 SHORT $LN237@rebalance_@3
$LN10@rebalance_@3:

; 2036 :           node->rebalance_left_to_right(right, to_move);

  0012a	8b 45 f4	 mov	 eax, DWORD PTR _right$157617[ebp]
  0012d	8b f7		 mov	 esi, edi
  0012f	e8 00 00 00 00	 call	 ?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right

; 2037 : 
; 2038 :           if (insert_position > node->count()) {

  00134	8b 03		 mov	 eax, DWORD PTR [ebx]
  00136	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0013a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0013d	3b c1		 cmp	 eax, ecx
  0013f	0f 8e 61 ff ff
	ff		 jle	 $LN1@rebalance_@3

; 2039 :             insert_position = insert_position - node->count() - 1;

  00145	2b c1		 sub	 eax, ecx

; 2040 :             node = right;

  00147	8b 4d f4	 mov	 ecx, DWORD PTR _right$157617[ebp]
  0014a	48		 dec	 eax
  0014b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0014e	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2092 :   }
; 2093 : }

  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 04 00	 ret	 4
$LN237@rebalance_@3:

; 2041 :           }
; 2042 : 
; 2043 :           assert(node->count() < node->max_count());
; 2044 :           return;

  00159	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  0015c	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
$LN11@rebalance_@3:

; 2045 :         }
; 2046 :       }
; 2047 :     }
; 2048 : 
; 2049 :     // Rebalancing failed, make sure there is room on the parent node for a new
; 2050 :     // value.
; 2051 :     if (parent->count() == parent->max_count()) {

  0015f	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00162	3a 48 02	 cmp	 cl, BYTE PTR [eax+2]
  00165	0f 85 d8 00 00
	00		 jne	 $LN5@rebalance_@3

; 2052 :       iterator parent_iter(node->parent(), node->position());

  0016b	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0016f	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00172	89 45 e4	 mov	 DWORD PTR _parent_iter$157626[ebp+4], eax

; 2053 :       rebalance_or_split(&parent_iter);

  00175	8d 45 e0	 lea	 eax, DWORD PTR _parent_iter$157626[ebp]
  00178	50		 push	 eax
  00179	8b ce		 mov	 ecx, esi
  0017b	89 55 e0	 mov	 DWORD PTR _parent_iter$157626[ebp], edx
  0017e	e8 00 00 00 00	 call	 ?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split

; 2054 :     }
; 2055 :   } else {

  00183	e9 bb 00 00 00	 jmp	 $LN5@rebalance_@3
$LN19@rebalance_@3:

; 2056 :     // Rebalancing not possible because this is the root node.
; 2057 :     if (root()->leaf()) {

  00188	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0018b	74 74		 je	 SHORT $LN6@rebalance_@3

; 2058 :       // The root node is currently a leaf node: create a new root node and set
; 2059 :       // the current root node as the child of the new root.
; 2060 :       parent = new_internal_root_node();

  0018d	68 88 01 00 00	 push	 392			; 00000188H
  00192	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00197	83 c4 04	 add	 esp, 4
  0019a	85 c0		 test	 eax, eax
  0019c	74 3b		 je	 SHORT $LN102@rebalance_@3
  0019e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001a0	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001a3	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  001a9	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  001ad	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001b3	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx
  001b9	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  001bd	89 90 84 01 00
	00		 mov	 DWORD PTR [eax+388], edx

; 2061 :       parent->set_child(0, root());

  001c3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c5	89 88 00 01 00
	00		 mov	 DWORD PTR [eax+256], ecx
  001cb	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001ce	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
  001d2	89 45 08	 mov	 DWORD PTR _parent$[ebp], eax

; 2062 :       *mutable_root() = parent;

  001d5	89 06		 mov	 DWORD PTR [esi], eax

; 2063 :       assert(*mutable_rightmost() == parent->child(0));
; 2064 :     } else {

  001d7	eb 6a		 jmp	 SHORT $LN5@rebalance_@3

; 2058 :       // The root node is currently a leaf node: create a new root node and set
; 2059 :       // the current root node as the child of the new root.
; 2060 :       parent = new_internal_root_node();

$LN102@rebalance_@3:
  001d9	8d 45 08	 lea	 eax, DWORD PTR $T183105[ebp]
  001dc	50		 push	 eax
  001dd	8d 4d dc	 lea	 ecx, DWORD PTR $T183185[ebp]
  001e0	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T183105[ebp], 0
  001e7	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  001ec	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  001f1	8d 4d dc	 lea	 ecx, DWORD PTR $T183185[ebp]
  001f4	51		 push	 ecx
  001f5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T183185[ebp], OFFSET ??_7bad_alloc@std@@6B@
  001fc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN243@rebalance_@3:
$LN6@rebalance_@3:

; 2065 :       // The root node is an internal node. We do not want to create a new root
; 2066 :       // node because the root node is special and holds the size of the tree
; 2067 :       // and a pointer to the rightmost node. So we create a new internal node
; 2068 :       // and move all of the items on the current root into the new node.
; 2069 :       parent = new_internal_node(parent);

  00201	68 80 01 00 00	 push	 384			; 00000180H
  00206	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0020b	8b f0		 mov	 esi, eax
  0020d	83 c4 04	 add	 esp, 4
  00210	85 f6		 test	 esi, esi
  00212	0f 84 ff 00 00
	00		 je	 $LN141@rebalance_@3

; 2070 :       parent->set_child(0, parent);
; 2071 :       parent->swap(root());

  00218	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0021b	66 c7 46 01 00
	1f		 mov	 WORD PTR [esi+1], 7936	; 00001f00H
  00221	c6 46 03 00	 mov	 BYTE PTR [esi+3], 0
  00225	c6 06 00	 mov	 BYTE PTR [esi], 0
  00228	89 b6 00 01 00
	00		 mov	 DWORD PTR [esi+256], esi
  0022e	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00231	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
  00235	8b 38		 mov	 edi, DWORD PTR [eax]
  00237	8b d6		 mov	 edx, esi
  00239	89 75 08	 mov	 DWORD PTR _parent$[ebp], esi
  0023c	e8 00 00 00 00	 call	 ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap

; 2072 :       node = parent;

  00241	89 33		 mov	 DWORD PTR [ebx], esi
$LN5@rebalance_@3:

; 2073 :     }
; 2074 :   }
; 2075 : 
; 2076 :   // Split the node.
; 2077 :   node_type *split_node;
; 2078 :   if (node->leaf()) {

  00243	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00245	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00248	74 76		 je	 SHORT $LN4@rebalance_@3

; 2079 :     split_node = new_leaf_node(parent);

  0024a	68 00 01 00 00	 push	 256			; 00000100H
  0024f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00254	8b f0		 mov	 esi, eax
  00256	83 c4 04	 add	 esp, 4
  00259	85 f6		 test	 esi, esi
  0025b	74 3b		 je	 SHORT $LN171@rebalance_@3
  0025d	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  00260	c7 06 01 00 1f
	00		 mov	 DWORD PTR [esi], 2031617 ; 001f0001H
  00266	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 2080 :     node->split(split_node, insert_position);

  00269	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0026c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0026e	56		 push	 esi
  0026f	e8 00 00 00 00	 call	 ?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split

; 2081 :     if (rightmost() == node) {

  00274	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00277	8b 00		 mov	 eax, DWORD PTR [eax]
  00279	85 c0		 test	 eax, eax
  0027b	74 0d		 je	 SHORT $LN186@rebalance_@3
  0027d	80 38 00	 cmp	 BYTE PTR [eax], 0
  00280	75 08		 jne	 SHORT $LN186@rebalance_@3
  00282	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  00288	eb 02		 jmp	 SHORT $LN198@rebalance_@3
$LN186@rebalance_@3:
  0028a	8b c8		 mov	 ecx, eax
$LN198@rebalance_@3:
  0028c	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  0028e	75 65		 jne	 SHORT $LN2@rebalance_@3

; 2082 :       *mutable_rightmost() = split_node;

  00290	89 b0 80 01 00
	00		 mov	 DWORD PTR [eax+384], esi

; 2083 :     }
; 2084 :   } else {

  00296	eb 5d		 jmp	 SHORT $LN2@rebalance_@3

; 2079 :     split_node = new_leaf_node(parent);

$LN171@rebalance_@3:
  00298	8d 4d 08	 lea	 ecx, DWORD PTR $T183324[ebp]
  0029b	51		 push	 ecx
  0029c	8d 4d dc	 lea	 ecx, DWORD PTR $T183361[ebp]
  0029f	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T183324[ebp], 0
  002a6	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  002ab	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  002b0	8d 55 dc	 lea	 edx, DWORD PTR $T183361[ebp]
  002b3	52		 push	 edx
  002b4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T183361[ebp], OFFSET ??_7bad_alloc@std@@6B@
  002bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN244@rebalance_@3:
$LN4@rebalance_@3:

; 2085 :     split_node = new_internal_node(parent);

  002c0	68 80 01 00 00	 push	 384			; 00000180H
  002c5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  002ca	83 c4 04	 add	 esp, 4
  002cd	85 c0		 test	 eax, eax
  002cf	0f 84 04 ff ff
	ff		 je	 $LN102@rebalance_@3
  002d5	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  002d8	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  002de	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  002e2	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  002e5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2086 :     node->split(split_node, insert_position);

  002e8	8b 3b		 mov	 edi, DWORD PTR [ebx]
  002ea	8b f0		 mov	 esi, eax
  002ec	50		 push	 eax
  002ed	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002f0	e8 00 00 00 00	 call	 ?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split
$LN2@rebalance_@3:

; 2087 :   }
; 2088 : 
; 2089 :   if (insert_position > node->count()) {

  002f5	8b 13		 mov	 edx, DWORD PTR [ebx]
  002f7	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  002fb	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002fe	3b c1		 cmp	 eax, ecx
  00300	0f 8e a0 fd ff
	ff		 jle	 $LN1@rebalance_@3

; 2090 :     insert_position = insert_position - node->count() - 1;

  00306	2b c1		 sub	 eax, ecx
  00308	48		 dec	 eax
  00309	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 2092 :   }
; 2093 : }

  0030c	5f		 pop	 edi
  0030d	89 33		 mov	 DWORD PTR [ebx], esi
  0030f	5e		 pop	 esi
  00310	5b		 pop	 ebx
  00311	8b e5		 mov	 esp, ebp
  00313	5d		 pop	 ebp
  00314	c2 04 00	 ret	 4

; 2065 :       // The root node is an internal node. We do not want to create a new root
; 2066 :       // node because the root node is special and holds the size of the tree
; 2067 :       // and a pointer to the rightmost node. So we create a new internal node
; 2068 :       // and move all of the items on the current root into the new node.
; 2069 :       parent = new_internal_node(parent);

$LN141@rebalance_@3:
  00317	8d 55 08	 lea	 edx, DWORD PTR $T183231[ebp]
  0031a	52		 push	 edx
  0031b	8d 4d dc	 lea	 ecx, DWORD PTR $T183286[ebp]
  0031e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T183231[ebp], 0
  00325	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0032a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0032f	8d 45 dc	 lea	 eax, DWORD PTR $T183286[ebp]
  00332	50		 push	 eax
  00333	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T183286[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0033a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN245@rebalance_@3:
$LN241@rebalance_@3:
  0033f	cc		 int	 3
?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::emplace_front<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = esi

; 721  : 		void emplace_front(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 722  : 		{	// insert element at beginning
; 723  : 		_Insert_rv(begin(), _STD forward<_Valty>(_Val));

  00007	8b 03		 mov	 eax, DWORD PTR [ebx]
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	51		 push	 ecx
  00010	57		 push	 edi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00016	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00019	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  0001e	2b d1		 sub	 edx, ecx
  00020	83 fa 01	 cmp	 edx, 1
  00023	73 0a		 jae	 SHORT $LN25@emplace_fr
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@emplace_fr:
$LN25@emplace_fr:
  0002f	41		 inc	 ecx
  00030	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00033	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	5f		 pop	 edi
  0003a	89 01		 mov	 DWORD PTR [ecx], eax
  0003c	5b		 pop	 ebx

; 724  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN42@emplace_fr:
??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::emplace_front<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
$T183760 = -20						; size = 12
$T183660 = -8						; size = 4
$T183659 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
$T183714 = 12						; size = 4
_v$ = 12						; size = 4
_iter$ = 16						; size = 8
?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert, COMDAT
; _this$ = eax

; 2201 : btree<P>::internal_insert(iterator iter, const value_type &v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax

; 2202 :   if (!iter.node->leaf()) {

  0000a	8b 45 10	 mov	 eax, DWORD PTR _iter$[ebp]
  0000d	80 38 00	 cmp	 BYTE PTR [eax], 0
  00010	57		 push	 edi
  00011	75 12		 jne	 SHORT $LN82@internal_i

; 2203 :     // We can't insert on an internal node. Instead, we'll insert after the
; 2204 :     // previous value which is guaranteed to be on a leaf node.
; 2205 :     --iter;

  00013	8d 45 10	 lea	 eax, DWORD PTR _iter$[ebp]
  00016	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow

; 2206 :     ++iter.position;

  0001b	bf 01 00 00 00	 mov	 edi, 1
  00020	01 7d 14	 add	 DWORD PTR _iter$[ebp+4], edi
  00023	eb 05		 jmp	 SHORT $LN6@internal_i
$LN82@internal_i:
  00025	bf 01 00 00 00	 mov	 edi, 1
$LN6@internal_i:

; 2207 :   }
; 2208 :   if (iter.node->count() == iter.node->max_count()) {

  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  0002d	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00030	38 41 03	 cmp	 BYTE PTR [ecx+3], al
  00033	0f 85 a7 00 00
	00		 jne	 $LN5@internal_i

; 2209 :     // Make room in the leaf for the new item.
; 2210 :     if (iter.node->max_count() < kNodeValues) {

  00039	3c 1f		 cmp	 al, 31			; 0000001fH
  0003b	0f 83 90 00 00
	00		 jae	 $LN4@internal_i

; 2211 :       // Insertion into the root where the root is smaller that the full node
; 2212 :       // size. Simply grow the size of the root node.
; 2213 :       assert(iter.node == root());
; 2214 :       iter.node = new_leaf_root_node(
; 2215 :           std::min<int>(kNodeValues, 2 * iter.node->max_count()));

  00041	0f b6 c0	 movzx	 eax, al
  00044	03 c0		 add	 eax, eax
  00046	89 45 fc	 mov	 DWORD PTR $T183659[ebp], eax
  00049	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004c	c7 45 f8 1f 00
	00 00		 mov	 DWORD PTR $T183660[ebp], 31 ; 0000001fH
  00053	8d 45 fc	 lea	 eax, DWORD PTR $T183659[ebp]
  00056	7c 03		 jl	 SHORT $LN29@internal_i
  00058	8d 45 f8	 lea	 eax, DWORD PTR $T183660[ebp]
$LN29@internal_i:
  0005b	8b 18		 mov	 ebx, DWORD PTR [eax]
  0005d	8d 0c dd 08 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8+8]
  00064	33 c0		 xor	 eax, eax
  00066	85 c9		 test	 ecx, ecx
  00068	74 12		 je	 SHORT $LN37@internal_i
  0006a	83 f9 ff	 cmp	 ecx, -1
  0006d	77 3a		 ja	 SHORT $LN36@internal_i
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00075	83 c4 04	 add	 esp, 4
  00078	85 c0		 test	 eax, eax
  0007a	74 2d		 je	 SHORT $LN36@internal_i
$LN37@internal_i:
  0007c	66 c7 00 01 00	 mov	 WORD PTR [eax], 1
  00081	88 58 02	 mov	 BYTE PTR [eax+2], bl
  00084	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  00088	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 2216 :       iter.node->swap(root());

  0008b	8b 3e		 mov	 edi, DWORD PTR [esi]
  0008d	8b d0		 mov	 edx, eax
  0008f	89 45 10	 mov	 DWORD PTR _iter$[ebp], eax
  00092	e8 00 00 00 00	 call	 ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap

; 2217 :       delete_leaf_node(root());

  00097	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 2218 :       *mutable_root() = iter.node;

  0009f	8b 55 10	 mov	 edx, DWORD PTR _iter$[ebp]
  000a2	83 c4 04	 add	 esp, 4
  000a5	89 16		 mov	 DWORD PTR [esi], edx

; 2219 :     } else {

  000a7	eb 44		 jmp	 SHORT $LN1@internal_i

; 2211 :       // Insertion into the root where the root is smaller that the full node
; 2212 :       // size. Simply grow the size of the root node.
; 2213 :       assert(iter.node == root());
; 2214 :       iter.node = new_leaf_root_node(
; 2215 :           std::min<int>(kNodeValues, 2 * iter.node->max_count()));

$LN36@internal_i:
  000a9	8d 45 0c	 lea	 eax, DWORD PTR $T183714[ebp]
  000ac	50		 push	 eax
  000ad	8d 4d ec	 lea	 ecx, DWORD PTR $T183760[ebp]
  000b0	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T183714[ebp], 0
  000b7	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000bc	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000c1	8d 4d ec	 lea	 ecx, DWORD PTR $T183760[ebp]
  000c4	51		 push	 ecx
  000c5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T183760[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000cc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN85@internal_i:
$LN4@internal_i:

; 2220 :       rebalance_or_split(&iter);

  000d1	8d 55 10	 lea	 edx, DWORD PTR _iter$[ebp]
  000d4	52		 push	 edx
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split

; 2221 :       ++*mutable_size();

  000dc	8b 36		 mov	 esi, DWORD PTR [esi]

; 2222 :     }

  000de	eb 07		 jmp	 SHORT $LN84@internal_i
$LN5@internal_i:

; 2223 :   } else if (!root()->leaf()) {

  000e0	8b 36		 mov	 esi, DWORD PTR [esi]
  000e2	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000e5	75 06		 jne	 SHORT $LN1@internal_i
$LN84@internal_i:

; 2224 :     ++*mutable_size();

  000e7	01 be 84 01 00
	00		 add	 DWORD PTR [esi+388], edi
$LN1@internal_i:

; 2225 :   }
; 2226 :   iter.node->insert_value(iter.position, v);

  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  000f0	8b 45 14	 mov	 eax, DWORD PTR _iter$[ebp+4]
  000f3	8b 75 10	 mov	 esi, DWORD PTR _iter$[ebp]
  000f6	e8 00 00 00 00	 call	 ?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value

; 2227 :   return iter;

  000fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000fe	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  00101	8b 55 14	 mov	 edx, DWORD PTR _iter$[ebp+4]

; 2228 : }

  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	89 08		 mov	 DWORD PTR [eax], ecx
  00108	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010b	5b		 pop	 ebx
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 10 00	 ret	 16			; 00000010H
$LN83@internal_i:
?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z
_TEXT	SEGMENT
tv562 = -4						; size = 4
_to_move$156979 = -4					; size = 4
$T183846 = 8						; size = 4
_to_move$156968 = 8					; size = 4
_this$ = 8						; size = 4
$T183845 = 12						; size = 4
_iter$ = 12						; size = 4
?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance, COMDAT

; 2109 : bool btree<P>::try_merge_or_rebalance(iterator *iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2110 :   node_type *parent = iter->node->parent();

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iter$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]

; 2111 :   if (iter->node->position() > 0) {

  0000c	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0000f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00012	84 c0		 test	 al, al
  00014	74 6e		 je	 SHORT $LN165@try_merge_

; 2112 :     // Try merging with our left sibling.
; 2113 :     node_type *left = parent->child(iter->node->position() - 1);
; 2114 :     if ((1 + left->count() + iter->node->count()) <= left->max_count()) {

  00016	0f b6 5f 03	 movzx	 ebx, BYTE PTR [edi+3]
  0001a	0f b6 d0	 movzx	 edx, al
  0001d	8b b4 91 fc 00
	00 00		 mov	 esi, DWORD PTR [ecx+edx*4+252]
  00024	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  00028	8d 54 13 01	 lea	 edx, DWORD PTR [ebx+edx+1]
  0002c	0f b6 5e 02	 movzx	 ebx, BYTE PTR [esi+2]
  00030	3b d3		 cmp	 edx, ebx
  00032	7f 50		 jg	 SHORT $LN165@try_merge_

; 2115 :       iter->position += 1 + left->count();

  00034	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _iter$[ebp]
  0003b	40		 inc	 eax
  0003c	01 43 04	 add	 DWORD PTR [ebx+4], eax

; 2116 :       merge_nodes(left, iter->node);

  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
  00047	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0004a	74 22		 je	 SHORT $LN30@try_merge_
  0004c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	85 c0		 test	 eax, eax
  00053	74 0d		 je	 SHORT $LN37@try_merge_
  00055	80 38 00	 cmp	 BYTE PTR [eax], 0
  00058	75 08		 jne	 SHORT $LN37@try_merge_
  0005a	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  00060	eb 02		 jmp	 SHORT $LN49@try_merge_
$LN37@try_merge_:
  00062	8b c8		 mov	 ecx, eax
$LN49@try_merge_:
  00064	3b cf		 cmp	 ecx, edi
  00066	75 06		 jne	 SHORT $LN30@try_merge_
  00068	89 b0 80 01 00
	00		 mov	 DWORD PTR [eax+384], esi
$LN30@try_merge_:
  0006e	57		 push	 edi
  0006f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00074	83 c4 04	 add	 esp, 4
  00077	5f		 pop	 edi

; 2117 :       iter->node = left;

  00078	89 33		 mov	 DWORD PTR [ebx], esi
  0007a	5e		 pop	 esi

; 2118 :       return true;

  0007b	b0 01		 mov	 al, 1
  0007d	5b		 pop	 ebx

; 2158 : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
$LN165@try_merge_:

; 2119 :     }
; 2120 :   }
; 2121 :   if (iter->node->position() < parent->count()) {

  00084	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  00087	0f 83 ae 00 00
	00		 jae	 $LN164@try_merge_

; 2122 :     // Try merging with our right sibling.
; 2123 :     node_type *right = parent->child(iter->node->position() + 1);

  0008d	0f b6 d0	 movzx	 edx, al
  00090	8b b4 91 04 01
	00 00		 mov	 esi, DWORD PTR [ecx+edx*4+260]

; 2124 :     if ((1 + iter->node->count() + right->count()) <= right->max_count()) {

  00097	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  0009b	0f b6 5e 03	 movzx	 ebx, BYTE PTR [esi+3]
  0009f	89 55 fc	 mov	 DWORD PTR tv562[ebp], edx
  000a2	8d 54 13 01	 lea	 edx, DWORD PTR [ebx+edx+1]
  000a6	0f b6 5e 02	 movzx	 ebx, BYTE PTR [esi+2]
  000aa	3b d3		 cmp	 edx, ebx
  000ac	7f 43		 jg	 SHORT $LN6@try_merge_

; 2125 :       merge_nodes(iter->node, right);

  000ae	56		 push	 esi
  000af	8b cf		 mov	 ecx, edi
  000b1	e8 00 00 00 00	 call	 ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
  000b6	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000b9	74 22		 je	 SHORT $LN87@try_merge_
  000bb	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 00		 mov	 eax, DWORD PTR [eax]
  000c0	85 c0		 test	 eax, eax
  000c2	74 0d		 je	 SHORT $LN94@try_merge_
  000c4	80 38 00	 cmp	 BYTE PTR [eax], 0
  000c7	75 08		 jne	 SHORT $LN94@try_merge_
  000c9	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  000cf	eb 02		 jmp	 SHORT $LN106@try_merge_
$LN94@try_merge_:
  000d1	8b c8		 mov	 ecx, eax
$LN106@try_merge_:
  000d3	3b ce		 cmp	 ecx, esi
  000d5	75 06		 jne	 SHORT $LN87@try_merge_
  000d7	89 b8 80 01 00
	00		 mov	 DWORD PTR [eax+384], edi
$LN87@try_merge_:
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e3	83 c4 04	 add	 esp, 4
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi

; 2126 :       return true;

  000e8	b0 01		 mov	 al, 1
  000ea	5b		 pop	 ebx

; 2158 : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 08 00	 ret	 8
$LN6@try_merge_:

; 2127 :     }
; 2128 :     // Try rebalancing with our right sibling. We don't perform rebalancing if
; 2129 :     // we deleted the first element from iter->node and the node is not
; 2130 :     // empty. This is a small optimization for the common pattern of deleting
; 2131 :     // from the front of the tree.
; 2132 :     if ((right->count() > kMinNodeValues) &&
; 2133 :         ((iter->node->count() == 0) ||
; 2134 :          (iter->position > 0))) {

  000f1	80 7e 03 0f	 cmp	 BYTE PTR [esi+3], 15	; 0000000fH
  000f5	76 44		 jbe	 SHORT $LN164@try_merge_
  000f7	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  000fa	84 d2		 test	 dl, dl
  000fc	74 09		 je	 SHORT $LN4@try_merge_
  000fe	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp]
  00101	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00105	7e 34		 jle	 SHORT $LN164@try_merge_
$LN4@try_merge_:

; 2135 :       int to_move = (right->count() - iter->node->count()) / 2;

  00107	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0010b	8b c1		 mov	 eax, ecx
  0010d	2b 45 fc	 sub	 eax, DWORD PTR tv562[ebp]

; 2136 :       to_move = std::min(to_move, right->count() - 1);

  00110	49		 dec	 ecx
  00111	99		 cdq
  00112	2b c2		 sub	 eax, edx
  00114	d1 f8		 sar	 eax, 1
  00116	89 45 08	 mov	 DWORD PTR _to_move$156968[ebp], eax
  00119	3b c8		 cmp	 ecx, eax
  0011b	89 4d 0c	 mov	 DWORD PTR $T183845[ebp], ecx
  0011e	8d 45 0c	 lea	 eax, DWORD PTR $T183845[ebp]
  00121	7c 03		 jl	 SHORT $LN141@try_merge_
  00123	8d 45 08	 lea	 eax, DWORD PTR _to_move$156968[ebp]
$LN141@try_merge_:
  00126	8b 10		 mov	 edx, DWORD PTR [eax]

; 2137 :       iter->node->rebalance_right_to_left(right, to_move);

  00128	57		 push	 edi
  00129	8b c6		 mov	 eax, esi
  0012b	e8 00 00 00 00	 call	 ?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi

; 2154 :       return false;
; 2155 :     }
; 2156 :   }
; 2157 :   return false;

  00132	32 c0		 xor	 al, al
  00134	5b		 pop	 ebx

; 2158 : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 08 00	 ret	 8
$LN164@try_merge_:

; 2138 :       return false;
; 2139 :     }
; 2140 :   }
; 2141 :   if (iter->node->position() > 0) {

  0013b	84 c0		 test	 al, al
  0013d	74 54		 je	 SHORT $LN2@try_merge_

; 2142 :     // Try rebalancing with our left sibling. We don't perform rebalancing if
; 2143 :     // we deleted the last element from iter->node and the node is not
; 2144 :     // empty. This is a small optimization for the common pattern of deleting
; 2145 :     // from the back of the tree.
; 2146 :     node_type *left = parent->child(iter->node->position() - 1);

  0013f	0f b6 c0	 movzx	 eax, al
  00142	8b b4 81 fc 00
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+252]

; 2147 :     if ((left->count() > kMinNodeValues) &&
; 2148 :         ((iter->node->count() == 0) ||
; 2149 :          (iter->position < iter->node->count()))) {

  00149	80 7e 03 0f	 cmp	 BYTE PTR [esi+3], 15	; 0000000fH
  0014d	76 44		 jbe	 SHORT $LN2@try_merge_
  0014f	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00152	84 c0		 test	 al, al
  00154	74 0b		 je	 SHORT $LN1@try_merge_
  00156	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp]
  00159	0f b6 c8	 movzx	 ecx, al
  0015c	39 4a 04	 cmp	 DWORD PTR [edx+4], ecx
  0015f	7d 32		 jge	 SHORT $LN2@try_merge_
$LN1@try_merge_:

; 2150 :       int to_move = (left->count() - iter->node->count()) / 2;

  00161	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  00165	0f b6 d0	 movzx	 edx, al
  00168	8b c1		 mov	 eax, ecx
  0016a	2b c2		 sub	 eax, edx
  0016c	99		 cdq
  0016d	2b c2		 sub	 eax, edx
  0016f	d1 f8		 sar	 eax, 1

; 2151 :       to_move = std::min(to_move, left->count() - 1);

  00171	49		 dec	 ecx
  00172	89 45 fc	 mov	 DWORD PTR _to_move$156979[ebp], eax
  00175	3b c8		 cmp	 ecx, eax
  00177	89 4d 08	 mov	 DWORD PTR $T183846[ebp], ecx
  0017a	8d 45 08	 lea	 eax, DWORD PTR $T183846[ebp]
  0017d	7c 03		 jl	 SHORT $LN163@try_merge_
  0017f	8d 45 fc	 lea	 eax, DWORD PTR _to_move$156979[ebp]
$LN163@try_merge_:
  00182	8b 18		 mov	 ebx, DWORD PTR [eax]

; 2152 :       left->rebalance_left_to_right(iter->node, to_move);

  00184	8b cb		 mov	 ecx, ebx
  00186	8b c7		 mov	 eax, edi
  00188	e8 00 00 00 00	 call	 ?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right

; 2153 :       iter->position += to_move;

  0018d	8b 45 0c	 mov	 eax, DWORD PTR _iter$[ebp]
  00190	01 58 04	 add	 DWORD PTR [eax+4], ebx
$LN2@try_merge_:

; 2154 :       return false;
; 2155 :     }
; 2156 :   }
; 2157 :   return false;

  00193	5f		 pop	 edi
  00194	5e		 pop	 esi
  00195	32 c0		 xor	 al, al
  00197	5b		 pop	 ebx

; 2158 : }

  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c2 08 00	 ret	 8
?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--, COMDAT
; _this$ = esi

; 419  : 		--(*(_Mybase *)this);

  00000	8b c6		 mov	 eax, esi
  00002	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00007	8b c6		 mov	 eax, esi

; 421  : 		}

  00009	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ
_TEXT	SEGMENT
tv471 = -4						; size = 4
tv469 = -4						; size = 4
__Tmp$184736 = -4					; size = 4
_this$ = 8						; size = 4
?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size, COMDAT

; 879  : 		{	// grow table as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 880  : 		if (max_load_factor() < load_factor())

  00008	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0000b	db 43 08	 fild	 DWORD PTR [ebx+8]
  0000e	56		 push	 esi
  0000f	8b 73 24	 mov	 esi, DWORD PTR [ebx+36]
  00012	85 c0		 test	 eax, eax
  00014	79 06		 jns	 SHORT $LN121@Check_size
  00016	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN121@Check_size:
  0001c	8b ce		 mov	 ecx, esi
  0001e	89 4d fc	 mov	 DWORD PTR tv469[ebp], ecx
  00021	db 45 fc	 fild	 DWORD PTR tv469[ebp]
  00024	85 c9		 test	 ecx, ecx
  00026	79 06		 jns	 SHORT $LN122@Check_size
  00028	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN122@Check_size:
  0002e	de f9		 fdivp	 ST(1), ST(0)
  00030	d9 43 28	 fld	 DWORD PTR [ebx+40]
  00033	d9 c9		 fxch	 ST(1)
  00035	df f1		 fcomip	 ST(1)
  00037	dd d8		 fstp	 ST(0)
  00039	76 6d		 jbe	 SHORT $LN4@Check_size

; 881  : 
; 882  :  #if _HAS_INCREMENTAL_HASH
; 883  : 			_Grow();	// too dense, need to grow hash table
; 884  : 
; 885  :  #else /* _HAS_INCREMENTAL_HASH */
; 886  : 			{	// rehash to bigger table
; 887  : 			size_type _Maxsize = _Vec.max_size() / 2;
; 888  : 			size_type _Newsize = bucket_count();
; 889  : 
; 890  : 			for (int _Idx = 0; _Idx < 3 && _Newsize < _Maxsize; ++_Idx)

  0003b	33 c0		 xor	 eax, eax
  0003d	8d 49 00	 npad	 3
$LL3@Check_size:
  00040	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00046	73 08		 jae	 SHORT $LN1@Check_size
  00048	40		 inc	 eax

; 891  : 				_Newsize *= 2;	// multiply safely by 8

  00049	03 f6		 add	 esi, esi
  0004b	83 f8 03	 cmp	 eax, 3
  0004e	7c f0		 jl	 SHORT $LL3@Check_size
$LN1@Check_size:

; 892  : 			_Init(_Newsize);

  00050	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00053	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00056	8d 53 10	 lea	 edx, DWORD PTR [ebx+16]
  00059	57		 push	 edi
  0005a	8b 3a		 mov	 edi, DWORD PTR [edx]
  0005c	89 45 fc	 mov	 DWORD PTR __Tmp$184736[ebp], eax
  0005f	3b f9		 cmp	 edi, ecx
  00061	74 21		 je	 SHORT $LN59@Check_size
  00063	8b c1		 mov	 eax, ecx
  00065	3b c9		 cmp	 ecx, ecx
  00067	74 18		 je	 SHORT $LN88@Check_size
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL90@Check_size:
  00070	8b 18		 mov	 ebx, DWORD PTR [eax]
  00072	89 1f		 mov	 DWORD PTR [edi], ebx
  00074	83 c0 04	 add	 eax, 4
  00077	83 c7 04	 add	 edi, 4
  0007a	3b c1		 cmp	 eax, ecx
  0007c	75 f2		 jne	 SHORT $LL90@Check_size
  0007e	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
$LN88@Check_size:
  00081	89 7a 04	 mov	 DWORD PTR [edx+4], edi
$LN59@Check_size:
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$184736[ebp]
  00089	51		 push	 ecx
  0008a	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 893  : 			_Reinsert(end());

  00093	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00096	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00099	50		 push	 eax
  0009a	8b cb		 mov	 ecx, ebx
  0009c	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  0009f	89 73 24	 mov	 DWORD PTR [ebx+36], esi
  000a2	e8 00 00 00 00	 call	 ?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert
  000a7	5f		 pop	 edi
$LN4@Check_size:
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 894  : 			}
; 895  :  #endif /* _HAS_INCREMENTAL_HASH */
; 896  : 		}

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -8						; size = 1
__Where$156733 = -4					; size = 4
_this$ = 8						; size = 4
$T184878 = 12						; size = 4
$T184876 = 12						; size = 4
__Node$ = 12						; size = 4
?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert, COMDAT
; ___$ReturnUdt$ = esi

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00009	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  0000c	53		 push	 ebx
  0000d	57		 push	 edi
  0000e	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d f8	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 1f		 jne	 SHORT $LN11@Linsert
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)
; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,
; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else
; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00022	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00025	8b f8		 mov	 edi, eax
  00027	0f 92 c1	 setb	 cl
  0002a	88 4d f8	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0002d	84 c9		 test	 cl, cl
  0002f	74 04		 je	 SHORT $LN15@Linsert
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00035	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00038	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003c	74 e4		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0003e	8b df		 mov	 ebx, edi
  00040	89 5d fc	 mov	 DWORD PTR __Where$156733[ebp], ebx

; 970  : 			if (!_Addleft)

  00043	84 c9		 test	 cl, cl
  00045	74 39		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00047	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	3b 39		 cmp	 edi, DWORD PTR [ecx]
  0004f	75 21		 jne	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00051	52		 push	 edx
  00052	6a 01		 push	 1
  00054	8d 55 0c	 lea	 edx, DWORD PTR $T184876[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	5f		 pop	 edi
  00063	89 06		 mov	 DWORD PTR [esi], eax
  00065	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00069	8b c6		 mov	 eax, esi
  0006b	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  00072	8d 45 fc	 lea	 eax, DWORD PTR __Where$156733[ebp]
  00075	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
  0007a	8b 5d fc	 mov	 ebx, DWORD PTR __Where$156733[ebp]
  0007d	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00080	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00083	52		 push	 edx
  00084	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00087	73 25		 jae	 SHORT $LN2@Linsert
  00089	8b 55 f8	 mov	 edx, DWORD PTR __Addleft$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	52		 push	 edx
  00090	8d 45 0c	 lea	 eax, DWORD PTR $T184878[ebp]
  00093	50		 push	 eax
  00094	51		 push	 ecx
  00095	8b cf		 mov	 ecx, edi
  00097	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0009c	8b 10		 mov	 edx, DWORD PTR [eax]
  0009e	5f		 pop	 edi
  0009f	89 16		 mov	 DWORD PTR [esi], edx
  000a1	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000a5	8b c6		 mov	 eax, esi
  000a7	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 08 00	 ret	 8
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));
; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000ae	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b3	83 c4 04	 add	 esp, 4
  000b6	5f		 pop	 edi

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000b7	89 1e		 mov	 DWORD PTR [esi], ebx
  000b9	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  000bd	8b c6		 mov	 eax, esi
  000bf	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
tv929 = -4						; size = 4
$T185914 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Plist$ = 16						; size = 4
?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert, COMDAT
; __Val$ = eax

; 849  : 		{	// try to insert existing node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 850  : 		size_type _Bucket = _Hashval(this->_Kfn(_Val));

  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 00		 mov	 eax, DWORD PTR [eax]
  00009	8b c8		 mov	 ecx, eax
  0000b	c1 e1 06	 shl	 ecx, 6
  0000e	89 45 fc	 mov	 DWORD PTR tv929[ebp], eax
  00011	2b c1		 sub	 eax, ecx
  00013	8b d0		 mov	 edx, eax
  00015	c1 ea 11	 shr	 edx, 17			; 00000011H
  00018	33 c2		 xor	 eax, edx
  0001a	8b c8		 mov	 ecx, eax
  0001c	c1 e1 09	 shl	 ecx, 9
  0001f	2b c1		 sub	 eax, ecx
  00021	8b d0		 mov	 edx, eax
  00023	c1 e2 04	 shl	 edx, 4
  00026	33 c2		 xor	 eax, edx
  00028	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0002f	2b c1		 sub	 eax, ecx
  00031	8b d0		 mov	 edx, eax
  00033	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00036	33 c2		 xor	 eax, edx
  00038	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  0003e	8b f0		 mov	 esi, eax
  00040	c1 ee 0f	 shr	 esi, 15			; 0000000fH
  00043	33 f0		 xor	 esi, eax
  00045	23 f1		 and	 esi, ecx
  00047	39 72 24	 cmp	 DWORD PTR [edx+36], esi
  0004a	77 09		 ja	 SHORT $LN13@Insert@2
  0004c	d1 e9		 shr	 ecx, 1
  0004e	83 c8 ff	 or	 eax, -1
  00051	2b c1		 sub	 eax, ecx
  00053	03 f0		 add	 esi, eax
$LN13@Insert@2:

; 851  : 		iterator _Where = _End(_Bucket);

  00055	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00058	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  0005b	8d 04 f1	 lea	 eax, DWORD PTR [ecx+esi*8]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00063	3b d9		 cmp	 ebx, ecx
  00065	74 18		 je	 SHORT $LN7@Insert@2
  00067	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006a	8b 18		 mov	 ebx, DWORD PTR [eax]

; 852  : 
; 853  : 		for (; _Where != _Begin(_Bucket); )

  0006c	3b d9		 cmp	 ebx, ecx
  0006e	74 0f		 je	 SHORT $LN7@Insert@2
$LL8@Insert@2:

; 854  : 			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Where)))

  00070	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00073	8b 45 fc	 mov	 eax, DWORD PTR tv929[ebp]
  00076	39 43 08	 cmp	 DWORD PTR [ebx+8], eax
  00079	74 40		 je	 SHORT $LN4@Insert@2

; 852  : 
; 853  : 		for (; _Where != _Begin(_Bucket); )

  0007b	3b d9		 cmp	 ebx, ecx
  0007d	75 f1		 jne	 SHORT $LL8@Insert@2
$LN7@Insert@2:

; 866  : 				}
; 867  : 
; 868  : 		iterator _Next = _Plist;
; 869  : 		if (_Where != ++_Next)

  0007f	8b 45 10	 mov	 eax, DWORD PTR __Plist$[ebp]
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	3b d9		 cmp	 ebx, ecx
  00086	74 12		 je	 SHORT $LN1@Insert@2

; 870  : 			_List._Splice_same(_Where, _List,
; 871  : 				_Plist, _Next, 1);	// move element into place

  00088	51		 push	 ecx
  00089	50		 push	 eax
  0008a	53		 push	 ebx
  0008b	8b cf		 mov	 ecx, edi
  0008d	8b d7		 mov	 edx, edi
  0008f	e8 00 00 00 00	 call	 ?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same
  00094	8b 45 10	 mov	 eax, DWORD PTR __Plist$[ebp]
  00097	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN1@Insert@2:

; 872  : 
; 873  : 		_Insert_bucket(_Plist, _Where, _Bucket);

  0009a	89 45 08	 mov	 DWORD PTR $T185914[ebp], eax
  0009d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000a0	8b 0c f0	 mov	 ecx, DWORD PTR [eax+esi*8]
  000a3	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  000a6	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  000a8	75 45		 jne	 SHORT $LN177@Insert@2
  000aa	8b 4d 10	 mov	 ecx, DWORD PTR __Plist$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR $T185914[ebp]
  000b5	89 4c f0 04	 mov	 DWORD PTR [eax+esi*8+4], ecx
  000b9	eb 5c		 jmp	 SHORT $LN236@Insert@2
$LN4@Insert@2:

; 855  : 				;	// still too high in bucket list
; 856  : 			else if (_Multi
; 857  : 				|| this->comp(this->_Kfn(*_Where), this->_Kfn(_Val)))
; 858  : 				{	// found insertion point, back up to it
; 859  : 				++_Where;
; 860  : 				break;
; 861  : 				}
; 862  : 			else
; 863  : 				{	// discard new list element and return existing
; 864  : 				_List.erase(_Plist);

  000bb	8b 45 10	 mov	 eax, DWORD PTR __Plist$[ebp]
  000be	3b 07		 cmp	 eax, DWORD PTR [edi]
  000c0	74 1b		 je	 SHORT $LN116@Insert@2
  000c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c5	8b 30		 mov	 esi, DWORD PTR [eax]
  000c7	89 32		 mov	 DWORD PTR [edx], esi
  000c9	8b 10		 mov	 edx, DWORD PTR [eax]
  000cb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ce	50		 push	 eax
  000cf	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000d2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d7	83 c4 04	 add	 esp, 4
  000da	ff 4f 04	 dec	 DWORD PTR [edi+4]
$LN116@Insert@2:

; 865  : 				return (_Pairib(_Where, false));

  000dd	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	89 18		 mov	 DWORD PTR [eax], ebx
  000e4	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000e8	5b		 pop	 ebx

; 876  : 		}

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 0c 00	 ret	 12			; 0000000cH

; 872  : 
; 873  : 		_Insert_bucket(_Plist, _Where, _Bucket);

$LN177@Insert@2:
  000ef	3b cb		 cmp	 ecx, ebx
  000f1	75 07		 jne	 SHORT $LN175@Insert@2
  000f3	8b 4d 10	 mov	 ecx, DWORD PTR __Plist$[ebp]
  000f6	89 08		 mov	 DWORD PTR [eax], ecx
  000f8	eb 1d		 jmp	 SHORT $LN236@Insert@2
$LN175@Insert@2:
  000fa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ff	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00102	3b 4d 08	 cmp	 ecx, DWORD PTR $T185914[ebp]
  00105	74 10		 je	 SHORT $LN236@Insert@2
  00107	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0010a	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  0010e	8d 74 f0 04	 lea	 esi, DWORD PTR [eax+esi*8+4]
  00112	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00115	89 06		 mov	 DWORD PTR [esi], eax
$LN236@Insert@2:

; 874  : 		_Check_size();

  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size

; 875  : 		return (_Pairib(_Plist, true));	// return iterator for new element

  0011d	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00120	8b 4d 10	 mov	 ecx, DWORD PTR __Plist$[ebp]
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	89 08		 mov	 DWORD PTR [eax], ecx
  00127	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  0012b	5b		 pop	 ebx

; 876  : 		}

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T185959 = -8						; size = 8
_this$ = 8						; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert, COMDAT
; ___$ReturnUdt$ = edi

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000d	53		 push	 ebx
  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Node$[ebp]
  00011	c7 45 10 00 00
	00 00		 mov	 DWORD PTR __Next$[ebp], 0
  00018	75 16		 jne	 SHORT $LN33@Insert@3

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	53		 push	 ebx
  0001e	6a 01		 push	 1
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00027	8b c7		 mov	 eax, edi
  00029	5b		 pop	 ebx

; 1181 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@3:

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  00030	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00033	56		 push	 esi
  00034	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00037	3b 30		 cmp	 esi, DWORD PTR [eax]
  00039	75 25		 jne	 SHORT $LN14@Insert@3

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  0003b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0003e	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00041	0f 83 dd 00 00
	00		 jae	 $LN1@Insert@3

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00047	53		 push	 ebx
$LN7@Insert@3:
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	6a 01		 push	 1
  0004d	57		 push	 edi
  0004e	51		 push	 ecx
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00056	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00057	8b c7		 mov	 eax, edi
  00059	5b		 pop	 ebx

; 1181 : 		}

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@3:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  00060	3b f0		 cmp	 esi, eax
  00062	75 26		 jne	 SHORT $LN11@Insert@3

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  00064	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00067	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006a	3b 53 0c	 cmp	 edx, DWORD PTR [ebx+12]
  0006d	0f 83 b1 00 00
	00		 jae	 $LN1@Insert@3

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  00073	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00076	53		 push	 ebx
  00077	6a 00		 push	 0
  00079	57		 push	 edi
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00080	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00081	8b c7		 mov	 eax, edi
  00083	5b		 pop	 ebx

; 1181 : 		}

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@3:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  0008a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0008d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00090	73 36		 jae	 SHORT $LN8@Insert@3
  00092	8d 45 10	 lea	 eax, DWORD PTR __Next$[ebp]
  00095	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi
  00098	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
  0009d	8b 4d 10	 mov	 ecx, DWORD PTR __Next$[ebp]
  000a0	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a3	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  000a6	73 20		 jae	 SHORT $LN8@Insert@3

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ab	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000af	53		 push	 ebx
  000b0	74 96		 je	 SHORT $LN7@Insert@3
  000b2	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	6a 00		 push	 0
  000b7	57		 push	 edi
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  000be	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  000bf	8b c7		 mov	 eax, edi
  000c1	5b		 pop	 ebx

; 1181 : 		}

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 0c 00	 ret	 12			; 0000000cH
$LN8@Insert@3:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000c8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000cb	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000ce	73 54		 jae	 SHORT $LN1@Insert@3
  000d0	8d 45 10	 lea	 eax, DWORD PTR __Next$[ebp]
  000d3	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi
  000d6	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
  000db	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000de	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e1	39 08		 cmp	 DWORD PTR [eax], ecx
  000e3	8b 4d 10	 mov	 ecx, DWORD PTR __Next$[ebp]
  000e6	74 08		 je	 SHORT $LN3@Insert@3
  000e8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000eb	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ee	73 34		 jae	 SHORT $LN1@Insert@3
$LN3@Insert@3:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000f0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f3	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  000f7	53		 push	 ebx
  000f8	74 17		 je	 SHORT $LN2@Insert@3
  000fa	6a 00		 push	 0
  000fc	8b ca		 mov	 ecx, edx
  000fe	57		 push	 edi
  000ff	51		 push	 ecx
  00100	8b ce		 mov	 ecx, esi
  00102	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00107	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00108	8b c7		 mov	 eax, edi
  0010a	5b		 pop	 ebx

; 1181 : 		}

  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@3:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00111	6a 01		 push	 1
  00113	57		 push	 edi
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0011a	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  0011b	8b c7		 mov	 eax, edi
  0011d	5b		 pop	 ebx

; 1181 : 		}

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 0c 00	 ret	 12			; 0000000cH
$LN1@Insert@3:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00124	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00127	53		 push	 ebx
  00128	50		 push	 eax
  00129	8d 75 f8	 lea	 esi, DWORD PTR $T185959[ebp]
  0012c	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert
  00131	8b 08		 mov	 ecx, DWORD PTR [eax]
  00133	5e		 pop	 esi
  00134	89 0f		 mov	 DWORD PTR [edi], ecx
  00136	8b c7		 mov	 eax, edi
  00138	5b		 pop	 ebx

; 1181 : 		}

  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = edi
; __Val$ = edx

; 278  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 279  : 		{	// try to insert node with value _Val
; 280  : 		_List.emplace_front(_STD forward<_Valty>(_Val));

  00003	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00006	53		 push	 ebx
  00007	8b 18		 mov	 ebx, DWORD PTR [eax]
  00009	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000c	56		 push	 esi
  0000d	51		 push	 ecx
  0000e	53		 push	 ebx
  0000f	8b f2		 mov	 esi, edx
  00011	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00016	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00019	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  0001e	2b d1		 sub	 edx, ecx
  00020	83 fa 01	 cmp	 edx, 1
  00023	73 0a		 jae	 SHORT $LN29@insert
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN82@insert:
$LN29@insert:

; 281  : 		return (_Insert(_List.front(), begin()));

  0002f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00032	41		 inc	 ecx
  00033	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00036	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	50		 push	 eax
  00044	56		 push	 esi
  00045	83 c0 08	 add	 eax, 8
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0004e	8b c6		 mov	 eax, esi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 282  : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN81@insert:
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax
; __Val$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f0		 mov	 esi, eax

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  0000b	8b f9		 mov	 edi, ecx
  0000d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00012	50		 push	 eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00016	50		 push	 eax
  00017	56		 push	 esi
  00018	8b fb		 mov	 edi, ebx
  0001a	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	8b c3		 mov	 eax, ebx
  00023	5b		 pop	 ebx

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z
_TEXT	SEGMENT
$T186999 = -24						; size = 12
$T186933 = -20						; size = 8
_res$ = -12						; size = 12
$T186931 = -8						; size = 8
$T186953 = 8						; size = 4
_key$ = 8						; size = 4
_value$ = 12						; size = 4
??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 1744 : btree<P>::insert_unique(const key_type &key, ValuePointer value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx

; 1745 :   if (empty()) {

  00007	33 db		 xor	 ebx, ebx
  00009	39 1f		 cmp	 DWORD PTR [edi], ebx
  0000b	75 19		 jne	 SHORT $LN5@insert_uni

; 1746 :     *mutable_root() = new_leaf_root_node(1);

  0000d	6a 10		 push	 16			; 00000010H
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	3b c3		 cmp	 eax, ebx
  00019	74 5d		 je	 SHORT $LN18@insert_uni
  0001b	c7 00 01 00 01
	00		 mov	 DWORD PTR [eax], 65537	; 00010001H
  00021	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00024	89 07		 mov	 DWORD PTR [edi], eax
$LN5@insert_uni:

; 1747 :   }
; 1748 : 
; 1749 :   std::pair<iterator, int> res = internal_locate(key, iterator(root(), 0));

  00026	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00028	8b 55 08	 mov	 edx, DWORD PTR _key$[ebp]
  0002b	83 ec 08	 sub	 esp, 8
  0002e	8b c4		 mov	 eax, esp
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00035	52		 push	 edx
  00036	8d 45 f4	 lea	 eax, DWORD PTR _res$[ebp]
  00039	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >

; 1750 :   iterator &iter = res.first;
; 1751 :   if (res.second == kExactMatch) {

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _res$[ebp+8]
  00041	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00046	75 54		 jne	 SHORT $LN4@insert_uni

; 1752 :     // The key already exists in the tree, do nothing.
; 1753 :     return std::make_pair(internal_last(iter), false);

  00048	8b 45 f4	 mov	 eax, DWORD PTR _res$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+4]
  0004e	3b c3		 cmp	 eax, ebx
  00050	74 15		 je	 SHORT $LN49@insert_uni
$LL50@insert_uni:
  00052	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  00056	3b ca		 cmp	 ecx, edx
  00058	75 0d		 jne	 SHORT $LN49@insert_uni
  0005a	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	38 18		 cmp	 BYTE PTR [eax], bl
  00063	74 ed		 je	 SHORT $LL50@insert_uni
  00065	33 c0		 xor	 eax, eax
$LN49@insert_uni:
  00067	89 06		 mov	 DWORD PTR [esi], eax
  00069	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0006c	88 5e 08	 mov	 BYTE PTR [esi+8], bl

; 1759 :     }
; 1760 :   }
; 1761 : 
; 1762 :   return std::make_pair(internal_insert(iter, *value), true);

  0006f	8b c6		 mov	 eax, esi

; 1763 : }

  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8

; 1746 :     *mutable_root() = new_leaf_root_node(1);

$LN18@insert_uni:
  00078	8d 45 08	 lea	 eax, DWORD PTR $T186953[ebp]
  0007b	50		 push	 eax
  0007c	8d 4d e8	 lea	 ecx, DWORD PTR $T186999[ebp]
  0007f	89 5d 08	 mov	 DWORD PTR $T186953[ebp], ebx
  00082	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00087	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0008c	8d 4d e8	 lea	 ecx, DWORD PTR $T186999[ebp]
  0008f	51		 push	 ecx
  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T186999[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00097	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN198@insert_uni:
$LN4@insert_uni:

; 1754 :   } else if (!res.second) {

  0009c	8b 55 f4	 mov	 edx, DWORD PTR _res$[ebp]
  0009f	3b c3		 cmp	 eax, ebx
  000a1	75 49		 jne	 SHORT $LN1@insert_uni

; 1755 :     iterator last = internal_last(iter);

  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+4]
  000a6	8b c2		 mov	 eax, edx
  000a8	3b d3		 cmp	 edx, ebx
  000aa	74 40		 je	 SHORT $LN1@insert_uni
  000ac	8d 64 24 00	 npad	 4
$LL87@insert_uni:
  000b0	0f b6 58 03	 movzx	 ebx, BYTE PTR [eax+3]
  000b4	3b cb		 cmp	 ecx, ebx
  000b6	75 0f		 jne	 SHORT $LN86@insert_uni
  000b8	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000bc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000bf	33 db		 xor	 ebx, ebx
  000c1	38 18		 cmp	 BYTE PTR [eax], bl
  000c3	74 eb		 je	 SHORT $LL87@insert_uni

; 1756 :     if (last.node && !compare_keys(key, last.key())) {

  000c5	eb 25		 jmp	 SHORT $LN1@insert_uni

; 1755 :     iterator last = internal_last(iter);

$LN86@insert_uni:

; 1756 :     if (last.node && !compare_keys(key, last.key())) {

  000c7	33 db		 xor	 ebx, ebx
  000c9	3b c3		 cmp	 eax, ebx
  000cb	74 1f		 je	 SHORT $LN1@insert_uni
  000cd	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
  000d0	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  000d2	3b 5c c8 08	 cmp	 ebx, DWORD PTR [eax+ecx*8+8]
  000d6	72 12		 jb	 SHORT $LN194@insert_uni

; 1757 :       // The key already exists in the tree, do nothing.
; 1758 :       return std::make_pair(last, false);

  000d8	89 06		 mov	 DWORD PTR [esi], eax
  000da	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000dd	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0

; 1759 :     }
; 1760 :   }
; 1761 : 
; 1762 :   return std::make_pair(internal_insert(iter, *value), true);

  000e1	8b c6		 mov	 eax, esi

; 1763 : }

  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
$LN194@insert_uni:

; 1757 :       // The key already exists in the tree, do nothing.
; 1758 :       return std::make_pair(last, false);

  000ea	33 db		 xor	 ebx, ebx
$LN1@insert_uni:

; 1759 :     }
; 1760 :   }
; 1761 : 
; 1762 :   return std::make_pair(internal_insert(iter, *value), true);

  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+4]
  000ef	83 ec 08	 sub	 esp, 8
  000f2	8b c4		 mov	 eax, esp
  000f4	89 10		 mov	 DWORD PTR [eax], edx
  000f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000f9	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  000fc	8b 02		 mov	 eax, DWORD PTR [edx]
  000fe	8d 4d f8	 lea	 ecx, DWORD PTR $T186931[ebp]
  00101	51		 push	 ecx
  00102	8d 55 ec	 lea	 edx, DWORD PTR $T186933[ebp]
  00105	89 45 f8	 mov	 DWORD PTR $T186931[ebp], eax
  00108	52		 push	 edx
  00109	8b c7		 mov	 eax, edi
  0010b	89 5d fc	 mov	 DWORD PTR $T186931[ebp+4], ebx
  0010e	e8 00 00 00 00	 call	 ?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00118	89 0e		 mov	 DWORD PTR [esi], ecx
  0011a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0011d	c6 46 08 01	 mov	 BYTE PTR [esi+8], 1
  00121	8b c6		 mov	 eax, esi

; 1763 : }

  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 08 00	 ret	 8
$LN196@insert_uni:
??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z
_TEXT	SEGMENT
_res$ = -8						; size = 8
_this$ = 8						; size = 4
_internal_delete$ = 11					; size = 1
___$ReturnUdt$ = 12					; size = 4
_iter$ = 16						; size = 8
?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase, COMDAT

; 1863 : typename btree<P>::iterator btree<P>::erase(iterator iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000a	56		 push	 esi

; 1864 :   bool internal_delete = false;
; 1865 :   if (!iter.node->leaf()) {

  0000b	8b 75 10	 mov	 esi, DWORD PTR _iter$[ebp]
  0000e	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00011	57		 push	 edi
  00012	c6 45 0b 00	 mov	 BYTE PTR _internal_delete$[ebp], 0
  00016	75 37		 jne	 SHORT $LN12@erase@5

; 1866 :     // Deletion of a value on an internal node. Swap the key with the largest
; 1867 :     // value of our left child. This is easy, we just decrement iter.
; 1868 :     iterator tmp_iter(iter--);

  00018	8b 7d 14	 mov	 edi, DWORD PTR _iter$[ebp+4]
  0001b	8d 45 10	 lea	 eax, DWORD PTR _iter$[ebp]
  0001e	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow

; 1869 :     assert(iter.node->leaf());
; 1870 :     assert(!compare_keys(tmp_iter.key(), iter.key()));
; 1871 :     iter.node->value_swap(iter.position, tmp_iter.node, tmp_iter.position);

  00023	8b 4d 14	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00026	8b 45 10	 mov	 eax, DWORD PTR _iter$[ebp]
  00029	8b 54 fe 08	 mov	 edx, DWORD PTR [esi+edi*8+8]
  0002d	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	89 10		 mov	 DWORD PTR [eax], edx
  00035	89 4c fe 08	 mov	 DWORD PTR [esi+edi*8+8], ecx
  00039	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003c	8d 4c fe 0c	 lea	 ecx, DWORD PTR [esi+edi*8+12]
  00040	8b 31		 mov	 esi, DWORD PTR [ecx]
  00042	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00045	89 11		 mov	 DWORD PTR [ecx], edx

; 1872 :     internal_delete = true;
; 1873 :     --*mutable_size();

  00047	8b 03		 mov	 eax, DWORD PTR [ebx]
  00049	c6 45 0b 01	 mov	 BYTE PTR _internal_delete$[ebp], 1
  0004d	eb 07		 jmp	 SHORT $LN120@erase@5
$LN12@erase@5:

; 1874 :   } else if (!root()->leaf()) {

  0004f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00051	80 38 00	 cmp	 BYTE PTR [eax], 0
  00054	75 06		 jne	 SHORT $LN10@erase@5
$LN120@erase@5:

; 1875 :     --*mutable_size();

  00056	ff 88 84 01 00
	00		 dec	 DWORD PTR [eax+388]
$LN10@erase@5:

; 1876 :   }
; 1877 : 
; 1878 :   // Delete the key from the leaf.
; 1879 :   iter.node->remove_value(iter.position);

  0005c	8b 45 14	 mov	 eax, DWORD PTR _iter$[ebp+4]
  0005f	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  00062	e8 00 00 00 00	 call	 ?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value

; 1880 : 
; 1881 :   // We want to return the next value after the one we just erased. If we
; 1882 :   // erased from an internal node (internal_delete == true), then the next
; 1883 :   // value is ++(++iter). If we erased from a leaf node (internal_delete ==
; 1884 :   // false) then the next value is ++iter. Note that ++iter may point to an
; 1885 :   // internal node and the value in the internal node may move to a leaf node
; 1886 :   // (iter.node) when rebalancing is performed at the leaf level.
; 1887 : 
; 1888 :   // Merge/rebalance as we walk back up the tree.
; 1889 :   iterator res(iter);

  00067	8b 45 10	 mov	 eax, DWORD PTR _iter$[ebp]
  0006a	8b 75 14	 mov	 esi, DWORD PTR _iter$[ebp+4]
  0006d	8b f8		 mov	 edi, eax
  0006f	89 7d f8	 mov	 DWORD PTR _res$[ebp], edi
  00072	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi

; 1890 :   for (;;) {
; 1891 :     if (iter.node == root()) {

  00075	3b 03		 cmp	 eax, DWORD PTR [ebx]
  00077	74 38		 je	 SHORT $LN112@erase@5
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL9@erase@5:

; 1895 :       }
; 1896 :       break;
; 1897 :     }
; 1898 :     if (iter.node->count() >= kMinNodeValues) {

  00080	80 78 03 0f	 cmp	 BYTE PTR [eax+3], 15	; 0000000fH
  00084	73 4d		 jae	 SHORT $LN119@erase@5

; 1899 :       break;
; 1900 :     }
; 1901 :     bool merged = try_merge_or_rebalance(&iter);

  00086	8d 45 10	 lea	 eax, DWORD PTR _iter$[ebp]
  00089	50		 push	 eax
  0008a	53		 push	 ebx
  0008b	e8 00 00 00 00	 call	 ?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance

; 1902 :     if (iter.node->leaf()) {

  00090	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  00093	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00096	74 05		 je	 SHORT $LN4@erase@5

; 1903 :       res = iter;

  00098	8b 75 14	 mov	 esi, DWORD PTR _iter$[ebp+4]
  0009b	8b f9		 mov	 edi, ecx
$LN4@erase@5:

; 1904 :     }
; 1905 :     if (!merged) {

  0009d	84 c0		 test	 al, al
  0009f	74 32		 je	 SHORT $LN119@erase@5

; 1906 :       break;
; 1907 :     }
; 1908 :     iter.node = iter.node->parent();

  000a1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a4	89 45 10	 mov	 DWORD PTR _iter$[ebp], eax
  000a7	3b 03		 cmp	 eax, DWORD PTR [ebx]
  000a9	75 d5		 jne	 SHORT $LL9@erase@5

; 1903 :       res = iter;

  000ab	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  000ae	89 7d f8	 mov	 DWORD PTR _res$[ebp], edi
$LN112@erase@5:

; 1892 :       try_shrink();

  000b1	53		 push	 ebx
  000b2	e8 00 00 00 00	 call	 ?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink

; 1893 :       if (empty()) {

  000b7	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  000ba	75 1d		 jne	 SHORT $LN6@erase@5

; 1894 :         return end();

  000bc	8b 75 0c	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	8b c6		 mov	 eax, esi
  000c1	8b cb		 mov	 ecx, ebx
  000c3	e8 00 00 00 00	 call	 ?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end
  000c8	8b c6		 mov	 eax, esi

; 1922 : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 10 00	 ret	 16			; 00000010H
$LN119@erase@5:

; 1903 :       res = iter;

  000d3	89 7d f8	 mov	 DWORD PTR _res$[ebp], edi
  000d6	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
$LN6@erase@5:

; 1909 :   }
; 1910 : 
; 1911 :   // Adjust our return value. If we're pointing at the end of a node, advance
; 1912 :   // the iterator.
; 1913 :   if (res.position == res.node->count()) {

  000d9	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  000dd	3b f0		 cmp	 esi, eax
  000df	75 21		 jne	 SHORT $LN93@erase@5

; 1914 :     res.position = res.node->count() - 1;
; 1915 :     ++res;

  000e1	80 3f 00	 cmp	 BYTE PTR [edi], 0
  000e4	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  000e7	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  000ea	74 08		 je	 SHORT $LN92@erase@5
  000ec	46		 inc	 esi
  000ed	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  000f0	3b f0		 cmp	 esi, eax
  000f2	7c 0e		 jl	 SHORT $LN93@erase@5
$LN92@erase@5:
  000f4	8d 45 f8	 lea	 eax, DWORD PTR _res$[ebp]
  000f7	e8 00 00 00 00	 call	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
  000fc	8b 75 fc	 mov	 esi, DWORD PTR _res$[ebp+4]
  000ff	8b 7d f8	 mov	 edi, DWORD PTR _res$[ebp]
$LN93@erase@5:

; 1916 :   }
; 1917 :   // If we erased from an internal node, advance the iterator.
; 1918 :   if (internal_delete) {

  00102	80 7d 0b 00	 cmp	 BYTE PTR _internal_delete$[ebp], 0
  00106	74 1f		 je	 SHORT $LN102@erase@5

; 1919 :     ++res;

  00108	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0010b	74 0c		 je	 SHORT $LN101@erase@5
  0010d	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00111	46		 inc	 esi
  00112	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  00115	3b f1		 cmp	 esi, ecx
  00117	7c 0e		 jl	 SHORT $LN102@erase@5
$LN101@erase@5:
  00119	8d 45 f8	 lea	 eax, DWORD PTR _res$[ebp]
  0011c	e8 00 00 00 00	 call	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
  00121	8b 75 fc	 mov	 esi, DWORD PTR _res$[ebp+4]
  00124	8b 7d f8	 mov	 edi, DWORD PTR _res$[ebp]
$LN102@erase@5:

; 1920 :   }
; 1921 :   return res;

  00127	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0012a	89 38		 mov	 DWORD PTR [eax], edi

; 1922 : }

  0012c	5f		 pop	 edi
  0012d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 10 00	 ret	 16			; 00000010H
?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted, COMDAT
; _this$ = eax
; _it$ = ecx

; 415  :     return test_deleted_key(get_key(*it));

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 10		 jbe	 SHORT $LN13@test_delet@4
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000e	75 06		 jne	 SHORT $LN13@test_delet@4
  00010	b8 01 00 00 00	 mov	 eax, 1

; 416  :   }

  00015	c3		 ret	 0

; 415  :     return test_deleted_key(get_key(*it));

$LN13@test_delet@4:
  00016	33 c0		 xor	 eax, eax

; 416  :   }

  00018	c3		 ret	 0
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ
_TEXT	SEGMENT
?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted, COMDAT
; _this$ = eax

; 236  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN40@advance_pa@2
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@advance_pa@2:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN1@advance_pa@2
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN50@advance_pa@2
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN50@advance_pa@2
$LN1@advance_pa@2:

; 237  :       ++pos;

  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL3@advance_pa@2
$LN50@advance_pa@2:
  00030	5e		 pop	 esi

; 236  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

$LN40@advance_pa@2:

; 238  :   }

  00031	c3		 ret	 0
?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z
_TEXT	SEGMENT
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 219  :     if (advance)  advance_past_empty_and_deleted();

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN46@dense_hash@5
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL9@dense_hash@5:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN7@dense_hash@5
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN59@dense_hash@5
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN59@dense_hash@5
$LN7@dense_hash@5:
  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL9@dense_hash@5
$LN59@dense_hash@5:
  00030	5e		 pop	 esi
$LN46@dense_hash@5:

; 220  :   }

  00031	c3		 ret	 0
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ
_TEXT	SEGMENT
??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator++, COMDAT
; _this$ = eax

; 240  :     assert(pos != end); ++pos; advance_past_empty_and_deleted(); return *this;

  00000	83 40 04 08	 add	 DWORD PTR [eax+4], 8
  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0000a	74 22		 je	 SHORT $LN42@operator@10
  0000c	56		 push	 esi
  0000d	8b 30		 mov	 esi, DWORD PTR [eax]
  0000f	90		 npad	 1
$LL5@operator@10:
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	39 56 2c	 cmp	 DWORD PTR [esi+44], edx
  00015	74 0b		 je	 SHORT $LN3@operator@10
  00017	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001b	76 10		 jbe	 SHORT $LN55@operator@10
  0001d	39 56 1c	 cmp	 DWORD PTR [esi+28], edx
  00020	75 0b		 jne	 SHORT $LN55@operator@10
$LN3@operator@10:
  00022	83 c1 08	 add	 ecx, 8
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00028	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0002b	75 e3		 jne	 SHORT $LL5@operator@10
$LN55@operator@10:
  0002d	5e		 pop	 esi
$LN42@operator@10:

; 241  :   }

  0002e	c3		 ret	 0
??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 314  :                                                        table+num_buckets,true);}

  00000	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00003	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00006	89 06		 mov	 DWORD PTR [esi], eax
  00008	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00011	8b c6		 mov	 eax, esi
  00013	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  00018	8b c6		 mov	 eax, esi
  0001a	c3		 ret	 0
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::begin, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 312  :                                                        table+num_buckets,true);}

  00000	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00003	89 06		 mov	 DWORD PTR [esi], eax
  00005	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00008	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000b	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  0000e	8b c6		 mov	 eax, esi
  00010	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00013	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  00018	8b c6		 mov	 eax, esi
  0001a	c3		 ret	 0
?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z
_TEXT	SEGMENT
_it$153562 = -16					; size = 12
tv647 = -4						; size = 4
_this$ = 8						; size = 4
_ht$ = 12						; size = 4
?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from, COMDAT
; _min_buckets_wanted$ = eax

; 614  :   void copy_from(const dense_hashtable &ht, size_type min_buckets_wanted) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _ht$[ebp]

; 615  :     clear_to_size(settings.min_buckets(ht.size(), min_buckets_wanted));

  0000f	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
  00012	2b 57 20	 sub	 edx, DWORD PTR [edi+32]
  00015	8b f0		 mov	 esi, eax
  00017	8b c3		 mov	 eax, ebx
  00019	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
  0001e	8b f3		 mov	 esi, ebx
  00020	e8 00 00 00 00	 call	 ?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size

; 616  : 
; 617  :     // We use a normal iterator to get non-deleted bcks from ht
; 618  :     // We could use insert() here, but since we know there are
; 619  :     // no duplicates and no deleted items, we can be more efficient
; 620  :     assert((bucket_count() & (bucket_count()-1)) == 0);      // a power of two
; 621  :     for ( const_iterator it = ht.begin(); it != ht.end(); ++it ) {

  00025	8b 77 34	 mov	 esi, DWORD PTR [edi+52]
  00028	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0002b	8d 0c c6	 lea	 ecx, DWORD PTR [esi+eax*8]
  0002e	89 4d f8	 mov	 DWORD PTR _it$153562[ebp+8], ecx
  00031	3b f1		 cmp	 esi, ecx
  00033	74 1b		 je	 SHORT $LL257@copy_from
  00035	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
$LL18@copy_from:
  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	3b d0		 cmp	 edx, eax
  0003c	74 0b		 je	 SHORT $LN254@copy_from
  0003e	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00042	76 0c		 jbe	 SHORT $LL257@copy_from
  00044	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00047	75 07		 jne	 SHORT $LL257@copy_from
$LN254@copy_from:
  00049	83 c6 08	 add	 esi, 8
  0004c	3b f1		 cmp	 esi, ecx
  0004e	75 e8		 jne	 SHORT $LL18@copy_from
$LL257@copy_from:
  00050	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00053	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00056	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00059	89 45 fc	 mov	 DWORD PTR tv647[ebp], eax
  0005c	3b c0		 cmp	 eax, eax
  0005e	74 1c		 je	 SHORT $LN253@copy_from
  00060	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
$LL119@copy_from:
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	3b d1		 cmp	 edx, ecx
  00067	74 0b		 je	 SHORT $LN252@copy_from
  00069	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0006d	76 0d		 jbe	 SHORT $LN253@copy_from
  0006f	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00072	75 08		 jne	 SHORT $LN253@copy_from
$LN252@copy_from:
  00074	83 c0 08	 add	 eax, 8
  00077	3b 45 fc	 cmp	 eax, DWORD PTR tv647[ebp]
  0007a	75 e7		 jne	 SHORT $LL119@copy_from
$LN253@copy_from:
  0007c	3b f0		 cmp	 esi, eax
  0007e	0f 84 b1 00 00
	00		 je	 $LN250@copy_from

; 622  :       size_type num_probes = 0;              // how many times we've probed
; 623  :       size_type bucknum;
; 624  :       const size_type bucket_count_minus_one = bucket_count() - 1;
; 625  :       for (bucknum = hash(get_key(*it)) & bucket_count_minus_one;

  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	8b c8		 mov	 ecx, eax
  00088	c1 e1 06	 shl	 ecx, 6
  0008b	2b c1		 sub	 eax, ecx
  0008d	8b c8		 mov	 ecx, eax
  0008f	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00092	33 c1		 xor	 eax, ecx
  00094	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  00097	8b c8		 mov	 ecx, eax
  00099	c1 e1 09	 shl	 ecx, 9
  0009c	2b c1		 sub	 eax, ecx
  0009e	8b c8		 mov	 ecx, eax
  000a0	c1 e1 04	 shl	 ecx, 4
  000a3	33 c1		 xor	 eax, ecx
  000a5	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  000ac	2b c1		 sub	 eax, ecx
  000ae	8b c8		 mov	 ecx, eax
  000b0	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  000b3	33 c1		 xor	 eax, ecx
  000b5	8b c8		 mov	 ecx, eax
  000b7	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  000ba	33 c8		 xor	 ecx, eax

; 626  :            !test_empty(bucknum);                               // not empty
; 627  :            bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one) {

  000bc	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  000bf	8b 5b 2c	 mov	 ebx, DWORD PTR [ebx+44]
  000c2	4a		 dec	 edx
  000c3	23 ca		 and	 ecx, edx
  000c5	33 ff		 xor	 edi, edi
  000c7	3b 1c c8	 cmp	 ebx, DWORD PTR [eax+ecx*8]
  000ca	74 13		 je	 SHORT $LN1@copy_from
  000cc	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  000cf	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  000d2	8b 5b 2c	 mov	 ebx, DWORD PTR [ebx+44]
$LL3@copy_from:

; 628  :         ++num_probes;

  000d5	47		 inc	 edi
  000d6	03 cf		 add	 ecx, edi
  000d8	23 ca		 and	 ecx, edx
  000da	3b 1c c8	 cmp	 ebx, DWORD PTR [eax+ecx*8]
  000dd	75 f6		 jne	 SHORT $LL3@copy_from
$LN1@copy_from:

; 629  :         assert(num_probes < bucket_count()
; 630  :                && "Hashtable is full: an error in key_equal<> or hash<>");
; 631  :       }
; 632  :       set_value(&table[bucknum], *it);       // copies the value to here

  000df	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  000e2	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  000e5	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 0a		 je	 SHORT $LN208@copy_from
  000ec	8b 06		 mov	 eax, DWORD PTR [esi]
  000ee	89 01		 mov	 DWORD PTR [ecx], eax
  000f0	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000f3	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN208@copy_from:

; 633  :       num_elements++;

  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _it$153562[ebp+8]
  000f9	ff 43 24	 inc	 DWORD PTR [ebx+36]
  000fc	8b 7d 0c	 mov	 edi, DWORD PTR _ht$[ebp]
  000ff	83 c6 08	 add	 esi, 8
  00102	3b f1		 cmp	 esi, ecx
  00104	0f 84 46 ff ff
	ff		 je	 $LL257@copy_from
  0010a	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0010d	8d 49 00	 npad	 3

; 616  : 
; 617  :     // We use a normal iterator to get non-deleted bcks from ht
; 618  :     // We could use insert() here, but since we know there are
; 619  :     // no duplicates and no deleted items, we can be more efficient
; 620  :     assert((bucket_count() & (bucket_count()-1)) == 0);      // a power of two
; 621  :     for ( const_iterator it = ht.begin(); it != ht.end(); ++it ) {

$LL67@copy_from:
  00110	8b 06		 mov	 eax, DWORD PTR [esi]
  00112	3b d0		 cmp	 edx, eax
  00114	74 13		 je	 SHORT $LN255@copy_from
  00116	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0011a	0f 86 30 ff ff
	ff		 jbe	 $LL257@copy_from
  00120	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00123	0f 85 27 ff ff
	ff		 jne	 $LL257@copy_from
$LN255@copy_from:
  00129	83 c6 08	 add	 esi, 8
  0012c	3b f1		 cmp	 esi, ecx
  0012e	75 e0		 jne	 SHORT $LL67@copy_from
  00130	e9 1b ff ff ff	 jmp	 $LL257@copy_from
$LN250@copy_from:

; 634  :     }
; 635  :     settings.inc_num_ht_copies();

  00135	ff 43 14	 inc	 DWORD PTR [ebx+20]
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx

; 636  :   }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 08 00	 ret	 8
?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = eax

; 271  : 		_Myiter _Tmp = *this;

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 272  : 		++*this;

  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	75 40		 jne	 SHORT $LN7@operator@11
  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00011	75 1a		 jne	 SHORT $LN38@operator@11
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00019	75 0f		 jne	 SHORT $LN21@operator@11
  0001b	eb 03 8d 49 00	 npad	 5
$LL22@operator@11:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00024	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00028	74 f6		 je	 SHORT $LL22@operator@11
$LN21@operator@11:
  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 273  : 		return (_Tmp);
; 274  : 		}

  0002c	c3		 ret	 0
$LN38@operator@11:

; 272  : 		++*this;

  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00034	75 12		 jne	 SHORT $LN5@operator@11
$LL6@operator@11:
  00036	8b 16		 mov	 edx, DWORD PTR [esi]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0b		 jne	 SHORT $LN5@operator@11
  0003d	89 0e		 mov	 DWORD PTR [esi], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ee		 je	 SHORT $LL6@operator@11
$LN5@operator@11:
  00048	89 0e		 mov	 DWORD PTR [esi], ecx
$LN7@operator@11:

; 273  : 		return (_Tmp);
; 274  : 		}

  0004a	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ
_TEXT	SEGMENT
?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted, COMDAT
; _this$ = eax

; 178  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN40@advance_pa@3
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@advance_pa@3:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN1@advance_pa@3
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN50@advance_pa@3
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN50@advance_pa@3
$LN1@advance_pa@3:

; 179  :       ++pos;

  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL3@advance_pa@3
$LN50@advance_pa@3:
  00030	5e		 pop	 esi

; 178  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

$LN40@advance_pa@3:

; 180  :   }

  00031	c3		 ret	 0
?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z
_TEXT	SEGMENT
tv281 = -12						; size = 8
tv272 = -12						; size = 8
tv259 = -12						; size = 8
tv251 = -12						; size = 8
tv290 = -8						; size = 4
tv283 = -8						; size = 4
tv274 = -8						; size = 4
tv269 = -8						; size = 4
tv261 = -8						; size = 4
tv253 = -8						; size = 4
tv286 = -2						; size = 2
tv278 = -2						; size = 2
tv265 = -2						; size = 2
tv256 = -2						; size = 2
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = edi
; _ht$ = ecx
; _min_buckets_wanted$ = eax

; 697  :         table(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00007	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
  0000b	f3 0f 7e 41 08	 movq	 xmm0, QWORD PTR [ecx+8]
  00010	66 0f d6 47 08	 movq	 QWORD PTR [edi+8], xmm0
  00015	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  0001a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001d	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	8b f0		 mov	 esi, eax
  00026	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00029	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0002c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0002f	33 db		 xor	 ebx, ebx
  00031	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  00034	89 5f 20	 mov	 DWORD PTR [edi+32], ebx
  00037	89 5f 24	 mov	 DWORD PTR [edi+36], ebx
  0003a	89 5f 28	 mov	 DWORD PTR [edi+40], ebx
  0003d	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00040	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  00043	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00046	89 57 30	 mov	 DWORD PTR [edi+48], edx
  00049	89 5f 34	 mov	 DWORD PTR [edi+52], ebx

; 698  :     if (!ht.settings.use_empty()) {

  0004c	38 59 11	 cmp	 BYTE PTR [ecx+17], bl
  0004f	75 6e		 jne	 SHORT $LN1@dense_hash@6

; 699  :       // If use_empty isn't set, copy_from will crash, so we do our own copying.
; 700  :       assert(ht.empty());
; 701  :       num_buckets = settings.min_buckets(ht.size(), min_buckets_wanted);

  00051	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00054	2b 51 20	 sub	 edx, DWORD PTR [ecx+32]
  00057	8b c7		 mov	 eax, edi
  00059	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets

; 702  :       settings.reset_thresholds(bucket_count());

  0005e	89 45 f8	 mov	 DWORD PTR tv290[ebp], eax
  00061	db 45 f8	 fild	 DWORD PTR tv290[ebp]
  00064	89 47 28	 mov	 DWORD PTR [edi+40], eax
  00067	85 c0		 test	 eax, eax
  00069	79 06		 jns	 SHORT $LN42@dense_hash@6
  0006b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN42@dense_hash@6:
  00071	d9 47 08	 fld	 DWORD PTR [edi+8]
  00074	5e		 pop	 esi
  00075	d9 7d fe	 fnstcw	 WORD PTR tv286[ebp]
  00078	88 5f 10	 mov	 BYTE PTR [edi+16], bl
  0007b	0f b7 45 fe	 movzx	 eax, WORD PTR tv286[ebp]
  0007f	d8 c9		 fmul	 ST(0), ST(1)
  00081	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00086	89 45 f8	 mov	 DWORD PTR tv283[ebp], eax
  00089	5b		 pop	 ebx
  0008a	d9 6d f8	 fldcw	 WORD PTR tv283[ebp]
  0008d	df 7d f4	 fistp	 QWORD PTR tv281[ebp]
  00090	8b 45 f4	 mov	 eax, DWORD PTR tv281[ebp]
  00093	89 07		 mov	 DWORD PTR [edi], eax
  00095	d9 6d fe	 fldcw	 WORD PTR tv286[ebp]
  00098	d8 4f 0c	 fmul	 DWORD PTR [edi+12]
  0009b	d9 7d fe	 fnstcw	 WORD PTR tv278[ebp]
  0009e	0f b7 45 fe	 movzx	 eax, WORD PTR tv278[ebp]
  000a2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000a7	89 45 f8	 mov	 DWORD PTR tv274[ebp], eax

; 707  :   }

  000aa	8b c7		 mov	 eax, edi
  000ac	d9 6d f8	 fldcw	 WORD PTR tv274[ebp]
  000af	df 7d f4	 fistp	 QWORD PTR tv272[ebp]
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR tv272[ebp]
  000b5	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  000b8	d9 6d fe	 fldcw	 WORD PTR tv278[ebp]
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN1@dense_hash@6:

; 703  :       return;
; 704  :     }
; 705  :     settings.reset_thresholds(bucket_count());

  000bf	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  000c2	db 47 28	 fild	 DWORD PTR [edi+40]
  000c5	85 d2		 test	 edx, edx
  000c7	79 06		 jns	 SHORT $LN43@dense_hash@6
  000c9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN43@dense_hash@6:
  000cf	d9 47 08	 fld	 DWORD PTR [edi+8]

; 706  :     copy_from(ht, min_buckets_wanted);   // copy_from() ignores deleted entries

  000d2	51		 push	 ecx
  000d3	d9 7d fe	 fnstcw	 WORD PTR tv265[ebp]
  000d6	57		 push	 edi
  000d7	0f b7 45 fe	 movzx	 eax, WORD PTR tv265[ebp]
  000db	d8 c9		 fmul	 ST(0), ST(1)
  000dd	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000e2	89 45 f8	 mov	 DWORD PTR tv261[ebp], eax
  000e5	88 5f 10	 mov	 BYTE PTR [edi+16], bl
  000e8	d9 6d f8	 fldcw	 WORD PTR tv261[ebp]
  000eb	df 7d f4	 fistp	 QWORD PTR tv259[ebp]
  000ee	8b 45 f4	 mov	 eax, DWORD PTR tv259[ebp]
  000f1	89 07		 mov	 DWORD PTR [edi], eax
  000f3	d9 6d fe	 fldcw	 WORD PTR tv265[ebp]
  000f6	d8 4f 0c	 fmul	 DWORD PTR [edi+12]
  000f9	d9 7d fe	 fnstcw	 WORD PTR tv256[ebp]
  000fc	0f b7 45 fe	 movzx	 eax, WORD PTR tv256[ebp]
  00100	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00105	89 45 f8	 mov	 DWORD PTR tv253[ebp], eax
  00108	8b c6		 mov	 eax, esi
  0010a	d9 6d f8	 fldcw	 WORD PTR tv253[ebp]
  0010d	df 7d f4	 fistp	 QWORD PTR tv251[ebp]
  00110	8b 55 f4	 mov	 edx, DWORD PTR tv251[ebp]
  00113	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00116	d9 6d fe	 fldcw	 WORD PTR tv256[ebp]
  00119	e8 00 00 00 00	 call	 ?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from
  0011e	5e		 pop	 esi

; 707  :   }

  0011f	8b c7		 mov	 eax, edi
  00121	5b		 pop	 ebx
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z
_TEXT	SEGMENT
??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 165  :     if (advance)  advance_past_empty_and_deleted();

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN46@dense_hash@7
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL9@dense_hash@7:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN7@dense_hash@7
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN59@dense_hash@7
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN59@dense_hash@7
$LN7@dense_hash@7:
  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL9@dense_hash@7
$LN59@dense_hash@7:
  00030	5e		 pop	 esi
$LN46@dense_hash@7:

; 166  :   }

  00031	c3		 ret	 0
??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T190152 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 19		 jne	 SHORT $LN97@erase@6
  00014	3b d0		 cmp	 edx, eax
  00016	75 15		 jne	 SHORT $LN97@erase@6

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear

; 1383 : 			return (begin());

  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1389 : 			return (iterator(_First._Ptr, this));

  00022	8b c6		 mov	 eax, esi
  00024	89 0e		 mov	 DWORD PTR [esi], ecx
  00026	5f		 pop	 edi

; 1390 : 			}
; 1391 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN97@erase@6:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0002d	3b ca		 cmp	 ecx, edx
  0002f	74 60		 je	 SHORT $LN1@erase@6
$LL2@erase@6:

; 1388 : 				erase(_First++);

  00031	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00035	8b d1		 mov	 edx, ecx
  00037	75 45		 jne	 SHORT $LN59@erase@6
  00039	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003c	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00040	75 1d		 jne	 SHORT $LN99@erase@6
  00042	8b c8		 mov	 ecx, eax
  00044	8b 01		 mov	 eax, DWORD PTR [ecx]
  00046	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0004a	75 0e		 jne	 SHORT $LN73@erase@6
  0004c	8d 64 24 00	 npad	 4
$LL74@erase@6:
  00050	8b c8		 mov	 ecx, eax
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00058	74 f6		 je	 SHORT $LL74@erase@6
$LN73@erase@6:
  0005a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
  0005d	eb 1f		 jmp	 SHORT $LN59@erase@6
$LN99@erase@6:
  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00062	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00066	75 13		 jne	 SHORT $LN57@erase@6
$LL58@erase@6:
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0e		 jne	 SHORT $LN57@erase@6
  0006d	8b c8		 mov	 ecx, eax
  0006f	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00079	74 ed		 je	 SHORT $LL58@erase@6
$LN57@erase@6:
  0007b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN59@erase@6:
  0007e	52		 push	 edx
  0007f	8d 55 fc	 lea	 edx, DWORD PTR $T190152[ebp]
  00082	52		 push	 edx
  00083	57		 push	 edi
  00084	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0008c	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0008f	75 a0		 jne	 SHORT $LL2@erase@6
$LN1@erase@6:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b c6		 mov	 eax, esi
  00093	89 0e		 mov	 DWORD PTR [esi], ecx
  00095	5f		 pop	 edi

; 1390 : 			}
; 1391 : 		}

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ
_TEXT	SEGMENT
_tmp$152976 = -64					; size = 56
tv209 = -8						; size = 4
tv205 = -8						; size = 4
_shrink_factor$152971 = -4				; size = 4
?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink, COMDAT
; _this$ = esi

; 524  :   bool maybe_shrink() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 525  :     assert(num_elements >= num_deleted);
; 526  :     assert((bucket_count() & (bucket_count()-1)) == 0); // is a power of two
; 527  :     assert(bucket_count() >= HT_MIN_BUCKETS);
; 528  :     bool retval = false;
; 529  : 
; 530  :     // If you construct a hashtable with < HT_DEFAULT_STARTING_BUCKETS,
; 531  :     // we'll never shrink until you get relatively big, and we'll never
; 532  :     // shrink below HT_DEFAULT_STARTING_BUCKETS.  Otherwise, something
; 533  :     // like "dense_hash_set<int> x; x.insert(4); x.erase(4);" will
; 534  :     // shrink us down to HT_MIN_BUCKETS buckets, which is too small.
; 535  :     const size_type num_remain = num_elements - num_deleted;

  00003	8b 46 24	 mov	 eax, DWORD PTR [esi+36]

; 536  :     const size_type shrink_threshold = settings.shrink_threshold();

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	2b 46 20	 sub	 eax, DWORD PTR [esi+32]
  0000c	83 ec 40	 sub	 esp, 64			; 00000040H
  0000f	53		 push	 ebx
  00010	32 db		 xor	 bl, bl
  00012	57		 push	 edi

; 537  :     if (shrink_threshold > 0 && num_remain < shrink_threshold &&
; 538  :         bucket_count() > HT_DEFAULT_STARTING_BUCKETS) {

  00013	85 c9		 test	 ecx, ecx
  00015	74 7a		 je	 SHORT $LN23@maybe_shri
  00017	3b c1		 cmp	 eax, ecx
  00019	73 76		 jae	 SHORT $LN23@maybe_shri
  0001b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001e	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00021	76 6e		 jbe	 SHORT $LN23@maybe_shri

; 539  :       const float shrink_factor = settings.shrink_factor();

  00023	f3 0f 10 46 0c	 movss	 xmm0, DWORD PTR [esi+12]

; 540  :       size_type sz = bucket_count() / 2;    // find how much we should shrink

  00028	d1 e9		 shr	 ecx, 1
  0002a	f3 0f 11 45 fc	 movss	 DWORD PTR _shrink_factor$152971[ebp], xmm0

; 541  :       while (sz > HT_DEFAULT_STARTING_BUCKETS &&
; 542  :              num_remain < sz * shrink_factor) {

  0002f	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00032	76 36		 jbe	 SHORT $LN1@maybe_shri
  00034	89 45 f8	 mov	 DWORD PTR tv209[ebp], eax
  00037	db 45 f8	 fild	 DWORD PTR tv209[ebp]
  0003a	85 c0		 test	 eax, eax
  0003c	79 06		 jns	 SHORT $LN36@maybe_shri
  0003e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN36@maybe_shri:
  00044	d9 45 fc	 fld	 DWORD PTR _shrink_factor$152971[ebp]
$LN2@maybe_shri:
  00047	8b c1		 mov	 eax, ecx
  00049	89 45 f8	 mov	 DWORD PTR tv205[ebp], eax
  0004c	db 45 f8	 fild	 DWORD PTR tv205[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	79 06		 jns	 SHORT $LN37@maybe_shri
  00053	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN37@maybe_shri:
  00059	d8 c9		 fmul	 ST(0), ST(1)
  0005b	df f2		 fcomip	 ST(2)
  0005d	76 07		 jbe	 SHORT $LN35@maybe_shri

; 543  :         sz /= 2;                            // stay a power of 2

  0005f	d1 e9		 shr	 ecx, 1
  00061	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00064	77 e1		 ja	 SHORT $LN2@maybe_shri
$LN35@maybe_shri:

; 541  :       while (sz > HT_DEFAULT_STARTING_BUCKETS &&
; 542  :              num_remain < sz * shrink_factor) {

  00066	dd d9		 fstp	 ST(1)
  00068	dd d8		 fstp	 ST(0)
$LN1@maybe_shri:

; 544  :       }
; 545  :       dense_hashtable tmp(*this, sz);       // Do the actual resizing

  0006a	8b c1		 mov	 eax, ecx
  0006c	8b ce		 mov	 ecx, esi
  0006e	8d 7d c0	 lea	 edi, DWORD PTR _tmp$152976[ebp]
  00071	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >

; 546  :       swap(tmp);                            // now we are tmp

  00076	8b d7		 mov	 edx, edi
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap

; 547  :       retval = true;
; 548  :     }

  0007f	8b 45 f4	 mov	 eax, DWORD PTR _tmp$152976[ebp+52]
  00082	b3 01		 mov	 bl, 1
  00084	85 c0		 test	 eax, eax
  00086	74 09		 je	 SHORT $LN23@maybe_shri
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _free
  0008e	83 c4 04	 add	 esp, 4
$LN23@maybe_shri:

; 549  :     settings.set_consider_shrink(false);    // because we just considered it
; 550  :     return retval;
; 551  :   }

  00091	5f		 pop	 edi
  00092	8a c3		 mov	 al, bl
  00094	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ
_TEXT	SEGMENT
_tmp$152945 = -56					; size = 56
?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::squash_deleted, COMDAT
; _this$ = esi

; 369  :   void squash_deleted() {           // gets rid of any deleted entries we have

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 370  :     if ( num_deleted ) {            // get rid of deleted before writing

  00006	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0000a	57		 push	 edi
  0000b	74 28		 je	 SHORT $LN13@squash_del

; 371  :       dense_hashtable tmp(*this);   // copying will get rid of deleted

  0000d	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00012	8b ce		 mov	 ecx, esi
  00014	8d 7d c8	 lea	 edi, DWORD PTR _tmp$152945[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >

; 372  :       swap(tmp);                    // now we are tmp

  0001c	8b d7		 mov	 edx, edi
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap

; 373  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _tmp$152945[ebp+52]
  00028	85 c0		 test	 eax, eax
  0002a	74 09		 je	 SHORT $LN13@squash_del
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
$LN13@squash_del:

; 374  :     assert(num_deleted == 0);
; 375  :   }

  00035	5f		 pop	 edi
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::squash_deleted
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T190571 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tidy, COMDAT
; _this$ = eax

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	51		 push	 ecx
  0000b	52		 push	 edx
  0000c	8d 75 fc	 lea	 esi, DWORD PTR $T190571[ebp]
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00014	5e		 pop	 esi

; 1867 : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tidy
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z
_TEXT	SEGMENT
_tmp$190697 = -60					; size = 56
_key$ = 8						; size = 4
?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key, COMDAT
; _this$ = esi

; 386  :   void set_deleted_key(const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 387  :     // the empty indicator (if specified) and the deleted indicator
; 388  :     // must be different
; 389  :     assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
; 390  :            && "Passed the empty-key to set_deleted_key");
; 391  :     // It's only safe to change what "deleted" means if we purge deleted guys
; 392  :     squash_deleted();

  00006	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0000a	57		 push	 edi
  0000b	74 28		 je	 SHORT $LN15@set_delete@2
  0000d	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00012	8b ce		 mov	 ecx, esi
  00014	8d 7d c4	 lea	 edi, DWORD PTR _tmp$190697[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
  0001c	8b d7		 mov	 edx, edi
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
  00025	8b 45 f8	 mov	 eax, DWORD PTR _tmp$190697[ebp+52]
  00028	85 c0		 test	 eax, eax
  0002a	74 09		 je	 SHORT $LN15@set_delete@2
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
$LN15@set_delete@2:

; 393  :     settings.set_use_deleted(true);
; 394  :     key_info.delkey = key;

  00035	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00038	c6 46 12 01	 mov	 BYTE PTR [esi+18], 1
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 395  :   }

  00041	5f		 pop	 edi
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 310  :                                                  table + num_buckets, true); }

  00000	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00003	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00006	89 06		 mov	 DWORD PTR [esi], eax
  00008	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00011	8b c6		 mov	 eax, esi
  00013	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  00018	8b c6		 mov	 eax, esi
  0001a	c3		 ret	 0
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z
_TEXT	SEGMENT
$T190717 = -8						; size = 8
$T190715 = -8						; size = 8
__Where$ = -4						; size = 4
??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[], COMDAT
; __Keyval$ = eax

; 275  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax
  0000a	57		 push	 edi
  0000b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap

; 276  : 		iterator _Where = this->lower_bound(_Keyval);

  00011	8d 45 fc	 lea	 eax, DWORD PTR __Where$[ebp]
  00014	50		 push	 eax
  00015	8b c6		 mov	 eax, esi
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 277  : 		if (_Where == this->end())

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Where$[ebp]
  00021	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00024	75 59		 jne	 SHORT $LN1@operator@12

; 278  : 			_Where = _Mybase::insert(
; 279  : 				value_type(_Keyval, mapped_type())).first;

  00026	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00029	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0002b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	50		 push	 eax
  00031	53		 push	 ebx
  00032	8d 75 f8	 lea	 esi, DWORD PTR $T190715[ebp]
  00035	89 4d f8	 mov	 DWORD PTR $T190715[ebp], ecx
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T190715[ebp+4], 0
  0003f	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00044	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00047	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  0004c	2b d1		 sub	 edx, ecx
  0004e	83 fa 01	 cmp	 edx, 1
  00051	73 0a		 jae	 SHORT $LN54@operator@12
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00058	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN114@operator@12:
$LN54@operator@12:
  0005d	41		 inc	 ecx
  0005e	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00061	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00064	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00067	89 01		 mov	 DWORD PTR [ecx], eax
  00069	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006c	8b 02		 mov	 eax, DWORD PTR [edx]
  0006e	50		 push	 eax
  0006f	8d 4d f8	 lea	 ecx, DWORD PTR $T190717[ebp]
  00072	51		 push	 ecx
  00073	83 c0 08	 add	 eax, 8
  00076	57		 push	 edi
  00077	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0007c	8b 45 f8	 mov	 eax, DWORD PTR $T190717[ebp]
$LN1@operator@12:

; 280  : 		return ((*_Where).second);
; 281  : 		}

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	83 c0 0c	 add	 eax, 12			; 0000000cH
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN113@operator@12:
??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T191305 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8d 75 f0	 lea	 esi, DWORD PTR $T191305[ebp]
  0002f	8b c7		 mov	 eax, edi
  00031	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 792  : 		}

  00036	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	83 c4 04	 add	 esp, 4
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z
_TEXT	SEGMENT
$T191348 = -8						; size = 8
$T191351 = -4						; size = 4
??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[], COMDAT
; __Keyval$ = edx

; 210  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  0000e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00018	57		 push	 edi
  00019	8b d9		 mov	 ebx, ecx
  0001b	75 17		 jne	 SHORT $LN9@operator@13
  0001d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001f	90		 npad	 1
$LL10@operator@13:
  00020	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00023	73 05		 jae	 SHORT $LN8@operator@13
  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00028	eb 04		 jmp	 SHORT $LN7@operator@13
$LN8@operator@13:
  0002a	8b d8		 mov	 ebx, eax
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@operator@13:
  0002e	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00032	74 ec		 je	 SHORT $LL10@operator@13
$LN9@operator@13:

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00034	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  00037	74 07		 je	 SHORT $LN1@operator@13
  00039	8b 02		 mov	 eax, DWORD PTR [edx]
  0003b	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0003e	73 2c		 jae	 SHORT $LN80@operator@13
$LN1@operator@13:

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	8d 7d f8	 lea	 edi, DWORD PTR $T191348[ebp]
  00045	89 4d f8	 mov	 DWORD PTR $T191348[ebp], ecx
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T191348[ebp+4], 0
  0004f	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00054	50		 push	 eax
  00055	53		 push	 ebx
  00056	56		 push	 esi
  00057	8d 7d fc	 lea	 edi, DWORD PTR $T191351[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0005f	8b 45 fc	 mov	 eax, DWORD PTR $T191351[ebp]

; 216  : 		return ((*_Where).second);

  00062	83 c0 10	 add	 eax, 16			; 00000010H

; 217  : 		}

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN80@operator@13:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T191722 = -16						; size = 12
$T191622 = -4						; size = 4
??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	6a 18		 push	 24			; 00000018H
  00008	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 25		 je	 SHORT $LN25@map
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001e	89 00		 mov	 DWORD PTR [eax], eax
  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002f	b0 01		 mov	 al, 1
  00031	88 41 14	 mov	 BYTE PTR [ecx+20], al
  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	88 42 15	 mov	 BYTE PTR [edx+21], al

; 107  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00040	8d 45 fc	 lea	 eax, DWORD PTR $T191622[ebp]
  00043	50		 push	 eax
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T191722[ebp]
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T191622[ebp], 0
  0004e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00053	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00058	8d 4d f0	 lea	 ecx, DWORD PTR $T191722[ebp]
  0005b	51		 push	 ecx
  0005c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T191722[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  00068	cc		 int	 3
??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z
_TEXT	SEGMENT
?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::erase, COMDAT
; ___$ReturnUdt$ = esi
; _iter$ = ecx

; 211  :   iterator erase(const iterator &iter) {

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00006	57		 push	 edi

; 212  :     return this->tree_.erase(iter);

  00007	8b 39		 mov	 edi, DWORD PTR [ecx]
  00009	83 ec 08	 sub	 esp, 8
  0000c	8b c4		 mov	 eax, esp
  0000e	89 38		 mov	 DWORD PTR [eax], edi
  00010	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00013	56		 push	 esi
  00014	52		 push	 edx
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00018	e8 00 00 00 00	 call	 ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase
  0001d	8b c6		 mov	 eax, esi

; 213  :   }

  0001f	5f		 pop	 edi
  00020	c3		 ret	 0
?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z
_TEXT	SEGMENT
$T191758 = -12						; size = 12
??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::operator[], COMDAT
; _key$ = eax

; 269  :   data_type& operator[](const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree

; 270  :     return this->tree_.insert_unique(key, generate_value(key)).first->second;

  0000e	50		 push	 eax
  0000f	50		 push	 eax
  00010	8d 75 f4	 lea	 esi, DWORD PTR $T191758[ebp]
  00013	e8 00 00 00 00	 call	 ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]

; 271  :   }

  0001d	5f		 pop	 edi
  0001e	8d 44 ca 0c	 lea	 eax, DWORD PTR [edx+ecx*8+12]
  00022	5e		 pop	 esi
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::operator[]
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z
_TEXT	SEGMENT
_tmp$191830 = -60					; size = 56
_key$ = 8						; size = 4
?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key, COMDAT

; 301  :   void set_deleted_key(const key_type& key)   { rep.set_deleted_key(key); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi
  00007	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0000d	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00011	57		 push	 edi
  00012	74 28		 je	 SHORT $LN17@set_delete@3
  00014	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00019	8b ce		 mov	 ecx, esi
  0001b	8d 7d c4	 lea	 edi, DWORD PTR _tmp$191830[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
  00023	8b d7		 mov	 edx, edi
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _tmp$191830[ebp+52]
  0002f	85 c0		 test	 eax, eax
  00031	74 09		 je	 SHORT $LN17@set_delete@3
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _free
  00039	83 c4 04	 add	 esp, 4
$LN17@set_delete@3:
  0003c	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0003f	c6 46 12 01	 mov	 BYTE PTR [esi+18], 1
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	5f		 pop	 edi
  00046	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  00049	5e		 pop	 esi
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end, COMDAT
; ___$ReturnUdt$ = esi

; 171  :   iterator end()                                 { return rep.end(); }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00005	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00008	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0000b	89 06		 mov	 DWORD PTR [esi], eax
  0000d	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00016	8b c6		 mov	 eax, esi
  00018	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  0001d	8b c6		 mov	 eax, esi
  0001f	c3		 ret	 0
?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T191995 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8d 75 f0	 lea	 esi, DWORD PTR $T191995[ebp]
  0002f	8b c7		 mov	 eax, edi
  00031	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00036	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	83 c4 04	 add	 esp, 4
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z$1
__ehfuncinfo$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T192213 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8d 75 f0	 lea	 esi, DWORD PTR $T192213[ebp]
  0002f	8b c7		 mov	 eax, edi
  00031	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00036	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	83 c4 08	 add	 esp, 8
  0004b	8b c7		 mov	 eax, edi
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z$1:
  00000	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
PUBLIC	?test_free@@YAXXZ				; test_free
;	COMDAT xdata$x
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\judyarray\judy64na.c
xdata$x	SEGMENT
__unwindtable$?test_free@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?test_free@@YAXXZ$5
__ehfuncinfo$?test_free@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?test_free@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark.cc
xdata$x	ENDS
;	COMDAT ?test_free@@YAXXZ
_TEXT	SEGMENT
$T192738 = -20						; size = 4
$T192259 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?test_free@@YAXXZ PROC					; test_free, COMDAT

; 803  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00009	6a ff		 push	 -1
  0000b	68 00 00 00 00	 push	 __ehhandler$?test_free@@YAXXZ
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	56		 push	 esi

; 804  : 	COND(DATA_TREE) {

  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00022	83 fe 05	 cmp	 esi, 5
  00025	75 1d		 jne	 SHORT $LN20@test_free

; 805  : 		free(RBTREE);

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RBTREE@@3PAUrbt_object@@A ; RBTREE
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
  00035	5e		 pop	 esi

; 901  : 	}
; 902  : #endif
; 903  : }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN20@test_free:

; 806  : 	}
; 807  : 
; 808  : 	COND(DATA_HASHTABLE) {

  00044	85 f6		 test	 esi, esi
  00046	75 2e		 jne	 SHORT $LN19@test_free

; 809  : 		if (tommy_hashtable_count(&hashtable) != 0)

  00048	39 35 0c 00 00
	00		 cmp	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12, esi
  0004e	74 0b		 je	 SHORT $LN18@test_free

; 810  : 			abort();

  00050	e8 00 00 00 00	 call	 _abort
  00055	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
$LN18@test_free:

; 811  : 		tommy_hashtable_done(&hashtable);

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _free

; 812  : 		free(HASHTABLE);

  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?HASHTABLE@@3PAUhashtable_object@@A ; HASHTABLE
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _free
  00073	83 c4 08	 add	 esp, 8
$LN19@test_free:

; 813  : 	}
; 814  : 
; 815  : 	COND(DATA_HASHDYN) {

  00076	83 fe 01	 cmp	 esi, 1
  00079	75 2e		 jne	 SHORT $LN17@test_free

; 816  : 		if (tommy_hashdyn_count(&hashdyn) != 0)

  0007b	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, 0
  00082	74 0b		 je	 SHORT $LN16@test_free

; 817  : 			abort();

  00084	e8 00 00 00 00	 call	 _abort
  00089	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
$LN16@test_free:

; 818  : 		tommy_hashdyn_done(&hashdyn);

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _free

; 819  : 		free(HASHDYN);

  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HASHDYN@@3PAUhashtable_object@@A ; HASHDYN
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _free
  000a6	83 c4 08	 add	 esp, 8
$LN17@test_free:

; 820  : 	}
; 821  : 
; 822  : 	COND(DATA_HASHLIN) {

  000a9	83 fe 02	 cmp	 esi, 2
  000ac	75 2e		 jne	 SHORT $LN15@test_free

; 823  : 		if (tommy_hashlin_count(&hashlin) != 0)

  000ae	83 3d a0 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160, 0
  000b5	74 0b		 je	 SHORT $LN14@test_free

; 824  : 			abort();

  000b7	e8 00 00 00 00	 call	 _abort
  000bc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
$LN14@test_free:

; 825  : 		tommy_hashlin_done(&hashlin);

  000c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _free

; 826  : 		free(HASHLIN);

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?HASHLIN@@3PAUhashtable_object@@A ; HASHLIN
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _free
  000d9	83 c4 08	 add	 esp, 8
$LN15@test_free:

; 827  : 	}
; 828  : 
; 829  : 	COND(DATA_TRIE) {

  000dc	83 fe 03	 cmp	 esi, 3
  000df	75 28		 jne	 SHORT $LN13@test_free

; 830  : 		if (tommy_trie_count(&trie) != 0)

  000e1	83 3d 80 00 00
	00 00		 cmp	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128, 0
  000e8	74 05		 je	 SHORT $LN12@test_free

; 831  : 			abort();

  000ea	e8 00 00 00 00	 call	 _abort
$LN12@test_free:

; 832  : 		tommy_allocator_done(&trie_allocator);

  000ef	e8 00 00 00 00	 call	 ?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z ; allocator_reset

; 833  : 		tommy_trie_done(&trie);
; 834  : 		free(TRIE);

  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?TRIE@@3PAUtrie_object@@A ; TRIE
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 _free
  00100	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00106	83 c4 04	 add	 esp, 4
$LN13@test_free:

; 835  : 	}
; 836  : 
; 837  : 	COND(DATA_TRIE_INPLACE) {

  00109	83 fe 04	 cmp	 esi, 4
  0010c	75 23		 jne	 SHORT $LN11@test_free

; 838  : 		if (tommy_trie_inplace_count(&trie_inplace) != 0)

  0010e	83 3d 00 01 00
	00 00		 cmp	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256, 0
  00115	74 0b		 je	 SHORT $LN10@test_free

; 839  : 			abort();

  00117	e8 00 00 00 00	 call	 _abort
  0011c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
$LN10@test_free:

; 840  : 		free(TRIE_INPLACE);

  00122	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?TRIE_INPLACE@@3PAUtrie_inplace_object@@A ; TRIE_INPLACE
  00128	52		 push	 edx
  00129	e8 00 00 00 00	 call	 _free
  0012e	83 c4 04	 add	 esp, 4
$LN11@test_free:

; 841  : 	}
; 842  : 
; 843  : 	COND(DATA_KHASH) {

  00131	83 fe 07	 cmp	 esi, 7
  00134	75 4b		 jne	 SHORT $LN9@test_free

; 844  : 		kh_destroy(word, khash);

  00136	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  0013c	85 f6		 test	 esi, esi
  0013e	74 24		 je	 SHORT $LN65@test_free
  00140	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _free
  00149	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0014c	51		 push	 ecx
  0014d	e8 00 00 00 00	 call	 _free
  00152	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _free
  0015b	56		 push	 esi
  0015c	e8 00 00 00 00	 call	 _free
  00161	83 c4 10	 add	 esp, 16			; 00000010H
$LN65@test_free:

; 845  : 		free(KHASH);

  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR ?KHASH@@3PAUkhash_object@@A ; KHASH
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _free
  0016f	83 c4 04	 add	 esp, 4
  00172	5e		 pop	 esi

; 901  : 	}
; 902  : #endif
; 903  : }

  00173	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00176	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
$LN9@test_free:

; 846  : 	}
; 847  : 
; 848  : #ifdef USE_CGOOGLEDENSEHASH
; 849  : 	COND(DATA_CGOOGLE) {
; 850  : 		FreeHashTable(cgoogledensehash);
; 851  : 		free(GOOGLE);
; 852  : 	}
; 853  : #endif
; 854  : 
; 855  : #ifdef USE_GOOGLEDENSEHASH
; 856  : 	COND(DATA_GOOGLEDENSEHASH) {

  00181	83 fe 0b	 cmp	 esi, 11			; 0000000bH
  00184	75 3c		 jne	 SHORT $LN70@test_free

; 857  : 		free(GOOGLE);

  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 _free

; 858  : 		delete googledensehash;

  00192	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00198	83 c4 04	 add	 esp, 4
  0019b	85 f6		 test	 esi, esi
  0019d	0f 84 86 01 00
	00		 je	 $LN164@test_free
  001a3	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  001a6	85 c0		 test	 eax, eax
  001a8	74 09		 je	 SHORT $LN83@test_free
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 _free
  001b0	83 c4 04	 add	 esp, 4
$LN83@test_free:
  001b3	56		 push	 esi
  001b4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001b9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  001bf	83 c4 04	 add	 esp, 4
$LN70@test_free:

; 859  : 	}
; 860  : #endif
; 861  : 
; 862  : #ifdef USE_GOOGLEBTREE
; 863  : 	COND(DATA_GOOGLEBTREE) {

  001c2	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  001c5	75 40		 jne	 SHORT $LN87@test_free

; 864  : 		free(GOOGLE);

  001c7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE
  001cd	52		 push	 edx
  001ce	e8 00 00 00 00	 call	 _free

; 865  : 		delete googlebtree;

  001d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  001d9	83 c4 04	 add	 esp, 4
  001dc	8b f1		 mov	 esi, ecx
  001de	85 c9		 test	 ecx, ecx
  001e0	0f 84 43 01 00
	00		 je	 $LN164@test_free
  001e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e8	85 c0		 test	 eax, eax
  001ea	74 06		 je	 SHORT $LN104@test_free
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN104@test_free:
  001f2	56		 push	 esi
  001f3	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  001f9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001fe	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00204	83 c4 04	 add	 esp, 4
$LN87@test_free:

; 866  : 	}
; 867  : #endif
; 868  : 
; 869  : #ifdef USE_CPPMAP
; 870  : 	COND(DATA_CPPMAP) {

  00207	53		 push	 ebx
  00208	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0020b	75 52		 jne	 SHORT $LN115@test_free

; 871  : 		free(CPP);

  0020d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _free

; 872  : 		delete cppmap;

  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  0021d	83 c4 04	 add	 esp, 4
  00220	8b d8		 mov	 ebx, eax
  00222	89 5d f0	 mov	 DWORD PTR $T192259[ebp], ebx
  00225	85 c0		 test	 eax, eax
  00227	0f 84 fb 00 00
	00		 je	 $LN174@test_free
  0022d	57		 push	 edi
  0022e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00235	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00238	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023a	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  0023d	51		 push	 ecx
  0023e	52		 push	 edx
  0023f	8d 75 ec	 lea	 esi, DWORD PTR $T192738[ebp]
  00242	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00247	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00249	51		 push	 ecx
  0024a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0024f	53		 push	 ebx
  00250	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00255	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  0025b	83 c4 08	 add	 esp, 8
  0025e	5f		 pop	 edi
$LN115@test_free:

; 873  : 	}
; 874  : #endif
; 875  : 
; 876  : #ifdef USE_CPPUNORDEREDMAP
; 877  : 	COND(DATA_CPPUNORDEREDMAP) {

  0025f	83 fe 0d	 cmp	 esi, 13			; 0000000dH
  00262	75 28		 jne	 SHORT $LN172@test_free

; 878  : 		free(CPP);

  00264	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP
  0026a	52		 push	 edx
  0026b	e8 00 00 00 00	 call	 _free

; 879  : 		delete cppunorderedmap;

  00270	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00276	83 c4 04	 add	 esp, 4
  00279	85 f6		 test	 esi, esi
  0027b	0f 84 a7 00 00
	00		 je	 $LN174@test_free
  00281	e8 00 00 00 00	 call	 ??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z
  00286	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
$LN172@test_free:

; 880  : 	}
; 881  : #endif
; 882  : 
; 883  : 	COND(DATA_UTHASH) {

  0028c	83 fe 08	 cmp	 esi, 8
  0028f	75 1e		 jne	 SHORT $LN4@test_free

; 884  : 		free(UTHASH);

  00291	a1 00 00 00 00	 mov	 eax, DWORD PTR ?UTHASH@@3PAUuthash_object@@A ; UTHASH
  00296	50		 push	 eax
  00297	e8 00 00 00 00	 call	 _free
  0029c	83 c4 04	 add	 esp, 4
  0029f	5b		 pop	 ebx
  002a0	5e		 pop	 esi

; 901  : 	}
; 902  : #endif
; 903  : }

  002a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c3		 ret	 0
$LN4@test_free:

; 885  : 	}
; 886  : 
; 887  : 	COND(DATA_NEDTRIE) {

  002af	83 fe 06	 cmp	 esi, 6
  002b2	75 1f		 jne	 SHORT $LN3@test_free

; 888  : 		free(NEDTRIE);

  002b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?NEDTRIE@@3PAUnedtrie_object@@A ; NEDTRIE
  002ba	51		 push	 ecx
  002bb	e8 00 00 00 00	 call	 _free
  002c0	83 c4 04	 add	 esp, 4
  002c3	5b		 pop	 ebx
  002c4	5e		 pop	 esi

; 901  : 	}
; 902  : #endif
; 903  : }

  002c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002cf	8b e5		 mov	 esp, ebp
  002d1	5d		 pop	 ebp
  002d2	c3		 ret	 0
$LN3@test_free:

; 889  : 	}
; 890  : 
; 891  : #ifdef USE_JUDY
; 892  : 	COND(DATA_JUDY) {

  002d3	83 fe 09	 cmp	 esi, 9
  002d6	75 1f		 jne	 SHORT $LN2@test_free

; 893  : 		free(JUDY);

  002d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?JUDY@@3PAUjudy_object@@A ; JUDY
  002de	52		 push	 edx
  002df	e8 00 00 00 00	 call	 _free
  002e4	83 c4 04	 add	 esp, 4
  002e7	5b		 pop	 ebx
  002e8	5e		 pop	 esi

; 901  : 	}
; 902  : #endif
; 903  : }

  002e9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002f3	8b e5		 mov	 esp, ebp
  002f5	5d		 pop	 ebp
  002f6	c3		 ret	 0
$LN2@test_free:

; 894  : 	}
; 895  : #endif
; 896  : 
; 897  : #ifdef USE_JUDYARRAY
; 898  : 	COND(DATA_JUDYARRAY) {

  002f7	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  002fa	75 2c		 jne	 SHORT $LN174@test_free

; 899  : 		free(JUDYARRAY);

  002fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A ; JUDYARRAY
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 _free

; 900  : 		judy_close(judyarray);

  00307	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  0030d	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00310	83 c4 04	 add	 esp, 4
  00313	85 c0		 test	 eax, eax
  00315	74 11		 je	 SHORT $LN174@test_free
$LL165@test_free:
  00317	8b 30		 mov	 esi, DWORD PTR [eax]
  00319	50		 push	 eax
  0031a	e8 00 00 00 00	 call	 _free
  0031f	83 c4 04	 add	 esp, 4
  00322	8b c6		 mov	 eax, esi
  00324	85 f6		 test	 esi, esi
  00326	75 ef		 jne	 SHORT $LL165@test_free
$LN174@test_free:
  00328	5b		 pop	 ebx
$LN164@test_free:

; 901  : 	}
; 902  : #endif
; 903  : }

  00329	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0032c	5e		 pop	 esi
  0032d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?test_free@@YAXXZ$5:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T192259[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$?test_free@@YAXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?test_free@@YAXXZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?test_free@@YAXXZ ENDP					; test_free
PUBLIC	?test_alloc@@YAXXZ				; test_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?test_alloc@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?test_alloc@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?test_alloc@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?test_alloc@@YAXXZ$3
__ehfuncinfo$?test_alloc@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?test_alloc@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?test_alloc@@YAXXZ
_TEXT	SEGMENT
$T192809 = -96						; size = 4
_tmp$193285 = -92					; size = 56
$T193613 = -36						; size = 12
tv1111 = -24						; size = 8
tv1103 = -24						; size = 8
tv1120 = -20						; size = 4
tv1113 = -20						; size = 4
tv1105 = -20						; size = 4
__Cat$193214 = -20					; size = 1
$T193460 = -20						; size = 4
$T192832 = -20						; size = 4
$T192828 = -20						; size = 4
$T192824 = -16						; size = 4
tv1116 = -14						; size = 2
tv1108 = -14						; size = 2
$T193644 = -14						; size = 2
__$EHRec$ = -12						; size = 12
?test_alloc@@YAXXZ PROC					; test_alloc, COMDAT

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?test_alloc@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 58	 sub	 esp, 88			; 00000058H
  0001b	53		 push	 ebx

; 753  : 		googledensehash->set_empty_key(-1);

  0001c	33 db		 xor	 ebx, ebx
  0001e	89 5d ec	 mov	 DWORD PTR $T192832[ebp], ebx
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	83 f8 05	 cmp	 eax, 5
  0002b	75 48		 jne	 SHORT $LN18@test_alloc

; 706  : 	COND(DATA_TREE) {
; 707  : 		rbt_new(&tree);

  0002d	b8 04 00 00 00	 mov	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00032	a3 00 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, eax
  00037	a3 04 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+4, eax
  0003c	83 e0 fe	 and	 eax, -2			; fffffffeH
  0003f	a3 08 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+8, eax

; 708  : 		RBTREE = (struct rbt_object*)malloc(sizeof(struct rbt_object) * the_max);

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00049	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00050	2b c8		 sub	 ecx, eax
  00052	03 c9		 add	 ecx, ecx
  00054	03 c9		 add	 ecx, ecx
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _malloc
  0005c	83 c4 04	 add	 esp, 4
  0005f	a3 00 00 00 00	 mov	 DWORD PTR ?RBTREE@@3PAUrbt_object@@A, eax ; RBTREE

; 798  : 	}
; 799  : #endif
; 800  : }

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN18@test_alloc:

; 709  : 	}
; 710  : 
; 711  : 	COND(DATA_HASHTABLE) {

  00075	3b c3		 cmp	 eax, ebx
  00077	75 2e		 jne	 SHORT $LN273@test_alloc

; 712  : 		tommy_hashtable_init(&hashtable, 2 * the_max);

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0007e	03 c0		 add	 eax, eax
  00080	e8 00 00 00 00	 call	 _tommy_hashtable_init

; 713  : 		HASHTABLE = (struct hashtable_object*)malloc(sizeof(struct hashtable_object) * the_max);

  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0008b	8d 14 f6	 lea	 edx, DWORD PTR [esi+esi*8]
  0008e	03 d2		 add	 edx, edx
  00090	03 d2		 add	 edx, edx
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 _malloc
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?HASHTABLE@@3PAUhashtable_object@@A, eax ; HASHTABLE
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  000a2	83 c4 04	 add	 esp, 4
  000a5	eb 06		 jmp	 SHORT $LN17@test_alloc
$LN273@test_alloc:
  000a7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
$LN17@test_alloc:

; 714  : 	}
; 715  : 
; 716  : 	COND(DATA_HASHDYN) {

  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 65		 jne	 SHORT $LN16@test_alloc

; 717  : 		tommy_hashdyn_init(&hashdyn);

  000b2	6a 40		 push	 64			; 00000040H
  000b4	c7 05 04 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4, 4
  000be	c7 05 08 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8, 16 ; 00000010H
  000c8	c7 05 0c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12, 15 ; 0000000fH
  000d2	e8 00 00 00 00	 call	 _malloc
  000d7	83 c4 04	 add	 esp, 4
  000da	6a 40		 push	 64			; 00000040H
  000dc	53		 push	 ebx
  000dd	50		 push	 eax
  000de	a3 00 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A, eax
  000e3	e8 00 00 00 00	 call	 _memset

; 718  : 		HASHDYN = (struct hashtable_object*)malloc(sizeof(struct hashtable_object) * the_max);

  000e8	8d 04 f6	 lea	 eax, DWORD PTR [esi+esi*8]
  000eb	03 c0		 add	 eax, eax
  000ed	03 c0		 add	 eax, eax
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	50		 push	 eax
  000f3	89 1d 10 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, ebx
  000f9	e8 00 00 00 00	 call	 _malloc
  000fe	83 c4 04	 add	 esp, 4
  00101	a3 00 00 00 00	 mov	 DWORD PTR ?HASHDYN@@3PAUhashtable_object@@A, eax ; HASHDYN

; 798  : 	}
; 799  : #endif
; 800  : }

  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
$LN16@test_alloc:

; 719  : 	}
; 720  : 
; 721  : 	COND(DATA_HASHLIN) {

  00117	83 f8 02	 cmp	 eax, 2
  0011a	75 25		 jne	 SHORT $LN15@test_alloc

; 722  : 		tommy_hashlin_init(&hashlin);

  0011c	e8 00 00 00 00	 call	 _tommy_hashlin_init

; 723  : 		HASHLIN = (struct hashtable_object*)malloc(sizeof(struct hashtable_object) * the_max);

  00121	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00127	8d 0c f6	 lea	 ecx, DWORD PTR [esi+esi*8]
  0012a	03 c9		 add	 ecx, ecx
  0012c	03 c9		 add	 ecx, ecx
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 _malloc
  00134	a3 00 00 00 00	 mov	 DWORD PTR ?HASHLIN@@3PAUhashtable_object@@A, eax ; HASHLIN
  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  0013e	83 c4 04	 add	 esp, 4
$LN15@test_alloc:

; 724  : 	}
; 725  : 
; 726  : 	COND(DATA_TRIE) {

  00141	83 f8 03	 cmp	 eax, 3
  00144	75 4c		 jne	 SHORT $LN14@test_alloc

; 727  : 		tommy_allocator_init(&trie_allocator, TOMMY_TRIE_BLOCK_SIZE, TOMMY_TRIE_BLOCK_SIZE);

  00146	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0014b	a3 08 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+8, eax
  00150	a3 0c 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+12, eax
  00155	89 1d 10 00 00
	00		 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+16, ebx
  0015b	89 1d 00 00 00
	00		 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A, ebx
  00161	89 1d 04 00 00
	00		 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4, ebx

; 728  : 		tommy_trie_init(&trie, &trie_allocator);

  00167	e8 00 00 00 00	 call	 _tommy_trie_init

; 729  : 		TRIE = (struct trie_object*)malloc(sizeof(struct trie_object) * the_max);

  0016c	8d 14 f6	 lea	 edx, DWORD PTR [esi+esi*8]
  0016f	03 d2		 add	 edx, edx
  00171	03 d2		 add	 edx, edx
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 _malloc
  00179	83 c4 04	 add	 esp, 4
  0017c	a3 00 00 00 00	 mov	 DWORD PTR ?TRIE@@3PAUtrie_object@@A, eax ; TRIE

; 798  : 	}
; 799  : #endif
; 800  : }

  00181	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00184	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
$LN14@test_alloc:

; 730  : 	}
; 731  : 
; 732  : 	COND(DATA_TRIE_INPLACE) {

  00192	83 f8 04	 cmp	 eax, 4
  00195	75 36		 jne	 SHORT $LN13@test_alloc

; 733  : 		tommy_trie_inplace_init(&trie_inplace);
; 734  : 		TRIE_INPLACE = (struct trie_inplace_object*)malloc(sizeof(struct trie_inplace_object) * the_max);

  00197	6b f6 34	 imul	 esi, 52			; 00000034H
  0019a	33 c0		 xor	 eax, eax
  0019c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a1	bf 00 00 00 00	 mov	 edi, OFFSET ?trie_inplace@@3Utommy_trie_inplace_struct@@A ; trie_inplace
  001a6	f3 ab		 rep stosd
  001a8	56		 push	 esi
  001a9	89 1d 00 01 00
	00		 mov	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256, ebx
  001af	e8 00 00 00 00	 call	 _malloc
  001b4	83 c4 04	 add	 esp, 4
  001b7	a3 00 00 00 00	 mov	 DWORD PTR ?TRIE_INPLACE@@3PAUtrie_inplace_object@@A, eax ; TRIE_INPLACE

; 798  : 	}
; 799  : #endif
; 800  : }

  001bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
$LN13@test_alloc:

; 735  : 	}
; 736  : 
; 737  : 	COND(DATA_KHASH) {

  001cd	83 f8 07	 cmp	 eax, 7
  001d0	75 37		 jne	 SHORT $LN12@test_alloc

; 738  : 		KHASH = (struct khash_object*)malloc(sizeof(struct khash_object) * the_max);

  001d2	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  001d5	03 c0		 add	 eax, eax
  001d7	03 c0		 add	 eax, eax
  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 _malloc
  001df	83 c4 04	 add	 esp, 4

; 739  : 		khash = kh_init(word);

  001e2	6a 1c		 push	 28			; 0000001cH
  001e4	6a 01		 push	 1
  001e6	a3 00 00 00 00	 mov	 DWORD PTR ?KHASH@@3PAUkhash_object@@A, eax ; KHASH
  001eb	e8 00 00 00 00	 call	 _calloc
  001f0	83 c4 08	 add	 esp, 8
  001f3	a3 00 00 00 00	 mov	 DWORD PTR ?khash@@3PAUkh_word_t@@A, eax ; khash

; 798  : 	}
; 799  : #endif
; 800  : }

  001f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
$LN12@test_alloc:

; 740  : 	}
; 741  : 
; 742  : #ifdef USE_CGOOGLEDENSEHASH
; 743  : 	COND(DATA_CGOOGLE) {
; 744  : 		GOOGLE = (struct google_object*)malloc(sizeof(struct google_object) * the_max);
; 745  : 		cgoogledensehash = AllocateHashTable(sizeof(void*), 0);
; 746  : 	}
; 747  : #endif
; 748  : 
; 749  : #ifdef USE_GOOGLEDENSEHASH
; 750  : 	COND(DATA_GOOGLEDENSEHASH) {

  00209	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0020c	0f 85 4e 01 00
	00		 jne	 $LN160@test_alloc

; 751  : 		GOOGLE = (struct google_object*)malloc(sizeof(struct google_object) * the_max);

  00212	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  00215	03 c9		 add	 ecx, ecx
  00217	03 c9		 add	 ecx, ecx
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 _malloc
  0021f	83 c4 04	 add	 esp, 4

; 752  : 		googledensehash = new googledensehash_t;

  00222	6a 38		 push	 56			; 00000038H
  00224	a3 00 00 00 00	 mov	 DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A, eax ; GOOGLE
  00229	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0022e	83 c4 04	 add	 esp, 4
  00231	8b c8		 mov	 ecx, eax
  00233	3b cb		 cmp	 ecx, ebx
  00235	0f 84 94 00 00
	00		 je	 $LN21@test_alloc
  0023b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00243	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00248	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00250	c7 41 28 20 00
	00 00		 mov	 DWORD PTR [ecx+40], 32	; 00000020H
  00257	66 c7 41 11 00
	00		 mov	 WORD PTR [ecx+17], 0
  0025d	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00260	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  00265	89 59 20	 mov	 DWORD PTR [ecx+32], ebx
  00268	89 59 24	 mov	 DWORD PTR [ecx+36], ebx
  0026b	89 59 2c	 mov	 DWORD PTR [ecx+44], ebx
  0026e	89 59 30	 mov	 DWORD PTR [ecx+48], ebx
  00271	db 41 28	 fild	 DWORD PTR [ecx+40]
  00274	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00277	89 59 34	 mov	 DWORD PTR [ecx+52], ebx
  0027a	85 d2		 test	 edx, edx
  0027c	79 06		 jns	 SHORT $LN275@test_alloc
  0027e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN275@test_alloc:
  00284	d9 7d f2	 fnstcw	 WORD PTR tv1116[ebp]
  00287	0f b7 45 f2	 movzx	 eax, WORD PTR tv1116[ebp]
  0028b	d9 c0		 fld	 ST(0)
  0028d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00292	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00295	89 45 ec	 mov	 DWORD PTR tv1113[ebp], eax
  00298	d9 6d ec	 fldcw	 WORD PTR tv1113[ebp]
  0029b	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0
  0029f	8b f1		 mov	 esi, ecx
  002a1	df 7d e8	 fistp	 QWORD PTR tv1111[ebp]
  002a4	8b 45 e8	 mov	 eax, DWORD PTR tv1111[ebp]
  002a7	89 01		 mov	 DWORD PTR [ecx], eax
  002a9	d9 6d f2	 fldcw	 WORD PTR tv1116[ebp]
  002ac	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  002af	d9 7d f2	 fnstcw	 WORD PTR tv1108[ebp]
  002b2	0f b7 45 f2	 movzx	 eax, WORD PTR tv1108[ebp]
  002b6	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002bb	89 45 ec	 mov	 DWORD PTR tv1105[ebp], eax
  002be	d9 6d ec	 fldcw	 WORD PTR tv1105[ebp]
  002c1	df 7d e8	 fistp	 QWORD PTR tv1103[ebp]
  002c4	8b 55 e8	 mov	 edx, DWORD PTR tv1103[ebp]
  002c7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  002ca	d9 6d f2	 fldcw	 WORD PTR tv1108[ebp]
  002cd	eb 02		 jmp	 SHORT $LN22@test_alloc
$LN21@test_alloc:
  002cf	33 f6		 xor	 esi, esi
$LN22@test_alloc:

; 753  : 		googledensehash->set_empty_key(-1);

  002d1	8d 7e 2c	 lea	 edi, DWORD PTR [esi+44]
  002d4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002db	89 35 00 00 00
	00		 mov	 DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A, esi ; googledensehash
  002e1	c6 46 11 01	 mov	 BYTE PTR [esi+17], 1
  002e5	3b fb		 cmp	 edi, ebx
  002e7	74 09		 je	 SHORT $LN142@test_alloc
  002e9	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
  002ef	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN142@test_alloc:
  002f2	8b 5e 28	 mov	 ebx, DWORD PTR [esi+40]
  002f5	8d 04 dd 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*8]
  002fc	50		 push	 eax
  002fd	e8 00 00 00 00	 call	 _malloc
  00302	8b 55 ec	 mov	 edx, DWORD PTR __Cat$193214[ebp]
  00305	83 c4 04	 add	 esp, 4
  00308	52		 push	 edx
  00309	8d 0c d8	 lea	 ecx, DWORD PTR [eax+ebx*8]
  0030c	50		 push	 eax
  0030d	8b d7		 mov	 edx, edi
  0030f	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00312	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  00317	83 c4 08	 add	 esp, 8

; 754  : 		googledensehash->set_deleted_key(-2);

  0031a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0031e	74 28		 je	 SHORT $LN174@test_alloc
  00320	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00325	8b ce		 mov	 ecx, esi
  00327	8d 7d a4	 lea	 edi, DWORD PTR _tmp$193285[ebp]
  0032a	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
  0032f	8b d7		 mov	 edx, edi
  00331	8b ce		 mov	 ecx, esi
  00333	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
  00338	8b 45 d8	 mov	 eax, DWORD PTR _tmp$193285[ebp+52]
  0033b	85 c0		 test	 eax, eax
  0033d	74 09		 je	 SHORT $LN174@test_alloc
  0033f	50		 push	 eax
  00340	e8 00 00 00 00	 call	 _free
  00345	83 c4 04	 add	 esp, 4
$LN174@test_alloc:
  00348	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  0034d	c6 46 12 01	 mov	 BYTE PTR [esi+18], 1
  00351	c7 46 1c fe ff
	ff ff		 mov	 DWORD PTR [esi+28], -2	; fffffffeH
  00358	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0035e	33 db		 xor	 ebx, ebx
$LN160@test_alloc:

; 755  : 	}
; 756  : #endif
; 757  : 
; 758  : #ifdef USE_GOOGLEBTREE
; 759  : 	COND(DATA_GOOGLEBTREE) {

  00360	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00363	75 39		 jne	 SHORT $LN10@test_alloc

; 760  : 		GOOGLE = (struct google_object*)malloc(sizeof(struct google_object) * the_max);

  00365	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00368	03 c0		 add	 eax, eax
  0036a	03 c0		 add	 eax, eax
  0036c	50		 push	 eax
  0036d	e8 00 00 00 00	 call	 _malloc
  00372	83 c4 04	 add	 esp, 4

; 761  : 		googlebtree = new googlebtree_t;

  00375	6a 04		 push	 4
  00377	a3 00 00 00 00	 mov	 DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A, eax ; GOOGLE
  0037c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00381	83 c4 04	 add	 esp, 4
  00384	3b c3		 cmp	 eax, ebx
  00386	74 04		 je	 SHORT $LN23@test_alloc
  00388	89 18		 mov	 DWORD PTR [eax], ebx
  0038a	eb 02		 jmp	 SHORT $LN24@test_alloc
$LN23@test_alloc:
  0038c	33 c0		 xor	 eax, eax
$LN24@test_alloc:
  0038e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00394	a3 00 00 00 00	 mov	 DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A, eax ; googlebtree
  00399	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
$LN10@test_alloc:

; 762  : 	}
; 763  : #endif
; 764  : 
; 765  : #ifdef USE_CPPMAP
; 766  : 	COND(DATA_CPPMAP) {

  0039e	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  003a1	0f 85 9f 00 00
	00		 jne	 $LN9@test_alloc

; 767  : 		CPP = (struct cpp_object*)malloc(sizeof(struct cpp_object) * the_max);

  003a7	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  003aa	03 c9		 add	 ecx, ecx
  003ac	03 c9		 add	 ecx, ecx
  003ae	51		 push	 ecx
  003af	e8 00 00 00 00	 call	 _malloc
  003b4	83 c4 04	 add	 esp, 4

; 768  : 		cppmap = new cppmap_t;

  003b7	6a 10		 push	 16			; 00000010H
  003b9	a3 00 00 00 00	 mov	 DWORD PTR ?CPP@@3PAUcpp_object@@A, eax ; CPP
  003be	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003c3	8b f0		 mov	 esi, eax
  003c5	83 c4 04	 add	 esp, 4
  003c8	89 75 f0	 mov	 DWORD PTR $T192824[ebp], esi
  003cb	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  003d2	3b f3		 cmp	 esi, ebx
  003d4	74 56		 je	 SHORT $LN25@test_alloc
  003d6	6a 18		 push	 24			; 00000018H
  003d8	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  003db	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003e0	83 c4 04	 add	 esp, 4
  003e3	3b c3		 cmp	 eax, ebx
  003e5	74 21		 je	 SHORT $LN228@test_alloc
  003e7	89 46 04	 mov	 DWORD PTR [esi+4], eax
  003ea	89 00		 mov	 DWORD PTR [eax], eax
  003ec	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  003ef	89 40 04	 mov	 DWORD PTR [eax+4], eax
  003f2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  003f5	89 40 08	 mov	 DWORD PTR [eax+8], eax
  003f8	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  003fb	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1
  003ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00402	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1
  00406	eb 26		 jmp	 SHORT $LN26@test_alloc
$LN228@test_alloc:
  00408	8d 4d ec	 lea	 ecx, DWORD PTR $T193460[ebp]
  0040b	51		 push	 ecx
  0040c	8d 4d dc	 lea	 ecx, DWORD PTR $T193613[ebp]
  0040f	89 5d ec	 mov	 DWORD PTR $T193460[ebp], ebx
  00412	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00417	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0041c	8d 55 dc	 lea	 edx, DWORD PTR $T193613[ebp]
  0041f	52		 push	 edx
  00420	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T193613[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00427	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN277@test_alloc:
$LN25@test_alloc:
  0042c	33 f6		 xor	 esi, esi
$LN26@test_alloc:
  0042e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00435	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  0043a	89 35 00 00 00
	00		 mov	 DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A, esi ; cppmap
  00440	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
$LN9@test_alloc:

; 769  : 	}
; 770  : #endif
; 771  : 
; 772  : #ifdef USE_CPPUNORDEREDMAP
; 773  : 	COND(DATA_CPPUNORDEREDMAP) {

  00446	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00449	75 4e		 jne	 SHORT $LN8@test_alloc

; 774  : 		CPP = (struct cpp_object*)malloc(sizeof(struct cpp_object) * the_max);

  0044b	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0044e	03 c0		 add	 eax, eax
  00450	03 c0		 add	 eax, eax
  00452	50		 push	 eax
  00453	e8 00 00 00 00	 call	 _malloc
  00458	83 c4 04	 add	 esp, 4

; 775  : 		cppunorderedmap = new cppunorderedmap_t;

  0045b	6a 2c		 push	 44			; 0000002cH
  0045d	a3 00 00 00 00	 mov	 DWORD PTR ?CPP@@3PAUcpp_object@@A, eax ; CPP
  00462	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00467	8b f0		 mov	 esi, eax
  00469	83 c4 04	 add	 esp, 4
  0046c	89 75 ec	 mov	 DWORD PTR $T192828[ebp], esi
  0046f	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00476	3b f3		 cmp	 esi, ebx
  00478	74 0c		 je	 SHORT $LN27@test_alloc
  0047a	8d 4d f2	 lea	 ecx, DWORD PTR $T193644[ebp]
  0047d	51		 push	 ecx
  0047e	56		 push	 esi
  0047f	e8 00 00 00 00	 call	 ??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
  00484	eb 02		 jmp	 SHORT $LN28@test_alloc
$LN27@test_alloc:
  00486	33 f6		 xor	 esi, esi
$LN28@test_alloc:
  00488	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  0048d	89 35 00 00 00
	00		 mov	 DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A, esi ; cppunorderedmap
  00493	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
$LN8@test_alloc:

; 776  : 	}
; 777  : #endif
; 778  : 
; 779  : 	COND(DATA_UTHASH) {

  00499	83 f8 08	 cmp	 eax, 8
  0049c	75 22		 jne	 SHORT $LN7@test_alloc

; 780  : 		UTHASH = (struct uthash_object*)malloc(sizeof(struct uthash_object) * the_max);

  0049e	6b f6 34	 imul	 esi, 52			; 00000034H
  004a1	56		 push	 esi
  004a2	e8 00 00 00 00	 call	 _malloc
  004a7	83 c4 04	 add	 esp, 4
  004aa	a3 00 00 00 00	 mov	 DWORD PTR ?UTHASH@@3PAUuthash_object@@A, eax ; UTHASH

; 798  : 	}
; 799  : #endif
; 800  : }

  004af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004b9	5f		 pop	 edi
  004ba	5e		 pop	 esi
  004bb	5b		 pop	 ebx
  004bc	8b e5		 mov	 esp, ebp
  004be	5d		 pop	 ebp
  004bf	c3		 ret	 0
$LN7@test_alloc:

; 781  : 	}
; 782  : 
; 783  : 	COND(DATA_NEDTRIE) {

  004c0	83 f8 06	 cmp	 eax, 6
  004c3	75 3b		 jne	 SHORT $LN6@test_alloc

; 784  : 		NEDTRIE_INIT(&nedtrie);

  004c5	68 88 00 00 00	 push	 136			; 00000088H
  004ca	53		 push	 ebx
  004cb	68 00 00 00 00	 push	 OFFSET ?nedtrie@@3Unedtrie_t@@A ; nedtrie
  004d0	e8 00 00 00 00	 call	 _memset

; 785  : 		NEDTRIE = (struct nedtrie_object*)malloc(sizeof(struct nedtrie_object) * the_max);

  004d5	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  004d8	03 d2		 add	 edx, edx
  004da	03 d2		 add	 edx, edx
  004dc	03 d2		 add	 edx, edx
  004de	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e1	52		 push	 edx
  004e2	e8 00 00 00 00	 call	 _malloc
  004e7	83 c4 04	 add	 esp, 4
  004ea	a3 00 00 00 00	 mov	 DWORD PTR ?NEDTRIE@@3PAUnedtrie_object@@A, eax ; NEDTRIE

; 798  : 	}
; 799  : #endif
; 800  : }

  004ef	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004f9	5f		 pop	 edi
  004fa	5e		 pop	 esi
  004fb	5b		 pop	 ebx
  004fc	8b e5		 mov	 esp, ebp
  004fe	5d		 pop	 ebp
  004ff	c3		 ret	 0
$LN6@test_alloc:

; 786  : 	}
; 787  : 
; 788  : #ifdef USE_JUDY
; 789  : 	COND(DATA_JUDY) {

  00500	83 f8 09	 cmp	 eax, 9
  00503	75 26		 jne	 SHORT $LN2@test_alloc

; 790  : 		JUDY = (struct judy_object*)malloc(sizeof(struct judy_object) * the_max);

  00505	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00508	03 c0		 add	 eax, eax
  0050a	03 c0		 add	 eax, eax
  0050c	50		 push	 eax
  0050d	e8 00 00 00 00	 call	 _malloc
  00512	83 c4 04	 add	 esp, 4
  00515	a3 00 00 00 00	 mov	 DWORD PTR ?JUDY@@3PAUjudy_object@@A, eax ; JUDY

; 798  : 	}
; 799  : #endif
; 800  : }

  0051a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0051d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00524	5f		 pop	 edi
  00525	5e		 pop	 esi
  00526	5b		 pop	 ebx
  00527	8b e5		 mov	 esp, ebp
  00529	5d		 pop	 ebp
  0052a	c3		 ret	 0
$LN2@test_alloc:

; 791  : 	}
; 792  : #endif
; 793  : 
; 794  : #ifdef USE_JUDYARRAY
; 795  : 	COND(DATA_JUDYARRAY) {

  0052b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0052e	75 1f		 jne	 SHORT $LN1@test_alloc

; 796  : 		JUDYARRAY = (struct judyarray_object*)malloc(sizeof(struct judyarray_object) * the_max);

  00530	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  00533	03 c9		 add	 ecx, ecx
  00535	03 c9		 add	 ecx, ecx
  00537	51		 push	 ecx
  00538	e8 00 00 00 00	 call	 _malloc
  0053d	83 c4 04	 add	 esp, 4
  00540	a3 00 00 00 00	 mov	 DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A, eax ; JUDYARRAY

; 797  : 		judyarray = (Judy*)judy_open(1024, 1);

  00545	e8 00 00 00 00	 call	 ?judy_open@@YAPAXII@Z	; judy_open
  0054a	a3 00 00 00 00	 mov	 DWORD PTR ?judyarray@@3PAUJudy@@A, eax ; judyarray
$LN1@test_alloc:

; 798  : 	}
; 799  : #endif
; 800  : }

  0054f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00552	5f		 pop	 edi
  00553	5e		 pop	 esi
  00554	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0055b	5b		 pop	 ebx
  0055c	8b e5		 mov	 esp, ebp
  0055e	5d		 pop	 ebp
  0055f	c3		 ret	 0
$LN276@test_alloc:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?test_alloc@@YAXXZ$0:
  00000	8b 45 a0	 mov	 eax, DWORD PTR $T192809[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__unwindfunclet$?test_alloc@@YAXXZ$2:
  0000b	8b 45 f0	 mov	 eax, DWORD PTR $T192824[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
__unwindfunclet$?test_alloc@@YAXXZ$3:
  00016	8b 45 ec	 mov	 eax, DWORD PTR $T192828[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	59		 pop	 ecx
  00020	c3		 ret	 0
__ehhandler$?test_alloc@@YAXXZ:
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?test_alloc@@YAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?test_alloc@@YAXXZ ENDP					; test_alloc
PUBLIC	?judy_cell@@YAPAIPAUJudy@@PAEI@Z		; judy_cell
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_cell@@YAPAIPAUJudy@@PAEI@Z
_TEXT	SEGMENT
tv1122 = -40						; size = 4
tv664 = -40						; size = 4
_table$ = -40						; size = 4
_start$ = -40						; size = 4
_size$ = -36						; size = 4
_test$ = -32						; size = 4
tv1087 = -28						; size = 4
tv697 = -28						; size = 4
tv756 = -24						; size = 4
tv666 = -24						; size = 4
_tst$ = -20						; size = 4
_slot$ = -20						; size = 4
_value$ = -16						; size = 4
_node$ = -12						; size = 4
_depth$ = -8						; size = 4
_next$ = -4						; size = 4
_buff$ = 8						; size = 4
?judy_cell@@YAPAIPAUJudy@@PAEI@Z PROC			; judy_cell, COMDAT

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray

; 1298 : judyvalue *src = (judyvalue *)buff;
; 1299 : int size, idx, slot, cnt, tst;
; 1300 : JudySlot *next = judy->root;
; 1301 : judyvalue test, value;
; 1302 : uint off = 0, start;

  0000e	33 db		 xor	 ebx, ebx

; 1303 : JudySlot *table;
; 1304 : JudySlot *node;
; 1305 : uint depth = 0;
; 1306 : uint keysize;
; 1307 : uchar *base;
; 1308 : 
; 1309 : 	judy->level = 0;

  00010	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  00013	57		 push	 edi
  00014	89 75 fc	 mov	 DWORD PTR _next$[ebp], esi
  00017	89 5d f8	 mov	 DWORD PTR _depth$[ebp], ebx

; 1310 : #ifdef ASKITIS
; 1311 : 	Words++;
; 1312 : #endif
; 1313 : 
; 1314 : 	while( *next ) {

  0001a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0001c	0f 84 f4 02 00
	00		 je	 $LN65@judy_cell
$LL66@judy_cell:

; 1315 : #ifndef ASKITIS
; 1316 : 		if( judy->level < judy->max )

  00022	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00025	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  00028	73 04		 jae	 SHORT $LN64@judy_cell

; 1317 : 			judy->level++;

  0002a	40		 inc	 eax
  0002b	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN64@judy_cell:

; 1318 : 
; 1319 : 		judy->stack[judy->level].next = *next;

  0002e	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00039	89 54 86 34	 mov	 DWORD PTR [esi+eax*4+52], edx

; 1320 : 		judy->stack[judy->level].off = off;

  0003d	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00040	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00043	89 5c 86 38	 mov	 DWORD PTR [esi+eax*4+56], ebx

; 1321 : #endif
; 1322 : 		switch( *next & 0x07 ) {

  00047	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00049	8b c1		 mov	 eax, ecx
  0004b	83 e0 07	 and	 eax, 7
  0004e	0f 84 1d 02 00
	00		 je	 $LN35@judy_cell
  00054	83 f8 07	 cmp	 eax, 7
  00057	0f 84 9b 01 00
	00		 je	 $LN24@judy_cell

; 1323 : 		default:
; 1324 : 			size = JudySize[*next & 0x07];

  0005d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[eax*4]

; 1325 : 			keysize = JUDY_key_size - (off & JUDY_key_mask);
; 1326 : 			cnt = size / (sizeof(JudySlot) + keysize);
; 1327 : 			base = (uchar *)(*next & JUDY_mask);

  00064	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00067	8b d3		 mov	 edx, ebx
  00069	83 e2 03	 and	 edx, 3
  0006c	89 4d e8	 mov	 DWORD PTR tv666[ebp], ecx

; 1328 : 			node = (JudySlot *)((*next & JUDY_mask) + size);

  0006f	03 c8		 add	 ecx, eax
  00071	bf 04 00 00 00	 mov	 edi, 4
  00076	2b fa		 sub	 edi, edx
  00078	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx
  0007b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0007e	33 d2		 xor	 edx, edx
  00080	89 45 dc	 mov	 DWORD PTR _size$[ebp], eax
  00083	f7 f1		 div	 ecx

; 1329 : 			start = off;
; 1330 : 			slot = cnt;
; 1331 : 			value = 0;

  00085	33 c9		 xor	 ecx, ecx
  00087	89 5d d8	 mov	 DWORD PTR _start$[ebp], ebx

; 1332 : 
; 1333 : 			if( judy->depth ) {

  0008a	39 4e 30	 cmp	 DWORD PTR [esi+48], ecx
  0008d	74 21		 je	 SHORT $LL58@judy_cell

; 1334 : 				value = src[depth++];

  0008f	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
  00095	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]

; 1335 : 				off |= JUDY_key_mask;

  00098	83 cb 03	 or	 ebx, 3
  0009b	42		 inc	 edx

; 1336 : 				off++;

  0009c	43		 inc	 ebx

; 1337 : 				value &= JudyMask[keysize];

  0009d	23 0c bd 00 00
	00 00		 and	 ecx, DWORD PTR ?JudyMask@@3PAIA[edi*4]
  000a4	89 55 f8	 mov	 DWORD PTR _depth$[ebp], edx

; 1338 : 			} else

  000a7	eb 10		 jmp	 SHORT $LN126@judy_cell
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL58@judy_cell:

; 1341 : 				if( off < max )
; 1342 : 					value |= buff[off];
; 1343 : 			  } while( ++off & JUDY_key_mask );

  000b0	43		 inc	 ebx
  000b1	c1 e1 08	 shl	 ecx, 8
  000b4	f6 c3 03	 test	 bl, 3
  000b7	75 f7		 jne	 SHORT $LL58@judy_cell
$LN126@judy_cell:

; 1339 : 			  do {
; 1340 : 				value <<= 8;

  000b9	89 4d f0	 mov	 DWORD PTR _value$[ebp], ecx

; 1344 : 
; 1345 : 			//  find slot > key
; 1346 : 
; 1347 : 			while( slot-- ) {

  000bc	85 c0		 test	 eax, eax
  000be	74 31		 je	 SHORT $LN113@judy_cell
  000c0	8b d0		 mov	 edx, eax
  000c2	0f af d7	 imul	 edx, edi
  000c5	8b cf		 mov	 ecx, edi
  000c7	f7 d9		 neg	 ecx
  000c9	03 55 e8	 add	 edx, DWORD PTR tv666[ebp]
  000cc	89 4d e4	 mov	 DWORD PTR tv1087[ebp], ecx
  000cf	eb 03		 jmp	 SHORT $LN54@judy_cell
$LL118@judy_cell:
  000d1	8b 4d e4	 mov	 ecx, DWORD PTR tv1087[ebp]
$LN54@judy_cell:
  000d4	03 d1		 add	 edx, ecx

; 1348 : 				test = *(judyvalue *)(base + slot * keysize);
; 1349 : #if BYTE_ORDER == BIG_ENDIAN
; 1350 : 				test >>= 8 * (JUDY_key_size - keysize); 
; 1351 : #else
; 1352 : 				test &= JudyMask[keysize];

  000d6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000d8	23 0c bd 00 00
	00 00		 and	 ecx, DWORD PTR ?JudyMask@@3PAIA[edi*4]
  000df	48		 dec	 eax
  000e0	89 45 ec	 mov	 DWORD PTR _slot$[ebp], eax
  000e3	89 4d e0	 mov	 DWORD PTR _test$[ebp], ecx

; 1353 : #endif
; 1354 : 				if( test <= value )

  000e6	3b 4d f0	 cmp	 ecx, DWORD PTR _value$[ebp]
  000e9	76 0d		 jbe	 SHORT $LN53@judy_cell

; 1344 : 
; 1345 : 			//  find slot > key
; 1346 : 
; 1347 : 			while( slot-- ) {

  000eb	85 c0		 test	 eax, eax
  000ed	75 e2		 jne	 SHORT $LL118@judy_cell
  000ef	eb 03		 jmp	 SHORT $LN119@judy_cell
$LN113@judy_cell:
  000f1	8b 4d e0	 mov	 ecx, DWORD PTR _test$[ebp]
$LN119@judy_cell:
  000f4	48		 dec	 eax
  000f5	89 45 ec	 mov	 DWORD PTR _slot$[ebp], eax
$LN53@judy_cell:

; 1355 : 					break;
; 1356 : 			}
; 1357 : #ifndef ASKITIS
; 1358 : 			judy->stack[judy->level].slot = slot;

  000f8	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000fb	8d 54 52 0f	 lea	 edx, DWORD PTR [edx+edx*2+15]
  000ff	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 1359 : #endif
; 1360 : 			if( test == value ) {		// new key is equal to slot key

  00102	3b 4d f0	 cmp	 ecx, DWORD PTR _value$[ebp]
  00105	75 35		 jne	 SHORT $LN51@judy_cell

; 1361 : 				next = &node[-slot-1];

  00107	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  0010e	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00111	2b c1		 sub	 eax, ecx
$LN138@judy_cell:
  00113	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 1362 : 
; 1363 : 				// is this a leaf?
; 1364 : 
; 1365 : 				if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth ) {

  00116	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00119	85 c0		 test	 eax, eax
  0011b	75 11		 jne	 SHORT $LN128@judy_cell
  0011d	38 45 f0	 cmp	 BYTE PTR _value$[ebp], al
  00120	0f 84 0e 04 00
	00		 je	 $LN2@judy_cell
  00126	85 c0		 test	 eax, eax
  00128	0f 84 dc 01 00
	00		 je	 $LN27@judy_cell
$LN128@judy_cell:
  0012e	39 45 f8	 cmp	 DWORD PTR _depth$[ebp], eax
  00131	0f 84 fd 03 00
	00		 je	 $LN2@judy_cell

; 1366 : #ifdef ASKITIS
; 1367 : 				  if( *next )
; 1368 : 					Found++;
; 1369 : 				  else
; 1370 : 					Inserts++;
; 1371 : #endif
; 1372 : 				  return next;
; 1373 : 				}
; 1374 : 
; 1375 : 				continue;

  00137	e9 ce 01 00 00	 jmp	 $LN27@judy_cell
$LN51@judy_cell:

; 1376 : 			}
; 1377 : 
; 1378 : 			//	if this node is not full
; 1379 : 			//	open up cell after slot
; 1380 : 
; 1381 : 			if( !node[-1] ) {

  0013c	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0013f	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  00143	75 60		 jne	 SHORT $LN47@judy_cell

; 1382 : 		 	  memmove(base, base + keysize, slot * keysize);	// move keys less than new key down one slot

  00145	8b 45 ec	 mov	 eax, DWORD PTR _slot$[ebp]
  00148	0f af c7	 imul	 eax, edi
  0014b	50		 push	 eax
  0014c	89 45 e4	 mov	 DWORD PTR tv697[ebp], eax
  0014f	8b 45 e8	 mov	 eax, DWORD PTR tv666[ebp]
  00152	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00155	52		 push	 edx
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _memmove

; 1383 : #if BYTE_ORDER != BIG_ENDIAN
; 1384 : 			  memcpy(base + slot * keysize, &value, keysize);	// copy new key into slot

  0015c	8b 4d e4	 mov	 ecx, DWORD PTR tv697[ebp]
  0015f	03 4d e8	 add	 ecx, DWORD PTR tv666[ebp]
  00162	57		 push	 edi
  00163	8d 45 f0	 lea	 eax, DWORD PTR _value$[ebp]
  00166	50		 push	 eax
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 _memcpy
  0016d	83 c4 18	 add	 esp, 24			; 00000018H

; 1385 : #else
; 1386 : 			  test = value;
; 1387 : 			  idx = keysize;
; 1388 : 
; 1389 : 			  while( idx-- )
; 1390 : 				  base[slot * keysize + idx] = test, test >>= 8;
; 1391 : #endif
; 1392 : 			  for( idx = 0; idx < slot; idx++ )

  00170	83 7d ec 00	 cmp	 DWORD PTR _slot$[ebp], 0
  00174	7e 15		 jle	 SHORT $LN114@judy_cell

; 1382 : 		 	  memmove(base, base + keysize, slot * keysize);	// move keys less than new key down one slot

  00176	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00179	8b 4d ec	 mov	 ecx, DWORD PTR _slot$[ebp]
  0017c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0017f	90		 npad	 1
$LL46@judy_cell:

; 1393 : 				node[-idx-1] = node[-idx-2];// copy tree ptrs/cells down one slot

  00180	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00183	89 10		 mov	 DWORD PTR [eax], edx
  00185	83 c0 fc	 add	 eax, -4			; fffffffcH
  00188	49		 dec	 ecx
  00189	75 f5		 jne	 SHORT $LL46@judy_cell
$LN114@judy_cell:

; 1394 : 
; 1395 : 			  node[-slot-1] = 0;			// set new tree ptr/cell

  0018b	8b 45 ec	 mov	 eax, DWORD PTR _slot$[ebp]
  0018e	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  00195	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00198	2b c1		 sub	 eax, ecx
  0019a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1396 : 			  next = &node[-slot-1];
; 1397 : 
; 1398 : 			  if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth ) {
; 1399 : #ifdef ASKITIS
; 1400 : 				  if( *next )
; 1401 : 					Found++;
; 1402 : 				  else
; 1403 : 					Inserts++;
; 1404 : #endif
; 1405 : 			  	return next;
; 1406 : 			  }
; 1407 : 
; 1408 : 			  continue;

  001a0	e9 6e ff ff ff	 jmp	 $LN138@judy_cell
$LN47@judy_cell:

; 1409 : 			}
; 1410 : 
; 1411 : 			if( size < JudySize[JUDY_max] ) {

  001a5	8b 45 dc	 mov	 eax, DWORD PTR _size$[ebp]
  001a8	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?JudySize@@3PAHA+24
  001ae	7d 1d		 jge	 SHORT $LN40@judy_cell

; 1412 : 			  next = judy_promote (judy, next, slot+1, value, keysize);

  001b0	8b 55 f0	 mov	 edx, DWORD PTR _value$[ebp]
  001b3	8b 45 ec	 mov	 eax, DWORD PTR _slot$[ebp]
  001b6	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  001b9	52		 push	 edx
  001ba	40		 inc	 eax
  001bb	50		 push	 eax
  001bc	51		 push	 ecx
  001bd	56		 push	 esi
  001be	8b c7		 mov	 eax, edi
  001c0	e8 00 00 00 00	 call	 ?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z ; judy_promote
  001c5	83 c4 10	 add	 esp, 16			; 00000010H

; 1413 : 
; 1414 : 			  if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth ) {
; 1415 : #ifdef ASKITIS
; 1416 : 				if( *next )
; 1417 : 					Found++;
; 1418 : 				else
; 1419 : 					Inserts++;
; 1420 : #endif
; 1421 : 				return next;
; 1422 : 			  }
; 1423 : 
; 1424 : 			  continue;

  001c8	e9 46 ff ff ff	 jmp	 $LN138@judy_cell
$LN40@judy_cell:

; 1425 : 			}
; 1426 : 
; 1427 : 			//	split full maximal node into JUDY_radix nodes
; 1428 : 			//  loop to reprocess new insert
; 1429 : 
; 1430 : 			judy_splitnode (judy, next, size, keysize, depth);

  001cd	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  001d0	52		 push	 edx
  001d1	57		 push	 edi
  001d2	50		 push	 eax
  001d3	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  001d6	50		 push	 eax
  001d7	56		 push	 esi
  001d8	e8 00 00 00 00	 call	 ?judy_splitnode@@YAXPAUJudy@@PAIIII@Z ; judy_splitnode

; 1431 : #ifndef ASKITIS
; 1432 : 			judy->level--;

  001dd	ff 4e 28	 dec	 DWORD PTR [esi+40]

; 1433 : #endif
; 1434 : 			off = start;

  001e0	8b 5d d8	 mov	 ebx, DWORD PTR _start$[ebp]
  001e3	83 c4 14	 add	 esp, 20			; 00000014H

; 1435 : 			if( judy->depth )

  001e6	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  001ea	0f 84 1a 01 00
	00		 je	 $LN27@judy_cell

; 1436 : 				depth--;

  001f0	ff 4d f8	 dec	 DWORD PTR _depth$[ebp]

; 1437 : 			continue;

  001f3	e9 12 01 00 00	 jmp	 $LN27@judy_cell
$LN24@judy_cell:

; 1465 : #ifdef ASKITIS
; 1466 : 				if( *next )
; 1467 : 					Found++;
; 1468 : 				else
; 1469 : 					Inserts++;
; 1470 : #endif
; 1471 : 				return next;
; 1472 : 			}
; 1473 : 
; 1474 : 			continue;
; 1475 : 
; 1476 : #ifndef ASKITIS
; 1477 : 		case JUDY_span:
; 1478 : 			base = (uchar *)(*next & JUDY_mask);

  001f8	8b f9		 mov	 edi, ecx

; 1479 : 			node = (JudySlot *)((*next & JUDY_mask) + JudySize[JUDY_span]);

  001fa	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?JudySize@@3PAHA+28
  00200	83 e7 f8	 and	 edi, -8			; fffffff8H

; 1480 : 			cnt = JUDY_span_bytes;
; 1481 : 			tst = cnt;
; 1482 : 
; 1483 : 			if( tst > (int)(max - off) )

  00203	8b c3		 mov	 eax, ebx
  00205	f7 d8		 neg	 eax
  00207	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  0020a	89 55 f4	 mov	 DWORD PTR _node$[ebp], edx
  0020d	c7 45 ec 1c 00
	00 00		 mov	 DWORD PTR _tst$[ebp], 28 ; 0000001cH
  00214	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  00217	7d 03		 jge	 SHORT $LN23@judy_cell

; 1484 : 				tst = max - off;

  00219	89 45 ec	 mov	 DWORD PTR _tst$[ebp], eax
$LN23@judy_cell:

; 1485 : 
; 1486 : 			value = strncmp((const char *)base, (const char *)(buff + off), tst);

  0021c	8b 45 ec	 mov	 eax, DWORD PTR _tst$[ebp]
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
  00222	50		 push	 eax
  00223	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  00226	52		 push	 edx
  00227	57		 push	 edi
  00228	e8 00 00 00 00	 call	 _strncmp
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1487 : 
; 1488 : 			if( !value && tst < cnt && !base[tst] ) // leaf?

  00230	85 c0		 test	 eax, eax
  00232	75 28		 jne	 SHORT $LN21@judy_cell
  00234	8b 45 ec	 mov	 eax, DWORD PTR _tst$[ebp]
  00237	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  0023a	7d 0d		 jge	 SHORT $LN133@judy_cell
  0023c	80 3c 38 00	 cmp	 BYTE PTR [eax+edi], 0
  00240	0f 84 39 01 00
	00		 je	 $LN83@judy_cell

; 1490 : 
; 1491 : 			if( !value && tst == cnt ) {

  00246	83 f8 1c	 cmp	 eax, 28			; 0000001cH
$LN133@judy_cell:
  00249	75 11		 jne	 SHORT $LN21@judy_cell

; 1492 : 				next = &node[-1];

  0024b	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0024e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00251	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 1493 : 				off += cnt;

  00254	83 c3 1c	 add	 ebx, 28			; 0000001cH

; 1494 : 				continue;

  00257	e9 ae 00 00 00	 jmp	 $LN27@judy_cell
$LN21@judy_cell:

; 1495 : 			}
; 1496 : 
; 1497 : 			//	bust up JUDY_span node and produce JUDY_1 nodes
; 1498 : 			//	then loop to reprocess insert
; 1499 : 
; 1500 : 			judy_splitspan (judy, next, base);

  0025c	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0025f	57		 push	 edi
  00260	56		 push	 esi
  00261	e8 00 00 00 00	 call	 ?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z ; judy_splitspan
  00266	83 c4 08	 add	 esp, 8

; 1501 : 			judy->level--;

  00269	ff 4e 28	 dec	 DWORD PTR [esi+40]

; 1502 : 			continue;

  0026c	e9 99 00 00 00	 jmp	 $LN27@judy_cell
$LN35@judy_cell:

; 1438 : 		
; 1439 : 		case JUDY_radix:
; 1440 : 			table = (JudySlot *)(*next & JUDY_mask); // outer radix
; 1441 : 
; 1442 : 			if( judy->depth )

  00271	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00274	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00277	89 4d d8	 mov	 DWORD PTR _table$[ebp], ecx
  0027a	85 c0		 test	 eax, eax
  0027c	74 21		 je	 SHORT $LN32@judy_cell

; 1443 : 				slot = (src[depth] >> ((JUDY_key_size - ++off & JUDY_key_mask) * 8)) & 0xff;

  0027e	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  00281	8b 7d f8	 mov	 edi, DWORD PTR _depth$[ebp]
  00284	8b 3c ba	 mov	 edi, DWORD PTR [edx+edi*4]
  00287	43		 inc	 ebx
  00288	8b cb		 mov	 ecx, ebx
  0028a	f7 d9		 neg	 ecx
  0028c	83 e1 03	 and	 ecx, 3
  0028f	03 c9		 add	 ecx, ecx
  00291	03 c9		 add	 ecx, ecx
  00293	03 c9		 add	 ecx, ecx
  00295	d3 ef		 shr	 edi, cl
  00297	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  0029d	eb 03		 jmp	 SHORT $LN31@judy_cell
$LN32@judy_cell:

; 1444 : 			else if( off < max )
; 1445 : 				slot = buff[off++];
; 1446 : 			else
; 1447 : 				slot = 0, off++;

  0029f	33 ff		 xor	 edi, edi
  002a1	43		 inc	 ebx
$LN31@judy_cell:

; 1448 : 
; 1449 : 			if( judy->depth )

  002a2	85 c0		 test	 eax, eax
  002a4	74 08		 je	 SHORT $LN29@judy_cell

; 1450 : 				if( !(off & JUDY_key_mask) )

  002a6	f6 c3 03	 test	 bl, 3
  002a9	75 03		 jne	 SHORT $LN29@judy_cell

; 1451 : 					depth++;

  002ab	ff 45 f8	 inc	 DWORD PTR _depth$[ebp]
$LN29@judy_cell:

; 1452 : 
; 1453 : 			// allocate inner radix if empty
; 1454 : 
; 1455 : 			if( !table[slot >> 4] )

  002ae	8b 4d d8	 mov	 ecx, DWORD PTR _table$[ebp]
  002b1	8b c7		 mov	 eax, edi
  002b3	c1 f8 04	 sar	 eax, 4
  002b6	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  002ba	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  002bd	89 45 e8	 mov	 DWORD PTR tv756[ebp], eax
  002c0	75 12		 jne	 SHORT $LN28@judy_cell

; 1456 : 				table[slot >> 4] = (JudySlot)judy_alloc (judy, JUDY_radix) | JUDY_radix;

  002c2	56		 push	 esi
  002c3	33 c9		 xor	 ecx, ecx
  002c5	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc
  002ca	8b 55 e8	 mov	 edx, DWORD PTR tv756[ebp]
  002cd	89 02		 mov	 DWORD PTR [edx], eax
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b c2		 mov	 eax, edx
$LN28@judy_cell:

; 1457 : 
; 1458 : 			table = (JudySlot *)(table[slot >> 4] & JUDY_mask);

  002d4	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1459 : #ifndef ASKITIS
; 1460 : 			judy->stack[judy->level].slot = slot;

  002d6	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  002d9	83 e1 f8	 and	 ecx, -8			; fffffff8H
  002dc	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]

; 1461 : #endif
; 1462 : 			next = &table[slot & 0x0F];

  002e0	8b d7		 mov	 edx, edi
  002e2	83 e2 0f	 and	 edx, 15			; 0000000fH
  002e5	89 3c 86	 mov	 DWORD PTR [esi+eax*4], edi
  002e8	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 1463 : 
; 1464 : 			if( !judy->depth && !slot || judy->depth && depth == judy->depth ) { // leaf?

  002eb	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  002ee	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 0c		 jne	 SHORT $LN135@judy_cell
  002f5	85 ff		 test	 edi, edi
  002f7	0f 84 3a 02 00
	00		 je	 $LN67@judy_cell
  002fd	85 c9		 test	 ecx, ecx
  002ff	74 09		 je	 SHORT $LN27@judy_cell
$LN135@judy_cell:
  00301	39 4d f8	 cmp	 DWORD PTR _depth$[ebp], ecx
  00304	0f 84 2d 02 00
	00		 je	 $LN67@judy_cell
$LN27@judy_cell:

; 1310 : #ifdef ASKITIS
; 1311 : 	Words++;
; 1312 : #endif
; 1313 : 
; 1314 : 	while( *next ) {

  0030a	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0030d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00310	0f 85 0c fd ff
	ff		 jne	 $LL66@judy_cell
$LN65@judy_cell:

; 1503 : #endif
; 1504 : 		}
; 1505 : 	}
; 1506 : 
; 1507 : 	// place JUDY_1 node under JUDY_radix node(s)
; 1508 : 
; 1509 : #ifndef ASKITIS
; 1510 : 	if( off & JUDY_key_mask )

  00316	8b c3		 mov	 eax, ebx
  00318	83 e0 03	 and	 eax, 3
  0031b	89 45 d8	 mov	 DWORD PTR tv664[ebp], eax
  0031e	0f 84 d2 00 00
	00		 je	 $LN19@judy_cell

; 1511 : 	 if( judy->depth || off <= max ) {

  00324	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  00328	75 08		 jne	 SHORT $LN18@judy_cell
  0032a	85 db		 test	 ebx, ebx
  0032c	0f 85 c4 00 00
	00		 jne	 $LN19@judy_cell
$LN18@judy_cell:

; 1512 : #else
; 1513 : 	  while( off <= max ) {
; 1514 : #endif
; 1515 : 		base = (uchar*)judy_alloc (judy, JUDY_1);

  00332	56		 push	 esi
  00333	b9 01 00 00 00	 mov	 ecx, 1
  00338	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1516 : 		keysize = JUDY_key_size - (off & JUDY_key_mask);
; 1517 : 		node = (JudySlot  *)(base + JudySize[JUDY_1]);

  0033d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?JudySize@@3PAHA+4
  00343	8b f8		 mov	 edi, eax
  00345	03 d7		 add	 edx, edi
  00347	89 55 f4	 mov	 DWORD PTR _node$[ebp], edx

; 1518 : 		*next = (JudySlot)base | JUDY_1;

  0034a	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0034d	83 c8 01	 or	 eax, 1
  00350	b9 04 00 00 00	 mov	 ecx, 4
  00355	2b 4d d8	 sub	 ecx, DWORD PTR tv664[ebp]
  00358	83 c4 04	 add	 esp, 4
  0035b	89 02		 mov	 DWORD PTR [edx], eax

; 1519 : 
; 1520 : 		//	fill in slot 0 with bytes of key
; 1521 : 
; 1522 : 		if( judy->depth ) {

  0035d	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  00361	74 29		 je	 SHORT $LN79@judy_cell

; 1523 : 			value = src[depth];

  00363	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  00366	8b 45 08	 mov	 eax, DWORD PTR _buff$[ebp]
  00369	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 1524 : #if BYTE_ORDER != BIG_ENDIAN
; 1525 : 			  memcpy(base, &value, keysize);	// copy new key into slot

  0036c	51		 push	 ecx
  0036d	8d 4d f0	 lea	 ecx, DWORD PTR _value$[ebp]
  00370	51		 push	 ecx
  00371	57		 push	 edi
  00372	89 45 f0	 mov	 DWORD PTR _value$[ebp], eax
  00375	e8 00 00 00 00	 call	 _memcpy
  0037a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1526 : #else
; 1527 : 			  while( keysize-- )
; 1528 : 				  base[keysize] = value, value >>= 8;
; 1529 : #endif
; 1530 : 		} else {

  0037d	eb 34		 jmp	 SHORT $LN117@judy_cell
$LN83@judy_cell:

; 1489 : 				return &node[-1];

  0037f	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00382	5f		 pop	 edi
  00383	5e		 pop	 esi
  00384	83 c0 fc	 add	 eax, -4			; fffffffcH
  00387	5b		 pop	 ebx

; 1612 : }

  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
$LN79@judy_cell:

; 1531 : #if BYTE_ORDER != BIG_ENDIAN
; 1532 : 		  while( keysize )

  0038c	85 c9		 test	 ecx, ecx
  0038e	74 23		 je	 SHORT $LN117@judy_cell
  00390	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  00393	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
$LL15@judy_cell:

; 1533 : 			if( off + keysize <= max )
; 1534 : 				*base++ = buff[off + --keysize];

  00396	49		 dec	 ecx
  00397	85 c0		 test	 eax, eax
  00399	75 12		 jne	 SHORT $LN13@judy_cell
  0039b	48		 dec	 eax
  0039c	89 45 d8	 mov	 DWORD PTR tv1122[ebp], eax
  0039f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  003a2	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  003a5	88 07		 mov	 BYTE PTR [edi], al

; 1535 : 			else

  003a7	8b 45 d8	 mov	 eax, DWORD PTR tv1122[ebp]
  003aa	47		 inc	 edi
  003ab	eb 02		 jmp	 SHORT $LN12@judy_cell
$LN13@judy_cell:

; 1536 : 				base++, --keysize;

  003ad	47		 inc	 edi
  003ae	48		 dec	 eax
$LN12@judy_cell:

; 1531 : #if BYTE_ORDER != BIG_ENDIAN
; 1532 : 		  while( keysize )

  003af	85 c9		 test	 ecx, ecx
  003b1	75 e3		 jne	 SHORT $LL15@judy_cell
$LN117@judy_cell:

; 1537 : #else
; 1538 : 		  tst = keysize;
; 1539 : 
; 1540 : 		  if( tst > (int)(max - off) )
; 1541 : 			tst = max - off;
; 1542 : 
; 1543 : 		  memcpy (base, buff + off, tst);
; 1544 : #endif
; 1545 : 		}
; 1546 : #ifndef ASKITIS
; 1547 : 		if( judy->level < judy->max )

  003b3	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003b6	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  003b9	73 04		 jae	 SHORT $LN11@judy_cell

; 1548 : 			judy->level++;

  003bb	40		 inc	 eax
  003bc	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN11@judy_cell:

; 1549 : 		judy->stack[judy->level].next = *next;

  003bf	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003c2	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]

; 1550 : 		judy->stack[judy->level].slot = 0;
; 1551 : 		judy->stack[judy->level].off = off;
; 1552 : #endif
; 1553 : 		next = &node[-1];
; 1554 : 
; 1555 : 		off |= JUDY_key_mask;
; 1556 : 		depth++;

  003c5	ff 45 f8	 inc	 DWORD PTR _depth$[ebp]
  003c8	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  003cb	8b 02		 mov	 eax, DWORD PTR [edx]
  003cd	89 44 8e 34	 mov	 DWORD PTR [esi+ecx*4+52], eax
  003d1	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003d4	8d 4c 40 0f	 lea	 ecx, DWORD PTR [eax+eax*2+15]
  003d8	c7 04 8e 00 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 0
  003df	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003e2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  003e5	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  003e8	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx
  003ec	83 c0 fc	 add	 eax, -4			; fffffffcH
  003ef	83 cb 03	 or	 ebx, 3
  003f2	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 1557 : 		off++;

  003f5	43		 inc	 ebx
$LN19@judy_cell:

; 1558 : 	}
; 1559 : 
; 1560 : 	//	produce span nodes to consume rest of key
; 1561 : 	//  or judy_1 nodes if not string tree
; 1562 : 
; 1563 : #ifndef ASKITIS
; 1564 : 	if( !judy->depth )

  003f6	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  003f9	85 c0		 test	 eax, eax
  003fb	0f 85 b2 00 00
	00		 jne	 $LN81@judy_cell

; 1565 : 	  while( off <= max ) {

  00401	85 db		 test	 ebx, ebx
  00403	0f 85 2b 01 00
	00		 jne	 $LN2@judy_cell
  00409	8d a4 24 00 00
	00 00		 npad	 7
$LL9@judy_cell:

; 1566 : 		base = (uchar*)judy_alloc (judy, JUDY_span);

  00410	56		 push	 esi
  00411	b9 07 00 00 00	 mov	 ecx, 7
  00416	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1567 : 		*next = (JudySlot)base | JUDY_span;

  0041b	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0041e	8b f8		 mov	 edi, eax
  00420	8b cf		 mov	 ecx, edi
  00422	83 c9 07	 or	 ecx, 7
  00425	89 0a		 mov	 DWORD PTR [edx], ecx

; 1568 : 		node = (JudySlot  *)(base + JudySize[JUDY_span]);

  00427	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?JudySize@@3PAHA+28
  0042c	03 c7		 add	 eax, edi
  0042e	89 45 f4	 mov	 DWORD PTR _node$[ebp], eax

; 1569 : 		cnt = tst = JUDY_span_bytes;
; 1570 : 		if( tst > (int)(max - off) )

  00431	8b c3		 mov	 eax, ebx
  00433	f7 d8		 neg	 eax
  00435	83 c4 04	 add	 esp, 4
  00438	c7 45 ec 1c 00
	00 00		 mov	 DWORD PTR _tst$[ebp], 28 ; 0000001cH
  0043f	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  00442	7d 03		 jge	 SHORT $LN7@judy_cell

; 1571 : 			tst = max - off;

  00444	89 45 ec	 mov	 DWORD PTR _tst$[ebp], eax
$LN7@judy_cell:

; 1572 : 		memcpy (base, buff + off, tst);

  00447	8b 4d ec	 mov	 ecx, DWORD PTR _tst$[ebp]
  0044a	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  0044d	51		 push	 ecx
  0044e	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00451	50		 push	 eax
  00452	57		 push	 edi
  00453	e8 00 00 00 00	 call	 _memcpy

; 1573 : 
; 1574 : 		if( judy->level < judy->max )

  00458	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0045b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0045e	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  00461	73 04		 jae	 SHORT $LN6@judy_cell

; 1575 : 			judy->level++;

  00463	40		 inc	 eax
  00464	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN6@judy_cell:

; 1576 : 		judy->stack[judy->level].next = *next;

  00467	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0046a	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0046d	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00470	8b 02		 mov	 eax, DWORD PTR [edx]
  00472	89 44 8e 34	 mov	 DWORD PTR [esi+ecx*4+52], eax

; 1577 : 		judy->stack[judy->level].slot = 0;

  00476	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00479	8d 4c 40 0f	 lea	 ecx, DWORD PTR [eax+eax*2+15]
  0047d	c7 04 8e 00 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 0

; 1578 : 		judy->stack[judy->level].off = off;

  00484	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00487	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]

; 1579 : 		next = &node[-1];

  0048a	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0048d	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx

; 1580 : 		off += tst;

  00491	03 5d ec	 add	 ebx, DWORD PTR _tst$[ebp]
  00494	83 c0 fc	 add	 eax, -4			; fffffffcH

; 1581 : 		depth++;
; 1582 : 
; 1583 : 		if( !base[cnt-1] )	// done on leaf

  00497	80 7f 1b 00	 cmp	 BYTE PTR [edi+27], 0
  0049b	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  0049e	0f 84 90 00 00
	00		 je	 $LN2@judy_cell

; 1565 : 	  while( off <= max ) {

  004a4	85 db		 test	 ebx, ebx
  004a6	0f 84 64 ff ff
	ff		 je	 $LL9@judy_cell
  004ac	5f		 pop	 edi
  004ad	5e		 pop	 esi
  004ae	5b		 pop	 ebx

; 1612 : }

  004af	8b e5		 mov	 esp, ebp
  004b1	5d		 pop	 ebp
  004b2	c3		 ret	 0
$LN81@judy_cell:

; 1584 : 			break;
; 1585 : 	  }
; 1586 : 	else
; 1587 : 	  while( depth < judy->depth ) {

  004b3	39 45 f8	 cmp	 DWORD PTR _depth$[ebp], eax
  004b6	73 7c		 jae	 SHORT $LN2@judy_cell
  004b8	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
  004bb	eb 03 8d 49 00	 npad	 5
$LL3@judy_cell:

; 1588 : 		base = (uchar*)judy_alloc (judy, JUDY_1);

  004c0	56		 push	 esi
  004c1	b9 01 00 00 00	 mov	 ecx, 1
  004c6	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1589 : 		node = (JudySlot  *)(base + JudySize[JUDY_1]);

  004cb	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?JudySize@@3PAHA+4
  004d1	03 c8		 add	 ecx, eax

; 1590 : 		*next = (JudySlot)base | JUDY_1;

  004d3	8b d0		 mov	 edx, eax
  004d5	83 ca 01	 or	 edx, 1
  004d8	89 17		 mov	 DWORD PTR [edi], edx

; 1591 : 
; 1592 : 		//	fill in slot 0 with bytes of key
; 1593 : 
; 1594 : 		*(judyvalue *)base = src[depth];

  004da	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  004dd	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx
  004e0	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
  004e3	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  004e6	89 08		 mov	 DWORD PTR [eax], ecx

; 1595 : 
; 1596 : 		if( judy->level < judy->max )

  004e8	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  004eb	83 c4 04	 add	 esp, 4
  004ee	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  004f1	73 04		 jae	 SHORT $LN1@judy_cell

; 1597 : 			judy->level++;

  004f3	40		 inc	 eax
  004f4	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN1@judy_cell:

; 1598 : 		judy->stack[judy->level].next = *next;

  004f7	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  004fa	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  004fd	8b 07		 mov	 eax, DWORD PTR [edi]

; 1599 : 		judy->stack[judy->level].slot = 0;
; 1600 : 		judy->stack[judy->level].off = off;
; 1601 : 		next = &node[-1];

  004ff	8b 7d f4	 mov	 edi, DWORD PTR _node$[ebp]
  00502	89 44 96 34	 mov	 DWORD PTR [esi+edx*4+52], eax
  00506	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00509	8d 4c 40 0f	 lea	 ecx, DWORD PTR [eax+eax*2+15]
  0050d	c7 04 8e 00 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 0
  00514	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00517	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]

; 1602 : 		off |= JUDY_key_mask;
; 1603 : 		depth++;

  0051a	8b 45 f8	 mov	 eax, DWORD PTR _depth$[ebp]
  0051d	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx
  00521	83 cb 03	 or	 ebx, 3
  00524	40		 inc	 eax
  00525	83 c7 fc	 add	 edi, -4			; fffffffcH

; 1604 : 		off++;

  00528	43		 inc	 ebx
  00529	89 45 f8	 mov	 DWORD PTR _depth$[ebp], eax
  0052c	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0052f	72 8f		 jb	 SHORT $LL3@judy_cell

; 1599 : 		judy->stack[judy->level].slot = 0;
; 1600 : 		judy->stack[judy->level].off = off;
; 1601 : 		next = &node[-1];

  00531	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
$LN2@judy_cell:

; 1605 : 	  }
; 1606 : #endif
; 1607 : 
; 1608 : #ifdef ASKITIS
; 1609 : 	Inserts++;
; 1610 : #endif
; 1611 : 	return next;

  00534	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LN67@judy_cell:
  00537	5f		 pop	 edi
  00538	5e		 pop	 esi
  00539	5b		 pop	 ebx

; 1612 : }

  0053a	8b e5		 mov	 esp, ebp
  0053c	5d		 pop	 ebp
  0053d	c3		 ret	 0
?judy_cell@@YAPAIPAUJudy@@PAEI@Z ENDP			; judy_cell
_TEXT	ENDS
PUBLIC	_tommy_hashlin_bucket
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashlin.c
;	COMDAT _tommy_hashlin_bucket
_TEXT	SEGMENT
_tommy_hashlin_bucket PROC				; COMDAT
; _hash$ = ecx

; 292  : 	return *tommy_hashlin_bucket_ptr(hashlin, hash);

  00000	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr
  00005	8b 00		 mov	 eax, DWORD PTR [eax]

; 293  : }

  00007	c3		 ret	 0
_tommy_hashlin_bucket ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashlin_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashlin_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_hashlin_insert PROC				; COMDAT
; _node$ = esi
; _hash$ = edi

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 270  : 	tommy_list_insert_tail(tommy_hashlin_bucket_ptr(hashlin, hash), node, data);

  00003	8b cf		 mov	 ecx, edi
  00005	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 16		 je	 SHORT $LN4@tommy_hash@8
  00010	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00013	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00016	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00019	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00022	89 31		 mov	 DWORD PTR [ecx], esi
  00024	eb 0b		 jmp	 SHORT $LN11@tommy_hash@8
$LN4@tommy_hash@8:
  00026	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002f	89 30		 mov	 DWORD PTR [eax], esi
$LN11@tommy_hash@8:
  00031	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00034	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 271  : 
; 272  : 	node->key = hash;

  00037	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 273  : 
; 274  : 	++hashlin->count;

  0003a	ff 05 a0 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 277  : }

  00040	5d		 pop	 ebp

; 275  : 
; 276  : 	hashlin_grow_step(hashlin);

  00041	e9 00 00 00 00	 jmp	 ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_grow_step
_tommy_hashlin_insert ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z
_TEXT	SEGMENT
_count$193788 = -4					; size = 4
?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z PROC ; hashlin_shrink_step, COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 204  : 	/* shrink if less than 12.5% full */
; 205  : 	if (hashlin->state != TOMMY_HASHLIN_STATE_SHRINK
; 206  : 		&& hashlin->count < hashlin->bucket_max / 8
; 207  : 	) {

  00004	8b 0d 9c 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156
  0000a	56		 push	 esi
  0000b	8b 35 a0 00 00
	00		 mov	 esi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  00011	83 f9 02	 cmp	 ecx, 2
  00014	74 5e		 je	 SHORT $LN40@hashlin_sh
  00016	a1 84 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  0001b	8b d0		 mov	 edx, eax
  0001d	c1 ea 03	 shr	 edx, 3
  00020	3b f2		 cmp	 esi, edx
  00022	0f 83 25 01 00
	00		 jae	 $LN2@hashlin_sh

; 208  : 		/* avoid to shrink the first bucket */
; 209  : 		if (hashlin->bucket_bit > TOMMY_HASHLIN_BIT) {

  00028	83 3d 80 00 00
	00 06		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, 6
  0002f	0f 86 18 01 00
	00		 jbe	 $LN2@hashlin_sh

; 210  : 			/* if we are stable, setup a new shrink state */
; 211  : 			/* otherwise continue with the already setup grow one */
; 212  : 			/* but in backward direction */
; 213  : 			if (hashlin->state == TOMMY_HASHLIN_STATE_STABLE) {

  00035	85 c9		 test	 ecx, ecx
  00037	75 29		 jne	 SHORT $LN39@hashlin_sh

; 214  : 				/* set the lower size */
; 215  : 				hashlin->low_max = hashlin->bucket_max / 2;
; 216  : 				hashlin->low_mask = hashlin->bucket_mask / 2;

  00039	8b 0d 88 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  0003f	d1 e8		 shr	 eax, 1
  00041	d1 e9		 shr	 ecx, 1

; 217  : 
; 218  : 				/* start from the half going backward */
; 219  : 				hashlin->split = hashlin->low_max;

  00043	8b d0		 mov	 edx, eax
  00045	a3 90 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144, eax
  0004a	89 0d 94 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148, ecx
  00050	89 15 98 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, edx

; 220  : 			}
; 221  : 
; 222  : 			/* start reallocation */
; 223  : 			hashlin->state = TOMMY_HASHLIN_STATE_SHRINK;

  00056	c7 05 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 2
  00060	eb 18		 jmp	 SHORT $LN38@hashlin_sh
$LN39@hashlin_sh:

; 217  : 
; 218  : 				/* start from the half going backward */
; 219  : 				hashlin->split = hashlin->low_max;

  00062	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152

; 220  : 			}
; 221  : 
; 222  : 			/* start reallocation */
; 223  : 			hashlin->state = TOMMY_HASHLIN_STATE_SHRINK;

  00068	c7 05 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 2
  00072	eb 06		 jmp	 SHORT $LN38@hashlin_sh
$LN40@hashlin_sh:
  00074	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
$LN38@hashlin_sh:

; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	/* if we are shrinking */
; 228  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_SHRINK) {
; 229  : 		/* compute the split target required to finish the reallocation before the next resize */
; 230  : 		unsigned split_target = 8 * hashlin->count;
; 231  : 
; 232  : 		/* reallocate buckets until the split target */
; 233  : 		while (hashlin->split + hashlin->low_max > split_target) {

  0007a	a1 90 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  0007f	03 f6		 add	 esi, esi
  00081	03 f6		 add	 esi, esi
  00083	03 f6		 add	 esi, esi
  00085	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00088	3b ce		 cmp	 ecx, esi
  0008a	0f 86 bd 00 00
	00		 jbe	 $LN2@hashlin_sh
  00090	57		 push	 edi
$LL3@hashlin_sh:

; 234  : 			tommy_hashlin_node** split[2];
; 235  : 
; 236  : 			/* go backward position */
; 237  : 			--hashlin->split;

  00091	4a		 dec	 edx
  00092	89 15 98 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, edx

; 238  :    
; 239  : 			/* get the low bucket */
; 240  : 			split[0] = tommy_hashlin_pos(hashlin, hashlin->split);

  00098	83 fa 40	 cmp	 edx, 64			; 00000040H
  0009b	73 0a		 jae	 SHORT $LN10@hashlin_sh
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  000a2	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000a5	eb 1b		 jmp	 SHORT $LN11@hashlin_sh
$LN10@hashlin_sh:
  000a7	0f bd ca	 bsr	 ecx, edx
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	d3 e0		 shl	 eax, cl
  000b1	89 4d fc	 mov	 DWORD PTR _count$193788[ebp], ecx
  000b4	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  000bb	8b fa		 mov	 edi, edx
  000bd	2b f8		 sub	 edi, eax
  000bf	8d 0c b9	 lea	 ecx, DWORD PTR [ecx+edi*4]
$LN11@hashlin_sh:

; 241  : 
; 242  : 			/* get the high bucket */
; 243  : 			/* it's always in the second half, so we can index it directly */
; 244  : 			/* without calling tommy_hashlin_pos() */
; 245  : 			split[1] = &hashlin->bucket[hashlin->bucket_mac-1][hashlin->split];

  000c2	a1 8c 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  000c7	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[eax*4-4]
  000ce	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 246  : 
; 247  : 			/* concat the high bucket into the low one */
; 248  : 			tommy_list_concat(split[0], split[1]);

  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	85 c0		 test	 eax, eax
  000d5	74 1a		 je	 SHORT $LN17@hashlin_sh
  000d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d9	85 d2		 test	 edx, edx
  000db	74 0c		 je	 SHORT $LN42@hashlin_sh
  000dd	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000e0	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e3	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  000e6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN42@hashlin_sh:
  000e9	89 01		 mov	 DWORD PTR [ecx], eax
  000eb	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
$LN17@hashlin_sh:

; 249  : 
; 250  : 			/* if we have finished, clean up and change the state */
; 251  : 			if (hashlin->split == 0) {

  000f1	85 d2		 test	 edx, edx
  000f3	74 13		 je	 SHORT $LN37@hashlin_sh

; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	/* if we are shrinking */
; 228  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_SHRINK) {
; 229  : 		/* compute the split target required to finish the reallocation before the next resize */
; 230  : 		unsigned split_target = 8 * hashlin->count;
; 231  : 
; 232  : 		/* reallocate buckets until the split target */
; 233  : 		while (hashlin->split + hashlin->low_max > split_target) {

  000f5	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  000fb	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000fe	3b c6		 cmp	 eax, esi
  00100	77 8f		 ja	 SHORT $LL3@hashlin_sh
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi

; 262  : 				break;
; 263  : 			}
; 264  : 		}
; 265  : 	}
; 266  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN37@hashlin_sh:

; 252  : 				hashlin->state = TOMMY_HASHLIN_STATE_STABLE;
; 253  : 
; 254  : 				/* shrink the hash size */
; 255  : 				--hashlin->bucket_bit;

  00108	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128
  0010e	49		 dec	 ecx

; 256  : 				hashlin->bucket_max = 1 << hashlin->bucket_bit;

  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	d3 e0		 shl	 eax, cl
  00116	c7 05 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  00120	89 0d 80 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, ecx
  00126	a3 84 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132, eax

; 257  : 				hashlin->bucket_mask = hashlin->bucket_max - 1;

  0012b	48		 dec	 eax
  0012c	a3 88 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136, eax

; 258  : 
; 259  : 				/* free the last segment */
; 260  : 				--hashlin->bucket_mac;

  00131	a1 8c 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  00136	48		 dec	 eax
  00137	a3 8c 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140, eax

; 261  : 				tommy_free(hashlin->bucket[hashlin->bucket_mac]);

  0013c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[eax*4]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _free
  00149	83 c4 04	 add	 esp, 4
  0014c	5f		 pop	 edi
$LN2@hashlin_sh:
  0014d	5e		 pop	 esi

; 262  : 				break;
; 263  : 			}
; 264  : 		}
; 265  : 	}
; 266  : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z ENDP ; hashlin_shrink_step
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashdyn.c
_TEXT	ENDS
;	COMDAT ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z
_TEXT	SEGMENT
_new_bucket_mask$ = -16					; size = 4
tv478 = -12						; size = 4
_bucket_max$ = -12					; size = 4
_new_bucket_max$ = -8					; size = 4
tv435 = -4						; size = 4
_new_bucket_bit$ = 8					; size = 4
?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z PROC ; tommy_hashdyn_resize, COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 58   : 	unsigned bucket_bit;
; 59   : 	unsigned bucket_max;
; 60   : 	unsigned new_bucket_max;
; 61   : 	unsigned new_bucket_mask;
; 62   : 	tommy_hashdyn_node** new_bucket;
; 63   : 
; 64   : 	bucket_bit = hashdyn->bucket_bit;
; 65   : 	bucket_max = hashdyn->bucket_max;
; 66   : 
; 67   : 	new_bucket_max = 1 << new_bucket_bit;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _new_bucket_bit$[ebp]
  00009	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  0000e	53		 push	 ebx
  0000f	bb 01 00 00 00	 mov	 ebx, 1
  00014	d3 e3		 shl	 ebx, cl
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	89 45 f4	 mov	 DWORD PTR _bucket_max$[ebp], eax

; 68   : 	new_bucket_mask = new_bucket_max - 1;

  0001b	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]

; 69   : 	new_bucket = tommy_cast(tommy_hashdyn_node**, tommy_malloc(new_bucket_max * sizeof(tommy_hashdyn_node*)));

  0001e	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00025	57		 push	 edi
  00026	89 5d f8	 mov	 DWORD PTR _new_bucket_max$[ebp], ebx
  00029	89 4d f0	 mov	 DWORD PTR _new_bucket_mask$[ebp], ecx
  0002c	e8 00 00 00 00	 call	 _malloc

; 70   : 
; 71   : 	/* reinsert all the elements */
; 72   : 	if (new_bucket_bit > bucket_bit) {

  00031	8b 55 08	 mov	 edx, DWORD PTR _new_bucket_bit$[ebp]
  00034	83 c4 04	 add	 esp, 4
  00037	8b f0		 mov	 esi, eax
  00039	3b 15 04 00 00
	00		 cmp	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  0003f	0f 86 b4 00 00
	00		 jbe	 $LN12@tommy_hash@9

; 73   : 		unsigned i;
; 74   : 
; 75   : 		/* grow */
; 76   : 		for(i=0;i<bucket_max;++i) {

  00045	8b 4d f4	 mov	 ecx, DWORD PTR _bucket_max$[ebp]
  00048	33 db		 xor	 ebx, ebx
  0004a	85 c9		 test	 ecx, ecx
  0004c	74 75		 je	 SHORT $LN47@tommy_hash@9
  0004e	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]
  00051	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00054	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL48@tommy_hash@9:

; 77   : 			tommy_hashdyn_node* j;
; 78   : 
; 79   : 			/* setup the new two buckets */
; 80   : 			new_bucket[i] = 0;
; 81   : 			new_bucket[i + bucket_max] = 0;

  00060	8b 55 fc	 mov	 edx, DWORD PTR tv435[ebp]
  00063	c7 04 9e 00 00
	00 00		 mov	 DWORD PTR [esi+ebx*4], 0
  0006a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 82   : 
; 83   : 			/* reinsert the bucket */
; 84   : 			j = hashdyn->bucket[i];

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00075	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 85   : 			while (j) {

  00078	85 c0		 test	 eax, eax
  0007a	74 3e		 je	 SHORT $LN10@tommy_hash@9
  0007c	8d 64 24 00	 npad	 4
$LL8@tommy_hash@9:

; 86   : 				tommy_hashdyn_node* j_next = j->next;
; 87   : 				unsigned index = j->key & new_bucket_mask;

  00080	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00083	23 4d f0	 and	 ecx, DWORD PTR _new_bucket_mask$[ebp]
  00086	8b 38		 mov	 edi, DWORD PTR [eax]

; 88   : 				if (new_bucket[index])

  00088	8b 14 8e	 mov	 edx, DWORD PTR [esi+ecx*4]
  0008b	85 d2		 test	 edx, edx
  0008d	74 16		 je	 SHORT $LN6@tommy_hash@9

; 89   : 					tommy_list_insert_tail_not_empty(new_bucket[index], j);

  0008f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00092	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00095	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00098	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a1	89 02		 mov	 DWORD PTR [edx], eax

; 90   : 				else

  000a3	eb 0c		 jmp	 SHORT $LN17@tommy_hash@9
$LN6@tommy_hash@9:

; 91   : 					tommy_list_insert_first(&new_bucket[index], j);

  000a5	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000ae	89 04 8e	 mov	 DWORD PTR [esi+ecx*4], eax
$LN17@tommy_hash@9:

; 92   : 				j = j_next;

  000b1	8b c7		 mov	 eax, edi
  000b3	85 ff		 test	 edi, edi
  000b5	75 c9		 jne	 SHORT $LL8@tommy_hash@9

; 85   : 			while (j) {

  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _bucket_max$[ebp]
$LN10@tommy_hash@9:

; 73   : 		unsigned i;
; 74   : 
; 75   : 		/* grow */
; 76   : 		for(i=0;i<bucket_max;++i) {

  000ba	83 45 fc 04	 add	 DWORD PTR tv435[ebp], 4
  000be	43		 inc	 ebx
  000bf	3b d9		 cmp	 ebx, ecx
  000c1	72 9d		 jb	 SHORT $LL48@tommy_hash@9
$LN47@tommy_hash@9:

; 93   : 			}
; 94   : 		}
; 95   : 	} else {
; 96   : 		unsigned i;
; 97   : 
; 98   : 		/* shrink */
; 99   : 		for(i=0;i<new_bucket_max;++i) {

  000c3	8b 5d f8	 mov	 ebx, DWORD PTR _new_bucket_max$[ebp]
$LN46@tommy_hash@9:

; 105  : 		}
; 106  : 	}
; 107  : 
; 108  : 	tommy_free(hashdyn->bucket);

  000c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _free

; 109  : 
; 110  : 	/* setup */
; 111  : 	hashdyn->bucket_bit = new_bucket_bit;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _new_bucket_bit$[ebp]

; 112  : 	hashdyn->bucket_max = new_bucket_max;
; 113  : 	hashdyn->bucket_mask = new_bucket_mask;

  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _new_bucket_mask$[ebp]
  000d8	83 c4 04	 add	 esp, 4
  000db	5f		 pop	 edi

; 114  : 	hashdyn->bucket = new_bucket;

  000dc	89 35 00 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A, esi
  000e2	5e		 pop	 esi
  000e3	89 1d 08 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8, ebx
  000e9	a3 04 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4, eax
  000ee	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12, ecx
  000f4	5b		 pop	 ebx

; 115  : }

  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
$LN12@tommy_hash@9:

; 93   : 			}
; 94   : 		}
; 95   : 	} else {
; 96   : 		unsigned i;
; 97   : 
; 98   : 		/* shrink */
; 99   : 		for(i=0;i<new_bucket_max;++i) {

  000f9	33 c0		 xor	 eax, eax
  000fb	85 db		 test	 ebx, ebx
  000fd	74 c7		 je	 SHORT $LN46@tommy_hash@9
  000ff	89 7d f4	 mov	 DWORD PTR tv478[ebp], edi
$LL49@tommy_hash@9:

; 100  : 			/* setup the new bucket with the lower bucket*/
; 101  : 			new_bucket[i] = hashdyn->bucket[i];

  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00108	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0010b	89 14 86	 mov	 DWORD PTR [esi+eax*4], edx

; 102  : 
; 103  : 			/* concat the upper bucket */
; 104  : 			tommy_list_concat(&new_bucket[i], &hashdyn->bucket[i + new_bucket_max]);

  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00114	8b 0c 0f	 mov	 ecx, DWORD PTR [edi+ecx]
  00117	85 c9		 test	 ecx, ecx
  00119	74 1a		 je	 SHORT $LN2@tommy_hash@9
  0011b	85 d2		 test	 edx, edx
  0011d	75 05		 jne	 SHORT $LN19@tommy_hash@9
  0011f	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  00122	eb 11		 jmp	 SHORT $LN2@tommy_hash@9
$LN19@tommy_hash@9:
  00124	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  00127	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0012a	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
  0012d	8b 5d f8	 mov	 ebx, DWORD PTR _new_bucket_max$[ebp]
  00130	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00133	89 0f		 mov	 DWORD PTR [edi], ecx
$LN2@tommy_hash@9:

; 93   : 			}
; 94   : 		}
; 95   : 	} else {
; 96   : 		unsigned i;
; 97   : 
; 98   : 		/* shrink */
; 99   : 		for(i=0;i<new_bucket_max;++i) {

  00135	8b 7d f4	 mov	 edi, DWORD PTR tv478[ebp]
  00138	40		 inc	 eax
  00139	83 c7 04	 add	 edi, 4
  0013c	89 7d f4	 mov	 DWORD PTR tv478[ebp], edi
  0013f	3b c3		 cmp	 eax, ebx
  00141	72 bf		 jb	 SHORT $LL49@tommy_hash@9
  00143	eb 81		 jmp	 SHORT $LN46@tommy_hash@9
?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ENDP ; tommy_hashdyn_resize
_TEXT	ENDS
PUBLIC	_tommy_trie_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommytrie.c
;	COMDAT _tommy_trie_remove
_TEXT	SEGMENT
_tommy_trie_remove PROC					; COMDAT
; _key$ = eax

; 260  : 	tommy_trie_node* ret;
; 261  : 	tommy_trie_node** let_ptr;
; 262  : 
; 263  : 	let_ptr = &trie->bucket[key >> TOMMY_TRIE_BUCKET_SHIFT];

  00000	8b c8		 mov	 ecx, eax
  00002	c1 e9 1b	 shr	 ecx, 27			; 0000001bH
  00005	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[ecx*4]

; 264  : 
; 265  : 	ret = trie_bucket_remove_existing(trie, TOMMY_TRIE_BUCKET_SHIFT, let_ptr, 0, key);

  0000c	e8 00 00 00 00	 call	 ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ; trie_bucket_remove_existing

; 266  : 
; 267  : 	if (!ret)

  00011	85 c0		 test	 eax, eax
  00013	75 01		 jne	 SHORT $LN1@tommy_trie@8

; 273  : }

  00015	c3		 ret	 0
$LN1@tommy_trie@8:

; 268  : 		return 0;
; 269  : 
; 270  : 	--trie->count;

  00016	ff 0d 80 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128

; 271  : 
; 272  : 	return ret->data;

  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 273  : }

  0001f	c3		 ret	 0
_tommy_trie_remove ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashlin.h
_TEXT	ENDS
;	COMDAT _tommy_hashlin_search
_TEXT	SEGMENT
_tommy_hashlin_search PROC				; COMDAT
; _cmp_arg$ = edi
; _hash$ = esi

; 228  : 	tommy_hashlin_node* i = tommy_hashlin_bucket(hashlin, hash);

  00000	8b ce		 mov	 ecx, esi
  00002	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr
  00007	8b 00		 mov	 eax, DWORD PTR [eax]

; 229  : 	while (i) {

  00009	85 c0		 test	 eax, eax
  0000b	74 18		 je	 SHORT $LN2@tommy_hash@10
  0000d	8d 49 00	 npad	 3
$LL3@tommy_hash@10:

; 230  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 231  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0)

  00010	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00013	75 0a		 jne	 SHORT $LN1@tommy_hash@10
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	8b 17		 mov	 edx, DWORD PTR [edi]
  0001a	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0001d	74 09		 je	 SHORT $LN12@tommy_hash@10
$LN1@tommy_hash@10:

; 233  : 		i = i->next;

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	85 c0		 test	 eax, eax
  00023	75 eb		 jne	 SHORT $LL3@tommy_hash@10
$LN2@tommy_hash@10:

; 234  : 	}
; 235  : 	return 0;

  00025	33 c0		 xor	 eax, eax

; 236  : }

  00027	c3		 ret	 0
$LN12@tommy_hash@10:

; 232  : 			return i->data;

  00028	8b c1		 mov	 eax, ecx

; 236  : }

  0002a	c3		 ret	 0
_tommy_hashlin_search ENDP
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T193965 = -8						; size = 8
__Last$ = 8						; size = 4
?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert, COMDAT
; _this$ = ecx

; 899  : 		{	// insert elements in [begin(), _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 900  : 		if (begin() != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000f	39 01		 cmp	 DWORD PTR [ecx], eax
  00011	74 2b		 je	 SHORT $LN54@Reinsert

; 901  : 			for (--_Last; ; )

  00013	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00016	89 55 08	 mov	 DWORD PTR __Last$[ebp], edx
  00019	53		 push	 ebx
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL3@Reinsert:

; 902  : 				{	// reinsert elements in [begin(), _Last]
; 903  : 				iterator _First = begin();

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	8b 00		 mov	 eax, DWORD PTR [eax]

; 904  : 				bool _Done = _First == _Last;

  00025	3b 45 08	 cmp	 eax, DWORD PTR __Last$[ebp]

; 905  : 				_Insert(*_First, _First);

  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR $T193965[ebp]
  0002c	51		 push	 ecx
  0002d	0f 94 c3	 sete	 bl
  00030	83 c0 08	 add	 eax, 8
  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert

; 906  : 				if (_Done)

  00039	84 db		 test	 bl, bl
  0003b	74 e3		 je	 SHORT $LL3@Reinsert
  0003d	5b		 pop	 ebx
$LN54@Reinsert:
  0003e	5e		 pop	 esi

; 907  : 					break;
; 908  : 				}
; 909  : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_deleted, COMDAT
; _this$ = eax
; _it$ = ecx

; 447  :     assert(settings.use_deleted());
; 448  :     return test_deleted(it);

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 10		 jbe	 SHORT $LN15@clear_dele
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000e	75 06		 jne	 SHORT $LN15@clear_dele
  00010	b8 01 00 00 00	 mov	 eax, 1

; 449  :   }

  00015	c3		 ret	 0

; 447  :     assert(settings.use_deleted());
; 448  :     return test_deleted(it);

$LN15@clear_dele:
  00016	33 c0		 xor	 eax, eax

; 449  :   }

  00018	c3		 ret	 0
?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z
_TEXT	SEGMENT
$T194200 = -12						; size = 12
$T194218 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_obj$ = 12						; size = 4
?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at, COMDAT
; _this$ = ecx
; _pos$ = eax

; 889  :   iterator insert_at(const_reference obj, size_type pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 890  :     if (size() >= max_size())

  00003	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0000e	8b de		 mov	 ebx, esi
  00010	2b da		 sub	 ebx, edx
  00012	57		 push	 edi
  00013	8b f8		 mov	 edi, eax
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	81 fb ff ff ff
	1f		 cmp	 ebx, 536870911		; 1fffffffH
  0001e	72 28		 jb	 SHORT $LN3@insert_at

; 891  :       throw std::length_error("insert overflow");

  00020	8d 45 08	 lea	 eax, DWORD PTR $T194218[ebp]
  00023	50		 push	 eax
  00024	8d 4d f4	 lea	 ecx, DWORD PTR $T194200[ebp]
  00027	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T194218[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  0002e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00033	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  00038	8d 4d f4	 lea	 ecx, DWORD PTR $T194200[ebp]
  0003b	51		 push	 ecx
  0003c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T194200[ebp], OFFSET ??_7length_error@std@@6B@
  00043	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN105@insert_at:
$LN3@insert_at:

; 892  :     if ( test_deleted(pos) ) {      // just replace if it's been del.

  00048	85 d2		 test	 edx, edx
  0004a	74 14		 je	 SHORT $LN103@insert_at
  0004c	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0004f	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  00052	3b 1c f8	 cmp	 ebx, DWORD PTR [eax+edi*8]

; 898  :     } else {

  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	75 06		 jne	 SHORT $LN103@insert_at

; 893  :       // shrug: shouldn't need to be const.
; 894  :       const_iterator delpos(this, table + pos, table + num_buckets, false);
; 895  :       clear_deleted(delpos);
; 896  :       assert( num_deleted > 0);
; 897  :       --num_deleted;                // used to be, now it isn't

  0005a	4a		 dec	 edx
  0005b	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 898  :     } else {

  0005e	eb 04		 jmp	 SHORT $LN1@insert_at
$LN103@insert_at:

; 899  :       ++num_elements;               // replacing an empty bucket

  00060	46		 inc	 esi
  00061	89 71 24	 mov	 DWORD PTR [ecx+36], esi
$LN1@insert_at:

; 900  :     }
; 901  :     set_value(&table[pos], obj);

  00064	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00067	8d 34 fd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*8]
  0006e	03 d6		 add	 edx, esi
  00070	74 0d		 je	 SHORT $LN88@insert_at
  00072	8b 7d 0c	 mov	 edi, DWORD PTR _obj$[ebp]
  00075	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00077	89 1a		 mov	 DWORD PTR [edx], ebx
  00079	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0007c	89 7a 04	 mov	 DWORD PTR [edx+4], edi
$LN88@insert_at:

; 902  :     return iterator(this, table + pos, table + num_buckets, false);

  0007f	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00082	03 f2		 add	 esi, edx
  00084	89 08		 mov	 DWORD PTR [eax], ecx
  00086	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00089	5f		 pop	 edi
  0008a	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0008d	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  00090	5e		 pop	 esi
  00091	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00094	5b		 pop	 ebx

; 903  :   }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
$LN104@insert_at:
?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z
_TEXT	SEGMENT
_tmp$ = -76						; size = 56
$T194588 = -20						; size = 12
_needed_size$ = -8					; size = 4
tv282 = 8						; size = 4
$T194604 = 8						; size = 4
_this$ = 8						; size = 4
_did_resize$ = 11					; size = 1
?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta, COMDAT
; _delta$ = eax

; 556  :   bool resize_delta(size_type delta) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 557  :     bool did_resize = false;
; 558  :     if ( settings.consider_shrink() ) {  // see if lots of deletes happened

  0000a	80 7b 10 00	 cmp	 BYTE PTR [ebx+16], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f8		 mov	 edi, eax
  00012	c6 45 0b 00	 mov	 BYTE PTR _did_resize$[ebp], 0
  00016	74 0f		 je	 SHORT $LN6@resize_del

; 559  :       if ( maybe_shrink() )

  00018	8b f3		 mov	 esi, ebx
  0001a	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
  0001f	84 c0		 test	 al, al
  00021	74 04		 je	 SHORT $LN6@resize_del

; 560  :         did_resize = true;

  00023	c6 45 0b 01	 mov	 BYTE PTR _did_resize$[ebp], 1
$LN6@resize_del:

; 561  :     }
; 562  :     if (num_elements >= (STL_NAMESPACE::numeric_limits<size_type>::max)() - delta)

  00027	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0002a	83 c9 ff	 or	 ecx, -1
  0002d	2b cf		 sub	 ecx, edi
  0002f	3b c1		 cmp	 eax, ecx
  00031	72 28		 jb	 SHORT $LN5@resize_del

; 563  :       throw std::length_error("resize overflow");

  00033	8d 55 08	 lea	 edx, DWORD PTR $T194604[ebp]
  00036	52		 push	 edx
  00037	8d 4d ec	 lea	 ecx, DWORD PTR $T194588[ebp]
  0003a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T194604[ebp], OFFSET ??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@
  00041	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00046	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0004b	8d 45 ec	 lea	 eax, DWORD PTR $T194588[ebp]
  0004e	50		 push	 eax
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T194588[ebp], OFFSET ??_7length_error@std@@6B@
  00056	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@resize_del:
$LN5@resize_del:

; 564  :     if ( bucket_count() >= HT_MIN_BUCKETS &&
; 565  :          (num_elements + delta) <= settings.enlarge_threshold() )

  0005b	83 7b 28 04	 cmp	 DWORD PTR [ebx+40], 4
  0005f	72 13		 jb	 SHORT $LN4@resize_del
  00061	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00064	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  00066	77 0c		 ja	 SHORT $LN4@resize_del
$LN45@resize_del:

; 566  :       return did_resize;                          // we're ok as we are

  00068	8a 45 0b	 mov	 al, BYTE PTR _did_resize$[ebp]

; 600  :   }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN4@resize_del:

; 567  : 
; 568  :     // Sometimes, we need to resize just to get rid of all the
; 569  :     // "deleted" buckets that are clogging up the hashtable.  So when
; 570  :     // deciding whether to resize, count the deleted buckets (which
; 571  :     // are currently taking up room).  But later, when we decide what
; 572  :     // size to resize to, *don't* count deleted buckets, since they
; 573  :     // get discarded during the resize.
; 574  :     const size_type needed_size = settings.min_buckets(num_elements + delta, 0);

  00074	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00077	33 f6		 xor	 esi, esi
  00079	8b c3		 mov	 eax, ebx
  0007b	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets

; 575  :     if ( needed_size <= bucket_count() )      // we have enough buckets

  00080	8b 73 28	 mov	 esi, DWORD PTR [ebx+40]
  00083	89 45 f8	 mov	 DWORD PTR _needed_size$[ebp], eax
  00086	3b c6		 cmp	 eax, esi

; 576  :       return did_resize;

  00088	76 de		 jbe	 SHORT $LN45@resize_del

; 577  : 
; 578  :     size_type resize_to =
; 579  :       settings.min_buckets(num_elements - num_deleted + delta, bucket_count());

  0008a	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  0008d	2b 53 20	 sub	 edx, DWORD PTR [ebx+32]
  00090	8b c3		 mov	 eax, ebx
  00092	03 d7		 add	 edx, edi
  00094	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
  00099	8b f0		 mov	 esi, eax

; 580  : 
; 581  :     if (resize_to < needed_size &&    // may double resize_to
; 582  :         resize_to < (STL_NAMESPACE::numeric_limits<size_type>::max)() / 2) {

  0009b	3b 75 f8	 cmp	 esi, DWORD PTR _needed_size$[ebp]
  0009e	73 24		 jae	 SHORT $LN1@resize_del
  000a0	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  000a6	73 1c		 jae	 SHORT $LN1@resize_del

; 583  :       // This situation means that we have enough deleted elements,
; 584  :       // that once we purge them, we won't actually have needed to
; 585  :       // grow.  But we may want to grow anyway: if we just purge one
; 586  :       // element, say, we'll have to grow anyway next time we
; 587  :       // insert.  Might as well grow now, since we're already going
; 588  :       // through the trouble of copying (in order to purge the
; 589  :       // deleted elements).
; 590  :       const size_type target =
; 591  :           static_cast<size_type>(settings.shrink_size(resize_to*2));

  000a8	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  000ab	8b cb		 mov	 ecx, ebx
  000ad	89 45 08	 mov	 DWORD PTR tv282[ebp], eax
  000b0	e8 00 00 00 00	 call	 ?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size

; 592  :       if (num_elements - num_deleted + delta >= target) {

  000b5	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  000b8	2b 53 20	 sub	 edx, DWORD PTR [ebx+32]
  000bb	03 d7		 add	 edx, edi
  000bd	3b d0		 cmp	 edx, eax
  000bf	72 03		 jb	 SHORT $LN1@resize_del

; 593  :         // Good, we won't be below the shrink threshhold even if we double.
; 594  :         resize_to *= 2;

  000c1	8b 75 08	 mov	 esi, DWORD PTR tv282[ebp]
$LN1@resize_del:

; 595  :       }
; 596  :     }
; 597  :     dense_hashtable tmp(*this, resize_to);

  000c4	8b c6		 mov	 eax, esi
  000c6	8b cb		 mov	 ecx, ebx
  000c8	8d 7d b4	 lea	 edi, DWORD PTR _tmp$[ebp]
  000cb	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >

; 598  :     swap(tmp);                             // now we are tmp

  000d0	8b d7		 mov	 edx, edi
  000d2	8b cb		 mov	 ecx, ebx
  000d4	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap

; 599  :     return true;

  000d9	8b 45 e8	 mov	 eax, DWORD PTR _tmp$[ebp+52]
  000dc	85 c0		 test	 eax, eax
  000de	74 09		 je	 SHORT $LN39@resize_del
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _free
  000e6	83 c4 04	 add	 esp, 4
$LN39@resize_del:

; 600  :   }

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	b0 01		 mov	 al, 1
  000ed	5b		 pop	 ebx
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 04 00	 ret	 4
$LN44@resize_del:
?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 12
?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase, COMDAT
; _this$ = eax

; 998  :   void erase(iterator pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 999  :     if ( pos == end() ) return;    // sanity check

  00003	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00006	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00009	56		 push	 esi
  0000a	8d 34 ca	 lea	 esi, DWORD PTR [edx+ecx*8]
  0000d	8b ce		 mov	 ecx, esi
  0000f	3b ce		 cmp	 ecx, esi
  00011	74 1d		 je	 SHORT $LN93@erase@7
  00013	57		 push	 edi
  00014	8b 78 2c	 mov	 edi, DWORD PTR [eax+44]
$LL12@erase@7:
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	3b fa		 cmp	 edi, edx
  0001b	74 0b		 je	 SHORT $LN10@erase@7
  0001d	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00021	76 0c		 jbe	 SHORT $LN94@erase@7
  00023	39 50 1c	 cmp	 DWORD PTR [eax+28], edx
  00026	75 07		 jne	 SHORT $LN94@erase@7
$LN10@erase@7:
  00028	83 c1 08	 add	 ecx, 8
  0002b	3b ce		 cmp	 ecx, esi
  0002d	75 e8		 jne	 SHORT $LL12@erase@7
$LN94@erase@7:
  0002f	5f		 pop	 edi
$LN93@erase@7:
  00030	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp+4]
  00033	3b d1		 cmp	 edx, ecx
  00035	74 31		 je	 SHORT $LN89@erase@7

; 1000 :     if ( set_deleted(pos) ) {      // true if object has been newly deleted

  00037	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0003b	53		 push	 ebx
  0003c	76 0e		 jbe	 SHORT $LN73@erase@7
  0003e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00041	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00043	75 07		 jne	 SHORT $LN73@erase@7
  00045	bb 01 00 00 00	 mov	 ebx, 1
  0004a	eb 02		 jmp	 SHORT $LN74@erase@7
$LN73@erase@7:
  0004c	33 db		 xor	 ebx, ebx
$LN74@erase@7:
  0004e	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00051	8b ca		 mov	 ecx, edx
  00053	84 db		 test	 bl, bl
  00055	89 32		 mov	 DWORD PTR [edx], esi
  00057	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0005e	5b		 pop	 ebx
  0005f	75 07		 jne	 SHORT $LN89@erase@7

; 1001 :       ++num_deleted;

  00061	ff 40 20	 inc	 DWORD PTR [eax+32]

; 1002 :       settings.set_consider_shrink(true); // will think about shrink after next insert

  00064	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1
$LN89@erase@7:
  00068	5e		 pop	 esi

; 1003 :     }
; 1004 :   }

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z
_TEXT	SEGMENT
_pos$ = -8						; size = 8
_key$ = 8						; size = 4
?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 834  :   iterator find(const key_type& key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f8		 mov	 edi, eax

; 835  :     if ( size() == 0 ) return end();

  00009	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0000c	2b 47 20	 sub	 eax, DWORD PTR [edi+32]
  0000f	75 21		 jne	 SHORT $LN3@find@2
  00011	89 3e		 mov	 DWORD PTR [esi], edi
$LN22@find@2:
  00013	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00016	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00019	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00022	8b c6		 mov	 eax, esi
  00024	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted

; 839  :     else
; 840  :       return iterator(this, table + pos.first, table + num_buckets, false);

  00029	8b c6		 mov	 eax, esi
  0002b	5f		 pop	 edi

; 841  :   }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN3@find@2:

; 836  :     pair<size_type, size_type> pos = find_position(key);

  00032	8d 45 f8	 lea	 eax, DWORD PTR _pos$[ebp]
  00035	50		 push	 eax
  00036	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00039	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position

; 837  :     if ( pos.first == ILLEGAL_BUCKET )     // alas, not there

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _pos$[ebp]

; 838  :       return end();

  00041	89 3e		 mov	 DWORD PTR [esi], edi
  00043	83 f9 ff	 cmp	 ecx, -1
  00046	74 cb		 je	 SHORT $LN22@find@2

; 839  :     else
; 840  :       return iterator(this, table + pos.first, table + num_buckets, false);

  00048	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0004b	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  0004e	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00051	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00054	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00057	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0005a	8b c6		 mov	 eax, esi
  0005c	5f		 pop	 edi

; 841  :   }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize, COMDAT
; _this$ = esi

; 643  :   void resize(size_type req_elements) {       // resize to this or larger

  00000	51		 push	 ecx

; 644  :     if ( settings.consider_shrink() || req_elements == 0 )
; 645  :       maybe_shrink();

  00001	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
  00006	59		 pop	 ecx

; 646  :     if ( req_elements > num_elements )
; 647  :       resize_delta(req_elements - num_elements);
; 648  :   }

  00007	c3		 ret	 0
?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
_it$ = 8						; size = 12
?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase, COMDAT

; 307  :   void erase(iterator it)                            { rep.erase(it); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 45 08	 movq	 xmm0, QWORD PTR _it$[ebp]
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _it$[ebp+8]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	8b c4		 mov	 eax, esp
  00010	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00014	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0001c	e8 00 00 00 00	 call	 ?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z
_TEXT	SEGMENT
_pos$195205 = -8					; size = 8
_key$ = 8						; size = 4
?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find, COMDAT
; ___$ReturnUdt$ = esi

; 262  :   iterator find(const key_type& key)                 { return rep.find(key); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0000d	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00010	2b 47 20	 sub	 eax, DWORD PTR [edi+32]
  00013	75 21		 jne	 SHORT $LN5@find@3
  00015	89 3e		 mov	 DWORD PTR [esi], edi
$LN24@find@3:
  00017	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0001a	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  0001d	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00020	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00023	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00026	8b c6		 mov	 eax, esi
  00028	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  0002d	8b c6		 mov	 eax, esi
  0002f	5f		 pop	 edi
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN5@find@3:
  00036	8d 45 f8	 lea	 eax, DWORD PTR _pos$195205[ebp]
  00039	50		 push	 eax
  0003a	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0003d	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _pos$195205[ebp]
  00045	89 3e		 mov	 DWORD PTR [esi], edi
  00047	83 f9 ff	 cmp	 ecx, -1
  0004a	74 cb		 je	 SHORT $LN24@find@3
  0004c	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0004f	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00052	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00055	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00058	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0005b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0005e	8b c6		 mov	 eax, esi
  00060	5f		 pop	 edi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize, COMDAT

; 258  :   void resize(size_type hint)         { rep.resize(hint); }

  00000	56		 push	 esi
  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00007	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
  0000c	5e		 pop	 esi
  0000d	c3		 ret	 0
?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
_TEXT	ENDS
PUBLIC	?test_miss@@YAXPAI@Z				; test_miss
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark.cc
;	COMDAT ?test_miss@@YAXPAI@Z
_TEXT	SEGMENT
$T199359 = -36						; size = 8
_t$199366 = -36						; size = 8
$T199336 = -36						; size = 8
$T199313 = -36						; size = 8
_t$199320 = -36						; size = 8
$T199290 = -36						; size = 8
$T199206 = -36						; size = 8
$T198842 = -36						; size = 8
_pos$196791 = -36					; size = 8
_t$197282 = -36						; size = 8
_t$199343 = -28						; size = 8
_t$199297 = -28						; size = 8
_t$199213 = -28						; size = 8
$T198487 = -28						; size = 8
_t$198849 = -28						; size = 8
$T197275 = -28						; size = 8
_t$195649 = -28						; size = 8
tv2817 = -20						; size = 8
tv2744 = -20						; size = 8
tv2684 = -20						; size = 8
tv2679 = -20						; size = 8
tv2197 = -20						; size = 8
tv1931 = -20						; size = 8
tv1869 = -20						; size = 8
$T198488 = -20						; size = 8
tv1389 = -20						; size = 8
tv1075 = -20						; size = 8
$T195642 = -20						; size = 8
$T195615 = -20						; size = 8
$T195573 = -20						; size = 8
_t$195582 = -20						; size = 8
tv818 = -20						; size = 8
tv743 = -20						; size = 8
$T195517 = -20						; size = 8
_t$195523 = -20						; size = 8
$T195379 = -20						; size = 8
_t$195386 = -20						; size = 8
$T195328 = -20						; size = 8
_t$195335 = -20						; size = 8
tv175 = -20						; size = 8
tv170 = -20						; size = 8
_bitpos$199408 = -16					; size = 4
__Where$199077 = -16					; size = 4
_count$195500 = -16					; size = 4
_key$149666 = -16					; size = 4
_key$149564 = -16					; size = 4
_key$149555 = -16					; size = 4
_key$149526 = -16					; size = 4
_t$195622 = -12						; size = 8
$T199082 = -8						; size = 4
$T195235 = -8						; size = 4
_i$ = -8						; size = 4
_SEARCH$ = 8						; size = 4
?test_miss@@YAXPAI@Z PROC				; test_miss, COMDAT

; 1274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx

; 1275 : 	unsigned i;
; 1276 : 
; 1277 : 	const unsigned DELTA = 0;
; 1278 : 
; 1279 : 	START(DATA_TREE) {

  00007	b8 05 00 00 00	 mov	 eax, 5
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  00010	57		 push	 edi
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0001c	0f 85 91 00 00
	00		 jne	 $LN119@test_miss
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00029	75 2e		 jne	 SHORT $LN129@test_miss
  0002b	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00036	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003d	50		 push	 eax
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00043	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0004a	52		 push	 edx
  0004b	51		 push	 ecx
  0004c	68 00 00 00 00	 push	 OFFSET $SG-100
  00051	e8 00 00 00 00	 call	 _printf
  00056	83 c4 10	 add	 esp, 16			; 00000010H
$LN129@test_miss:
  00059	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005e	33 ff		 xor	 edi, edi
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00065	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  0006b	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00071	76 40		 jbe	 SHORT $LN119@test_miss
$LL121@test_miss:

; 1280 : 		struct rbt_object key;
; 1281 : 		key.value = SEARCH[i] + DELTA;
; 1282 : 		if (rbt_search(&tree, &key))

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A
  00078	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]
  0007b	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00080	74 28		 je	 SHORT $LN120@test_miss
$LL139@test_miss:
  00082	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00085	3b d1		 cmp	 edx, ecx
  00087	7c 11		 jl	 SHORT $LN1000@test_miss
  00089	7e 13		 jle	 SHORT $LN138@test_miss
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	83 e0 fe	 and	 eax, -2			; fffffffeH
$LN136@test_miss:
  00091	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00096	75 ea		 jne	 SHORT $LL139@test_miss
  00098	eb 10		 jmp	 SHORT $LN120@test_miss
$LN1000@test_miss:
  0009a	8b 00		 mov	 eax, DWORD PTR [eax]
  0009c	eb f3		 jmp	 SHORT $LN136@test_miss
$LN138@test_miss:
  0009e	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  000a3	74 05		 je	 SHORT $LN120@test_miss

; 1283 : 			abort();

  000a5	e8 00 00 00 00	 call	 _abort
$LN120@test_miss:

; 1275 : 	unsigned i;
; 1276 : 
; 1277 : 	const unsigned DELTA = 0;
; 1278 : 
; 1279 : 	START(DATA_TREE) {

  000aa	47		 inc	 edi
  000ab	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  000b1	72 c0		 jb	 SHORT $LL121@test_miss
$LN119@test_miss:

; 1284 : 	} STOP();

  000b3	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1285 : 
; 1286 : 	START(DATA_HASHTABLE) {

  000b8	33 ff		 xor	 edi, edi
  000ba	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_start_data@@3IA, edi ; the_start_data
  000c0	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, edi ; the_data
  000c6	0f 85 cb 00 00
	00		 jne	 $LN114@test_miss
  000cc	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_log@@3HA, edi ; the_log
  000d2	75 2f		 jne	 SHORT $LN146@test_miss
  000d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  000df	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  000e6	52		 push	 edx
  000e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  000ed	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  000f4	51		 push	 ecx
  000f5	50		 push	 eax
  000f6	68 00 00 00 00	 push	 OFFSET $SG-100
  000fb	e8 00 00 00 00	 call	 _printf
  00100	83 c4 10	 add	 esp, 16			; 00000010H
$LN146@test_miss:
  00103	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00108	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0010d	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00113	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00119	76 7c		 jbe	 SHORT $LN114@test_miss
  0011b	eb 03 8d 49 00	 npad	 5
$LL116@test_miss:

; 1287 : 		unsigned key = SEARCH[i] + DELTA;

  00120	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]

; 1288 : 		unsigned hash_key = hash(key);

  00123	8b ca		 mov	 ecx, edx
  00125	c1 e1 06	 shl	 ecx, 6
  00128	8b c2		 mov	 eax, edx
  0012a	2b c1		 sub	 eax, ecx
  0012c	8b c8		 mov	 ecx, eax
  0012e	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00131	33 c1		 xor	 eax, ecx
  00133	8b c8		 mov	 ecx, eax
  00135	c1 e1 09	 shl	 ecx, 9
  00138	2b c1		 sub	 eax, ecx

; 1289 : 		struct hashtable_object* obj;
; 1290 : 		obj = (struct hashtable_object*)tommy_hashtable_search(&hashtable, tommy_hashtable_compare, &key, hash_key);

  0013a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00140	8b c8		 mov	 ecx, eax
  00142	c1 e1 04	 shl	 ecx, 4
  00145	33 c1		 xor	 eax, ecx
  00147	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0014e	2b c1		 sub	 eax, ecx
  00150	8b c8		 mov	 ecx, eax
  00152	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00155	33 c1		 xor	 eax, ecx
  00157	8b c8		 mov	 ecx, eax
  00159	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  0015c	33 c8		 xor	 ecx, eax
  0015e	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00163	23 c1		 and	 eax, ecx
  00165	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  00168	85 c0		 test	 eax, eax
  0016a	74 22		 je	 SHORT $LN115@test_miss
  0016c	8d 64 24 00	 npad	 4
$LL156@test_miss:
  00170	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00173	75 08		 jne	 SHORT $LN154@test_miss
  00175	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  00178	3b 53 10	 cmp	 edx, DWORD PTR [ebx+16]
  0017b	74 08		 je	 SHORT $LN962@test_miss
$LN154@test_miss:
  0017d	8b 00		 mov	 eax, DWORD PTR [eax]
  0017f	85 c0		 test	 eax, eax
  00181	75 ed		 jne	 SHORT $LL156@test_miss
  00183	eb 09		 jmp	 SHORT $LN115@test_miss
$LN962@test_miss:

; 1291 : 		if (obj)

  00185	85 db		 test	 ebx, ebx
  00187	74 05		 je	 SHORT $LN115@test_miss

; 1292 : 			abort();

  00189	e8 00 00 00 00	 call	 _abort
$LN115@test_miss:

; 1285 : 
; 1286 : 	START(DATA_HASHTABLE) {

  0018e	47		 inc	 edi
  0018f	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00195	72 89		 jb	 SHORT $LL116@test_miss
$LN114@test_miss:

; 1293 : 	} STOP();

  00197	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1294 : 
; 1295 : 	START(DATA_HASHDYN) {

  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  001a6	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  001ac	0f 85 38 01 00
	00		 jne	 $LN109@test_miss
  001b2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  001b9	75 30		 jne	 SHORT $LN164@test_miss
  001bb	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  001c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  001c7	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  001ce	51		 push	 ecx
  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  001d5	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  001dc	50		 push	 eax
  001dd	52		 push	 edx
  001de	68 00 00 00 00	 push	 OFFSET $SG-100
  001e3	e8 00 00 00 00	 call	 _printf
  001e8	83 c4 10	 add	 esp, 16			; 00000010H
$LN164@test_miss:
  001eb	8d 45 ec	 lea	 eax, DWORD PTR _t$195335[ebp]
  001ee	50		 push	 eax
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  001f5	85 c0		 test	 eax, eax
  001f7	75 11		 jne	 SHORT $LN170@test_miss
  001f9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  001fd	66 0f 13 45 ec	 movlpd	 QWORD PTR $T195328[ebp], xmm0
  00202	8b 5d f0	 mov	 ebx, DWORD PTR $T195328[ebp+4]
  00205	8b 7d ec	 mov	 edi, DWORD PTR $T195328[ebp]
  00208	eb 57		 jmp	 SHORT $LN171@test_miss
$LN170@test_miss:
  0020a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00210	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00216	8b 4d f0	 mov	 ecx, DWORD PTR _t$195335[ebp+4]
  00219	8b 55 ec	 mov	 edx, DWORD PTR _t$195335[ebp]
  0021c	57		 push	 edi
  0021d	56		 push	 esi
  0021e	51		 push	 ecx
  0021f	52		 push	 edx
  00220	e8 00 00 00 00	 call	 __alldvrm
  00225	6a 00		 push	 0
  00227	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0022c	53		 push	 ebx
  0022d	51		 push	 ecx
  0022e	89 45 ec	 mov	 DWORD PTR tv743[ebp], eax
  00231	89 55 f0	 mov	 DWORD PTR tv743[ebp+4], edx
  00234	e8 00 00 00 00	 call	 __allmul
  00239	57		 push	 edi
  0023a	56		 push	 esi
  0023b	52		 push	 edx
  0023c	50		 push	 eax
  0023d	e8 00 00 00 00	 call	 __alldiv
  00242	8b 4d ec	 mov	 ecx, DWORD PTR tv743[ebp]
  00245	6a 00		 push	 0
  00247	8b f8		 mov	 edi, eax
  00249	8b 45 f0	 mov	 eax, DWORD PTR tv743[ebp+4]
  0024c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00251	50		 push	 eax
  00252	51		 push	 ecx
  00253	8b da		 mov	 ebx, edx
  00255	e8 00 00 00 00	 call	 __allmul
  0025a	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  0025d	03 f8		 add	 edi, eax
  0025f	13 da		 adc	 ebx, edx
$LN171@test_miss:
  00261	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00267	33 ff		 xor	 edi, edi
  00269	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0026f	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00275	76 73		 jbe	 SHORT $LN109@test_miss
$LL111@test_miss:

; 1296 : 		unsigned key = SEARCH[i] + DELTA;

  00277	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]

; 1297 : 		unsigned hash_key = hash(key);

  0027a	8b ca		 mov	 ecx, edx
  0027c	c1 e1 06	 shl	 ecx, 6
  0027f	8b c2		 mov	 eax, edx
  00281	2b c1		 sub	 eax, ecx
  00283	8b c8		 mov	 ecx, eax
  00285	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00288	33 c1		 xor	 eax, ecx
  0028a	8b c8		 mov	 ecx, eax
  0028c	c1 e1 09	 shl	 ecx, 9
  0028f	2b c1		 sub	 eax, ecx

; 1298 : 		struct hashtable_object* obj;
; 1299 : 		obj = (struct hashtable_object*)tommy_hashdyn_search(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  00291	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00297	8b c8		 mov	 ecx, eax
  00299	c1 e1 04	 shl	 ecx, 4
  0029c	33 c1		 xor	 eax, ecx
  0029e	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  002a5	2b c1		 sub	 eax, ecx
  002a7	8b c8		 mov	 ecx, eax
  002a9	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  002ac	33 c1		 xor	 eax, ecx
  002ae	8b c8		 mov	 ecx, eax
  002b0	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  002b3	33 c8		 xor	 ecx, eax
  002b5	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  002ba	23 c1		 and	 eax, ecx
  002bc	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  002bf	85 c0		 test	 eax, eax
  002c1	74 1e		 je	 SHORT $LN110@test_miss
$LL177@test_miss:
  002c3	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  002c6	75 08		 jne	 SHORT $LN175@test_miss
  002c8	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  002cb	3b 53 10	 cmp	 edx, DWORD PTR [ebx+16]
  002ce	74 08		 je	 SHORT $LN963@test_miss
$LN175@test_miss:
  002d0	8b 00		 mov	 eax, DWORD PTR [eax]
  002d2	85 c0		 test	 eax, eax
  002d4	75 ed		 jne	 SHORT $LL177@test_miss
  002d6	eb 09		 jmp	 SHORT $LN110@test_miss
$LN963@test_miss:

; 1300 : 		if (obj)

  002d8	85 db		 test	 ebx, ebx
  002da	74 05		 je	 SHORT $LN110@test_miss

; 1301 : 			abort();

  002dc	e8 00 00 00 00	 call	 _abort
$LN110@test_miss:

; 1294 : 
; 1295 : 	START(DATA_HASHDYN) {

  002e1	47		 inc	 edi
  002e2	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  002e8	72 8d		 jb	 SHORT $LL111@test_miss
$LN109@test_miss:

; 1302 : 	} STOP();

  002ea	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1303 : 
; 1304 : 	START(DATA_HASHLIN) {

  002ef	b8 02 00 00 00	 mov	 eax, 2
  002f4	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  002f9	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  002ff	0f 85 87 01 00
	00		 jne	 $LN104@test_miss
  00305	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0030c	75 30		 jne	 SHORT $LN185@test_miss
  0030e	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  00314	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0031a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00321	51		 push	 ecx
  00322	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00328	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0032f	50		 push	 eax
  00330	52		 push	 edx
  00331	68 00 00 00 00	 push	 OFFSET $SG-100
  00336	e8 00 00 00 00	 call	 _printf
  0033b	83 c4 10	 add	 esp, 16			; 00000010H
$LN185@test_miss:
  0033e	8d 45 ec	 lea	 eax, DWORD PTR _t$195386[ebp]
  00341	50		 push	 eax
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00348	85 c0		 test	 eax, eax
  0034a	75 11		 jne	 SHORT $LN191@test_miss
  0034c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00350	66 0f 13 45 ec	 movlpd	 QWORD PTR $T195379[ebp], xmm0
  00355	8b 5d f0	 mov	 ebx, DWORD PTR $T195379[ebp+4]
  00358	8b 7d ec	 mov	 edi, DWORD PTR $T195379[ebp]
  0035b	eb 57		 jmp	 SHORT $LN192@test_miss
$LN191@test_miss:
  0035d	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00363	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00369	8b 4d f0	 mov	 ecx, DWORD PTR _t$195386[ebp+4]
  0036c	8b 55 ec	 mov	 edx, DWORD PTR _t$195386[ebp]
  0036f	57		 push	 edi
  00370	56		 push	 esi
  00371	51		 push	 ecx
  00372	52		 push	 edx
  00373	e8 00 00 00 00	 call	 __alldvrm
  00378	6a 00		 push	 0
  0037a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0037f	53		 push	 ebx
  00380	51		 push	 ecx
  00381	89 45 ec	 mov	 DWORD PTR tv818[ebp], eax
  00384	89 55 f0	 mov	 DWORD PTR tv818[ebp+4], edx
  00387	e8 00 00 00 00	 call	 __allmul
  0038c	57		 push	 edi
  0038d	56		 push	 esi
  0038e	52		 push	 edx
  0038f	50		 push	 eax
  00390	e8 00 00 00 00	 call	 __alldiv
  00395	8b 4d ec	 mov	 ecx, DWORD PTR tv818[ebp]
  00398	6a 00		 push	 0
  0039a	8b f8		 mov	 edi, eax
  0039c	8b 45 f0	 mov	 eax, DWORD PTR tv818[ebp+4]
  0039f	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003a4	50		 push	 eax
  003a5	51		 push	 ecx
  003a6	8b da		 mov	 ebx, edx
  003a8	e8 00 00 00 00	 call	 __allmul
  003ad	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  003b0	03 f8		 add	 edi, eax
  003b2	13 da		 adc	 ebx, edx
$LN192@test_miss:
  003b4	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  003ba	33 db		 xor	 ebx, ebx
  003bc	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  003c2	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  003c8	0f 86 be 00 00
	00		 jbe	 $LN104@test_miss
$LN106@test_miss:

; 1305 : 		unsigned key = SEARCH[i] + DELTA;

  003ce	8b 3c 9e	 mov	 edi, DWORD PTR [esi+ebx*4]

; 1306 : 		unsigned hash_key = hash(key);

  003d1	8b d7		 mov	 edx, edi
  003d3	c1 e2 06	 shl	 edx, 6
  003d6	8b c7		 mov	 eax, edi
  003d8	2b c2		 sub	 eax, edx
  003da	8b c8		 mov	 ecx, eax
  003dc	c1 e9 11	 shr	 ecx, 17			; 00000011H
  003df	33 c1		 xor	 eax, ecx
  003e1	8b d0		 mov	 edx, eax
  003e3	c1 e2 09	 shl	 edx, 9
  003e6	2b c2		 sub	 eax, edx
  003e8	8b c8		 mov	 ecx, eax
  003ea	c1 e1 04	 shl	 ecx, 4
  003ed	33 c1		 xor	 eax, ecx
  003ef	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  003f6	2b c2		 sub	 eax, edx
  003f8	8b c8		 mov	 ecx, eax
  003fa	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  003fd	33 c1		 xor	 eax, ecx
  003ff	8b d0		 mov	 edx, eax
  00401	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00404	33 d0		 xor	 edx, eax

; 1307 : 		struct hashtable_object* obj;
; 1308 : 		obj = (struct hashtable_object*)tommy_hashlin_search(&hashlin, tommy_hashtable_compare, &key, hash_key);

  00406	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  0040d	74 1c		 je	 SHORT $LN203@test_miss
  0040f	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  00414	23 c2		 and	 eax, edx
  00416	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  0041c	72 0d		 jb	 SHORT $LN203@test_miss
  0041e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00421	73 1c		 jae	 SHORT $LN212@test_miss
  00423	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00429	eb 2d		 jmp	 SHORT $LN1051@test_miss
$LN203@test_miss:
  0042b	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00430	23 c2		 and	 eax, edx
  00432	83 f8 40	 cmp	 eax, 64			; 00000040H
  00435	73 08		 jae	 SHORT $LN212@test_miss
  00437	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  0043d	eb 19		 jmp	 SHORT $LN1051@test_miss
$LN212@test_miss:
  0043f	0f bd c8	 bsr	 ecx, eax
  00442	be 01 00 00 00	 mov	 esi, 1
  00447	d3 e6		 shl	 esi, cl
  00449	89 4d f0	 mov	 DWORD PTR _count$195500[ebp], ecx
  0044c	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  00453	2b c6		 sub	 eax, esi
  00455	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
$LN1051@test_miss:
  00458	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0045b	8b 00		 mov	 eax, DWORD PTR [eax]
  0045d	85 c0		 test	 eax, eax
  0045f	74 1e		 je	 SHORT $LN105@test_miss
$LL198@test_miss:
  00461	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00464	75 08		 jne	 SHORT $LN196@test_miss
  00466	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00469	3b 79 10	 cmp	 edi, DWORD PTR [ecx+16]
  0046c	74 08		 je	 SHORT $LN964@test_miss
$LN196@test_miss:
  0046e	8b 00		 mov	 eax, DWORD PTR [eax]
  00470	85 c0		 test	 eax, eax
  00472	75 ed		 jne	 SHORT $LL198@test_miss
  00474	eb 09		 jmp	 SHORT $LN105@test_miss
$LN964@test_miss:

; 1309 : 		if (obj)

  00476	85 c9		 test	 ecx, ecx
  00478	74 05		 je	 SHORT $LN105@test_miss

; 1310 : 			abort();

  0047a	e8 00 00 00 00	 call	 _abort
$LN105@test_miss:

; 1303 : 
; 1304 : 	START(DATA_HASHLIN) {

  0047f	43		 inc	 ebx
  00480	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00486	0f 82 42 ff ff
	ff		 jb	 $LN106@test_miss
$LN104@test_miss:

; 1311 : 	} STOP();

  0048c	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1312 : 
; 1313 : 	START(DATA_TRIE) {

  00491	b8 03 00 00 00	 mov	 eax, 3
  00496	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0049b	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  004a1	0f 85 12 01 00
	00		 jne	 $LN99@test_miss
  004a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  004ae	75 2f		 jne	 SHORT $LN220@test_miss
  004b0	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  004b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  004bb	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  004c2	52		 push	 edx
  004c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  004c9	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  004d0	51		 push	 ecx
  004d1	50		 push	 eax
  004d2	68 00 00 00 00	 push	 OFFSET $SG-100
  004d7	e8 00 00 00 00	 call	 _printf
  004dc	83 c4 10	 add	 esp, 16			; 00000010H
$LN220@test_miss:
  004df	8d 4d ec	 lea	 ecx, DWORD PTR _t$195523[ebp]
  004e2	51		 push	 ecx
  004e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  004e9	85 c0		 test	 eax, eax
  004eb	75 11		 jne	 SHORT $LN226@test_miss
  004ed	66 0f 57 c0	 xorpd	 xmm0, xmm0
  004f1	66 0f 13 45 ec	 movlpd	 QWORD PTR $T195517[ebp], xmm0
  004f6	8b 5d f0	 mov	 ebx, DWORD PTR $T195517[ebp+4]
  004f9	8b 7d ec	 mov	 edi, DWORD PTR $T195517[ebp]
  004fc	eb 57		 jmp	 SHORT $LN227@test_miss
$LN226@test_miss:
  004fe	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00504	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0050a	8b 55 f0	 mov	 edx, DWORD PTR _t$195523[ebp+4]
  0050d	8b 45 ec	 mov	 eax, DWORD PTR _t$195523[ebp]
  00510	57		 push	 edi
  00511	56		 push	 esi
  00512	52		 push	 edx
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 __alldvrm
  00519	6a 00		 push	 0
  0051b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00520	53		 push	 ebx
  00521	51		 push	 ecx
  00522	89 45 ec	 mov	 DWORD PTR tv170[ebp], eax
  00525	89 55 f0	 mov	 DWORD PTR tv170[ebp+4], edx
  00528	e8 00 00 00 00	 call	 __allmul
  0052d	57		 push	 edi
  0052e	56		 push	 esi
  0052f	52		 push	 edx
  00530	50		 push	 eax
  00531	e8 00 00 00 00	 call	 __alldiv
  00536	8b 4d f0	 mov	 ecx, DWORD PTR tv170[ebp+4]
  00539	6a 00		 push	 0
  0053b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00540	8b da		 mov	 ebx, edx
  00542	8b 55 ec	 mov	 edx, DWORD PTR tv170[ebp]
  00545	51		 push	 ecx
  00546	52		 push	 edx
  00547	8b f8		 mov	 edi, eax
  00549	e8 00 00 00 00	 call	 __allmul
  0054e	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  00551	03 f8		 add	 edi, eax
  00553	13 da		 adc	 ebx, edx
$LN227@test_miss:
  00555	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  0055b	33 ff		 xor	 edi, edi
  0055d	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00563	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00569	76 4e		 jbe	 SHORT $LN99@test_miss
  0056b	eb 03 8d 49 00	 npad	 5
$LL101@test_miss:

; 1314 : 		struct trie_object* obj;
; 1315 : 		obj = (struct trie_object*)tommy_trie_search(&trie, SEARCH[i] + DELTA);

  00570	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]
  00573	8b c2		 mov	 eax, edx
  00575	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  00578	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  0057f	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  00584	85 c0		 test	 eax, eax
  00586	74 28		 je	 SHORT $LN100@test_miss
$recurse$195554:
  00588	a8 01		 test	 al, 1
  0058a	74 14		 je	 SHORT $LN234@test_miss
  0058c	8b da		 mov	 ebx, edx
  0058e	d3 eb		 shr	 ebx, cl
  00590	83 e9 03	 sub	 ecx, 3
  00593	83 e3 07	 and	 ebx, 7
  00596	8b 44 98 ff	 mov	 eax, DWORD PTR [eax+ebx*4-1]
  0059a	85 c0		 test	 eax, eax
  0059c	75 ea		 jne	 SHORT $recurse$195554
  0059e	eb 10		 jmp	 SHORT $LN100@test_miss
$LN234@test_miss:
  005a0	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  005a3	75 0b		 jne	 SHORT $LN100@test_miss

; 1316 : 		if (obj)

  005a5	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  005a9	74 05		 je	 SHORT $LN100@test_miss

; 1317 : 			abort();

  005ab	e8 00 00 00 00	 call	 _abort
$LN100@test_miss:

; 1312 : 
; 1313 : 	START(DATA_TRIE) {

  005b0	47		 inc	 edi
  005b1	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  005b7	72 b7		 jb	 SHORT $LL101@test_miss
$LN99@test_miss:

; 1318 : 	} STOP();

  005b9	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1319 : 
; 1320 : 	START(DATA_TRIE_INPLACE) {

  005be	b8 04 00 00 00	 mov	 eax, 4
  005c3	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  005c8	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  005ce	0f 85 15 01 00
	00		 jne	 $LN94@test_miss
  005d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  005db	75 30		 jne	 SHORT $LN240@test_miss
  005dd	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  005e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  005e9	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  005f0	51		 push	 ecx
  005f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  005f7	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  005fe	50		 push	 eax
  005ff	52		 push	 edx
  00600	68 00 00 00 00	 push	 OFFSET $SG-100
  00605	e8 00 00 00 00	 call	 _printf
  0060a	83 c4 10	 add	 esp, 16			; 00000010H
$LN240@test_miss:
  0060d	8d 45 ec	 lea	 eax, DWORD PTR _t$195582[ebp]
  00610	50		 push	 eax
  00611	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00617	85 c0		 test	 eax, eax
  00619	75 11		 jne	 SHORT $LN246@test_miss
  0061b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0061f	66 0f 13 45 ec	 movlpd	 QWORD PTR $T195573[ebp], xmm0
  00624	8b 5d f0	 mov	 ebx, DWORD PTR $T195573[ebp+4]
  00627	8b 7d ec	 mov	 edi, DWORD PTR $T195573[ebp]
  0062a	eb 57		 jmp	 SHORT $LN247@test_miss
$LN246@test_miss:
  0062c	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00632	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00638	8b 4d f0	 mov	 ecx, DWORD PTR _t$195582[ebp+4]
  0063b	8b 55 ec	 mov	 edx, DWORD PTR _t$195582[ebp]
  0063e	57		 push	 edi
  0063f	56		 push	 esi
  00640	51		 push	 ecx
  00641	52		 push	 edx
  00642	e8 00 00 00 00	 call	 __alldvrm
  00647	6a 00		 push	 0
  00649	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0064e	53		 push	 ebx
  0064f	51		 push	 ecx
  00650	89 45 ec	 mov	 DWORD PTR tv175[ebp], eax
  00653	89 55 f0	 mov	 DWORD PTR tv175[ebp+4], edx
  00656	e8 00 00 00 00	 call	 __allmul
  0065b	57		 push	 edi
  0065c	56		 push	 esi
  0065d	52		 push	 edx
  0065e	50		 push	 eax
  0065f	e8 00 00 00 00	 call	 __alldiv
  00664	8b 4d ec	 mov	 ecx, DWORD PTR tv175[ebp]
  00667	6a 00		 push	 0
  00669	8b f8		 mov	 edi, eax
  0066b	8b 45 f0	 mov	 eax, DWORD PTR tv175[ebp+4]
  0066e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00673	50		 push	 eax
  00674	51		 push	 ecx
  00675	8b da		 mov	 ebx, edx
  00677	e8 00 00 00 00	 call	 __allmul
  0067c	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  0067f	03 f8		 add	 edi, eax
  00681	13 da		 adc	 ebx, edx
$LN247@test_miss:
  00683	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00689	33 ff		 xor	 edi, edi
  0068b	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00691	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00697	76 50		 jbe	 SHORT $LN94@test_miss
  00699	8d a4 24 00 00
	00 00		 npad	 7
$LL96@test_miss:

; 1321 : 		struct trie_inplace_object* obj;
; 1322 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_search(&trie_inplace, SEARCH[i] + DELTA);

  006a0	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]
  006a3	8b c2		 mov	 eax, edx
  006a5	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  006a8	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]
  006af	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  006b4	85 c0		 test	 eax, eax
  006b6	74 28		 je	 SHORT $LN95@test_miss
$LN253@test_miss:
  006b8	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  006bb	74 14		 je	 SHORT $LN252@test_miss
  006bd	8b da		 mov	 ebx, edx
  006bf	d3 eb		 shr	 ebx, cl
  006c1	83 e9 02	 sub	 ecx, 2
  006c4	83 e3 03	 and	 ebx, 3
  006c7	8b 44 98 10	 mov	 eax, DWORD PTR [eax+ebx*4+16]
  006cb	85 c0		 test	 eax, eax
  006cd	75 e9		 jne	 SHORT $LN253@test_miss
  006cf	eb 0f		 jmp	 SHORT $LN95@test_miss
$LN252@test_miss:
  006d1	85 c0		 test	 eax, eax
  006d3	74 0b		 je	 SHORT $LN95@test_miss

; 1323 : 		if (obj)

  006d5	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  006d9	74 05		 je	 SHORT $LN95@test_miss

; 1324 : 			abort();

  006db	e8 00 00 00 00	 call	 _abort
$LN95@test_miss:

; 1319 : 
; 1320 : 	START(DATA_TRIE_INPLACE) {

  006e0	47		 inc	 edi
  006e1	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  006e7	72 b7		 jb	 SHORT $LL96@test_miss
$LN94@test_miss:

; 1325 : 	} STOP();

  006e9	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1326 : 
; 1327 : 	START(DATA_KHASH) {

  006ee	b8 07 00 00 00	 mov	 eax, 7
  006f3	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  006f8	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  006fe	0f 85 23 01 00
	00		 jne	 $LN89@test_miss
  00704	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0070b	75 30		 jne	 SHORT $LN256@test_miss
  0070d	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00713	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00719	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00720	51		 push	 ecx
  00721	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00727	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0072e	50		 push	 eax
  0072f	52		 push	 edx
  00730	68 00 00 00 00	 push	 OFFSET $SG-100
  00735	e8 00 00 00 00	 call	 _printf
  0073a	83 c4 10	 add	 esp, 16			; 00000010H
$LN256@test_miss:
  0073d	8d 45 f4	 lea	 eax, DWORD PTR _t$195622[ebp]
  00740	50		 push	 eax
  00741	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00747	85 c0		 test	 eax, eax
  00749	75 11		 jne	 SHORT $LN262@test_miss
  0074b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0074f	66 0f 13 45 ec	 movlpd	 QWORD PTR $T195615[ebp], xmm0
  00754	8b 5d f0	 mov	 ebx, DWORD PTR $T195615[ebp+4]
  00757	8b 7d ec	 mov	 edi, DWORD PTR $T195615[ebp]
  0075a	eb 57		 jmp	 SHORT $LN263@test_miss
$LN262@test_miss:
  0075c	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00762	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00768	8b 4d f8	 mov	 ecx, DWORD PTR _t$195622[ebp+4]
  0076b	8b 55 f4	 mov	 edx, DWORD PTR _t$195622[ebp]
  0076e	57		 push	 edi
  0076f	56		 push	 esi
  00770	51		 push	 ecx
  00771	52		 push	 edx
  00772	e8 00 00 00 00	 call	 __alldvrm
  00777	6a 00		 push	 0
  00779	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0077e	53		 push	 ebx
  0077f	51		 push	 ecx
  00780	89 45 ec	 mov	 DWORD PTR tv2817[ebp], eax
  00783	89 55 f0	 mov	 DWORD PTR tv2817[ebp+4], edx
  00786	e8 00 00 00 00	 call	 __allmul
  0078b	57		 push	 edi
  0078c	56		 push	 esi
  0078d	52		 push	 edx
  0078e	50		 push	 eax
  0078f	e8 00 00 00 00	 call	 __alldiv
  00794	8b 4d ec	 mov	 ecx, DWORD PTR tv2817[ebp]
  00797	6a 00		 push	 0
  00799	8b f8		 mov	 edi, eax
  0079b	8b 45 f0	 mov	 eax, DWORD PTR tv2817[ebp+4]
  0079e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007a3	50		 push	 eax
  007a4	51		 push	 ecx
  007a5	8b da		 mov	 ebx, edx
  007a7	e8 00 00 00 00	 call	 __allmul
  007ac	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  007af	03 f8		 add	 edi, eax
  007b1	13 da		 adc	 ebx, edx
$LN263@test_miss:
  007b3	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  007b9	33 ff		 xor	 edi, edi
  007bb	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  007c1	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  007c7	76 5e		 jbe	 SHORT $LN89@test_miss
  007c9	8d a4 24 00 00
	00 00		 npad	 7
$LL91@test_miss:

; 1328 : 		unsigned key = SEARCH[i] + DELTA;
; 1329 : 		unsigned hash_key = hash(key);

  007d0	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]
  007d3	8b d0		 mov	 edx, eax
  007d5	c1 e2 06	 shl	 edx, 6
  007d8	2b c2		 sub	 eax, edx
  007da	8b c8		 mov	 ecx, eax
  007dc	c1 e9 11	 shr	 ecx, 17			; 00000011H
  007df	33 c1		 xor	 eax, ecx
  007e1	8b d0		 mov	 edx, eax
  007e3	c1 e2 09	 shl	 edx, 9
  007e6	2b c2		 sub	 eax, edx
  007e8	8b c8		 mov	 ecx, eax
  007ea	c1 e1 04	 shl	 ecx, 4
  007ed	33 c1		 xor	 eax, ecx
  007ef	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  007f6	2b c2		 sub	 eax, edx
  007f8	8b c8		 mov	 ecx, eax
  007fa	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  007fd	33 c1		 xor	 eax, ecx
  007ff	8b d0		 mov	 edx, eax
  00801	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00804	33 d0		 xor	 edx, eax

; 1330 : 		khiter_t k;
; 1331 : 		k = kh_get(word, khash, hash_key);

  00806	52		 push	 edx
  00807	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word

; 1332 : 		if (k != kh_end(khash))

  0080c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00812	83 c4 04	 add	 esp, 4
  00815	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00817	74 05		 je	 SHORT $LN90@test_miss

; 1333 : 			abort();

  00819	e8 00 00 00 00	 call	 _abort
$LN90@test_miss:

; 1326 : 
; 1327 : 	START(DATA_KHASH) {

  0081e	47		 inc	 edi
  0081f	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00825	72 a9		 jb	 SHORT $LL91@test_miss
$LN89@test_miss:

; 1334 : 	} STOP();

  00827	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1335 : 
; 1336 : #ifdef USE_CGOOGLEDENSEHASH
; 1337 : 	START(DATA_CGOOGLE) {
; 1338 : 		unsigned key = SEARCH[i] + DELTA;
; 1339 : 		HTItem* ptr;
; 1340 : 		ptr = HashFind(cgoogledensehash, key);
; 1341 : 		if (ptr)
; 1342 : 			abort();
; 1343 : 	} STOP();
; 1344 : #endif
; 1345 : 
; 1346 : #ifdef USE_GOOGLEDENSEHASH
; 1347 : 	START(DATA_GOOGLEDENSEHASH) {

  0082c	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00831	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00836	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0083c	0f 85 ac 01 00
	00		 jne	 $LN84@test_miss
  00842	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00849	75 2f		 jne	 SHORT $LN267@test_miss
  0084b	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  00851	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00856	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0085d	52		 push	 edx
  0085e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00864	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0086b	51		 push	 ecx
  0086c	50		 push	 eax
  0086d	68 00 00 00 00	 push	 OFFSET $SG-100
  00872	e8 00 00 00 00	 call	 _printf
  00877	83 c4 10	 add	 esp, 16			; 00000010H
$LN267@test_miss:
  0087a	8d 4d e4	 lea	 ecx, DWORD PTR _t$195649[ebp]
  0087d	51		 push	 ecx
  0087e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00884	85 c0		 test	 eax, eax
  00886	75 11		 jne	 SHORT $LN273@test_miss
  00888	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0088c	66 0f 13 45 ec	 movlpd	 QWORD PTR $T195642[ebp], xmm0
  00891	8b 5d f0	 mov	 ebx, DWORD PTR $T195642[ebp+4]
  00894	8b 7d ec	 mov	 edi, DWORD PTR $T195642[ebp]
  00897	eb 57		 jmp	 SHORT $LN274@test_miss
$LN273@test_miss:
  00899	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0089f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  008a5	8b 55 e8	 mov	 edx, DWORD PTR _t$195649[ebp+4]
  008a8	8b 45 e4	 mov	 eax, DWORD PTR _t$195649[ebp]
  008ab	57		 push	 edi
  008ac	56		 push	 esi
  008ad	52		 push	 edx
  008ae	50		 push	 eax
  008af	e8 00 00 00 00	 call	 __alldvrm
  008b4	6a 00		 push	 0
  008b6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  008bb	53		 push	 ebx
  008bc	51		 push	 ecx
  008bd	89 45 ec	 mov	 DWORD PTR tv1075[ebp], eax
  008c0	89 55 f0	 mov	 DWORD PTR tv1075[ebp+4], edx
  008c3	e8 00 00 00 00	 call	 __allmul
  008c8	57		 push	 edi
  008c9	56		 push	 esi
  008ca	52		 push	 edx
  008cb	50		 push	 eax
  008cc	e8 00 00 00 00	 call	 __alldiv
  008d1	8b 4d f0	 mov	 ecx, DWORD PTR tv1075[ebp+4]
  008d4	6a 00		 push	 0
  008d6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  008db	8b da		 mov	 ebx, edx
  008dd	8b 55 ec	 mov	 edx, DWORD PTR tv1075[ebp]
  008e0	51		 push	 ecx
  008e1	52		 push	 edx
  008e2	8b f8		 mov	 edi, eax
  008e4	e8 00 00 00 00	 call	 __allmul
  008e9	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  008ec	03 f8		 add	 edi, eax
  008ee	13 da		 adc	 ebx, edx
$LN274@test_miss:
  008f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  008f7	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  008fd	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00903	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0090a	0f 86 de 00 00
	00		 jbe	 $LN84@test_miss
  00910	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN86@test_miss:

; 1348 : 		unsigned key = SEARCH[i] + DELTA;

  00916	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 1349 : 		googledensehash_t::const_iterator ptr = googledensehash->find(key);

  00919	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
  0091c	2b 57 20	 sub	 edx, DWORD PTR [edi+32]
  0091f	8b 0c 86	 mov	 ecx, DWORD PTR [esi+eax*4]
  00922	89 4d f0	 mov	 DWORD PTR _key$149526[ebp], ecx
  00925	75 33		 jne	 SHORT $LN280@test_miss
  00927	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0092a	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0092d	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00930	8b c2		 mov	 eax, edx
  00932	3b c2		 cmp	 eax, edx
  00934	74 6a		 je	 SHORT $LL394@test_miss
  00936	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  00939	8d a4 24 00 00
	00 00		 npad	 7
$LL292@test_miss:
  00940	8b 08		 mov	 ecx, DWORD PTR [eax]
  00942	3b d9		 cmp	 ebx, ecx
  00944	74 0b		 je	 SHORT $LN290@test_miss
  00946	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0094a	76 54		 jbe	 SHORT $LL394@test_miss
  0094c	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  0094f	75 4f		 jne	 SHORT $LL394@test_miss
$LN290@test_miss:
  00951	83 c0 08	 add	 eax, 8
  00954	3b c2		 cmp	 eax, edx
  00956	75 e8		 jne	 SHORT $LL292@test_miss
  00958	eb 46		 jmp	 SHORT $LL394@test_miss
$LN280@test_miss:
  0095a	8d 55 dc	 lea	 edx, DWORD PTR _pos$196791[ebp]
  0095d	52		 push	 edx
  0095e	8d 45 f0	 lea	 eax, DWORD PTR _key$149526[ebp]
  00961	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00966	8b 45 dc	 mov	 eax, DWORD PTR _pos$196791[ebp]
  00969	83 f8 ff	 cmp	 eax, -1
  0096c	75 2c		 jne	 SHORT $LN279@test_miss
  0096e	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00971	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00974	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00977	8b c2		 mov	 eax, edx
  00979	3b c2		 cmp	 eax, edx
  0097b	74 23		 je	 SHORT $LL394@test_miss
  0097d	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
$LL344@test_miss:
  00980	8b 08		 mov	 ecx, DWORD PTR [eax]
  00982	3b d9		 cmp	 ebx, ecx
  00984	74 0b		 je	 SHORT $LN342@test_miss
  00986	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0098a	76 14		 jbe	 SHORT $LL394@test_miss
  0098c	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  0098f	75 0f		 jne	 SHORT $LL394@test_miss
$LN342@test_miss:
  00991	83 c0 08	 add	 eax, 8
  00994	3b c2		 cmp	 eax, edx
  00996	75 e8		 jne	 SHORT $LL344@test_miss
  00998	eb 06		 jmp	 SHORT $LL394@test_miss
$LN279@test_miss:
  0099a	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  0099d	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
$LL394@test_miss:

; 1350 : 		if (ptr != googledensehash->end())

  009a0	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  009a3	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  009a6	8d 1c ca	 lea	 ebx, DWORD PTR [edx+ecx*8]
  009a9	8b cb		 mov	 ecx, ebx
  009ab	3b cb		 cmp	 ecx, ebx
  009ad	74 1d		 je	 SHORT $LN487@test_miss
  009af	90		 npad	 1
$LL450@test_miss:
  009b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  009b2	39 57 2c	 cmp	 DWORD PTR [edi+44], edx
  009b5	74 0b		 je	 SHORT $LN448@test_miss
  009b7	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  009bb	76 0c		 jbe	 SHORT $LN1039@test_miss
  009bd	39 57 1c	 cmp	 DWORD PTR [edi+28], edx
  009c0	75 07		 jne	 SHORT $LN1039@test_miss
$LN448@test_miss:
  009c2	83 c1 08	 add	 ecx, 8
  009c5	3b cb		 cmp	 ecx, ebx
  009c7	75 e7		 jne	 SHORT $LL450@test_miss
$LN1039@test_miss:
  009c9	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
$LN487@test_miss:
  009cc	3b c1		 cmp	 eax, ecx
  009ce	74 0b		 je	 SHORT $LN85@test_miss

; 1351 : 			abort();

  009d0	e8 00 00 00 00	 call	 _abort
  009d5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN85@test_miss:

; 1335 : 
; 1336 : #ifdef USE_CGOOGLEDENSEHASH
; 1337 : 	START(DATA_CGOOGLE) {
; 1338 : 		unsigned key = SEARCH[i] + DELTA;
; 1339 : 		HTItem* ptr;
; 1340 : 		ptr = HashFind(cgoogledensehash, key);
; 1341 : 		if (ptr)
; 1342 : 			abort();
; 1343 : 	} STOP();
; 1344 : #endif
; 1345 : 
; 1346 : #ifdef USE_GOOGLEDENSEHASH
; 1347 : 	START(DATA_GOOGLEDENSEHASH) {

  009db	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  009de	40		 inc	 eax
  009df	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  009e2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  009e8	0f 82 28 ff ff
	ff		 jb	 $LN86@test_miss
$LN84@test_miss:

; 1352 : 	} STOP();

  009ee	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1353 : #endif
; 1354 : 
; 1355 : #ifdef USE_GOOGLEBTREE
; 1356 : 	START(DATA_GOOGLEBTREE) {

  009f3	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  009f8	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  009fd	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00a03	0f 85 fc 01 00
	00		 jne	 $LN79@test_miss
  00a09	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00a10	75 2e		 jne	 SHORT $LN499@test_miss
  00a12	a1 30 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  00a17	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00a1d	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00a24	50		 push	 eax
  00a25	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00a2a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00a31	52		 push	 edx
  00a32	51		 push	 ecx
  00a33	68 00 00 00 00	 push	 OFFSET $SG-100
  00a38	e8 00 00 00 00	 call	 _printf
  00a3d	83 c4 10	 add	 esp, 16			; 00000010H
$LN499@test_miss:
  00a40	8d 55 dc	 lea	 edx, DWORD PTR _t$197282[ebp]
  00a43	52		 push	 edx
  00a44	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00a4a	85 c0		 test	 eax, eax
  00a4c	75 11		 jne	 SHORT $LN505@test_miss
  00a4e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00a52	66 0f 13 45 e4	 movlpd	 QWORD PTR $T197275[ebp], xmm0
  00a57	8b 5d e8	 mov	 ebx, DWORD PTR $T197275[ebp+4]
  00a5a	8b 7d e4	 mov	 edi, DWORD PTR $T197275[ebp]
  00a5d	eb 54		 jmp	 SHORT $LN506@test_miss
$LN505@test_miss:
  00a5f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00a65	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00a6b	8b 45 e0	 mov	 eax, DWORD PTR _t$197282[ebp+4]
  00a6e	8b 4d dc	 mov	 ecx, DWORD PTR _t$197282[ebp]
  00a71	57		 push	 edi
  00a72	56		 push	 esi
  00a73	50		 push	 eax
  00a74	51		 push	 ecx
  00a75	e8 00 00 00 00	 call	 __alldvrm
  00a7a	6a 00		 push	 0
  00a7c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a81	53		 push	 ebx
  00a82	51		 push	 ecx
  00a83	89 45 ec	 mov	 DWORD PTR tv1389[ebp], eax
  00a86	89 55 f0	 mov	 DWORD PTR tv1389[ebp+4], edx
  00a89	e8 00 00 00 00	 call	 __allmul
  00a8e	57		 push	 edi
  00a8f	56		 push	 esi
  00a90	52		 push	 edx
  00a91	50		 push	 eax
  00a92	e8 00 00 00 00	 call	 __alldiv
  00a97	6a 00		 push	 0
  00a99	8b da		 mov	 ebx, edx
  00a9b	8b 55 f0	 mov	 edx, DWORD PTR tv1389[ebp+4]
  00a9e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00aa3	8b f8		 mov	 edi, eax
  00aa5	8b 45 ec	 mov	 eax, DWORD PTR tv1389[ebp]
  00aa8	52		 push	 edx
  00aa9	50		 push	 eax
  00aaa	e8 00 00 00 00	 call	 __allmul
  00aaf	03 f8		 add	 edi, eax
  00ab1	13 da		 adc	 ebx, edx
$LN506@test_miss:
  00ab3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00aba	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00ac0	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00ac6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00acd	0f 86 32 01 00
	00		 jbe	 $LN79@test_miss
$LN81@test_miss:

; 1357 : 		unsigned key = SEARCH[i] + DELTA;
; 1358 : 		googlebtree_t::const_iterator ptr = googlebtree->find(key);

  00ad3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00ad8	8b 18		 mov	 ebx, DWORD PTR [eax]
  00ada	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  00add	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00ae0	8b 34 91	 mov	 esi, DWORD PTR [ecx+edx*4]
  00ae3	85 db		 test	 ebx, ebx
  00ae5	74 73		 je	 SHORT $LN637@test_miss
  00ae7	8b cb		 mov	 ecx, ebx
  00ae9	8d a4 24 00 00
	00 00		 npad	 7
$LL534@test_miss:
  00af0	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00af4	33 c0		 xor	 eax, eax
  00af6	85 ff		 test	 edi, edi
  00af8	7e 12		 jle	 SHORT $LN966@test_miss
  00afa	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00afd	8d 49 00	 npad	 3
$LL549@test_miss:
  00b00	39 32		 cmp	 DWORD PTR [edx], esi
  00b02	73 08		 jae	 SHORT $LN966@test_miss
  00b04	40		 inc	 eax
  00b05	83 c2 08	 add	 edx, 8
  00b08	3b c7		 cmp	 eax, edi
  00b0a	7c f4		 jl	 SHORT $LL549@test_miss
$LN966@test_miss:
  00b0c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00b0f	75 0f		 jne	 SHORT $LL967@test_miss
  00b11	8b 8c 81 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+256]
  00b18	eb d6		 jmp	 SHORT $LL534@test_miss
  00b1a	8d 9b 00 00 00
	00		 npad	 6
$LL967@test_miss:
  00b20	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00b24	3b c2		 cmp	 eax, edx
  00b26	75 1d		 jne	 SHORT $LN591@test_miss
  00b28	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00b2c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00b2f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00b32	74 ec		 je	 SHORT $LL967@test_miss
$LN627@test_miss:
  00b34	85 db		 test	 ebx, ebx
  00b36	74 22		 je	 SHORT $LN637@test_miss
  00b38	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00b3b	75 1d		 jne	 SHORT $LN637@test_miss
  00b3d	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00b43	eb 17		 jmp	 SHORT $LN649@test_miss
$LN591@test_miss:
  00b45	85 c9		 test	 ecx, ecx
  00b47	74 eb		 je	 SHORT $LN627@test_miss
  00b49	3b 74 c1 08	 cmp	 esi, DWORD PTR [ecx+eax*8+8]
  00b4d	72 e5		 jb	 SHORT $LN627@test_miss
  00b4f	89 45 e8	 mov	 DWORD PTR $T198487[ebp+4], eax
  00b52	89 4d e4	 mov	 DWORD PTR $T198487[ebp], ecx
  00b55	8d 45 e4	 lea	 eax, DWORD PTR $T198487[ebp]
  00b58	eb 41		 jmp	 SHORT $LN628@test_miss
$LN637@test_miss:
  00b5a	8b c3		 mov	 eax, ebx
$LN649@test_miss:
  00b5c	85 c0		 test	 eax, eax
  00b5e	74 1d		 je	 SHORT $LN633@test_miss
  00b60	85 db		 test	 ebx, ebx
  00b62	74 11		 je	 SHORT $LN653@test_miss
  00b64	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00b67	75 0c		 jne	 SHORT $LN653@test_miss
  00b69	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00b6f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00b73	eb 0a		 jmp	 SHORT $LN634@test_miss
$LN653@test_miss:
  00b75	8b c3		 mov	 eax, ebx
  00b77	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00b7b	eb 02		 jmp	 SHORT $LN634@test_miss
$LN633@test_miss:
  00b7d	33 c9		 xor	 ecx, ecx
$LN634@test_miss:
  00b7f	85 db		 test	 ebx, ebx
  00b81	74 0d		 je	 SHORT $LN671@test_miss
  00b83	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00b86	75 08		 jne	 SHORT $LN671@test_miss
  00b88	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00b8e	eb 02		 jmp	 SHORT $LN683@test_miss
$LN671@test_miss:
  00b90	8b c3		 mov	 eax, ebx
$LN683@test_miss:
  00b92	89 45 ec	 mov	 DWORD PTR $T198488[ebp], eax
  00b95	89 4d f0	 mov	 DWORD PTR $T198488[ebp+4], ecx
  00b98	8d 45 ec	 lea	 eax, DWORD PTR $T198488[ebp]
$LN628@test_miss:
  00b9b	8b 10		 mov	 edx, DWORD PTR [eax]
  00b9d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1359 : 		if (ptr != googlebtree->end())

  00ba0	85 db		 test	 ebx, ebx
  00ba2	74 0d		 je	 SHORT $LN699@test_miss
  00ba4	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00ba7	75 08		 jne	 SHORT $LN699@test_miss
  00ba9	8b 8b 80 01 00
	00		 mov	 ecx, DWORD PTR [ebx+384]
  00baf	eb 02		 jmp	 SHORT $LN711@test_miss
$LN699@test_miss:
  00bb1	8b cb		 mov	 ecx, ebx
$LN711@test_miss:
  00bb3	85 c9		 test	 ecx, ecx
  00bb5	74 1d		 je	 SHORT $LN695@test_miss
  00bb7	85 db		 test	 ebx, ebx
  00bb9	74 11		 je	 SHORT $LN715@test_miss
  00bbb	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00bbe	75 0c		 jne	 SHORT $LN715@test_miss
  00bc0	8b 8b 80 01 00
	00		 mov	 ecx, DWORD PTR [ebx+384]
  00bc6	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00bca	eb 0a		 jmp	 SHORT $LN696@test_miss
$LN715@test_miss:
  00bcc	8b cb		 mov	 ecx, ebx
  00bce	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00bd2	eb 02		 jmp	 SHORT $LN696@test_miss
$LN695@test_miss:
  00bd4	33 c9		 xor	 ecx, ecx
$LN696@test_miss:
  00bd6	85 db		 test	 ebx, ebx
  00bd8	74 0b		 je	 SHORT $LN733@test_miss
  00bda	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00bdd	75 06		 jne	 SHORT $LN733@test_miss
  00bdf	8b 9b 80 01 00
	00		 mov	 ebx, DWORD PTR [ebx+384]
$LN733@test_miss:
  00be5	3b d3		 cmp	 edx, ebx
  00be7	75 04		 jne	 SHORT $LN753@test_miss
  00be9	3b c1		 cmp	 eax, ecx
  00beb	74 05		 je	 SHORT $LN80@test_miss
$LN753@test_miss:

; 1360 : 			abort();

  00bed	e8 00 00 00 00	 call	 _abort
$LN80@test_miss:

; 1353 : #endif
; 1354 : 
; 1355 : #ifdef USE_GOOGLEBTREE
; 1356 : 	START(DATA_GOOGLEBTREE) {

  00bf2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00bf5	40		 inc	 eax
  00bf6	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00bf9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00bff	0f 82 ce fe ff
	ff		 jb	 $LN81@test_miss
$LN79@test_miss:

; 1361 : 	} STOP();

  00c05	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1362 : #endif
; 1363 : 
; 1364 : #ifdef USE_CPPMAP
; 1365 : 	START(DATA_CPPMAP) {

  00c0a	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00c0f	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00c14	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00c1a	0f 85 26 01 00
	00		 jne	 $LN74@test_miss
  00c20	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00c27	75 2e		 jne	 SHORT $LN755@test_miss
  00c29	a1 38 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  00c2e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00c34	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00c3b	50		 push	 eax
  00c3c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00c41	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00c48	52		 push	 edx
  00c49	51		 push	 ecx
  00c4a	68 00 00 00 00	 push	 OFFSET $SG-100
  00c4f	e8 00 00 00 00	 call	 _printf
  00c54	83 c4 10	 add	 esp, 16			; 00000010H
$LN755@test_miss:
  00c57	8d 55 e4	 lea	 edx, DWORD PTR _t$198849[ebp]
  00c5a	52		 push	 edx
  00c5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00c61	85 c0		 test	 eax, eax
  00c63	75 11		 jne	 SHORT $LN761@test_miss
  00c65	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00c69	66 0f 13 45 dc	 movlpd	 QWORD PTR $T198842[ebp], xmm0
  00c6e	8b 5d e0	 mov	 ebx, DWORD PTR $T198842[ebp+4]
  00c71	8b 7d dc	 mov	 edi, DWORD PTR $T198842[ebp]
  00c74	eb 54		 jmp	 SHORT $LN762@test_miss
$LN761@test_miss:
  00c76	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00c7c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00c82	8b 45 e8	 mov	 eax, DWORD PTR _t$198849[ebp+4]
  00c85	8b 4d e4	 mov	 ecx, DWORD PTR _t$198849[ebp]
  00c88	57		 push	 edi
  00c89	56		 push	 esi
  00c8a	50		 push	 eax
  00c8b	51		 push	 ecx
  00c8c	e8 00 00 00 00	 call	 __alldvrm
  00c91	6a 00		 push	 0
  00c93	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c98	53		 push	 ebx
  00c99	51		 push	 ecx
  00c9a	89 45 ec	 mov	 DWORD PTR tv2744[ebp], eax
  00c9d	89 55 f0	 mov	 DWORD PTR tv2744[ebp+4], edx
  00ca0	e8 00 00 00 00	 call	 __allmul
  00ca5	57		 push	 edi
  00ca6	56		 push	 esi
  00ca7	52		 push	 edx
  00ca8	50		 push	 eax
  00ca9	e8 00 00 00 00	 call	 __alldiv
  00cae	6a 00		 push	 0
  00cb0	8b da		 mov	 ebx, edx
  00cb2	8b 55 f0	 mov	 edx, DWORD PTR tv2744[ebp+4]
  00cb5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00cba	8b f8		 mov	 edi, eax
  00cbc	8b 45 ec	 mov	 eax, DWORD PTR tv2744[ebp]
  00cbf	52		 push	 edx
  00cc0	50		 push	 eax
  00cc1	e8 00 00 00 00	 call	 __allmul
  00cc6	03 f8		 add	 edi, eax
  00cc8	13 da		 adc	 ebx, edx
$LN762@test_miss:
  00cca	33 f6		 xor	 esi, esi
  00ccc	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00cd2	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00cd8	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00cde	76 66		 jbe	 SHORT $LN74@test_miss
  00ce0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  00ce6	8b 5d 08	 mov	 ebx, DWORD PTR _SEARCH$[ebp]
  00ce9	8d a4 24 00 00
	00 00		 npad	 7
$LL76@test_miss:

; 1366 : 		unsigned key = SEARCH[i] + DELTA;
; 1367 : 		cppmap_t::const_iterator ptr = cppmap->find(key);

  00cf0	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00cf3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00cf6	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00cfa	8b 14 b3	 mov	 edx, DWORD PTR [ebx+esi*4]
  00cfd	75 15		 jne	 SHORT $LN772@test_miss
  00cff	90		 npad	 1
$LL773@test_miss:
  00d00	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00d03	73 05		 jae	 SHORT $LN771@test_miss
  00d05	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00d08	eb 04		 jmp	 SHORT $LN770@test_miss
$LN771@test_miss:
  00d0a	8b c8		 mov	 ecx, eax
  00d0c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN770@test_miss:
  00d0e	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00d12	74 ec		 je	 SHORT $LL773@test_miss
$LN772@test_miss:
  00d14	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00d17	89 4d f0	 mov	 DWORD PTR __Where$199077[ebp], ecx
  00d1a	3b c8		 cmp	 ecx, eax
  00d1c	74 0a		 je	 SHORT $LN766@test_miss
  00d1e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00d21	72 05		 jb	 SHORT $LN766@test_miss
  00d23	8d 4d f0	 lea	 ecx, DWORD PTR __Where$199077[ebp]
  00d26	eb 06		 jmp	 SHORT $LN767@test_miss
$LN766@test_miss:
  00d28	89 45 f8	 mov	 DWORD PTR $T199082[ebp], eax
  00d2b	8d 4d f8	 lea	 ecx, DWORD PTR $T199082[ebp]
$LN767@test_miss:

; 1368 : 		if (ptr != cppmap->end())

  00d2e	39 01		 cmp	 DWORD PTR [ecx], eax
  00d30	74 0b		 je	 SHORT $LN75@test_miss

; 1369 : 			abort();

  00d32	e8 00 00 00 00	 call	 _abort
  00d37	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
$LN75@test_miss:

; 1362 : #endif
; 1363 : 
; 1364 : #ifdef USE_CPPMAP
; 1365 : 	START(DATA_CPPMAP) {

  00d3d	46		 inc	 esi
  00d3e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00d44	72 aa		 jb	 SHORT $LL76@test_miss
$LN74@test_miss:

; 1370 : 	} STOP();

  00d46	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1371 : #endif
; 1372 : 
; 1373 : #ifdef USE_CPPUNORDEREDMAP
; 1374 : 	START(DATA_CPPUNORDEREDMAP) {

  00d4b	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  00d50	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00d55	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00d5b	0f 85 02 01 00
	00		 jne	 $LN69@test_miss
  00d61	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00d68	75 30		 jne	 SHORT $LN848@test_miss
  00d6a	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  00d70	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00d76	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00d7d	51		 push	 ecx
  00d7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00d84	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  00d8b	50		 push	 eax
  00d8c	52		 push	 edx
  00d8d	68 00 00 00 00	 push	 OFFSET $SG-100
  00d92	e8 00 00 00 00	 call	 _printf
  00d97	83 c4 10	 add	 esp, 16			; 00000010H
$LN848@test_miss:
  00d9a	8d 45 e4	 lea	 eax, DWORD PTR _t$199213[ebp]
  00d9d	50		 push	 eax
  00d9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00da4	85 c0		 test	 eax, eax
  00da6	75 11		 jne	 SHORT $LN854@test_miss
  00da8	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00dac	66 0f 13 45 dc	 movlpd	 QWORD PTR $T199206[ebp], xmm0
  00db1	8b 5d e0	 mov	 ebx, DWORD PTR $T199206[ebp+4]
  00db4	8b 7d dc	 mov	 edi, DWORD PTR $T199206[ebp]
  00db7	eb 54		 jmp	 SHORT $LN855@test_miss
$LN854@test_miss:
  00db9	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00dbf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00dc5	8b 4d e8	 mov	 ecx, DWORD PTR _t$199213[ebp+4]
  00dc8	8b 55 e4	 mov	 edx, DWORD PTR _t$199213[ebp]
  00dcb	57		 push	 edi
  00dcc	56		 push	 esi
  00dcd	51		 push	 ecx
  00dce	52		 push	 edx
  00dcf	e8 00 00 00 00	 call	 __alldvrm
  00dd4	6a 00		 push	 0
  00dd6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00ddb	53		 push	 ebx
  00ddc	51		 push	 ecx
  00ddd	89 45 ec	 mov	 DWORD PTR tv1869[ebp], eax
  00de0	89 55 f0	 mov	 DWORD PTR tv1869[ebp+4], edx
  00de3	e8 00 00 00 00	 call	 __allmul
  00de8	57		 push	 edi
  00de9	56		 push	 esi
  00dea	52		 push	 edx
  00deb	50		 push	 eax
  00dec	e8 00 00 00 00	 call	 __alldiv
  00df1	8b 4d ec	 mov	 ecx, DWORD PTR tv1869[ebp]
  00df4	6a 00		 push	 0
  00df6	8b f8		 mov	 edi, eax
  00df8	8b 45 f0	 mov	 eax, DWORD PTR tv1869[ebp+4]
  00dfb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00e00	50		 push	 eax
  00e01	51		 push	 ecx
  00e02	8b da		 mov	 ebx, edx
  00e04	e8 00 00 00 00	 call	 __allmul
  00e09	03 f8		 add	 edi, eax
  00e0b	13 da		 adc	 ebx, edx
$LN855@test_miss:
  00e0d	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00e13	33 ff		 xor	 edi, edi
  00e15	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00e1b	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00e21	76 40		 jbe	 SHORT $LN69@test_miss
  00e23	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00e29	8d a4 24 00 00
	00 00		 npad	 7
$LL71@test_miss:

; 1375 : 		unsigned key = SEARCH[i] + DELTA;

  00e30	8b 55 08	 mov	 edx, DWORD PTR _SEARCH$[ebp]
  00e33	8b 04 ba	 mov	 eax, DWORD PTR [edx+edi*4]

; 1376 : 		cppunorderedmap_t::const_iterator ptr = cppunorderedmap->find(key);

  00e36	8d 4d f8	 lea	 ecx, DWORD PTR $T195235[ebp]
  00e39	89 45 f0	 mov	 DWORD PTR _key$149555[ebp], eax
  00e3c	51		 push	 ecx
  00e3d	8d 45 f0	 lea	 eax, DWORD PTR _key$149555[ebp]
  00e40	8b ce		 mov	 ecx, esi
  00e42	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1377 : 		if (ptr != cppunorderedmap->end())

  00e47	8b 55 f8	 mov	 edx, DWORD PTR $T195235[ebp]
  00e4a	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  00e4d	74 0b		 je	 SHORT $LN70@test_miss

; 1378 : 			abort();

  00e4f	e8 00 00 00 00	 call	 _abort
  00e54	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN70@test_miss:

; 1371 : #endif
; 1372 : 
; 1373 : #ifdef USE_CPPUNORDEREDMAP
; 1374 : 	START(DATA_CPPUNORDEREDMAP) {

  00e5a	47		 inc	 edi
  00e5b	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00e61	72 cd		 jb	 SHORT $LL71@test_miss
$LN69@test_miss:

; 1379 : 	} STOP();

  00e63	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1380 : #endif
; 1381 : 
; 1382 : 	START(DATA_UTHASH) {

  00e68	b8 08 00 00 00	 mov	 eax, 8
  00e6d	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00e72	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00e78	0f 85 c9 01 00
	00		 jne	 $LN64@test_miss
  00e7e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00e85	75 2e		 jne	 SHORT $LN875@test_miss
  00e87	a1 20 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+32
  00e8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00e92	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00e99	50		 push	 eax
  00e9a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00e9f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00ea6	52		 push	 edx
  00ea7	51		 push	 ecx
  00ea8	68 00 00 00 00	 push	 OFFSET $SG-100
  00ead	e8 00 00 00 00	 call	 _printf
  00eb2	83 c4 10	 add	 esp, 16			; 00000010H
$LN875@test_miss:
  00eb5	8d 55 e4	 lea	 edx, DWORD PTR _t$199297[ebp]
  00eb8	52		 push	 edx
  00eb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00ebf	85 c0		 test	 eax, eax
  00ec1	75 11		 jne	 SHORT $LN881@test_miss
  00ec3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ec7	66 0f 13 45 dc	 movlpd	 QWORD PTR $T199290[ebp], xmm0
  00ecc	8b 5d e0	 mov	 ebx, DWORD PTR $T199290[ebp+4]
  00ecf	8b 7d dc	 mov	 edi, DWORD PTR $T199290[ebp]
  00ed2	eb 54		 jmp	 SHORT $LN882@test_miss
$LN881@test_miss:
  00ed4	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00eda	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00ee0	8b 45 e8	 mov	 eax, DWORD PTR _t$199297[ebp+4]
  00ee3	8b 4d e4	 mov	 ecx, DWORD PTR _t$199297[ebp]
  00ee6	57		 push	 edi
  00ee7	56		 push	 esi
  00ee8	50		 push	 eax
  00ee9	51		 push	 ecx
  00eea	e8 00 00 00 00	 call	 __alldvrm
  00eef	6a 00		 push	 0
  00ef1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00ef6	53		 push	 ebx
  00ef7	51		 push	 ecx
  00ef8	89 45 ec	 mov	 DWORD PTR tv1931[ebp], eax
  00efb	89 55 f0	 mov	 DWORD PTR tv1931[ebp+4], edx
  00efe	e8 00 00 00 00	 call	 __allmul
  00f03	57		 push	 edi
  00f04	56		 push	 esi
  00f05	52		 push	 edx
  00f06	50		 push	 eax
  00f07	e8 00 00 00 00	 call	 __alldiv
  00f0c	6a 00		 push	 0
  00f0e	8b da		 mov	 ebx, edx
  00f10	8b 55 f0	 mov	 edx, DWORD PTR tv1931[ebp+4]
  00f13	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f18	8b f8		 mov	 edi, eax
  00f1a	8b 45 ec	 mov	 eax, DWORD PTR tv1931[ebp]
  00f1d	52		 push	 edx
  00f1e	50		 push	 eax
  00f1f	e8 00 00 00 00	 call	 __allmul
  00f24	03 f8		 add	 edi, eax
  00f26	13 da		 adc	 ebx, edx
$LN882@test_miss:
  00f28	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00f2f	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00f35	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00f3b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f42	0f 86 ff 00 00
	00		 jbe	 $LN64@test_miss
  00f48	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  00f4e	8b ff		 npad	 2
$LL66@test_miss:

; 1383 : 		unsigned key = SEARCH[i] + DELTA;

  00f50	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  00f53	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00f56	8b 1c 91	 mov	 ebx, DWORD PTR [ecx+edx*4]
  00f59	89 5d f0	 mov	 DWORD PTR _key$149564[ebp], ebx

; 1384 : 		struct uthash_object* obj;
; 1385 : 		HASH_FIND_INT(uthash, &key, obj);  

  00f5c	85 f6		 test	 esi, esi
  00f5e	0f 84 d0 00 00
	00		 je	 $LN65@test_miss
  00f64	0f be 45 f3	 movsx	 eax, BYTE PTR _key$149564[ebp+3]
  00f68	0f be 4d f2	 movsx	 ecx, BYTE PTR _key$149564[ebp+2]
  00f6c	c1 e0 18	 shl	 eax, 24			; 00000018H
  00f6f	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  00f74	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00f77	03 c1		 add	 eax, ecx
  00f79	0f be d7	 movsx	 edx, bh
  00f7c	c1 e2 08	 shl	 edx, 8
  00f7f	03 d0		 add	 edx, eax
  00f81	0f be cb	 movsx	 ecx, bl
  00f84	03 d1		 add	 edx, ecx
  00f86	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  00f8c	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  00f92	8b c2		 mov	 eax, edx
  00f94	c1 e0 08	 shl	 eax, 8
  00f97	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  00f9c	2b ca		 sub	 ecx, edx
  00f9e	33 c8		 xor	 ecx, eax
  00fa0	8b f9		 mov	 edi, ecx
  00fa2	c1 ef 0d	 shr	 edi, 13			; 0000000dH
  00fa5	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  00faa	2b c1		 sub	 eax, ecx
  00fac	2b c2		 sub	 eax, edx
  00fae	33 c7		 xor	 eax, edi
  00fb0	2b d1		 sub	 edx, ecx
  00fb2	2b d0		 sub	 edx, eax
  00fb4	8b f8		 mov	 edi, eax
  00fb6	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  00fb9	33 d7		 xor	 edx, edi
  00fbb	2b ca		 sub	 ecx, edx
  00fbd	2b c8		 sub	 ecx, eax
  00fbf	8b fa		 mov	 edi, edx
  00fc1	c1 e7 10	 shl	 edi, 16			; 00000010H
  00fc4	33 cf		 xor	 ecx, edi
  00fc6	2b c1		 sub	 eax, ecx
  00fc8	2b c2		 sub	 eax, edx
  00fca	8b f9		 mov	 edi, ecx
  00fcc	c1 ef 05	 shr	 edi, 5
  00fcf	33 c7		 xor	 eax, edi
  00fd1	2b d1		 sub	 edx, ecx
  00fd3	2b d0		 sub	 edx, eax
  00fd5	8b f8		 mov	 edi, eax
  00fd7	c1 ef 03	 shr	 edi, 3
  00fda	33 d7		 xor	 edx, edi
  00fdc	2b ca		 sub	 ecx, edx
  00fde	2b c8		 sub	 ecx, eax
  00fe0	8b fa		 mov	 edi, edx
  00fe2	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  00fe5	33 cf		 xor	 ecx, edi
  00fe7	8b 3e		 mov	 edi, DWORD PTR [esi]
  00fe9	2b c1		 sub	 eax, ecx
  00feb	2b c2		 sub	 eax, edx
  00fed	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00ff0	33 c1		 xor	 eax, ecx
  00ff2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00ff5	49		 dec	 ecx
  00ff6	23 c1		 and	 eax, ecx
  00ff8	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00ffb	8b 07		 mov	 eax, DWORD PTR [edi]
  00ffd	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  01000	85 c0		 test	 eax, eax
  01002	74 30		 je	 SHORT $LN65@test_miss
  01004	8b 7f 14	 mov	 edi, DWORD PTR [edi+20]
  01007	2b c7		 sub	 eax, edi
  01009	74 29		 je	 SHORT $LN65@test_miss
  0100b	b9 04 00 00 00	 mov	 ecx, 4
$LL26@test_miss:
  01010	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  01013	75 07		 jne	 SHORT $LN23@test_miss
  01015	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01018	39 1a		 cmp	 DWORD PTR [edx], ebx
  0101a	74 0d		 je	 SHORT $LN33@test_miss
$LN23@test_miss:
  0101c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0101f	85 c0		 test	 eax, eax
  01021	74 11		 je	 SHORT $LN65@test_miss
  01023	2b c7		 sub	 eax, edi
  01025	75 e9		 jne	 SHORT $LL26@test_miss

; 1386 : 		if (obj)

  01027	eb 0b		 jmp	 SHORT $LN65@test_miss
$LN33@test_miss:

; 1387 : 			abort();

  01029	e8 00 00 00 00	 call	 _abort
  0102e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN65@test_miss:

; 1380 : #endif
; 1381 : 
; 1382 : 	START(DATA_UTHASH) {

  01034	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01037	40		 inc	 eax
  01038	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0103b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01041	0f 82 09 ff ff
	ff		 jb	 $LL66@test_miss
$LN64@test_miss:

; 1388 : 	} STOP();

  01047	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1389 : 
; 1390 : #ifdef USE_JUDY
; 1391 : 	START(DATA_JUDY) {

  0104c	b8 09 00 00 00	 mov	 eax, 9
  01051	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01056	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0105c	0f 85 ec 00 00
	00		 jne	 $LN1036@test_miss
  01062	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01069	75 2e		 jne	 SHORT $LN884@test_miss
  0106b	a1 24 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+36
  01070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01076	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0107d	50		 push	 eax
  0107e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01083	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0108a	52		 push	 edx
  0108b	51		 push	 ecx
  0108c	68 00 00 00 00	 push	 OFFSET $SG-100
  01091	e8 00 00 00 00	 call	 _printf
  01096	83 c4 10	 add	 esp, 16			; 00000010H
$LN884@test_miss:
  01099	8d 55 dc	 lea	 edx, DWORD PTR _t$199320[ebp]
  0109c	52		 push	 edx
  0109d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  010a3	85 c0		 test	 eax, eax
  010a5	75 11		 jne	 SHORT $LN890@test_miss
  010a7	66 0f 57 c0	 xorpd	 xmm0, xmm0
  010ab	66 0f 13 45 dc	 movlpd	 QWORD PTR $T199313[ebp], xmm0
  010b0	8b 5d e0	 mov	 ebx, DWORD PTR $T199313[ebp+4]
  010b3	8b 7d dc	 mov	 edi, DWORD PTR $T199313[ebp]
  010b6	eb 54		 jmp	 SHORT $LN891@test_miss
$LN890@test_miss:
  010b8	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  010be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  010c4	8b 45 e0	 mov	 eax, DWORD PTR _t$199320[ebp+4]
  010c7	8b 4d dc	 mov	 ecx, DWORD PTR _t$199320[ebp]
  010ca	57		 push	 edi
  010cb	56		 push	 esi
  010cc	50		 push	 eax
  010cd	51		 push	 ecx
  010ce	e8 00 00 00 00	 call	 __alldvrm
  010d3	6a 00		 push	 0
  010d5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  010da	53		 push	 ebx
  010db	51		 push	 ecx
  010dc	89 45 ec	 mov	 DWORD PTR tv2679[ebp], eax
  010df	89 55 f0	 mov	 DWORD PTR tv2679[ebp+4], edx
  010e2	e8 00 00 00 00	 call	 __allmul
  010e7	57		 push	 edi
  010e8	56		 push	 esi
  010e9	52		 push	 edx
  010ea	50		 push	 eax
  010eb	e8 00 00 00 00	 call	 __alldiv
  010f0	6a 00		 push	 0
  010f2	8b da		 mov	 ebx, edx
  010f4	8b 55 f0	 mov	 edx, DWORD PTR tv2679[ebp+4]
  010f7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  010fc	8b f8		 mov	 edi, eax
  010fe	8b 45 ec	 mov	 eax, DWORD PTR tv2679[ebp]
  01101	52		 push	 edx
  01102	50		 push	 eax
  01103	e8 00 00 00 00	 call	 __allmul
  01108	03 f8		 add	 edi, eax
  0110a	13 da		 adc	 ebx, edx
$LN891@test_miss:
  0110c	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  0110f	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01115	33 ff		 xor	 edi, edi
  01117	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0111d	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01123	76 2c		 jbe	 SHORT $LN13@test_miss
$LL15@test_miss:

; 1392 : 		Word_t key = SEARCH[i] + DELTA;

  01125	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]

; 1393 : 		Pvoid_t PValue;
; 1394 : 		JLG(PValue, judy, key);

  01128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judy@@3PAXA ; judy
  0112e	6a 00		 push	 0
  01130	50		 push	 eax
  01131	51		 push	 ecx
  01132	e8 00 00 00 00	 call	 _JudyLGet
  01137	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1395 : 		if (PValue)

  0113a	85 c0		 test	 eax, eax
  0113c	74 05		 je	 SHORT $LN14@test_miss

; 1396 : 			abort();

  0113e	e8 00 00 00 00	 call	 _abort
$LN14@test_miss:

; 1389 : 
; 1390 : #ifdef USE_JUDY
; 1391 : 	START(DATA_JUDY) {

  01143	47		 inc	 edi
  01144	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  0114a	72 d9		 jb	 SHORT $LL15@test_miss
  0114c	eb 03		 jmp	 SHORT $LN13@test_miss
$LN1036@test_miss:
  0114e	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
$LN13@test_miss:

; 1397 : 	} STOP();

  01151	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1398 : #endif
; 1399 : 
; 1400 : #ifdef USE_JUDYARRAY
; 1401 : 	START(DATA_JUDYARRAY) {

  01156	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0115b	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01160	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  01166	0f 85 ed 00 00
	00		 jne	 $LN8@test_miss
  0116c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01173	75 2f		 jne	 SHORT $LN893@test_miss
  01175	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+40
  0117b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01180	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01187	52		 push	 edx
  01188	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0118e	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01195	51		 push	 ecx
  01196	50		 push	 eax
  01197	68 00 00 00 00	 push	 OFFSET $SG-100
  0119c	e8 00 00 00 00	 call	 _printf
  011a1	83 c4 10	 add	 esp, 16			; 00000010H
$LN893@test_miss:
  011a4	8d 4d e4	 lea	 ecx, DWORD PTR _t$199343[ebp]
  011a7	51		 push	 ecx
  011a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  011ae	85 c0		 test	 eax, eax
  011b0	75 11		 jne	 SHORT $LN899@test_miss
  011b2	66 0f 57 c0	 xorpd	 xmm0, xmm0
  011b6	66 0f 13 45 dc	 movlpd	 QWORD PTR $T199336[ebp], xmm0
  011bb	8b 5d e0	 mov	 ebx, DWORD PTR $T199336[ebp+4]
  011be	8b 7d dc	 mov	 edi, DWORD PTR $T199336[ebp]
  011c1	eb 57		 jmp	 SHORT $LN900@test_miss
$LN899@test_miss:
  011c3	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  011c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  011cf	8b 55 e8	 mov	 edx, DWORD PTR _t$199343[ebp+4]
  011d2	8b 45 e4	 mov	 eax, DWORD PTR _t$199343[ebp]
  011d5	57		 push	 edi
  011d6	56		 push	 esi
  011d7	52		 push	 edx
  011d8	50		 push	 eax
  011d9	e8 00 00 00 00	 call	 __alldvrm
  011de	6a 00		 push	 0
  011e0	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  011e5	53		 push	 ebx
  011e6	51		 push	 ecx
  011e7	89 45 ec	 mov	 DWORD PTR tv2197[ebp], eax
  011ea	89 55 f0	 mov	 DWORD PTR tv2197[ebp+4], edx
  011ed	e8 00 00 00 00	 call	 __allmul
  011f2	57		 push	 edi
  011f3	56		 push	 esi
  011f4	52		 push	 edx
  011f5	50		 push	 eax
  011f6	e8 00 00 00 00	 call	 __alldiv
  011fb	8b 4d f0	 mov	 ecx, DWORD PTR tv2197[ebp+4]
  011fe	6a 00		 push	 0
  01200	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01205	8b da		 mov	 ebx, edx
  01207	8b 55 ec	 mov	 edx, DWORD PTR tv2197[ebp]
  0120a	51		 push	 ecx
  0120b	52		 push	 edx
  0120c	8b f8		 mov	 edi, eax
  0120e	e8 00 00 00 00	 call	 __allmul
  01213	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  01216	03 f8		 add	 edi, eax
  01218	13 da		 adc	 ebx, edx
$LN900@test_miss:
  0121a	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01220	33 ff		 xor	 edi, edi
  01222	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01228	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  0122e	76 29		 jbe	 SHORT $LN8@test_miss
$LL10@test_miss:

; 1402 : 		judyvalue key = SEARCH[i] + DELTA;

  01230	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]

; 1403 : 		JudySlot* pvalue;
; 1404 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  01233	8d 4d f0	 lea	 ecx, DWORD PTR _key$149666[ebp]
  01236	51		 push	 ecx
  01237	89 45 f0	 mov	 DWORD PTR _key$149666[ebp], eax
  0123a	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  0123f	83 c4 04	 add	 esp, 4

; 1405 : 		if (pvalue) {

  01242	85 c0		 test	 eax, eax
  01244	74 0a		 je	 SHORT $LN9@test_miss

; 1406 : 			/* workaround for a judyarray bug. Sometimes it returns a pvalue pointing to NULL */
; 1407 : 			void* obj = *(void**)pvalue;
; 1408 : 			if (obj)

  01246	83 38 00	 cmp	 DWORD PTR [eax], 0
  01249	74 05		 je	 SHORT $LN9@test_miss

; 1409 : 				abort();

  0124b	e8 00 00 00 00	 call	 _abort
$LN9@test_miss:

; 1398 : #endif
; 1399 : 
; 1400 : #ifdef USE_JUDYARRAY
; 1401 : 	START(DATA_JUDYARRAY) {

  01250	47		 inc	 edi
  01251	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  01257	72 d7		 jb	 SHORT $LL10@test_miss
$LN8@test_miss:

; 1410 : 		}
; 1411 : 	} STOP();

  01259	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1412 : #endif
; 1413 : 
; 1414 : 	START(DATA_NEDTRIE) {

  0125e	b8 06 00 00 00	 mov	 eax, 6
  01263	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01268	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0126e	0f 85 26 01 00
	00		 jne	 $LN2@test_miss
  01274	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0127b	75 2f		 jne	 SHORT $LN902@test_miss
  0127d	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+24
  01283	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01288	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0128f	52		 push	 edx
  01290	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01296	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0129d	51		 push	 ecx
  0129e	50		 push	 eax
  0129f	68 00 00 00 00	 push	 OFFSET $SG-100
  012a4	e8 00 00 00 00	 call	 _printf
  012a9	83 c4 10	 add	 esp, 16			; 00000010H
$LN902@test_miss:
  012ac	8d 4d dc	 lea	 ecx, DWORD PTR _t$199366[ebp]
  012af	51		 push	 ecx
  012b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  012b6	85 c0		 test	 eax, eax
  012b8	75 11		 jne	 SHORT $LN908@test_miss
  012ba	66 0f 57 c0	 xorpd	 xmm0, xmm0
  012be	66 0f 13 45 dc	 movlpd	 QWORD PTR $T199359[ebp], xmm0
  012c3	8b 5d e0	 mov	 ebx, DWORD PTR $T199359[ebp+4]
  012c6	8b 7d dc	 mov	 edi, DWORD PTR $T199359[ebp]
  012c9	eb 57		 jmp	 SHORT $LN909@test_miss
$LN908@test_miss:
  012cb	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  012d1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  012d7	8b 55 e0	 mov	 edx, DWORD PTR _t$199366[ebp+4]
  012da	8b 45 dc	 mov	 eax, DWORD PTR _t$199366[ebp]
  012dd	57		 push	 edi
  012de	56		 push	 esi
  012df	52		 push	 edx
  012e0	50		 push	 eax
  012e1	e8 00 00 00 00	 call	 __alldvrm
  012e6	6a 00		 push	 0
  012e8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  012ed	53		 push	 ebx
  012ee	51		 push	 ecx
  012ef	89 45 ec	 mov	 DWORD PTR tv2684[ebp], eax
  012f2	89 55 f0	 mov	 DWORD PTR tv2684[ebp+4], edx
  012f5	e8 00 00 00 00	 call	 __allmul
  012fa	57		 push	 edi
  012fb	56		 push	 esi
  012fc	52		 push	 edx
  012fd	50		 push	 eax
  012fe	e8 00 00 00 00	 call	 __alldiv
  01303	8b 4d f0	 mov	 ecx, DWORD PTR tv2684[ebp+4]
  01306	6a 00		 push	 0
  01308	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0130d	8b da		 mov	 ebx, edx
  0130f	8b 55 ec	 mov	 edx, DWORD PTR tv2684[ebp]
  01312	51		 push	 ecx
  01313	52		 push	 edx
  01314	8b f8		 mov	 edi, eax
  01316	e8 00 00 00 00	 call	 __allmul
  0131b	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  0131e	03 f8		 add	 edi, eax
  01320	13 da		 adc	 ebx, edx
$LN909@test_miss:
  01322	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01328	33 db		 xor	 ebx, ebx
  0132a	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01330	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  01336	76 62		 jbe	 SHORT $LN2@test_miss
$LN4@test_miss:

; 1415 : 		unsigned key = SEARCH[i] + DELTA;
; 1416 : 		struct nedtrie_object key_obj;
; 1417 : 		struct nedtrie_object* obj;
; 1418 : 		key_obj.value = key;
; 1419 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  01338	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, 0
  0133f	8b 3c 9e	 mov	 edi, DWORD PTR [esi+ebx*4]
  01342	74 4d		 je	 SHORT $LN3@test_miss
  01344	8b c7		 mov	 eax, edi
  01346	83 c8 01	 or	 eax, 1
  01349	0f bd c8	 bsr	 ecx, eax
  0134c	8b 04 8d 04 00
	00 00		 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  01353	89 4d f0	 mov	 DWORD PTR _bitpos$199408[ebp], ecx
  01356	85 c0		 test	 eax, eax
  01358	74 37		 je	 SHORT $LN3@test_miss
  0135a	ba 01 00 00 00	 mov	 edx, 1
  0135f	d3 e2		 shl	 edx, cl
  01361	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  01364	74 19		 je	 SHORT $end$199399
$LL916@test_miss:
  01366	d1 ea		 shr	 edx, 1
  01368	8b ca		 mov	 ecx, edx
  0136a	23 cf		 and	 ecx, edi
  0136c	f7 d9		 neg	 ecx
  0136e	1b c9		 sbb	 ecx, ecx
  01370	f7 d9		 neg	 ecx
  01372	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  01376	85 c0		 test	 eax, eax
  01378	74 17		 je	 SHORT $LN3@test_miss
  0137a	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  0137d	75 e7		 jne	 SHORT $LL916@test_miss
$end$199399:
  0137f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01382	85 c9		 test	 ecx, ecx
  01384	74 02		 je	 SHORT $LN921@test_miss
  01386	8b c1		 mov	 eax, ecx
$LN921@test_miss:

; 1420 : 		if (obj)

  01388	85 c0		 test	 eax, eax
  0138a	74 05		 je	 SHORT $LN3@test_miss

; 1421 : 			abort();

  0138c	e8 00 00 00 00	 call	 _abort
$LN3@test_miss:

; 1412 : #endif
; 1413 : 
; 1414 : 	START(DATA_NEDTRIE) {

  01391	43		 inc	 ebx
  01392	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01398	72 9e		 jb	 SHORT $LN4@test_miss
$LN2@test_miss:

; 1422 : 	} STOP();

  0139a	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1423 : }

  0139f	5f		 pop	 edi
  013a0	5e		 pop	 esi
  013a1	5b		 pop	 ebx
  013a2	8b e5		 mov	 esp, ebp
  013a4	5d		 pop	 ebp
  013a5	c3		 ret	 0
?test_miss@@YAXPAI@Z ENDP				; test_miss
_TEXT	ENDS
PUBLIC	?test_hit@@YAXPAI@Z				; test_hit
; Function compile flags: /Ogtp
;	COMDAT ?test_hit@@YAXPAI@Z
_TEXT	SEGMENT
$T203706 = -44						; size = 8
_t$203712 = -44						; size = 8
$T203683 = -44						; size = 8
$T203660 = -44						; size = 8
_t$203667 = -44						; size = 8
$T203637 = -44						; size = 8
$T203169 = -44						; size = 8
$T202807 = -44						; size = 8
$T203543 = -44						; size = 8
_pos$201190 = -44					; size = 8
_t$203689 = -36						; size = 8
_t$203644 = -36						; size = 8
_t$203550 = -36						; size = 8
_t$203176 = -36						; size = 8
_t$201601 = -36						; size = 8
$T202806 = -28						; size = 8
$T201594 = -28						; size = 8
_t$199959 = -28						; size = 8
tv2907 = -20						; size = 8
tv2820 = -20						; size = 8
tv2793 = -20						; size = 8
tv2784 = -20						; size = 8
tv2756 = -20						; size = 8
tv2531 = -20						; size = 8
tv2304 = -20						; size = 8
tv1520 = -20						; size = 8
tv1155 = -20						; size = 8
$T199952 = -20						; size = 8
$T199925 = -20						; size = 8
$T199884 = -20						; size = 8
_t$199891 = -20						; size = 8
$T199829 = -20						; size = 8
_t$199836 = -20						; size = 8
$T199691 = -20						; size = 8
_t$199698 = -20						; size = 8
$T199640 = -20						; size = 8
_t$199649 = -20						; size = 8
tv462 = -20						; size = 8
tv447 = -20						; size = 8
tv188 = -20						; size = 8
tv133 = -20						; size = 8
_bitpos$203755 = -16					; size = 4
__Where$203404 = -16					; size = 4
_count$199800 = -16					; size = 4
_key$149444 = -16					; size = 4
_key$149336 = -16					; size = 4
_key$149191 = -16					; size = 4
_key$148806 = -16					; size = 4
_key$148623 = -16					; size = 4
_t$199932 = -12						; size = 8
$T203409 = -8						; size = 4
$T199547 = -8						; size = 4
_i$ = -8						; size = 4
_SEARCH$ = 8						; size = 4
?test_hit@@YAXPAI@Z PROC				; test_hit, COMDAT

; 1044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	53		 push	 ebx

; 1045 : 	unsigned i;
; 1046 : 
; 1047 : 	/* always dereference the object found. It has cache effect. */
; 1048 : 	/* considering we are dealing with objects, it makes sense to simulate an access to it */
; 1049 : 	/* this favorites data structures that store part of the information in the object itself */
; 1050 : 	const int dereference = 1;
; 1051 : 
; 1052 : 	const unsigned DELTA = 1;
; 1053 : 
; 1054 : 	START(DATA_TREE) {

  00007	b8 05 00 00 00	 mov	 eax, 5
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00013	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00019	0f 85 ad 00 00
	00		 jne	 $LN148@test_hit
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00026	75 2e		 jne	 SHORT $LN158@test_hit
  00028	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00033	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003a	50		 push	 eax
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00040	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00047	52		 push	 edx
  00048	51		 push	 ecx
  00049	68 00 00 00 00	 push	 OFFSET $SG-100
  0004e	e8 00 00 00 00	 call	 _printf
  00053	83 c4 10	 add	 esp, 16			; 00000010H
$LN158@test_hit:
  00056	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005b	33 f6		 xor	 esi, esi
  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00062	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00068	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  0006e	76 5c		 jbe	 SHORT $LN148@test_hit
$LL150@test_hit:

; 1055 : 		unsigned key = SEARCH[i] + DELTA;

  00070	8b 55 08	 mov	 edx, DWORD PTR _SEARCH$[ebp]
  00073	8b 1c b2	 mov	 ebx, DWORD PTR [edx+esi*4]

; 1056 : 		struct rbt_object key_obj;
; 1057 : 		struct rbt_object* obj;
; 1058 : 		key_obj.value = key;
; 1059 : 		obj = rbt_search(&tree, &key_obj); 

  00076	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?tree@@3Urbtree_t@@A
  0007c	43		 inc	 ebx
  0007d	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  00083	74 27		 je	 SHORT $LN1043@test_hit
$LL168@test_hit:
  00085	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00088	3b d8		 cmp	 ebx, eax
  0008a	7c 14		 jl	 SHORT $LN1046@test_hit
  0008c	7e 16		 jle	 SHORT $LN167@test_hit
  0008e	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00091	83 e7 fe	 and	 edi, -2			; fffffffeH
$LN165@test_hit:
  00094	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  0009a	75 e9		 jne	 SHORT $LL168@test_hit
  0009c	33 ff		 xor	 edi, edi

; 1060 : 		if (!obj)

  0009e	eb 14		 jmp	 SHORT $LN1079@test_hit
$LN1046@test_hit:

; 1056 : 		struct rbt_object key_obj;
; 1057 : 		struct rbt_object* obj;
; 1058 : 		key_obj.value = key;
; 1059 : 		obj = rbt_search(&tree, &key_obj); 

  000a0	8b 3f		 mov	 edi, DWORD PTR [edi]
  000a2	eb f0		 jmp	 SHORT $LN165@test_hit
$LN167@test_hit:
  000a4	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  000aa	75 04		 jne	 SHORT $LN164@test_hit
$LN1043@test_hit:
  000ac	33 ff		 xor	 edi, edi

; 1060 : 		if (!obj)

  000ae	eb 04		 jmp	 SHORT $LN1079@test_hit

; 1056 : 		struct rbt_object key_obj;
; 1057 : 		struct rbt_object* obj;
; 1058 : 		key_obj.value = key;
; 1059 : 		obj = rbt_search(&tree, &key_obj); 

$LN164@test_hit:

; 1060 : 		if (!obj)

  000b0	85 ff		 test	 edi, edi
  000b2	75 05		 jne	 SHORT $LN147@test_hit
$LN1079@test_hit:

; 1061 : 			abort();

  000b4	e8 00 00 00 00	 call	 _abort
$LN147@test_hit:

; 1062 : 		if (dereference) {
; 1063 : 			if (obj->value != key)

  000b9	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  000bc	74 05		 je	 SHORT $LN149@test_hit

; 1064 : 				abort();

  000be	e8 00 00 00 00	 call	 _abort
$LN149@test_hit:

; 1045 : 	unsigned i;
; 1046 : 
; 1047 : 	/* always dereference the object found. It has cache effect. */
; 1048 : 	/* considering we are dealing with objects, it makes sense to simulate an access to it */
; 1049 : 	/* this favorites data structures that store part of the information in the object itself */
; 1050 : 	const int dereference = 1;
; 1051 : 
; 1052 : 	const unsigned DELTA = 1;
; 1053 : 
; 1054 : 	START(DATA_TREE) {

  000c3	46		 inc	 esi
  000c4	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  000ca	72 a4		 jb	 SHORT $LL150@test_hit
$LN148@test_hit:

; 1065 : 		}
; 1066 : 	} STOP();

  000cc	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1067 : 
; 1068 : 	START(DATA_HASHTABLE) {

  000d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_data@@3IA, 0 ; the_data
  000d8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 0 ; the_start_data
  000e2	0f 85 e1 00 00
	00		 jne	 $LN141@test_hit
  000e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  000ef	75 2e		 jne	 SHORT $LN175@test_hit
  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  000fc	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00103	50		 push	 eax
  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00109	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00110	52		 push	 edx
  00111	51		 push	 ecx
  00112	68 00 00 00 00	 push	 OFFSET $SG-100
  00117	e8 00 00 00 00	 call	 _printf
  0011c	83 c4 10	 add	 esp, 16			; 00000010H
$LN175@test_hit:
  0011f	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00124	33 f6		 xor	 esi, esi
  00126	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0012b	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00131	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00137	0f 86 8c 00 00
	00		 jbe	 $LN141@test_hit
  0013d	8d 49 00	 npad	 3
$LL143@test_hit:

; 1069 : 		unsigned key = SEARCH[i] + DELTA;

  00140	8b 55 08	 mov	 edx, DWORD PTR _SEARCH$[ebp]
  00143	8b 3c b2	 mov	 edi, DWORD PTR [edx+esi*4]
  00146	47		 inc	 edi

; 1070 : 		unsigned hash_key = hash(key);

  00147	8b cf		 mov	 ecx, edi
  00149	c1 e1 06	 shl	 ecx, 6
  0014c	8b c7		 mov	 eax, edi
  0014e	2b c1		 sub	 eax, ecx
  00150	8b d0		 mov	 edx, eax
  00152	c1 ea 11	 shr	 edx, 17			; 00000011H
  00155	33 c2		 xor	 eax, edx
  00157	8b c8		 mov	 ecx, eax
  00159	c1 e1 09	 shl	 ecx, 9
  0015c	2b c1		 sub	 eax, ecx
  0015e	8b d0		 mov	 edx, eax
  00160	c1 e2 04	 shl	 edx, 4
  00163	33 c2		 xor	 eax, edx
  00165	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0016c	2b c1		 sub	 eax, ecx
  0016e	8b d0		 mov	 edx, eax
  00170	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00173	33 c2		 xor	 eax, edx

; 1071 : 		struct hashtable_object* obj;
; 1072 : 		obj = (struct hashtable_object*)tommy_hashtable_search(&hashtable, tommy_hashtable_compare, &key, hash_key);

  00175	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0017b	8b c8		 mov	 ecx, eax
  0017d	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00180	33 c8		 xor	 ecx, eax
  00182	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00187	23 c1		 and	 eax, ecx
  00189	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0018c	85 c0		 test	 eax, eax
  0018e	74 13		 je	 SHORT $LN184@test_hit
$LL185@test_hit:
  00190	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00193	75 08		 jne	 SHORT $LN183@test_hit
  00195	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00198	3b 7a 10	 cmp	 edi, DWORD PTR [edx+16]
  0019b	74 0a		 je	 SHORT $LN1007@test_hit
$LN183@test_hit:
  0019d	8b 00		 mov	 eax, DWORD PTR [eax]
  0019f	85 c0		 test	 eax, eax
  001a1	75 ed		 jne	 SHORT $LL185@test_hit
$LN184@test_hit:
  001a3	33 db		 xor	 ebx, ebx

; 1073 : 		if (!obj)

  001a5	eb 06		 jmp	 SHORT $LN1048@test_hit
$LN1007@test_hit:

; 1071 : 		struct hashtable_object* obj;
; 1072 : 		obj = (struct hashtable_object*)tommy_hashtable_search(&hashtable, tommy_hashtable_compare, &key, hash_key);

  001a7	8b da		 mov	 ebx, edx

; 1073 : 		if (!obj)

  001a9	85 db		 test	 ebx, ebx
  001ab	75 05		 jne	 SHORT $LN140@test_hit
$LN1048@test_hit:

; 1074 : 			abort();

  001ad	e8 00 00 00 00	 call	 _abort
$LN140@test_hit:

; 1075 : 		if (dereference) {
; 1076 : 			if (obj->value != key)

  001b2	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  001b5	74 05		 je	 SHORT $LN142@test_hit

; 1077 : 				abort();

  001b7	e8 00 00 00 00	 call	 _abort
$LN142@test_hit:

; 1067 : 
; 1068 : 	START(DATA_HASHTABLE) {

  001bc	46		 inc	 esi
  001bd	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  001c3	0f 82 77 ff ff
	ff		 jb	 $LL143@test_hit
$LN141@test_hit:

; 1078 : 		}
; 1079 : 	} STOP();

  001c9	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1080 : 
; 1081 : 	START(DATA_HASHDYN) {

  001ce	b8 01 00 00 00	 mov	 eax, 1
  001d3	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  001d8	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  001de	0f 85 4d 01 00
	00		 jne	 $LN134@test_hit
  001e4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  001eb	75 2e		 jne	 SHORT $LN193@test_hit
  001ed	a1 04 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  001f8	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  001ff	50		 push	 eax
  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00205	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0020c	52		 push	 edx
  0020d	51		 push	 ecx
  0020e	68 00 00 00 00	 push	 OFFSET $SG-100
  00213	e8 00 00 00 00	 call	 _printf
  00218	83 c4 10	 add	 esp, 16			; 00000010H
$LN193@test_hit:
  0021b	8d 55 ec	 lea	 edx, DWORD PTR _t$199649[ebp]
  0021e	52		 push	 edx
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00225	85 c0		 test	 eax, eax
  00227	75 11		 jne	 SHORT $LN199@test_hit
  00229	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0022d	66 0f 13 45 ec	 movlpd	 QWORD PTR $T199640[ebp], xmm0
  00232	8b 5d f0	 mov	 ebx, DWORD PTR $T199640[ebp+4]
  00235	8b 7d ec	 mov	 edi, DWORD PTR $T199640[ebp]
  00238	eb 54		 jmp	 SHORT $LN200@test_hit
$LN199@test_hit:
  0023a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00240	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00246	8b 45 f0	 mov	 eax, DWORD PTR _t$199649[ebp+4]
  00249	8b 4d ec	 mov	 ecx, DWORD PTR _t$199649[ebp]
  0024c	57		 push	 edi
  0024d	56		 push	 esi
  0024e	50		 push	 eax
  0024f	51		 push	 ecx
  00250	e8 00 00 00 00	 call	 __alldvrm
  00255	6a 00		 push	 0
  00257	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0025c	53		 push	 ebx
  0025d	51		 push	 ecx
  0025e	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  00261	89 55 f0	 mov	 DWORD PTR tv133[ebp+4], edx
  00264	e8 00 00 00 00	 call	 __allmul
  00269	57		 push	 edi
  0026a	56		 push	 esi
  0026b	52		 push	 edx
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 __alldiv
  00272	6a 00		 push	 0
  00274	8b da		 mov	 ebx, edx
  00276	8b 55 f0	 mov	 edx, DWORD PTR tv133[ebp+4]
  00279	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0027e	8b f8		 mov	 edi, eax
  00280	8b 45 ec	 mov	 eax, DWORD PTR tv133[ebp]
  00283	52		 push	 edx
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 __allmul
  0028a	03 f8		 add	 edi, eax
  0028c	13 da		 adc	 ebx, edx
$LN200@test_hit:
  0028e	33 f6		 xor	 esi, esi
  00290	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00296	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0029c	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  002a2	0f 86 89 00 00
	00		 jbe	 $LN134@test_hit
$LL136@test_hit:

; 1082 : 		unsigned key = SEARCH[i] + DELTA;

  002a8	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  002ab	8b 3c b1	 mov	 edi, DWORD PTR [ecx+esi*4]
  002ae	47		 inc	 edi

; 1083 : 		unsigned hash_key = hash(key);

  002af	8b d7		 mov	 edx, edi
  002b1	c1 e2 06	 shl	 edx, 6
  002b4	8b c7		 mov	 eax, edi
  002b6	2b c2		 sub	 eax, edx
  002b8	8b c8		 mov	 ecx, eax
  002ba	c1 e9 11	 shr	 ecx, 17			; 00000011H
  002bd	33 c1		 xor	 eax, ecx
  002bf	8b d0		 mov	 edx, eax
  002c1	c1 e2 09	 shl	 edx, 9
  002c4	2b c2		 sub	 eax, edx
  002c6	8b c8		 mov	 ecx, eax
  002c8	c1 e1 04	 shl	 ecx, 4
  002cb	33 c1		 xor	 eax, ecx
  002cd	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  002d4	2b c2		 sub	 eax, edx

; 1084 : 		struct hashtable_object* obj;
; 1085 : 		obj = (struct hashtable_object*)tommy_hashdyn_search(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  002d6	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  002dc	8b c8		 mov	 ecx, eax
  002de	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  002e1	33 c1		 xor	 eax, ecx
  002e3	8b c8		 mov	 ecx, eax
  002e5	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  002e8	33 c8		 xor	 ecx, eax
  002ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  002ef	23 d1		 and	 edx, ecx
  002f1	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  002f4	85 c0		 test	 eax, eax
  002f6	74 13		 je	 SHORT $LN205@test_hit
$LL206@test_hit:
  002f8	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  002fb	75 08		 jne	 SHORT $LN204@test_hit
  002fd	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00300	3b 7a 10	 cmp	 edi, DWORD PTR [edx+16]
  00303	74 0a		 je	 SHORT $LN1008@test_hit
$LN204@test_hit:
  00305	8b 00		 mov	 eax, DWORD PTR [eax]
  00307	85 c0		 test	 eax, eax
  00309	75 ed		 jne	 SHORT $LL206@test_hit
$LN205@test_hit:
  0030b	33 db		 xor	 ebx, ebx

; 1086 : 		if (!obj)

  0030d	eb 06		 jmp	 SHORT $LN1050@test_hit
$LN1008@test_hit:

; 1084 : 		struct hashtable_object* obj;
; 1085 : 		obj = (struct hashtable_object*)tommy_hashdyn_search(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  0030f	8b da		 mov	 ebx, edx

; 1086 : 		if (!obj)

  00311	85 db		 test	 ebx, ebx
  00313	75 05		 jne	 SHORT $LN133@test_hit
$LN1050@test_hit:

; 1087 : 			abort();

  00315	e8 00 00 00 00	 call	 _abort
$LN133@test_hit:

; 1088 : 		if (dereference) {
; 1089 : 			if (obj->value != key)

  0031a	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  0031d	74 05		 je	 SHORT $LN135@test_hit

; 1090 : 				abort();

  0031f	e8 00 00 00 00	 call	 _abort
$LN135@test_hit:

; 1080 : 
; 1081 : 	START(DATA_HASHDYN) {

  00324	46		 inc	 esi
  00325	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0032b	0f 82 77 ff ff
	ff		 jb	 $LL136@test_hit
$LN134@test_hit:

; 1091 : 		}
; 1092 : 	} STOP();

  00331	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1093 : 
; 1094 : 	START(DATA_HASHLIN) {

  00336	b8 02 00 00 00	 mov	 eax, 2
  0033b	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00340	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00346	0f 85 9a 01 00
	00		 jne	 $LN127@test_hit
  0034c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00353	75 2e		 jne	 SHORT $LN214@test_hit
  00355	a1 08 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  0035a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00360	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00367	50		 push	 eax
  00368	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0036d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00374	52		 push	 edx
  00375	51		 push	 ecx
  00376	68 00 00 00 00	 push	 OFFSET $SG-100
  0037b	e8 00 00 00 00	 call	 _printf
  00380	83 c4 10	 add	 esp, 16			; 00000010H
$LN214@test_hit:
  00383	8d 55 ec	 lea	 edx, DWORD PTR _t$199698[ebp]
  00386	52		 push	 edx
  00387	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0038d	85 c0		 test	 eax, eax
  0038f	75 11		 jne	 SHORT $LN220@test_hit
  00391	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00395	66 0f 13 45 ec	 movlpd	 QWORD PTR $T199691[ebp], xmm0
  0039a	8b 5d f0	 mov	 ebx, DWORD PTR $T199691[ebp+4]
  0039d	8b 7d ec	 mov	 edi, DWORD PTR $T199691[ebp]
  003a0	eb 54		 jmp	 SHORT $LN221@test_hit
$LN220@test_hit:
  003a2	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  003a8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  003ae	8b 45 f0	 mov	 eax, DWORD PTR _t$199698[ebp+4]
  003b1	8b 4d ec	 mov	 ecx, DWORD PTR _t$199698[ebp]
  003b4	57		 push	 edi
  003b5	56		 push	 esi
  003b6	50		 push	 eax
  003b7	51		 push	 ecx
  003b8	e8 00 00 00 00	 call	 __alldvrm
  003bd	6a 00		 push	 0
  003bf	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003c4	53		 push	 ebx
  003c5	51		 push	 ecx
  003c6	89 45 ec	 mov	 DWORD PTR tv2531[ebp], eax
  003c9	89 55 f0	 mov	 DWORD PTR tv2531[ebp+4], edx
  003cc	e8 00 00 00 00	 call	 __allmul
  003d1	57		 push	 edi
  003d2	56		 push	 esi
  003d3	52		 push	 edx
  003d4	50		 push	 eax
  003d5	e8 00 00 00 00	 call	 __alldiv
  003da	6a 00		 push	 0
  003dc	8b da		 mov	 ebx, edx
  003de	8b 55 f0	 mov	 edx, DWORD PTR tv2531[ebp+4]
  003e1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003e6	8b f8		 mov	 edi, eax
  003e8	8b 45 ec	 mov	 eax, DWORD PTR tv2531[ebp]
  003eb	52		 push	 edx
  003ec	50		 push	 eax
  003ed	e8 00 00 00 00	 call	 __allmul
  003f2	03 f8		 add	 edi, eax
  003f4	13 da		 adc	 ebx, edx
$LN221@test_hit:
  003f6	33 c0		 xor	 eax, eax
  003f8	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  003fe	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00404	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00407	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  0040d	0f 86 d3 00 00
	00		 jbe	 $LN127@test_hit
$LN129@test_hit:

; 1095 : 		unsigned key = SEARCH[i] + DELTA;

  00413	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  00416	8b 3c 81	 mov	 edi, DWORD PTR [ecx+eax*4]
  00419	47		 inc	 edi

; 1096 : 		unsigned hash_key = hash(key);

  0041a	8b d7		 mov	 edx, edi
  0041c	c1 e2 06	 shl	 edx, 6
  0041f	8b c7		 mov	 eax, edi
  00421	2b c2		 sub	 eax, edx
  00423	8b c8		 mov	 ecx, eax
  00425	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00428	33 c1		 xor	 eax, ecx
  0042a	8b d0		 mov	 edx, eax
  0042c	c1 e2 09	 shl	 edx, 9
  0042f	2b c2		 sub	 eax, edx
  00431	8b c8		 mov	 ecx, eax
  00433	c1 e1 04	 shl	 ecx, 4
  00436	33 c1		 xor	 eax, ecx
  00438	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0043f	2b c2		 sub	 eax, edx
  00441	8b c8		 mov	 ecx, eax
  00443	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00446	33 c1		 xor	 eax, ecx
  00448	8b d0		 mov	 edx, eax
  0044a	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0044d	33 d0		 xor	 edx, eax

; 1097 : 		struct hashtable_object* obj;
; 1098 : 		obj = (struct hashtable_object*)tommy_hashlin_search(&hashlin, tommy_hashtable_compare, &key, hash_key);

  0044f	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  00456	74 1c		 je	 SHORT $LN232@test_hit
  00458	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  0045d	23 c2		 and	 eax, edx
  0045f	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  00465	72 0d		 jb	 SHORT $LN232@test_hit
  00467	83 f8 40	 cmp	 eax, 64			; 00000040H
  0046a	73 1c		 jae	 SHORT $LN241@test_hit
  0046c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00472	eb 2a		 jmp	 SHORT $LN1100@test_hit
$LN232@test_hit:
  00474	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00479	23 c2		 and	 eax, edx
  0047b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0047e	73 08		 jae	 SHORT $LN241@test_hit
  00480	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00486	eb 16		 jmp	 SHORT $LN1100@test_hit
$LN241@test_hit:
  00488	0f bd c8	 bsr	 ecx, eax
  0048b	be 01 00 00 00	 mov	 esi, 1
  00490	d3 e6		 shl	 esi, cl
  00492	89 4d f0	 mov	 DWORD PTR _count$199800[ebp], ecx
  00495	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  0049c	2b c6		 sub	 eax, esi
$LN1100@test_hit:
  0049e	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  004a1	8b 00		 mov	 eax, DWORD PTR [eax]
  004a3	85 c0		 test	 eax, eax
  004a5	74 13		 je	 SHORT $LN226@test_hit
$LL227@test_hit:
  004a7	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  004aa	75 08		 jne	 SHORT $LN225@test_hit
  004ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004af	3b 79 10	 cmp	 edi, DWORD PTR [ecx+16]
  004b2	74 0a		 je	 SHORT $LN1009@test_hit
$LN225@test_hit:
  004b4	8b 00		 mov	 eax, DWORD PTR [eax]
  004b6	85 c0		 test	 eax, eax
  004b8	75 ed		 jne	 SHORT $LL227@test_hit
$LN226@test_hit:
  004ba	33 db		 xor	 ebx, ebx

; 1099 : 		if (!obj)

  004bc	eb 06		 jmp	 SHORT $LN1052@test_hit
$LN1009@test_hit:

; 1097 : 		struct hashtable_object* obj;
; 1098 : 		obj = (struct hashtable_object*)tommy_hashlin_search(&hashlin, tommy_hashtable_compare, &key, hash_key);

  004be	8b d9		 mov	 ebx, ecx

; 1099 : 		if (!obj)

  004c0	85 db		 test	 ebx, ebx
  004c2	75 05		 jne	 SHORT $LN126@test_hit
$LN1052@test_hit:

; 1100 : 			abort();

  004c4	e8 00 00 00 00	 call	 _abort
$LN126@test_hit:

; 1101 : 		if (dereference) {
; 1102 : 			if (obj->value != key)

  004c9	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  004cc	74 05		 je	 SHORT $LN128@test_hit

; 1103 : 				abort();

  004ce	e8 00 00 00 00	 call	 _abort
$LN128@test_hit:

; 1093 : 
; 1094 : 	START(DATA_HASHLIN) {

  004d3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  004d6	40		 inc	 eax
  004d7	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  004da	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  004e0	0f 82 2d ff ff
	ff		 jb	 $LN129@test_hit
$LN127@test_hit:

; 1104 : 		}
; 1105 : 	} STOP();

  004e6	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1106 : 
; 1107 : 	START(DATA_TRIE) {

  004eb	b8 03 00 00 00	 mov	 eax, 3
  004f0	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  004f5	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  004fb	0f 85 21 01 00
	00		 jne	 $LN120@test_hit
  00501	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00508	75 2f		 jne	 SHORT $LN249@test_hit
  0050a	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  00510	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00515	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0051c	52		 push	 edx
  0051d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00523	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0052a	51		 push	 ecx
  0052b	50		 push	 eax
  0052c	68 00 00 00 00	 push	 OFFSET $SG-100
  00531	e8 00 00 00 00	 call	 _printf
  00536	83 c4 10	 add	 esp, 16			; 00000010H
$LN249@test_hit:
  00539	8d 4d ec	 lea	 ecx, DWORD PTR _t$199836[ebp]
  0053c	51		 push	 ecx
  0053d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00543	85 c0		 test	 eax, eax
  00545	75 11		 jne	 SHORT $LN255@test_hit
  00547	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0054b	66 0f 13 45 ec	 movlpd	 QWORD PTR $T199829[ebp], xmm0
  00550	8b 5d f0	 mov	 ebx, DWORD PTR $T199829[ebp+4]
  00553	8b 7d ec	 mov	 edi, DWORD PTR $T199829[ebp]
  00556	eb 54		 jmp	 SHORT $LN256@test_hit
$LN255@test_hit:
  00558	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0055e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00564	8b 55 f0	 mov	 edx, DWORD PTR _t$199836[ebp+4]
  00567	8b 45 ec	 mov	 eax, DWORD PTR _t$199836[ebp]
  0056a	57		 push	 edi
  0056b	56		 push	 esi
  0056c	52		 push	 edx
  0056d	50		 push	 eax
  0056e	e8 00 00 00 00	 call	 __alldvrm
  00573	6a 00		 push	 0
  00575	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0057a	53		 push	 ebx
  0057b	51		 push	 ecx
  0057c	89 45 ec	 mov	 DWORD PTR tv188[ebp], eax
  0057f	89 55 f0	 mov	 DWORD PTR tv188[ebp+4], edx
  00582	e8 00 00 00 00	 call	 __allmul
  00587	57		 push	 edi
  00588	56		 push	 esi
  00589	52		 push	 edx
  0058a	50		 push	 eax
  0058b	e8 00 00 00 00	 call	 __alldiv
  00590	8b 4d f0	 mov	 ecx, DWORD PTR tv188[ebp+4]
  00593	6a 00		 push	 0
  00595	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0059a	8b da		 mov	 ebx, edx
  0059c	8b 55 ec	 mov	 edx, DWORD PTR tv188[ebp]
  0059f	51		 push	 ecx
  005a0	52		 push	 edx
  005a1	8b f8		 mov	 edi, eax
  005a3	e8 00 00 00 00	 call	 __allmul
  005a8	03 f8		 add	 edi, eax
  005aa	13 da		 adc	 ebx, edx
$LN256@test_hit:
  005ac	33 f6		 xor	 esi, esi
  005ae	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  005b4	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  005ba	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  005c0	76 60		 jbe	 SHORT $LN120@test_hit
$LL122@test_hit:

; 1108 : 		unsigned key = SEARCH[i] + DELTA;

  005c2	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  005c5	8b 3c b0	 mov	 edi, DWORD PTR [eax+esi*4]
  005c8	47		 inc	 edi

; 1109 : 		struct trie_object* obj;
; 1110 : 		obj = (struct trie_object*)tommy_trie_search(&trie, key);

  005c9	8b cf		 mov	 ecx, edi
  005cb	c1 e9 1b	 shr	 ecx, 27			; 0000001bH
  005ce	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[ecx*4]
  005d5	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  005da	85 c0		 test	 eax, eax
  005dc	74 21		 je	 SHORT $LN1054@test_hit
  005de	8b ff		 npad	 2
$recurse$199864:
  005e0	a8 01		 test	 al, 1
  005e2	74 16		 je	 SHORT $LN263@test_hit
  005e4	8b d7		 mov	 edx, edi
  005e6	d3 ea		 shr	 edx, cl
  005e8	83 e9 03	 sub	 ecx, 3
  005eb	83 e2 07	 and	 edx, 7
  005ee	8b 44 90 ff	 mov	 eax, DWORD PTR [eax+edx*4-1]
  005f2	85 c0		 test	 eax, eax
  005f4	75 ea		 jne	 SHORT $recurse$199864
  005f6	33 db		 xor	 ebx, ebx
  005f8	eb 10		 jmp	 SHORT $LN1055@test_hit
$LN263@test_hit:
  005fa	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  005fd	74 04		 je	 SHORT $LN258@test_hit
$LN1054@test_hit:
  005ff	33 db		 xor	 ebx, ebx
  00601	eb 07		 jmp	 SHORT $LN1055@test_hit
$LN258@test_hit:
  00603	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1111 : 		if (!obj)

  00606	85 db		 test	 ebx, ebx
  00608	75 05		 jne	 SHORT $LN119@test_hit
$LN1055@test_hit:

; 1112 : 			abort();

  0060a	e8 00 00 00 00	 call	 _abort
$LN119@test_hit:

; 1113 : 		if (dereference) {
; 1114 : 			if (obj->value != key)

  0060f	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  00612	74 05		 je	 SHORT $LN121@test_hit

; 1115 : 				abort();

  00614	e8 00 00 00 00	 call	 _abort
$LN121@test_hit:

; 1106 : 
; 1107 : 	START(DATA_TRIE) {

  00619	46		 inc	 esi
  0061a	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00620	72 a0		 jb	 SHORT $LL122@test_hit
$LN120@test_hit:

; 1116 : 		}
; 1117 : 	} STOP();

  00622	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1118 : 
; 1119 : 	START(DATA_TRIE_INPLACE) {

  00627	b8 04 00 00 00	 mov	 eax, 4
  0062c	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00631	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00637	0f 85 25 01 00
	00		 jne	 $LN113@test_hit
  0063d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00644	75 2e		 jne	 SHORT $LN269@test_hit
  00646	a1 10 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  0064b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00651	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00658	50		 push	 eax
  00659	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0065e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00665	52		 push	 edx
  00666	51		 push	 ecx
  00667	68 00 00 00 00	 push	 OFFSET $SG-100
  0066c	e8 00 00 00 00	 call	 _printf
  00671	83 c4 10	 add	 esp, 16			; 00000010H
$LN269@test_hit:
  00674	8d 55 ec	 lea	 edx, DWORD PTR _t$199891[ebp]
  00677	52		 push	 edx
  00678	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0067e	85 c0		 test	 eax, eax
  00680	75 11		 jne	 SHORT $LN275@test_hit
  00682	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00686	66 0f 13 45 ec	 movlpd	 QWORD PTR $T199884[ebp], xmm0
  0068b	8b 5d f0	 mov	 ebx, DWORD PTR $T199884[ebp+4]
  0068e	8b 7d ec	 mov	 edi, DWORD PTR $T199884[ebp]
  00691	eb 54		 jmp	 SHORT $LN276@test_hit
$LN275@test_hit:
  00693	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00699	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0069f	8b 45 f0	 mov	 eax, DWORD PTR _t$199891[ebp+4]
  006a2	8b 4d ec	 mov	 ecx, DWORD PTR _t$199891[ebp]
  006a5	57		 push	 edi
  006a6	56		 push	 esi
  006a7	50		 push	 eax
  006a8	51		 push	 ecx
  006a9	e8 00 00 00 00	 call	 __alldvrm
  006ae	6a 00		 push	 0
  006b0	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  006b5	53		 push	 ebx
  006b6	51		 push	 ecx
  006b7	89 45 ec	 mov	 DWORD PTR tv2907[ebp], eax
  006ba	89 55 f0	 mov	 DWORD PTR tv2907[ebp+4], edx
  006bd	e8 00 00 00 00	 call	 __allmul
  006c2	57		 push	 edi
  006c3	56		 push	 esi
  006c4	52		 push	 edx
  006c5	50		 push	 eax
  006c6	e8 00 00 00 00	 call	 __alldiv
  006cb	6a 00		 push	 0
  006cd	8b da		 mov	 ebx, edx
  006cf	8b 55 f0	 mov	 edx, DWORD PTR tv2907[ebp+4]
  006d2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  006d7	8b f8		 mov	 edi, eax
  006d9	8b 45 ec	 mov	 eax, DWORD PTR tv2907[ebp]
  006dc	52		 push	 edx
  006dd	50		 push	 eax
  006de	e8 00 00 00 00	 call	 __allmul
  006e3	03 f8		 add	 edi, eax
  006e5	13 da		 adc	 ebx, edx
$LN276@test_hit:
  006e7	33 f6		 xor	 esi, esi
  006e9	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  006ef	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  006f5	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  006fb	76 65		 jbe	 SHORT $LN113@test_hit
  006fd	8d 49 00	 npad	 3
$LL115@test_hit:

; 1120 : 		unsigned key = SEARCH[i] + DELTA;

  00700	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  00703	8b 3c b1	 mov	 edi, DWORD PTR [ecx+esi*4]
  00706	47		 inc	 edi

; 1121 : 		struct trie_inplace_object* obj;
; 1122 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_search(&trie_inplace, key);

  00707	8b d7		 mov	 edx, edi
  00709	c1 ea 1a	 shr	 edx, 26			; 0000001aH
  0070c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[edx*4]
  00713	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00718	85 c0		 test	 eax, eax
  0071a	74 23		 je	 SHORT $LN1080@test_hit
  0071c	8d 64 24 00	 npad	 4
$LL282@test_hit:
  00720	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  00723	74 16		 je	 SHORT $LN281@test_hit
  00725	8b d7		 mov	 edx, edi
  00727	d3 ea		 shr	 edx, cl
  00729	83 e9 02	 sub	 ecx, 2
  0072c	83 e2 03	 and	 edx, 3
  0072f	8b 44 90 10	 mov	 eax, DWORD PTR [eax+edx*4+16]
  00733	85 c0		 test	 eax, eax
  00735	75 e9		 jne	 SHORT $LL282@test_hit
  00737	33 db		 xor	 ebx, ebx
  00739	eb 0f		 jmp	 SHORT $LN1057@test_hit
$LN281@test_hit:
  0073b	85 c0		 test	 eax, eax
  0073d	75 04		 jne	 SHORT $LN278@test_hit
$LN1080@test_hit:
  0073f	33 db		 xor	 ebx, ebx
  00741	eb 07		 jmp	 SHORT $LN1057@test_hit
$LN278@test_hit:
  00743	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1123 : 		if (!obj)

  00746	85 db		 test	 ebx, ebx
  00748	75 05		 jne	 SHORT $LN112@test_hit
$LN1057@test_hit:

; 1124 : 			abort();

  0074a	e8 00 00 00 00	 call	 _abort
$LN112@test_hit:

; 1125 : 		if (dereference) {
; 1126 : 			if (obj->value != key)

  0074f	39 7b 20	 cmp	 DWORD PTR [ebx+32], edi
  00752	74 05		 je	 SHORT $LN114@test_hit

; 1127 : 				abort();

  00754	e8 00 00 00 00	 call	 _abort
$LN114@test_hit:

; 1118 : 
; 1119 : 	START(DATA_TRIE_INPLACE) {

  00759	46		 inc	 esi
  0075a	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00760	72 9e		 jb	 SHORT $LL115@test_hit
$LN113@test_hit:

; 1128 : 		}
; 1129 : 	} STOP();

  00762	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1130 : 
; 1131 : 	START(DATA_KHASH) {

  00767	b8 07 00 00 00	 mov	 eax, 7
  0076c	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00771	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00777	0f 85 36 01 00
	00		 jne	 $LN106@test_hit
  0077d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00784	75 2e		 jne	 SHORT $LN285@test_hit
  00786	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  0078b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00791	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00798	50		 push	 eax
  00799	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0079e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  007a5	52		 push	 edx
  007a6	51		 push	 ecx
  007a7	68 00 00 00 00	 push	 OFFSET $SG-100
  007ac	e8 00 00 00 00	 call	 _printf
  007b1	83 c4 10	 add	 esp, 16			; 00000010H
$LN285@test_hit:
  007b4	8d 55 f4	 lea	 edx, DWORD PTR _t$199932[ebp]
  007b7	52		 push	 edx
  007b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  007be	85 c0		 test	 eax, eax
  007c0	75 11		 jne	 SHORT $LN291@test_hit
  007c2	66 0f 57 c0	 xorpd	 xmm0, xmm0
  007c6	66 0f 13 45 ec	 movlpd	 QWORD PTR $T199925[ebp], xmm0
  007cb	8b 5d f0	 mov	 ebx, DWORD PTR $T199925[ebp+4]
  007ce	8b 7d ec	 mov	 edi, DWORD PTR $T199925[ebp]
  007d1	eb 54		 jmp	 SHORT $LN292@test_hit
$LN291@test_hit:
  007d3	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  007d9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  007df	8b 45 f8	 mov	 eax, DWORD PTR _t$199932[ebp+4]
  007e2	8b 4d f4	 mov	 ecx, DWORD PTR _t$199932[ebp]
  007e5	57		 push	 edi
  007e6	56		 push	 esi
  007e7	50		 push	 eax
  007e8	51		 push	 ecx
  007e9	e8 00 00 00 00	 call	 __alldvrm
  007ee	6a 00		 push	 0
  007f0	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007f5	53		 push	 ebx
  007f6	51		 push	 ecx
  007f7	89 45 ec	 mov	 DWORD PTR tv2304[ebp], eax
  007fa	89 55 f0	 mov	 DWORD PTR tv2304[ebp+4], edx
  007fd	e8 00 00 00 00	 call	 __allmul
  00802	57		 push	 edi
  00803	56		 push	 esi
  00804	52		 push	 edx
  00805	50		 push	 eax
  00806	e8 00 00 00 00	 call	 __alldiv
  0080b	6a 00		 push	 0
  0080d	8b da		 mov	 ebx, edx
  0080f	8b 55 f0	 mov	 edx, DWORD PTR tv2304[ebp+4]
  00812	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00817	8b f8		 mov	 edi, eax
  00819	8b 45 ec	 mov	 eax, DWORD PTR tv2304[ebp]
  0081c	52		 push	 edx
  0081d	50		 push	 eax
  0081e	e8 00 00 00 00	 call	 __allmul
  00823	03 f8		 add	 edi, eax
  00825	13 da		 adc	 ebx, edx
$LN292@test_hit:
  00827	33 f6		 xor	 esi, esi
  00829	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  0082f	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00835	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  0083b	76 76		 jbe	 SHORT $LN106@test_hit
  0083d	8d 49 00	 npad	 3
$LL108@test_hit:

; 1132 : 		unsigned key = SEARCH[i] + DELTA;

  00840	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  00843	8b 3c b1	 mov	 edi, DWORD PTR [ecx+esi*4]
  00846	47		 inc	 edi

; 1133 : 		unsigned hash_key = hash(key);

  00847	8b d7		 mov	 edx, edi
  00849	c1 e2 06	 shl	 edx, 6
  0084c	8b c7		 mov	 eax, edi
  0084e	2b c2		 sub	 eax, edx
  00850	8b c8		 mov	 ecx, eax
  00852	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00855	33 c1		 xor	 eax, ecx
  00857	8b d0		 mov	 edx, eax
  00859	c1 e2 09	 shl	 edx, 9
  0085c	2b c2		 sub	 eax, edx
  0085e	8b c8		 mov	 ecx, eax
  00860	c1 e1 04	 shl	 ecx, 4
  00863	33 c1		 xor	 eax, ecx
  00865	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0086c	2b c2		 sub	 eax, edx
  0086e	8b c8		 mov	 ecx, eax
  00870	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00873	33 c1		 xor	 eax, ecx
  00875	8b d0		 mov	 edx, eax
  00877	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0087a	33 d0		 xor	 edx, eax

; 1134 : 		khiter_t k;
; 1135 : 		k = kh_get(word, khash, hash_key);

  0087c	52		 push	 edx
  0087d	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word
  00882	8b d8		 mov	 ebx, eax

; 1136 : 		if (k == kh_end(khash))

  00884	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00889	83 c4 04	 add	 esp, 4
  0088c	3b 18		 cmp	 ebx, DWORD PTR [eax]
  0088e	75 05		 jne	 SHORT $LN105@test_hit

; 1137 : 			abort();

  00890	e8 00 00 00 00	 call	 _abort
$LN105@test_hit:

; 1138 : 		if (dereference) {
; 1139 : 			struct khash_object* obj = kh_value(khash, k);

  00895	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  0089b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0089e	8b 04 9a	 mov	 eax, DWORD PTR [edx+ebx*4]

; 1140 : 			if (obj->value != key)

  008a1	39 38		 cmp	 DWORD PTR [eax], edi
  008a3	74 05		 je	 SHORT $LN107@test_hit

; 1141 : 				abort();

  008a5	e8 00 00 00 00	 call	 _abort
$LN107@test_hit:

; 1130 : 
; 1131 : 	START(DATA_KHASH) {

  008aa	46		 inc	 esi
  008ab	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  008b1	72 8d		 jb	 SHORT $LL108@test_hit
$LN106@test_hit:

; 1142 : 		}
; 1143 : 	} STOP();

  008b3	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1144 : 
; 1145 : #ifdef USE_CGOOGLEDENSEHASH
; 1146 : 	START(DATA_CGOOGLE) {
; 1147 : 		unsigned key = SEARCH[i] + DELTA;
; 1148 : 		HTItem* ptr;
; 1149 : 		ptr = HashFind(cgoogledensehash, key);
; 1150 : 		if (!ptr)
; 1151 : 			abort();
; 1152 : 		if (dereference) {
; 1153 : 			struct google_object* obj = (void*)ptr->data;
; 1154 : 			if (obj->value != key)
; 1155 : 				abort();
; 1156 : 		}
; 1157 : 	} STOP();
; 1158 : #endif
; 1159 : 
; 1160 : #ifdef USE_GOOGLEDENSEHASH
; 1161 : 	START(DATA_GOOGLEDENSEHASH) {

  008b8	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  008bd	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  008c2	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  008c8	0f 85 b8 01 00
	00		 jne	 $LN99@test_hit
  008ce	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  008d5	75 30		 jne	 SHORT $LN296@test_hit
  008d7	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  008dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  008e3	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  008ea	51		 push	 ecx
  008eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  008f1	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  008f8	50		 push	 eax
  008f9	52		 push	 edx
  008fa	68 00 00 00 00	 push	 OFFSET $SG-100
  008ff	e8 00 00 00 00	 call	 _printf
  00904	83 c4 10	 add	 esp, 16			; 00000010H
$LN296@test_hit:
  00907	8d 45 e4	 lea	 eax, DWORD PTR _t$199959[ebp]
  0090a	50		 push	 eax
  0090b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00911	85 c0		 test	 eax, eax
  00913	75 11		 jne	 SHORT $LN302@test_hit
  00915	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00919	66 0f 13 45 ec	 movlpd	 QWORD PTR $T199952[ebp], xmm0
  0091e	8b 5d f0	 mov	 ebx, DWORD PTR $T199952[ebp+4]
  00921	8b 7d ec	 mov	 edi, DWORD PTR $T199952[ebp]
  00924	eb 54		 jmp	 SHORT $LN303@test_hit
$LN302@test_hit:
  00926	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0092c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00932	8b 4d e8	 mov	 ecx, DWORD PTR _t$199959[ebp+4]
  00935	8b 55 e4	 mov	 edx, DWORD PTR _t$199959[ebp]
  00938	57		 push	 edi
  00939	56		 push	 esi
  0093a	51		 push	 ecx
  0093b	52		 push	 edx
  0093c	e8 00 00 00 00	 call	 __alldvrm
  00941	6a 00		 push	 0
  00943	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00948	53		 push	 ebx
  00949	51		 push	 ecx
  0094a	89 45 ec	 mov	 DWORD PTR tv1155[ebp], eax
  0094d	89 55 f0	 mov	 DWORD PTR tv1155[ebp+4], edx
  00950	e8 00 00 00 00	 call	 __allmul
  00955	57		 push	 edi
  00956	56		 push	 esi
  00957	52		 push	 edx
  00958	50		 push	 eax
  00959	e8 00 00 00 00	 call	 __alldiv
  0095e	8b 4d ec	 mov	 ecx, DWORD PTR tv1155[ebp]
  00961	6a 00		 push	 0
  00963	8b f8		 mov	 edi, eax
  00965	8b 45 f0	 mov	 eax, DWORD PTR tv1155[ebp+4]
  00968	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0096d	50		 push	 eax
  0096e	51		 push	 ecx
  0096f	8b da		 mov	 ebx, edx
  00971	e8 00 00 00 00	 call	 __allmul
  00976	03 f8		 add	 edi, eax
  00978	13 da		 adc	 ebx, edx
$LN303@test_hit:
  0097a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00981	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00987	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0098d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00994	0f 86 ec 00 00
	00		 jbe	 $LN99@test_hit
  0099a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LL101@test_hit:

; 1162 : 		unsigned key = SEARCH[i] + DELTA;

  009a0	8b 55 08	 mov	 edx, DWORD PTR _SEARCH$[ebp]
  009a3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  009a6	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]

; 1163 : 		googledensehash_t::const_iterator ptr = googledensehash->find(key);

  009a9	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  009ac	46		 inc	 esi
  009ad	2b 4f 20	 sub	 ecx, DWORD PTR [edi+32]
  009b0	89 75 f0	 mov	 DWORD PTR _key$148623[ebp], esi
  009b3	75 2c		 jne	 SHORT $LN309@test_hit
  009b5	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  009b8	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  009bb	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  009be	8b d9		 mov	 ebx, ecx
  009c0	3b d9		 cmp	 ebx, ecx
  009c2	74 63		 je	 SHORT $LL423@test_hit
  009c4	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
$LL321@test_hit:
  009c7	8b 03		 mov	 eax, DWORD PTR [ebx]
  009c9	3b d0		 cmp	 edx, eax
  009cb	74 0b		 je	 SHORT $LN319@test_hit
  009cd	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  009d1	76 54		 jbe	 SHORT $LL423@test_hit
  009d3	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  009d6	75 4f		 jne	 SHORT $LL423@test_hit
$LN319@test_hit:
  009d8	83 c3 08	 add	 ebx, 8
  009db	3b d9		 cmp	 ebx, ecx
  009dd	75 e8		 jne	 SHORT $LL321@test_hit
  009df	eb 46		 jmp	 SHORT $LL423@test_hit
$LN309@test_hit:
  009e1	8d 4d d4	 lea	 ecx, DWORD PTR _pos$201190[ebp]
  009e4	51		 push	 ecx
  009e5	8d 45 f0	 lea	 eax, DWORD PTR _key$148623[ebp]
  009e8	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  009ed	8b 45 d4	 mov	 eax, DWORD PTR _pos$201190[ebp]
  009f0	83 f8 ff	 cmp	 eax, -1
  009f3	75 2c		 jne	 SHORT $LN308@test_hit
  009f5	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  009f8	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  009fb	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  009fe	8b d9		 mov	 ebx, ecx
  00a00	3b d9		 cmp	 ebx, ecx
  00a02	74 23		 je	 SHORT $LL423@test_hit
  00a04	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
$LL373@test_hit:
  00a07	8b 03		 mov	 eax, DWORD PTR [ebx]
  00a09	3b d0		 cmp	 edx, eax
  00a0b	74 0b		 je	 SHORT $LN371@test_hit
  00a0d	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00a11	76 14		 jbe	 SHORT $LL423@test_hit
  00a13	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00a16	75 0f		 jne	 SHORT $LL423@test_hit
$LN371@test_hit:
  00a18	83 c3 08	 add	 ebx, 8
  00a1b	3b d9		 cmp	 ebx, ecx
  00a1d	75 e8		 jne	 SHORT $LL373@test_hit
  00a1f	eb 06		 jmp	 SHORT $LL423@test_hit
$LN308@test_hit:
  00a21	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00a24	8d 1c c1	 lea	 ebx, DWORD PTR [ecx+eax*8]
$LL423@test_hit:

; 1164 : 		if (ptr == googledensehash->end())

  00a27	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00a2a	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00a2d	8d 14 d0	 lea	 edx, DWORD PTR [eax+edx*8]
  00a30	8b c2		 mov	 eax, edx
  00a32	3b c2		 cmp	 eax, edx
  00a34	74 1c		 je	 SHORT $LN516@test_hit
$LL479@test_hit:
  00a36	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a38	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  00a3b	74 0b		 je	 SHORT $LN477@test_hit
  00a3d	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00a41	76 0c		 jbe	 SHORT $LN1092@test_hit
  00a43	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00a46	75 07		 jne	 SHORT $LN1092@test_hit
$LN477@test_hit:
  00a48	83 c0 08	 add	 eax, 8
  00a4b	3b c2		 cmp	 eax, edx
  00a4d	75 e7		 jne	 SHORT $LL479@test_hit
$LN1092@test_hit:
  00a4f	8b 75 f0	 mov	 esi, DWORD PTR _key$148623[ebp]
$LN516@test_hit:
  00a52	3b d8		 cmp	 ebx, eax
  00a54	75 0b		 jne	 SHORT $LN98@test_hit

; 1165 : 			abort();

  00a56	e8 00 00 00 00	 call	 _abort
  00a5b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN98@test_hit:

; 1166 : 		if (dereference) {
; 1167 : 			struct google_object* obj = ptr->second;

  00a61	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 1168 : 			if (obj->value != key)

  00a64	39 31		 cmp	 DWORD PTR [ecx], esi
  00a66	74 0b		 je	 SHORT $LN100@test_hit

; 1169 : 				abort();

  00a68	e8 00 00 00 00	 call	 _abort
  00a6d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN100@test_hit:

; 1144 : 
; 1145 : #ifdef USE_CGOOGLEDENSEHASH
; 1146 : 	START(DATA_CGOOGLE) {
; 1147 : 		unsigned key = SEARCH[i] + DELTA;
; 1148 : 		HTItem* ptr;
; 1149 : 		ptr = HashFind(cgoogledensehash, key);
; 1150 : 		if (!ptr)
; 1151 : 			abort();
; 1152 : 		if (dereference) {
; 1153 : 			struct google_object* obj = (void*)ptr->data;
; 1154 : 			if (obj->value != key)
; 1155 : 				abort();
; 1156 : 		}
; 1157 : 	} STOP();
; 1158 : #endif
; 1159 : 
; 1160 : #ifdef USE_GOOGLEDENSEHASH
; 1161 : 	START(DATA_GOOGLEDENSEHASH) {

  00a73	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a76	40		 inc	 eax
  00a77	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00a7a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00a80	0f 82 1a ff ff
	ff		 jb	 $LL101@test_hit
$LN99@test_hit:

; 1170 : 		}
; 1171 : 	} STOP();

  00a86	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1172 : #endif
; 1173 : 
; 1174 : #ifdef USE_GOOGLEBTREE
; 1175 : 	START(DATA_GOOGLEBTREE) {

  00a8b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00a90	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00a95	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00a9b	0f 85 04 02 00
	00		 jne	 $LN92@test_hit
  00aa1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00aa8	75 2f		 jne	 SHORT $LN532@test_hit
  00aaa	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  00ab0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00ab5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00abc	52		 push	 edx
  00abd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00ac3	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00aca	51		 push	 ecx
  00acb	50		 push	 eax
  00acc	68 00 00 00 00	 push	 OFFSET $SG-100
  00ad1	e8 00 00 00 00	 call	 _printf
  00ad6	83 c4 10	 add	 esp, 16			; 00000010H
$LN532@test_hit:
  00ad9	8d 4d dc	 lea	 ecx, DWORD PTR _t$201601[ebp]
  00adc	51		 push	 ecx
  00add	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00ae3	85 c0		 test	 eax, eax
  00ae5	75 11		 jne	 SHORT $LN538@test_hit
  00ae7	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00aeb	66 0f 13 45 e4	 movlpd	 QWORD PTR $T201594[ebp], xmm0
  00af0	8b 5d e8	 mov	 ebx, DWORD PTR $T201594[ebp+4]
  00af3	8b 7d e4	 mov	 edi, DWORD PTR $T201594[ebp]
  00af6	eb 54		 jmp	 SHORT $LN539@test_hit
$LN538@test_hit:
  00af8	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00afe	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00b04	8b 55 e0	 mov	 edx, DWORD PTR _t$201601[ebp+4]
  00b07	8b 45 dc	 mov	 eax, DWORD PTR _t$201601[ebp]
  00b0a	57		 push	 edi
  00b0b	56		 push	 esi
  00b0c	52		 push	 edx
  00b0d	50		 push	 eax
  00b0e	e8 00 00 00 00	 call	 __alldvrm
  00b13	6a 00		 push	 0
  00b15	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b1a	53		 push	 ebx
  00b1b	51		 push	 ecx
  00b1c	89 45 ec	 mov	 DWORD PTR tv1520[ebp], eax
  00b1f	89 55 f0	 mov	 DWORD PTR tv1520[ebp+4], edx
  00b22	e8 00 00 00 00	 call	 __allmul
  00b27	57		 push	 edi
  00b28	56		 push	 esi
  00b29	52		 push	 edx
  00b2a	50		 push	 eax
  00b2b	e8 00 00 00 00	 call	 __alldiv
  00b30	8b 4d f0	 mov	 ecx, DWORD PTR tv1520[ebp+4]
  00b33	6a 00		 push	 0
  00b35	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b3a	8b da		 mov	 ebx, edx
  00b3c	8b 55 ec	 mov	 edx, DWORD PTR tv1520[ebp]
  00b3f	51		 push	 ecx
  00b40	52		 push	 edx
  00b41	8b f8		 mov	 edi, eax
  00b43	e8 00 00 00 00	 call	 __allmul
  00b48	03 f8		 add	 edi, eax
  00b4a	13 da		 adc	 ebx, edx
$LN539@test_hit:
  00b4c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00b53	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00b59	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00b5f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00b66	0f 86 39 01 00
	00		 jbe	 $LN92@test_hit
$LN94@test_hit:

; 1176 : 		unsigned key = SEARCH[i] + DELTA;

  00b6c	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  00b6f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]

; 1177 : 		googlebtree_t::const_iterator ptr = googlebtree->find(key);

  00b72	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00b78	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
  00b7b	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00b7d	46		 inc	 esi
  00b7e	89 75 f0	 mov	 DWORD PTR _key$148806[ebp], esi
  00b81	85 db		 test	 ebx, ebx
  00b83	74 65		 je	 SHORT $LN670@test_hit
  00b85	8b cb		 mov	 ecx, ebx
$LL567@test_hit:
  00b87	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00b8b	33 c0		 xor	 eax, eax
  00b8d	85 ff		 test	 edi, edi
  00b8f	7e 0f		 jle	 SHORT $LN1011@test_hit
  00b91	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
$LL582@test_hit:
  00b94	39 32		 cmp	 DWORD PTR [edx], esi
  00b96	73 08		 jae	 SHORT $LN1011@test_hit
  00b98	40		 inc	 eax
  00b99	83 c2 08	 add	 edx, 8
  00b9c	3b c7		 cmp	 eax, edi
  00b9e	7c f4		 jl	 SHORT $LL582@test_hit
$LN1011@test_hit:
  00ba0	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00ba3	75 0b		 jne	 SHORT $LL1012@test_hit
  00ba5	8b 8c 81 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+256]
  00bac	eb d9		 jmp	 SHORT $LL567@test_hit
  00bae	8b ff		 npad	 2
$LL1012@test_hit:
  00bb0	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00bb4	3b c2		 cmp	 eax, edx
  00bb6	75 1d		 jne	 SHORT $LN624@test_hit
  00bb8	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00bbc	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00bbf	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00bc2	74 ec		 je	 SHORT $LL1012@test_hit
$LN660@test_hit:
  00bc4	85 db		 test	 ebx, ebx
  00bc6	74 22		 je	 SHORT $LN670@test_hit
  00bc8	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00bcb	75 1d		 jne	 SHORT $LN670@test_hit
  00bcd	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00bd3	eb 17		 jmp	 SHORT $LN682@test_hit
$LN624@test_hit:
  00bd5	85 c9		 test	 ecx, ecx
  00bd7	74 eb		 je	 SHORT $LN660@test_hit
  00bd9	3b 74 c1 08	 cmp	 esi, DWORD PTR [ecx+eax*8+8]
  00bdd	72 e5		 jb	 SHORT $LN660@test_hit
  00bdf	89 45 e8	 mov	 DWORD PTR $T202806[ebp+4], eax
  00be2	89 4d e4	 mov	 DWORD PTR $T202806[ebp], ecx
  00be5	8d 45 e4	 lea	 eax, DWORD PTR $T202806[ebp]
  00be8	eb 41		 jmp	 SHORT $LN661@test_hit
$LN670@test_hit:
  00bea	8b c3		 mov	 eax, ebx
$LN682@test_hit:
  00bec	85 c0		 test	 eax, eax
  00bee	74 1d		 je	 SHORT $LN666@test_hit
  00bf0	85 db		 test	 ebx, ebx
  00bf2	74 11		 je	 SHORT $LN686@test_hit
  00bf4	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00bf7	75 0c		 jne	 SHORT $LN686@test_hit
  00bf9	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00bff	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00c03	eb 0a		 jmp	 SHORT $LN667@test_hit
$LN686@test_hit:
  00c05	8b c3		 mov	 eax, ebx
  00c07	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00c0b	eb 02		 jmp	 SHORT $LN667@test_hit
$LN666@test_hit:
  00c0d	33 c9		 xor	 ecx, ecx
$LN667@test_hit:
  00c0f	85 db		 test	 ebx, ebx
  00c11	74 0d		 je	 SHORT $LN704@test_hit
  00c13	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c16	75 08		 jne	 SHORT $LN704@test_hit
  00c18	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00c1e	eb 02		 jmp	 SHORT $LN716@test_hit
$LN704@test_hit:
  00c20	8b c3		 mov	 eax, ebx
$LN716@test_hit:
  00c22	89 45 d4	 mov	 DWORD PTR $T202807[ebp], eax
  00c25	89 4d d8	 mov	 DWORD PTR $T202807[ebp+4], ecx
  00c28	8d 45 d4	 lea	 eax, DWORD PTR $T202807[ebp]
$LN661@test_hit:
  00c2b	8b 38		 mov	 edi, DWORD PTR [eax]
  00c2d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1178 : 		if (ptr == googlebtree->end())

  00c30	85 db		 test	 ebx, ebx
  00c32	74 0d		 je	 SHORT $LN732@test_hit
  00c34	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c37	75 08		 jne	 SHORT $LN732@test_hit
  00c39	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00c3f	eb 02		 jmp	 SHORT $LN744@test_hit
$LN732@test_hit:
  00c41	8b c3		 mov	 eax, ebx
$LN744@test_hit:
  00c43	85 c0		 test	 eax, eax
  00c45	74 1d		 je	 SHORT $LN728@test_hit
  00c47	85 db		 test	 ebx, ebx
  00c49	74 11		 je	 SHORT $LN748@test_hit
  00c4b	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c4e	75 0c		 jne	 SHORT $LN748@test_hit
  00c50	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00c56	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00c5a	eb 0a		 jmp	 SHORT $LN729@test_hit
$LN748@test_hit:
  00c5c	8b c3		 mov	 eax, ebx
  00c5e	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00c62	eb 02		 jmp	 SHORT $LN729@test_hit
$LN728@test_hit:
  00c64	33 c0		 xor	 eax, eax
$LN729@test_hit:
  00c66	85 db		 test	 ebx, ebx
  00c68	74 0b		 je	 SHORT $LN766@test_hit
  00c6a	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c6d	75 06		 jne	 SHORT $LN766@test_hit
  00c6f	8b 9b 80 01 00
	00		 mov	 ebx, DWORD PTR [ebx+384]
$LN766@test_hit:
  00c75	3b fb		 cmp	 edi, ebx
  00c77	75 09		 jne	 SHORT $LN91@test_hit
  00c79	3b f0		 cmp	 esi, eax
  00c7b	75 05		 jne	 SHORT $LN91@test_hit

; 1179 : 			abort();

  00c7d	e8 00 00 00 00	 call	 _abort
$LN91@test_hit:

; 1180 : 		if (dereference) {
; 1181 : 			struct google_object* obj = ptr->second;

  00c82	8b 44 f7 0c	 mov	 eax, DWORD PTR [edi+esi*8+12]

; 1182 : 			if (obj->value != key)

  00c86	8b 4d f0	 mov	 ecx, DWORD PTR _key$148806[ebp]
  00c89	39 08		 cmp	 DWORD PTR [eax], ecx
  00c8b	74 05		 je	 SHORT $LN93@test_hit

; 1183 : 				abort();

  00c8d	e8 00 00 00 00	 call	 _abort
$LN93@test_hit:

; 1172 : #endif
; 1173 : 
; 1174 : #ifdef USE_GOOGLEBTREE
; 1175 : 	START(DATA_GOOGLEBTREE) {

  00c92	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00c95	40		 inc	 eax
  00c96	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00c99	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00c9f	0f 82 c7 fe ff
	ff		 jb	 $LN94@test_hit
$LN92@test_hit:

; 1184 : 		}
; 1185 : 	} STOP();

  00ca5	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1186 : #endif
; 1187 : 
; 1188 : #ifdef USE_CPPMAP
; 1189 : 	START(DATA_CPPMAP) {

  00caa	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00caf	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00cb4	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00cba	0f 85 3e 01 00
	00		 jne	 $LN85@test_hit
  00cc0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00cc7	75 2f		 jne	 SHORT $LN792@test_hit
  00cc9	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  00ccf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00cd4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00cdb	52		 push	 edx
  00cdc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00ce2	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00ce9	51		 push	 ecx
  00cea	50		 push	 eax
  00ceb	68 00 00 00 00	 push	 OFFSET $SG-100
  00cf0	e8 00 00 00 00	 call	 _printf
  00cf5	83 c4 10	 add	 esp, 16			; 00000010H
$LN792@test_hit:
  00cf8	8d 4d dc	 lea	 ecx, DWORD PTR _t$203176[ebp]
  00cfb	51		 push	 ecx
  00cfc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00d02	85 c0		 test	 eax, eax
  00d04	75 11		 jne	 SHORT $LN798@test_hit
  00d06	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00d0a	66 0f 13 45 d4	 movlpd	 QWORD PTR $T203169[ebp], xmm0
  00d0f	8b 5d d8	 mov	 ebx, DWORD PTR $T203169[ebp+4]
  00d12	8b 7d d4	 mov	 edi, DWORD PTR $T203169[ebp]
  00d15	eb 54		 jmp	 SHORT $LN799@test_hit
$LN798@test_hit:
  00d17	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00d1d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00d23	8b 55 e0	 mov	 edx, DWORD PTR _t$203176[ebp+4]
  00d26	8b 45 dc	 mov	 eax, DWORD PTR _t$203176[ebp]
  00d29	57		 push	 edi
  00d2a	56		 push	 esi
  00d2b	52		 push	 edx
  00d2c	50		 push	 eax
  00d2d	e8 00 00 00 00	 call	 __alldvrm
  00d32	6a 00		 push	 0
  00d34	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d39	53		 push	 ebx
  00d3a	51		 push	 ecx
  00d3b	89 45 ec	 mov	 DWORD PTR tv2820[ebp], eax
  00d3e	89 55 f0	 mov	 DWORD PTR tv2820[ebp+4], edx
  00d41	e8 00 00 00 00	 call	 __allmul
  00d46	57		 push	 edi
  00d47	56		 push	 esi
  00d48	52		 push	 edx
  00d49	50		 push	 eax
  00d4a	e8 00 00 00 00	 call	 __alldiv
  00d4f	8b 4d f0	 mov	 ecx, DWORD PTR tv2820[ebp+4]
  00d52	6a 00		 push	 0
  00d54	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d59	8b da		 mov	 ebx, edx
  00d5b	8b 55 ec	 mov	 edx, DWORD PTR tv2820[ebp]
  00d5e	51		 push	 ecx
  00d5f	52		 push	 edx
  00d60	8b f8		 mov	 edi, eax
  00d62	e8 00 00 00 00	 call	 __allmul
  00d67	03 f8		 add	 edi, eax
  00d69	13 da		 adc	 ebx, edx
$LN799@test_hit:
  00d6b	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00d71	33 db		 xor	 ebx, ebx
  00d73	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00d79	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  00d7f	0f 86 79 00 00
	00		 jbe	 $LN85@test_hit
  00d85	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL87@test_hit:

; 1190 : 		unsigned key = SEARCH[i] + DELTA;

  00d90	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]

; 1191 : 		cppmap_t::const_iterator ptr = cppmap->find(key);

  00d93	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  00d99	8b 3c 98	 mov	 edi, DWORD PTR [eax+ebx*4]
  00d9c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00d9f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00da2	47		 inc	 edi
  00da3	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00da7	75 1b		 jne	 SHORT $LN809@test_hit
  00da9	8d a4 24 00 00
	00 00		 npad	 7
$LL810@test_hit:
  00db0	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  00db3	73 05		 jae	 SHORT $LN808@test_hit
  00db5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00db8	eb 04		 jmp	 SHORT $LN807@test_hit
$LN808@test_hit:
  00dba	8b c8		 mov	 ecx, eax
  00dbc	8b 00		 mov	 eax, DWORD PTR [eax]
$LN807@test_hit:
  00dbe	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00dc2	74 ec		 je	 SHORT $LL810@test_hit
$LN809@test_hit:
  00dc4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00dc7	89 4d f0	 mov	 DWORD PTR __Where$203404[ebp], ecx
  00dca	3b c8		 cmp	 ecx, eax
  00dcc	74 0a		 je	 SHORT $LN803@test_hit
  00dce	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00dd1	72 05		 jb	 SHORT $LN803@test_hit
  00dd3	8d 4d f0	 lea	 ecx, DWORD PTR __Where$203404[ebp]
  00dd6	eb 06		 jmp	 SHORT $LN804@test_hit
$LN803@test_hit:
  00dd8	89 45 f8	 mov	 DWORD PTR $T203409[ebp], eax
  00ddb	8d 4d f8	 lea	 ecx, DWORD PTR $T203409[ebp]
$LN804@test_hit:
  00dde	8b 31		 mov	 esi, DWORD PTR [ecx]

; 1192 : 		if (ptr == cppmap->end())

  00de0	3b f0		 cmp	 esi, eax
  00de2	75 05		 jne	 SHORT $LN84@test_hit

; 1193 : 			abort();

  00de4	e8 00 00 00 00	 call	 _abort
$LN84@test_hit:

; 1194 : 		if (dereference) {
; 1195 : 			struct cpp_object* obj = ptr->second;

  00de9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 1196 : 			if (obj->value != key)

  00dec	39 39		 cmp	 DWORD PTR [ecx], edi
  00dee	74 05		 je	 SHORT $LN86@test_hit

; 1197 : 				abort();

  00df0	e8 00 00 00 00	 call	 _abort
$LN86@test_hit:

; 1186 : #endif
; 1187 : 
; 1188 : #ifdef USE_CPPMAP
; 1189 : 	START(DATA_CPPMAP) {

  00df5	43		 inc	 ebx
  00df6	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00dfc	72 92		 jb	 SHORT $LL87@test_hit
$LN85@test_hit:

; 1198 : 		}
; 1199 : 	} STOP();

  00dfe	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1200 : #endif
; 1201 : 
; 1202 : #ifdef USE_CPPUNORDEREDMAP
; 1203 : 	START(DATA_CPPUNORDEREDMAP) {

  00e03	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  00e08	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00e0d	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00e13	0f 85 0b 01 00
	00		 jne	 $LN78@test_hit
  00e19	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00e20	75 2f		 jne	 SHORT $LN889@test_hit
  00e22	8b 15 34 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  00e28	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00e2d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00e34	52		 push	 edx
  00e35	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00e3b	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00e42	51		 push	 ecx
  00e43	50		 push	 eax
  00e44	68 00 00 00 00	 push	 OFFSET $SG-100
  00e49	e8 00 00 00 00	 call	 _printf
  00e4e	83 c4 10	 add	 esp, 16			; 00000010H
$LN889@test_hit:
  00e51	8d 4d dc	 lea	 ecx, DWORD PTR _t$203550[ebp]
  00e54	51		 push	 ecx
  00e55	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00e5b	85 c0		 test	 eax, eax
  00e5d	75 11		 jne	 SHORT $LN895@test_hit
  00e5f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00e63	66 0f 13 45 d4	 movlpd	 QWORD PTR $T203543[ebp], xmm0
  00e68	8b 5d d8	 mov	 ebx, DWORD PTR $T203543[ebp+4]
  00e6b	8b 7d d4	 mov	 edi, DWORD PTR $T203543[ebp]
  00e6e	eb 54		 jmp	 SHORT $LN896@test_hit
$LN895@test_hit:
  00e70	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00e76	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00e7c	8b 55 e0	 mov	 edx, DWORD PTR _t$203550[ebp+4]
  00e7f	8b 45 dc	 mov	 eax, DWORD PTR _t$203550[ebp]
  00e82	57		 push	 edi
  00e83	56		 push	 esi
  00e84	52		 push	 edx
  00e85	50		 push	 eax
  00e86	e8 00 00 00 00	 call	 __alldvrm
  00e8b	6a 00		 push	 0
  00e8d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00e92	53		 push	 ebx
  00e93	51		 push	 ecx
  00e94	89 45 ec	 mov	 DWORD PTR tv2793[ebp], eax
  00e97	89 55 f0	 mov	 DWORD PTR tv2793[ebp+4], edx
  00e9a	e8 00 00 00 00	 call	 __allmul
  00e9f	57		 push	 edi
  00ea0	56		 push	 esi
  00ea1	52		 push	 edx
  00ea2	50		 push	 eax
  00ea3	e8 00 00 00 00	 call	 __alldiv
  00ea8	8b 4d f0	 mov	 ecx, DWORD PTR tv2793[ebp+4]
  00eab	6a 00		 push	 0
  00ead	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00eb2	8b da		 mov	 ebx, edx
  00eb4	8b 55 ec	 mov	 edx, DWORD PTR tv2793[ebp]
  00eb7	51		 push	 ecx
  00eb8	52		 push	 edx
  00eb9	8b f8		 mov	 edi, eax
  00ebb	e8 00 00 00 00	 call	 __allmul
  00ec0	03 f8		 add	 edi, eax
  00ec2	13 da		 adc	 ebx, edx
$LN896@test_hit:
  00ec4	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00eca	33 db		 xor	 ebx, ebx
  00ecc	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00ed2	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  00ed8	76 4a		 jbe	 SHORT $LN78@test_hit
  00eda	8d 9b 00 00 00
	00		 npad	 6
$LL80@test_hit:

; 1204 : 		unsigned key = SEARCH[i] + DELTA;

  00ee0	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  00ee3	8b 3c 98	 mov	 edi, DWORD PTR [eax+ebx*4]

; 1205 : 		cppunorderedmap_t::const_iterator ptr = cppunorderedmap->find(key);

  00ee6	8d 4d f8	 lea	 ecx, DWORD PTR $T199547[ebp]
  00ee9	51		 push	 ecx
  00eea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00ef0	47		 inc	 edi
  00ef1	8d 45 f0	 lea	 eax, DWORD PTR _key$149191[ebp]
  00ef4	89 7d f0	 mov	 DWORD PTR _key$149191[ebp], edi
  00ef7	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1206 : 		if (ptr == cppunorderedmap->end())

  00efc	8b 75 f8	 mov	 esi, DWORD PTR $T199547[ebp]
  00eff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00f05	3b 72 04	 cmp	 esi, DWORD PTR [edx+4]
  00f08	75 05		 jne	 SHORT $LN77@test_hit

; 1207 : 			abort();

  00f0a	e8 00 00 00 00	 call	 _abort
$LN77@test_hit:

; 1208 : 		if (dereference) {
; 1209 : 			struct cpp_object* obj = ptr->second;

  00f0f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 1210 : 			if (obj->value != key)

  00f12	39 38		 cmp	 DWORD PTR [eax], edi
  00f14	74 05		 je	 SHORT $LN79@test_hit

; 1211 : 				abort();

  00f16	e8 00 00 00 00	 call	 _abort
$LN79@test_hit:

; 1200 : #endif
; 1201 : 
; 1202 : #ifdef USE_CPPUNORDEREDMAP
; 1203 : 	START(DATA_CPPUNORDEREDMAP) {

  00f1b	43		 inc	 ebx
  00f1c	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00f22	72 bc		 jb	 SHORT $LL80@test_hit
$LN78@test_hit:

; 1212 : 		}
; 1213 : 	} STOP();

  00f24	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1214 : #endif
; 1215 : 
; 1216 : 	START(DATA_UTHASH) {

  00f29	b8 08 00 00 00	 mov	 eax, 8
  00f2e	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00f33	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00f39	0f 85 cb 01 00
	00		 jne	 $LN71@test_hit
  00f3f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00f46	75 30		 jne	 SHORT $LN920@test_hit
  00f48	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+32
  00f4e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00f54	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00f5b	51		 push	 ecx
  00f5c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00f62	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  00f69	50		 push	 eax
  00f6a	52		 push	 edx
  00f6b	68 00 00 00 00	 push	 OFFSET $SG-100
  00f70	e8 00 00 00 00	 call	 _printf
  00f75	83 c4 10	 add	 esp, 16			; 00000010H
$LN920@test_hit:
  00f78	8d 45 dc	 lea	 eax, DWORD PTR _t$203644[ebp]
  00f7b	50		 push	 eax
  00f7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00f82	85 c0		 test	 eax, eax
  00f84	75 11		 jne	 SHORT $LN926@test_hit
  00f86	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00f8a	66 0f 13 45 d4	 movlpd	 QWORD PTR $T203637[ebp], xmm0
  00f8f	8b 5d d8	 mov	 ebx, DWORD PTR $T203637[ebp+4]
  00f92	8b 7d d4	 mov	 edi, DWORD PTR $T203637[ebp]
  00f95	eb 54		 jmp	 SHORT $LN927@test_hit
$LN926@test_hit:
  00f97	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00f9d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00fa3	8b 4d e0	 mov	 ecx, DWORD PTR _t$203644[ebp+4]
  00fa6	8b 55 dc	 mov	 edx, DWORD PTR _t$203644[ebp]
  00fa9	57		 push	 edi
  00faa	56		 push	 esi
  00fab	51		 push	 ecx
  00fac	52		 push	 edx
  00fad	e8 00 00 00 00	 call	 __alldvrm
  00fb2	6a 00		 push	 0
  00fb4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00fb9	53		 push	 ebx
  00fba	51		 push	 ecx
  00fbb	89 45 ec	 mov	 DWORD PTR tv2784[ebp], eax
  00fbe	89 55 f0	 mov	 DWORD PTR tv2784[ebp+4], edx
  00fc1	e8 00 00 00 00	 call	 __allmul
  00fc6	57		 push	 edi
  00fc7	56		 push	 esi
  00fc8	52		 push	 edx
  00fc9	50		 push	 eax
  00fca	e8 00 00 00 00	 call	 __alldiv
  00fcf	8b 4d ec	 mov	 ecx, DWORD PTR tv2784[ebp]
  00fd2	6a 00		 push	 0
  00fd4	8b f8		 mov	 edi, eax
  00fd6	8b 45 f0	 mov	 eax, DWORD PTR tv2784[ebp+4]
  00fd9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00fde	50		 push	 eax
  00fdf	51		 push	 ecx
  00fe0	8b da		 mov	 ebx, edx
  00fe2	e8 00 00 00 00	 call	 __allmul
  00fe7	03 f8		 add	 edi, eax
  00fe9	13 da		 adc	 ebx, edx
$LN927@test_hit:
  00feb	33 f6		 xor	 esi, esi
  00fed	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00ff3	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00ff9	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00fff	0f 86 05 01 00
	00		 jbe	 $LN71@test_hit
$LL73@test_hit:

; 1217 : 		unsigned key = SEARCH[i] + DELTA;

  01005	8b 55 08	 mov	 edx, DWORD PTR _SEARCH$[ebp]
  01008	8b 1c b2	 mov	 ebx, DWORD PTR [edx+esi*4]
  0100b	43		 inc	 ebx

; 1218 : 		struct uthash_object* obj;
; 1219 : 		HASH_FIND_INT(uthash, &key, obj);  

  0100c	33 ff		 xor	 edi, edi
  0100e	89 5d f0	 mov	 DWORD PTR _key$149336[ebp], ebx
  01011	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?uthash@@3PAUuthash_object@@A, edi ; uthash
  01017	0f 84 d1 00 00
	00		 je	 $LN1042@test_hit
  0101d	0f be 45 f3	 movsx	 eax, BYTE PTR _key$149336[ebp+3]
  01021	0f be 4d f2	 movsx	 ecx, BYTE PTR _key$149336[ebp+2]
  01025	c1 e0 18	 shl	 eax, 24			; 00000018H
  01028	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  0102d	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01030	03 c1		 add	 eax, ecx
  01032	0f be d7	 movsx	 edx, bh
  01035	c1 e2 08	 shl	 edx, 8
  01038	03 d0		 add	 edx, eax
  0103a	0f be cb	 movsx	 ecx, bl
  0103d	03 d1		 add	 edx, ecx
  0103f	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  01045	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  0104b	8b c2		 mov	 eax, edx
  0104d	c1 e0 08	 shl	 eax, 8
  01050	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  01055	2b ca		 sub	 ecx, edx
  01057	33 c8		 xor	 ecx, eax
  01059	8b f9		 mov	 edi, ecx
  0105b	c1 ef 0d	 shr	 edi, 13			; 0000000dH
  0105e	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  01063	2b c1		 sub	 eax, ecx
  01065	2b c2		 sub	 eax, edx
  01067	33 c7		 xor	 eax, edi
  01069	2b d1		 sub	 edx, ecx
  0106b	2b d0		 sub	 edx, eax
  0106d	8b f8		 mov	 edi, eax
  0106f	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  01072	33 d7		 xor	 edx, edi
  01074	2b ca		 sub	 ecx, edx
  01076	2b c8		 sub	 ecx, eax
  01078	8b fa		 mov	 edi, edx
  0107a	c1 e7 10	 shl	 edi, 16			; 00000010H
  0107d	33 cf		 xor	 ecx, edi
  0107f	2b c1		 sub	 eax, ecx
  01081	2b c2		 sub	 eax, edx
  01083	8b f9		 mov	 edi, ecx
  01085	c1 ef 05	 shr	 edi, 5
  01088	33 c7		 xor	 eax, edi
  0108a	2b d1		 sub	 edx, ecx
  0108c	2b d0		 sub	 edx, eax
  0108e	8b f8		 mov	 edi, eax
  01090	c1 ef 03	 shr	 edi, 3
  01093	33 d7		 xor	 edx, edi
  01095	2b ca		 sub	 ecx, edx
  01097	2b c8		 sub	 ecx, eax
  01099	8b fa		 mov	 edi, edx
  0109b	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  0109e	33 cf		 xor	 ecx, edi
  010a0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  010a6	8b 3f		 mov	 edi, DWORD PTR [edi]
  010a8	2b c1		 sub	 eax, ecx
  010aa	2b c2		 sub	 eax, edx
  010ac	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  010af	33 c1		 xor	 eax, ecx
  010b1	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  010b4	49		 dec	 ecx
  010b5	23 c1		 and	 eax, ecx
  010b7	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  010ba	8b 07		 mov	 eax, DWORD PTR [edi]
  010bc	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  010bf	85 c0		 test	 eax, eax
  010c1	74 29		 je	 SHORT $LN29@test_hit
  010c3	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  010c6	2b c1		 sub	 eax, ecx
  010c8	8b f8		 mov	 edi, eax
  010ca	85 ff		 test	 edi, edi
  010cc	74 20		 je	 SHORT $LN1042@test_hit
  010ce	b8 04 00 00 00	 mov	 eax, 4
$LL33@test_hit:
  010d3	39 47 18	 cmp	 DWORD PTR [edi+24], eax
  010d6	75 07		 jne	 SHORT $LN30@test_hit
  010d8	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  010db	39 1a		 cmp	 DWORD PTR [edx], ebx
  010dd	74 14		 je	 SHORT $LN24@test_hit
$LN30@test_hit:
  010df	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  010e2	85 ff		 test	 edi, edi
  010e4	74 06		 je	 SHORT $LN29@test_hit
  010e6	2b f9		 sub	 edi, ecx
  010e8	75 e9		 jne	 SHORT $LL33@test_hit
  010ea	eb 02		 jmp	 SHORT $LN1042@test_hit
$LN29@test_hit:
  010ec	33 ff		 xor	 edi, edi
$LN1042@test_hit:

; 1220 : 		if (!obj)
; 1221 : 			abort();

  010ee	e8 00 00 00 00	 call	 _abort
$LN24@test_hit:

; 1222 : 		if (dereference) {
; 1223 : 			if (obj->value != key)

  010f3	39 5f 20	 cmp	 DWORD PTR [edi+32], ebx
  010f6	74 05		 je	 SHORT $LN72@test_hit

; 1224 : 				abort();

  010f8	e8 00 00 00 00	 call	 _abort
$LN72@test_hit:

; 1214 : #endif
; 1215 : 
; 1216 : 	START(DATA_UTHASH) {

  010fd	46		 inc	 esi
  010fe	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01104	0f 82 fb fe ff
	ff		 jb	 $LL73@test_hit
$LN71@test_hit:

; 1225 : 		}
; 1226 : 	} STOP();

  0110a	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1227 : 
; 1228 : #ifdef USE_JUDY
; 1229 : 	START(DATA_JUDY) {

  0110f	b8 09 00 00 00	 mov	 eax, 9
  01114	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01119	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0111f	0f 85 03 01 00
	00		 jne	 $LN18@test_hit
  01125	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0112c	75 2e		 jne	 SHORT $LN929@test_hit
  0112e	a1 24 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+36
  01133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01139	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  01140	50		 push	 eax
  01141	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01146	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0114d	52		 push	 edx
  0114e	51		 push	 ecx
  0114f	68 00 00 00 00	 push	 OFFSET $SG-100
  01154	e8 00 00 00 00	 call	 _printf
  01159	83 c4 10	 add	 esp, 16			; 00000010H
$LN929@test_hit:
  0115c	8d 55 d4	 lea	 edx, DWORD PTR _t$203667[ebp]
  0115f	52		 push	 edx
  01160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01166	85 c0		 test	 eax, eax
  01168	75 11		 jne	 SHORT $LN935@test_hit
  0116a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0116e	66 0f 13 45 d4	 movlpd	 QWORD PTR $T203660[ebp], xmm0
  01173	8b 5d d8	 mov	 ebx, DWORD PTR $T203660[ebp+4]
  01176	8b 7d d4	 mov	 edi, DWORD PTR $T203660[ebp]
  01179	eb 54		 jmp	 SHORT $LN936@test_hit
$LN935@test_hit:
  0117b	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01181	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01187	8b 45 d8	 mov	 eax, DWORD PTR _t$203667[ebp+4]
  0118a	8b 4d d4	 mov	 ecx, DWORD PTR _t$203667[ebp]
  0118d	57		 push	 edi
  0118e	56		 push	 esi
  0118f	50		 push	 eax
  01190	51		 push	 ecx
  01191	e8 00 00 00 00	 call	 __alldvrm
  01196	6a 00		 push	 0
  01198	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0119d	53		 push	 ebx
  0119e	51		 push	 ecx
  0119f	89 45 ec	 mov	 DWORD PTR tv447[ebp], eax
  011a2	89 55 f0	 mov	 DWORD PTR tv447[ebp+4], edx
  011a5	e8 00 00 00 00	 call	 __allmul
  011aa	57		 push	 edi
  011ab	56		 push	 esi
  011ac	52		 push	 edx
  011ad	50		 push	 eax
  011ae	e8 00 00 00 00	 call	 __alldiv
  011b3	6a 00		 push	 0
  011b5	8b da		 mov	 ebx, edx
  011b7	8b 55 f0	 mov	 edx, DWORD PTR tv447[ebp+4]
  011ba	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  011bf	8b f8		 mov	 edi, eax
  011c1	8b 45 ec	 mov	 eax, DWORD PTR tv447[ebp]
  011c4	52		 push	 edx
  011c5	50		 push	 eax
  011c6	e8 00 00 00 00	 call	 __allmul
  011cb	03 f8		 add	 edi, eax
  011cd	13 da		 adc	 ebx, edx
$LN936@test_hit:
  011cf	33 f6		 xor	 esi, esi
  011d1	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  011d7	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  011dd	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  011e3	76 43		 jbe	 SHORT $LN18@test_hit
  011e5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL20@test_hit:

; 1230 : 		Word_t key = SEARCH[i] + DELTA;

  011f0	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  011f3	8b 3c b1	 mov	 edi, DWORD PTR [ecx+esi*4]

; 1231 : 		Pvoid_t PValue;
; 1232 : 		JLG(PValue, judy, key);

  011f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judy@@3PAXA ; judy
  011fc	6a 00		 push	 0
  011fe	47		 inc	 edi
  011ff	57		 push	 edi
  01200	52		 push	 edx
  01201	e8 00 00 00 00	 call	 _JudyLGet
  01206	8b d8		 mov	 ebx, eax
  01208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1233 : 		if (!PValue)

  0120b	85 db		 test	 ebx, ebx
  0120d	75 05		 jne	 SHORT $LN17@test_hit

; 1234 : 			abort();

  0120f	e8 00 00 00 00	 call	 _abort
$LN17@test_hit:

; 1235 : 		if (dereference) {
; 1236 : 			struct judy_object* obj = *(struct judy_object**)PValue;

  01214	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1237 : 			if (obj->value != key)

  01216	39 38		 cmp	 DWORD PTR [eax], edi
  01218	74 05		 je	 SHORT $LN19@test_hit

; 1238 : 				abort();

  0121a	e8 00 00 00 00	 call	 _abort
$LN19@test_hit:

; 1227 : 
; 1228 : #ifdef USE_JUDY
; 1229 : 	START(DATA_JUDY) {

  0121f	46		 inc	 esi
  01220	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01226	72 c8		 jb	 SHORT $LL20@test_hit
$LN18@test_hit:

; 1239 : 		}
; 1240 : 	} STOP();

  01228	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1241 : #endif
; 1242 : 
; 1243 : #ifdef USE_JUDYARRAY
; 1244 : 	START(DATA_JUDYARRAY) {

  0122d	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  01232	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01237	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0123d	0f 85 fa 00 00
	00		 jne	 $LN11@test_hit
  01243	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0124a	75 30		 jne	 SHORT $LN938@test_hit
  0124c	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+40
  01252	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01258	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  0125f	51		 push	 ecx
  01260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  01266	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0126d	50		 push	 eax
  0126e	52		 push	 edx
  0126f	68 00 00 00 00	 push	 OFFSET $SG-100
  01274	e8 00 00 00 00	 call	 _printf
  01279	83 c4 10	 add	 esp, 16			; 00000010H
$LN938@test_hit:
  0127c	8d 45 dc	 lea	 eax, DWORD PTR _t$203689[ebp]
  0127f	50		 push	 eax
  01280	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01286	85 c0		 test	 eax, eax
  01288	75 11		 jne	 SHORT $LN944@test_hit
  0128a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0128e	66 0f 13 45 d4	 movlpd	 QWORD PTR $T203683[ebp], xmm0
  01293	8b 5d d8	 mov	 ebx, DWORD PTR $T203683[ebp+4]
  01296	8b 7d d4	 mov	 edi, DWORD PTR $T203683[ebp]
  01299	eb 54		 jmp	 SHORT $LN945@test_hit
$LN944@test_hit:
  0129b	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  012a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  012a7	8b 4d e0	 mov	 ecx, DWORD PTR _t$203689[ebp+4]
  012aa	8b 55 dc	 mov	 edx, DWORD PTR _t$203689[ebp]
  012ad	57		 push	 edi
  012ae	56		 push	 esi
  012af	51		 push	 ecx
  012b0	52		 push	 edx
  012b1	e8 00 00 00 00	 call	 __alldvrm
  012b6	6a 00		 push	 0
  012b8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  012bd	53		 push	 ebx
  012be	51		 push	 ecx
  012bf	89 45 ec	 mov	 DWORD PTR tv462[ebp], eax
  012c2	89 55 f0	 mov	 DWORD PTR tv462[ebp+4], edx
  012c5	e8 00 00 00 00	 call	 __allmul
  012ca	57		 push	 edi
  012cb	56		 push	 esi
  012cc	52		 push	 edx
  012cd	50		 push	 eax
  012ce	e8 00 00 00 00	 call	 __alldiv
  012d3	8b 4d ec	 mov	 ecx, DWORD PTR tv462[ebp]
  012d6	6a 00		 push	 0
  012d8	8b f8		 mov	 edi, eax
  012da	8b 45 f0	 mov	 eax, DWORD PTR tv462[ebp+4]
  012dd	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  012e2	50		 push	 eax
  012e3	51		 push	 ecx
  012e4	8b da		 mov	 ebx, edx
  012e6	e8 00 00 00 00	 call	 __allmul
  012eb	03 f8		 add	 edi, eax
  012ed	13 da		 adc	 ebx, edx
$LN945@test_hit:
  012ef	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  012f5	33 db		 xor	 ebx, ebx
  012f7	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  012fd	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  01303	76 38		 jbe	 SHORT $LN11@test_hit
  01305	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
$LL13@test_hit:

; 1245 : 		judyvalue key = SEARCH[i] + DELTA;

  01308	8b 14 9e	 mov	 edx, DWORD PTR [esi+ebx*4]

; 1246 : 		JudySlot* pvalue;
; 1247 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  0130b	8d 45 f0	 lea	 eax, DWORD PTR _key$149444[ebp]
  0130e	42		 inc	 edx
  0130f	50		 push	 eax
  01310	89 55 f0	 mov	 DWORD PTR _key$149444[ebp], edx
  01313	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  01318	8b f8		 mov	 edi, eax
  0131a	83 c4 04	 add	 esp, 4

; 1248 : 		if (!pvalue)

  0131d	85 ff		 test	 edi, edi
  0131f	75 05		 jne	 SHORT $LN10@test_hit

; 1249 : 			abort();

  01321	e8 00 00 00 00	 call	 _abort
$LN10@test_hit:

; 1250 : 		if (dereference) {
; 1251 : 			struct judyarray_object* obj = *(struct judyarray_object**)pvalue;

  01326	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1252 : 			if (obj->value != key)

  01328	8b 11		 mov	 edx, DWORD PTR [ecx]
  0132a	3b 55 f0	 cmp	 edx, DWORD PTR _key$149444[ebp]
  0132d	74 05		 je	 SHORT $LN12@test_hit

; 1253 : 				abort();

  0132f	e8 00 00 00 00	 call	 _abort
$LN12@test_hit:

; 1241 : #endif
; 1242 : 
; 1243 : #ifdef USE_JUDYARRAY
; 1244 : 	START(DATA_JUDYARRAY) {

  01334	43		 inc	 ebx
  01335	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  0133b	72 cb		 jb	 SHORT $LL13@test_hit
$LN11@test_hit:

; 1254 : 		}
; 1255 : 	} STOP();

  0133d	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1256 : #endif
; 1257 : 
; 1258 : 	START(DATA_NEDTRIE) {

  01342	b8 06 00 00 00	 mov	 eax, 6
  01347	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0134c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  01352	0f 85 3e 01 00
	00		 jne	 $LN4@test_hit
  01358	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0135f	75 2e		 jne	 SHORT $LN947@test_hit
  01361	a1 18 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+24
  01366	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0136c	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  01373	50		 push	 eax
  01374	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01379	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  01380	52		 push	 edx
  01381	51		 push	 ecx
  01382	68 00 00 00 00	 push	 OFFSET $SG-100
  01387	e8 00 00 00 00	 call	 _printf
  0138c	83 c4 10	 add	 esp, 16			; 00000010H
$LN947@test_hit:
  0138f	8d 55 d4	 lea	 edx, DWORD PTR _t$203712[ebp]
  01392	52		 push	 edx
  01393	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01399	85 c0		 test	 eax, eax
  0139b	75 11		 jne	 SHORT $LN953@test_hit
  0139d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  013a1	66 0f 13 45 d4	 movlpd	 QWORD PTR $T203706[ebp], xmm0
  013a6	8b 5d d8	 mov	 ebx, DWORD PTR $T203706[ebp+4]
  013a9	8b 7d d4	 mov	 edi, DWORD PTR $T203706[ebp]
  013ac	eb 54		 jmp	 SHORT $LN954@test_hit
$LN953@test_hit:
  013ae	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  013b4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  013ba	8b 45 d8	 mov	 eax, DWORD PTR _t$203712[ebp+4]
  013bd	8b 4d d4	 mov	 ecx, DWORD PTR _t$203712[ebp]
  013c0	57		 push	 edi
  013c1	56		 push	 esi
  013c2	50		 push	 eax
  013c3	51		 push	 ecx
  013c4	e8 00 00 00 00	 call	 __alldvrm
  013c9	6a 00		 push	 0
  013cb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013d0	53		 push	 ebx
  013d1	51		 push	 ecx
  013d2	89 45 ec	 mov	 DWORD PTR tv2756[ebp], eax
  013d5	89 55 f0	 mov	 DWORD PTR tv2756[ebp+4], edx
  013d8	e8 00 00 00 00	 call	 __allmul
  013dd	57		 push	 edi
  013de	56		 push	 esi
  013df	52		 push	 edx
  013e0	50		 push	 eax
  013e1	e8 00 00 00 00	 call	 __alldiv
  013e6	6a 00		 push	 0
  013e8	8b da		 mov	 ebx, edx
  013ea	8b 55 f0	 mov	 edx, DWORD PTR tv2756[ebp+4]
  013ed	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013f2	8b f8		 mov	 edi, eax
  013f4	8b 45 ec	 mov	 eax, DWORD PTR tv2756[ebp]
  013f7	52		 push	 edx
  013f8	50		 push	 eax
  013f9	e8 00 00 00 00	 call	 __allmul
  013fe	03 f8		 add	 edi, eax
  01400	13 da		 adc	 ebx, edx
$LN954@test_hit:
  01402	33 f6		 xor	 esi, esi
  01404	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  0140a	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01410	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  01416	0f 86 7a 00 00
	00		 jbe	 $LN4@test_hit
$LN6@test_hit:

; 1259 : 		unsigned key = SEARCH[i] + DELTA;

  0141c	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  0141f	8b 3c b1	 mov	 edi, DWORD PTR [ecx+esi*4]
  01422	47		 inc	 edi

; 1260 : 		struct nedtrie_object key_obj;
; 1261 : 		struct nedtrie_object* obj;
; 1262 : 		key_obj.value = key;
; 1263 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  01423	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, 0
  0142a	75 04		 jne	 SHORT $LN963@test_hit
$LN1015@test_hit:
  0142c	33 db		 xor	 ebx, ebx
  0142e	eb 4e		 jmp	 SHORT $LN1070@test_hit
$LN963@test_hit:
  01430	8b d7		 mov	 edx, edi
  01432	83 ca 01	 or	 edx, 1
  01435	0f bd c2	 bsr	 eax, edx
  01438	8b c8		 mov	 ecx, eax
  0143a	89 45 f0	 mov	 DWORD PTR _bitpos$203755[ebp], eax
  0143d	8b 04 8d 04 00
	00 00		 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  01444	85 c0		 test	 eax, eax
  01446	75 04		 jne	 SHORT $LN962@test_hit
  01448	33 db		 xor	 ebx, ebx
  0144a	eb 32		 jmp	 SHORT $LN1070@test_hit
$LN962@test_hit:
  0144c	ba 01 00 00 00	 mov	 edx, 1
  01451	d3 e2		 shl	 edx, cl
  01453	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  01456	74 19		 je	 SHORT $end$203746
$LL961@test_hit:
  01458	d1 ea		 shr	 edx, 1
  0145a	8b cf		 mov	 ecx, edi
  0145c	23 ca		 and	 ecx, edx
  0145e	f7 d9		 neg	 ecx
  01460	1b c9		 sbb	 ecx, ecx
  01462	f7 d9		 neg	 ecx
  01464	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  01468	85 c0		 test	 eax, eax
  0146a	74 c0		 je	 SHORT $LN1015@test_hit
  0146c	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  0146f	75 e7		 jne	 SHORT $LL961@test_hit
$end$203746:
  01471	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  01474	85 db		 test	 ebx, ebx
  01476	75 0b		 jne	 SHORT $LN3@test_hit
  01478	8b d8		 mov	 ebx, eax

; 1264 : 		if (!obj)

  0147a	85 db		 test	 ebx, ebx
  0147c	75 05		 jne	 SHORT $LN3@test_hit
$LN1070@test_hit:

; 1265 : 			abort();

  0147e	e8 00 00 00 00	 call	 _abort
$LN3@test_hit:

; 1266 : 		if (dereference) {
; 1267 : 			if (obj->value != key)

  01483	39 7b 14	 cmp	 DWORD PTR [ebx+20], edi
  01486	74 05		 je	 SHORT $LN5@test_hit

; 1268 : 				abort();

  01488	e8 00 00 00 00	 call	 _abort
$LN5@test_hit:

; 1256 : #endif
; 1257 : 
; 1258 : 	START(DATA_NEDTRIE) {

  0148d	46		 inc	 esi
  0148e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01494	72 86		 jb	 SHORT $LN6@test_hit
$LN4@test_hit:

; 1269 : 		}
; 1270 : 	} STOP();

  01496	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1271 : }

  0149b	5f		 pop	 edi
  0149c	5e		 pop	 esi
  0149d	5b		 pop	 ebx
  0149e	8b e5		 mov	 esp, ebp
  014a0	5d		 pop	 ebp
  014a1	c3		 ret	 0
?test_hit@@YAXPAI@Z ENDP				; test_hit
_TEXT	ENDS
PUBLIC	_tommy_hashlin_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashlin.c
;	COMDAT _tommy_hashlin_remove
_TEXT	SEGMENT
_cmp_arg$ = 8						; size = 4
_tommy_hashlin_remove PROC				; COMDAT
; _hash$ = eax

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f8		 mov	 edi, eax

; 297  : 	tommy_hashlin_node** let_ptr = tommy_hashlin_bucket_ptr(hashlin, hash);

  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr

; 298  : 	tommy_hashlin_node* i = *let_ptr;

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	8b f2		 mov	 esi, edx

; 299  : 
; 300  : 	while (i) {

  00013	85 f6		 test	 esi, esi
  00015	74 18		 je	 SHORT $LN2@tommy_hash@11
$LL3@tommy_hash@11:

; 301  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 302  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0) {

  00017	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  0001a	75 0d		 jne	 SHORT $LN1@tommy_hash@11
  0001c	8b 5d 08	 mov	 ebx, DWORD PTR _cmp_arg$[ebp]
  0001f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00022	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00024	3b 59 10	 cmp	 ebx, DWORD PTR [ecx+16]
  00027	74 0d		 je	 SHORT $LN18@tommy_hash@11
$LN1@tommy_hash@11:

; 310  : 		}
; 311  : 		i = i->next;

  00029	8b 36		 mov	 esi, DWORD PTR [esi]
  0002b	85 f6		 test	 esi, esi
  0002d	75 e8		 jne	 SHORT $LL3@tommy_hash@11
$LN2@tommy_hash@11:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 312  : 	}
; 313  : 
; 314  : 	return 0;

  00031	33 c0		 xor	 eax, eax
  00033	5b		 pop	 ebx

; 315  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN18@tommy_hash@11:

; 303  : 			tommy_list_remove_existing(let_ptr, i);

  00036	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 08		 je	 SHORT $LN12@tommy_hash@11
  0003c	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0003f	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00042	eb 06		 jmp	 SHORT $LN11@tommy_hash@11
$LN12@tommy_hash@11:
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN11@tommy_hash@11:
  0004a	3b d6		 cmp	 edx, esi
  0004c	75 17		 jne	 SHORT $LN10@tommy_hash@11
  0004e	8b 16		 mov	 edx, DWORD PTR [esi]
  00050	89 10		 mov	 DWORD PTR [eax], edx

; 304  : 
; 305  : 			--hashlin->count;

  00052	ff 0d a0 00 00
	00		 dec	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 306  : 
; 307  : 			hashlin_shrink_step(hashlin);

  00058	e8 00 00 00 00	 call	 ?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_shrink_step

; 308  : 
; 309  : 			return i->data;

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 315  : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0

; 303  : 			tommy_list_remove_existing(let_ptr, i);

$LN10@tommy_hash@11:
  00065	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00068	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx

; 304  : 
; 305  : 			--hashlin->count;

  0006c	ff 0d a0 00 00
	00		 dec	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 306  : 
; 307  : 			hashlin_shrink_step(hashlin);

  00072	e8 00 00 00 00	 call	 ?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_shrink_step

; 308  : 
; 309  : 			return i->data;

  00077	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx

; 315  : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_tommy_hashlin_remove ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashdyn.c
_TEXT	ENDS
;	COMDAT ?hashdyn_shrink_step@@YAXPAUtommy_hashdyn_struct@@@Z
_TEXT	SEGMENT
?hashdyn_shrink_step@@YAXPAUtommy_hashdyn_struct@@@Z PROC ; hashdyn_shrink_step, COMDAT

; 133  : 	/* shrink if less than 12.5% full */
; 134  : 	if (hashdyn->count <= hashdyn->bucket_max / 8 && hashdyn->bucket_bit > TOMMY_HASHDYN_BIT) {

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00005	c1 e8 03	 shr	 eax, 3
  00008	39 05 10 00 00
	00		 cmp	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0000e	77 12		 ja	 SHORT $LN1@hashdyn_sh
  00010	a1 04 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00015	83 f8 04	 cmp	 eax, 4
  00018	76 08		 jbe	 SHORT $LN1@hashdyn_sh

; 135  : 		tommy_hashdyn_resize(hashdyn, hashdyn->bucket_bit - 1);

  0001a	48		 dec	 eax
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  00021	59		 pop	 ecx
$LN1@hashdyn_sh:

; 136  : 	}
; 137  : }

  00022	c3		 ret	 0
?hashdyn_shrink_step@@YAXPAUtommy_hashdyn_struct@@@Z ENDP ; hashdyn_shrink_step
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?hashdyn_grow_step@@YAXPAUtommy_hashdyn_struct@@@Z
_TEXT	SEGMENT
?hashdyn_grow_step@@YAXPAUtommy_hashdyn_struct@@@Z PROC	; hashdyn_grow_step, COMDAT

; 122  : 	/* grow if more than 50% full */
; 123  : 	if (hashdyn->count >= hashdyn->bucket_max / 2) {

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00005	d1 e8		 shr	 eax, 1
  00007	39 05 10 00 00
	00		 cmp	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0000d	72 0e		 jb	 SHORT $LN1@hashdyn_gr

; 124  : 		tommy_hashdyn_resize(hashdyn, hashdyn->bucket_bit + 1);

  0000f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00015	41		 inc	 ecx
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0001c	59		 pop	 ecx
$LN1@hashdyn_gr:

; 125  : 	}
; 126  : }

  0001d	c3		 ret	 0
?hashdyn_grow_step@@YAXPAUtommy_hashdyn_struct@@@Z ENDP	; hashdyn_grow_step
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z
_TEXT	SEGMENT
$T203928 = -16						; size = 12
$T203926 = -16						; size = 12
_pos$ = -12						; size = 8
$T203924 = 8						; size = 4
_obj$ = 8						; size = 4
?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 906  :   pair<iterator, bool> insert_noresize(const_reference obj) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _obj$[ebp]
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax

; 907  :     // First, double-check we're not inserting delkey or emptyval
; 908  :     assert((!settings.use_empty() || !equals(get_key(obj),
; 909  :                                              get_key(val_info.emptyval)))
; 910  :            && "Inserting the empty key");
; 911  :     assert((!settings.use_deleted() || !equals(get_key(obj), key_info.delkey))
; 912  :            && "Inserting the deleted key");
; 913  :     const pair<size_type,size_type> pos = find_position(get_key(obj));

  0000d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000f	8d 4d f4	 lea	 ecx, DWORD PTR _pos$[ebp]
  00012	89 45 08	 mov	 DWORD PTR $T203924[ebp], eax
  00015	51		 push	 ecx
  00016	8d 45 08	 lea	 eax, DWORD PTR $T203924[ebp]
  00019	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position

; 914  :     if ( pos.first != ILLEGAL_BUCKET) {      // object was already there

  0001e	8b 4d f4	 mov	 ecx, DWORD PTR _pos$[ebp]
  00021	83 f9 ff	 cmp	 ecx, -1
  00024	74 2c		 je	 SHORT $LN2@insert_nor

; 915  :       return pair<iterator,bool>(iterator(this, table + pos.first,
; 916  :                                           table + num_buckets, false),
; 917  :                                  false);          // false: we didn't insert

  00026	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00029	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  0002c	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0002f	89 7d f0	 mov	 DWORD PTR $T203926[ebp], edi
  00032	89 55 f4	 mov	 DWORD PTR $T203926[ebp+4], edx
  00035	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR $T203926[ebp]
  0003a	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 918  :     } else {                                 // pos.second says where to put it
; 919  :       return pair<iterator,bool>(insert_at(obj, pos.second), true);

  0003d	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00041	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00044	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00048	8b c6		 mov	 eax, esi

; 920  :     }
; 921  :   }

  0004a	5f		 pop	 edi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN2@insert_nor:

; 918  :     } else {                                 // pos.second says where to put it
; 919  :       return pair<iterator,bool>(insert_at(obj, pos.second), true);

  00052	8b 45 f8	 mov	 eax, DWORD PTR _pos$[ebp+4]
  00055	53		 push	 ebx
  00056	8d 55 f0	 lea	 edx, DWORD PTR $T203928[ebp]
  00059	52		 push	 edx
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
  00061	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00065	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00068	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0

; 920  :     }
; 921  :   }

  0006c	5f		 pop	 edi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1
  00074	8b c6		 mov	 eax, esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
$T204272 = -24						; size = 16
$T204274 = -20						; size = 12
_pos$ = -16						; size = 8
$T204273 = -8						; size = 8
$T204271 = -8						; size = 8
??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>, COMDAT
; _this$ = ecx
; _key$ = eax

; 960  :   value_type& find_or_insert(const key_type& key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	8b f0		 mov	 esi, eax
  00009	57		 push	 edi

; 961  :     // First, double-check we're not inserting emptykey or delkey
; 962  :     assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
; 963  :            && "Inserting the empty key");
; 964  :     assert((!settings.use_deleted() || !equals(key, key_info.delkey))
; 965  :            && "Inserting the deleted key");
; 966  :     const pair<size_type,size_type> pos = find_position(key);

  0000a	8d 45 f0	 lea	 eax, DWORD PTR _pos$[ebp]
  0000d	50		 push	 eax
  0000e	8b f9		 mov	 edi, ecx
  00010	8b c6		 mov	 eax, esi
  00012	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position

; 967  :     DefaultValue default_value;
; 968  :     if ( pos.first != ILLEGAL_BUCKET) {  // object was already there

  00017	8b 45 f0	 mov	 eax, DWORD PTR _pos$[ebp]
  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	74 0c		 je	 SHORT $LN4@find_or_in

; 969  :       return table[pos.first];

  0001f	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00022	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 975  :     }
; 976  :   }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@find_or_in:

; 970  :     } else if (resize_delta(1)) {        // needed to rehash to make room

  0002b	57		 push	 edi
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	e8 00 00 00 00	 call	 ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta

; 971  :       // Since we resized, we can't use pos, so recalculate where to insert.
; 972  :       return *insert_noresize(default_value(key)).first;

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T204271[ebp+4], 0
  0003d	84 c0		 test	 al, al
  0003f	74 1c		 je	 SHORT $LN2@find_or_in
  00041	8b 16		 mov	 edx, DWORD PTR [esi]
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T204271[ebp]
  00046	50		 push	 eax
  00047	8d 75 e8	 lea	 esi, DWORD PTR $T204272[ebp]
  0004a	8b c7		 mov	 eax, edi
  0004c	89 55 f8	 mov	 DWORD PTR $T204271[ebp], edx
  0004f	e8 00 00 00 00	 call	 ?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize

; 973  :     } else {                             // no need to rehash, insert right here
; 974  :       return *insert_at(default_value(key), pos.second);

  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 975  :     }
; 976  :   }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN2@find_or_in:

; 973  :     } else {                             // no need to rehash, insert right here
; 974  :       return *insert_at(default_value(key), pos.second);

  0005d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005f	8d 55 f8	 lea	 edx, DWORD PTR $T204273[ebp]
  00062	52		 push	 edx
  00063	8d 45 ec	 lea	 eax, DWORD PTR $T204274[ebp]
  00066	89 4d f8	 mov	 DWORD PTR $T204273[ebp], ecx
  00069	50		 push	 eax
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _pos$[ebp+4]
  0006d	8b cf		 mov	 ecx, edi
  0006f	e8 00 00 00 00	 call	 ?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
  00074	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 975  :     }
; 976  :   }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z
_TEXT	SEGMENT
??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator[], COMDAT
; _key$ = eax

; 265  :   data_type& operator[](const key_type& key) {       // This is our value-add!

  00000	51		 push	 ecx
  00001	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash

; 266  :     // If key is in the hashtable, returns find(key)->second,
; 267  :     // otherwise returns insert(value_type(key, T()).first->second.
; 268  :     // Note it does not create an empty T unless the find fails.
; 269  :     return rep.template find_or_insert<DefaultValue>(key).second;

  00007	e8 00 00 00 00	 call	 ??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>
  0000c	83 c0 04	 add	 eax, 4
  0000f	59		 pop	 ecx

; 270  :   }

  00010	c3		 ret	 0
??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator[]
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\tommyhashdyn.c
;	COMDAT _tommy_hashdyn_remove
_TEXT	SEGMENT
_cmp_arg$ = 8						; size = 4
_tommy_hashdyn_remove PROC				; COMDAT
; _hash$ = eax

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 167  : 	unsigned pos = hash % hashdyn->bucket_max;

  00005	33 d2		 xor	 edx, edx
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	f7 35 08 00 00
	00		 div	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8

; 168  : 	tommy_hashdyn_node* i = hashdyn->bucket[pos];

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00015	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _cmp_arg$[ebp]
  0001b	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]

; 169  : 
; 170  : 	while (i) {

  0001e	85 f6		 test	 esi, esi
  00020	74 15		 je	 SHORT $LN2@tommy_hash@12
$LL3@tommy_hash@12:

; 171  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 172  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0) {

  00022	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00025	75 0a		 jne	 SHORT $LN1@tommy_hash@12
  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002f	74 0d		 je	 SHORT $LN21@tommy_hash@12
$LN1@tommy_hash@12:

; 180  : 		}
; 181  : 		i = i->next;

  00031	8b 36		 mov	 esi, DWORD PTR [esi]
  00033	85 f6		 test	 esi, esi
  00035	75 eb		 jne	 SHORT $LL3@tommy_hash@12
$LN2@tommy_hash@12:
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 182  : 	}
; 183  : 
; 184  : 	return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	5b		 pop	 ebx

; 185  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN21@tommy_hash@12:

; 173  : 			tommy_list_remove_existing(&hashdyn->bucket[pos], i);

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	85 c0		 test	 eax, eax
  00044	74 08		 je	 SHORT $LN12@tommy_hash@12
  00046	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00049	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0004c	eb 06		 jmp	 SHORT $LN11@tommy_hash@12
$LN12@tommy_hash@12:
  0004e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00051	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@tommy_hash@12:
  00054	3b d6		 cmp	 edx, esi
  00056	75 06		 jne	 SHORT $LN10@tommy_hash@12
  00058	8b 16		 mov	 edx, DWORD PTR [esi]
  0005a	89 11		 mov	 DWORD PTR [ecx], edx
  0005c	eb 07		 jmp	 SHORT $LN9@tommy_hash@12
$LN10@tommy_hash@12:
  0005e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00061	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00063	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@tommy_hash@12:

; 174  : 
; 175  : 			--hashdyn->count;

  00065	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16

; 176  : 
; 177  : 			hashdyn_shrink_step(hashdyn);

  0006a	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00070	48		 dec	 eax
  00071	c1 ea 03	 shr	 edx, 3
  00074	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  00079	3b c2		 cmp	 eax, edx
  0007b	77 14		 ja	 SHORT $LN17@tommy_hash@12
  0007d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00082	83 f8 04	 cmp	 eax, 4
  00085	76 0a		 jbe	 SHORT $LN17@tommy_hash@12
  00087	48		 dec	 eax
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0008e	83 c4 04	 add	 esp, 4
$LN17@tommy_hash@12:

; 178  : 
; 179  : 			return i->data;

  00091	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx

; 185  : }

  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_tommy_hashdyn_remove ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashdyn_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_hashdyn_insert PROC				; COMDAT
; _node$ = eax
; _hash$ = esi

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 141  : 	unsigned pos = hash & hashdyn->bucket_mask;

  00003	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12

; 142  : 
; 143  : 	tommy_list_insert_tail(&hashdyn->bucket[pos], node, data);

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  0000f	23 ce		 and	 ecx, esi
  00011	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	85 c9		 test	 ecx, ecx
  00018	74 16		 je	 SHORT $LN4@tommy_hash@13
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00020	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	89 01		 mov	 DWORD PTR [ecx], eax
  0002e	eb 0b		 jmp	 SHORT $LN11@tommy_hash@13
$LN4@tommy_hash@13:
  00030	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00039	89 02		 mov	 DWORD PTR [edx], eax
$LN11@tommy_hash@13:
  0003b	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0003e	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 144  : 
; 145  : 	node->key = hash;

  00041	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 146  : 
; 147  : 	++hashdyn->count;

  00044	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16

; 148  : 
; 149  : 	hashdyn_grow_step(hashdyn);

  00049	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  0004f	40		 inc	 eax
  00050	d1 e9		 shr	 ecx, 1
  00052	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  00057	3b c1		 cmp	 eax, ecx
  00059	72 10		 jb	 SHORT $LN13@tommy_hash@13
  0005b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00061	42		 inc	 edx
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  00068	83 c4 04	 add	 esp, 4
$LN13@tommy_hash@13:

; 150  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_tommy_hashdyn_insert ENDP
_TEXT	ENDS
PUBLIC	?test_remove@@YAXPAI@Z				; test_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.4\benchmark.cc
;	COMDAT ?test_remove@@YAXPAI@Z
_TEXT	SEGMENT
_J_Error$150406 = -84					; size = 24
$T204598 = -60						; size = 8
$T209916 = -52						; size = 8
$T209893 = -52						; size = 8
_t$209925 = -52						; size = 8
_t$209878 = -52						; size = 8
$T209870 = -52						; size = 8
$T209847 = -52						; size = 8
$T209126 = -52						; size = 8
_t$208750 = -52						; size = 8
_pos$206008 = -52					; size = 8
_ptr$150233 = -52					; size = 8
_t$209902 = -44						; size = 8
_t$209853 = -44						; size = 8
_t$209133 = -44						; size = 8
$T208743 = -44						; size = 8
$T208312 = -44						; size = 8
$T207159 = -44						; size = 8
_t$204866 = -44						; size = 8
tv3659 = -36						; size = 8
tv3638 = -36						; size = 8
tv3469 = -36						; size = 8
tv3441 = -36						; size = 8
tv3437 = -36						; size = 8
tv3433 = -36						; size = 8
tv2694 = -36						; size = 8
tv2564 = -36						; size = 8
tv2171 = -36						; size = 8
$T208313 = -36						; size = 8
tv1621 = -36						; size = 8
tv1457 = -36						; size = 8
tv1441 = -36						; size = 8
tv1148 = -36						; size = 8
$T204859 = -36						; size = 8
$T204827 = -36						; size = 8
$T204798 = -36						; size = 8
_t$204807 = -36						; size = 8
$T204769 = -36						; size = 8
_t$204778 = -36						; size = 8
$T204742 = -36						; size = 8
_t$204748 = -36						; size = 8
$T204715 = -36						; size = 8
_t$204721 = -36						; size = 8
_bitpos$209949 = -32					; size = 4
_obj$150260 = -32					; size = 4
$T204601 = -32						; size = 4
_t$204834 = -28						; size = 8
__Where$209010 = -24					; size = 4
_ptr$150261 = -24					; size = 4
_key$150231 = -24					; size = 4
_obj$150220 = -24					; size = 4
_t$207166 = -20						; size = 8
$T209015 = -16						; size = 4
_key$150419 = -16					; size = 4
_key$150273 = -16					; size = 4
_key$150259 = -16					; size = 4
_key$150219 = -16					; size = 4
_obj$150209 = -16					; size = 4
_key$150176 = -16					; size = 4
_key$150165 = -16					; size = 4
_i$ = -8						; size = 4
_REMOVE$ = 8						; size = 4
?test_remove@@YAXPAI@Z PROC				; test_remove, COMDAT

; 1687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx

; 1688 : 	unsigned i;
; 1689 : 
; 1690 : 	/* always dereference the object deleted. It has cache effect. */
; 1691 : 	/* considering we are dealing with objects, it makes sense to simulate an access to it */
; 1692 : 	/* even on deletion, because you have at least to do a free() call. */
; 1693 : 	/* this favorites data structures that store part of the information in the object itself */
; 1694 : 	const int dereference = 1;
; 1695 : 
; 1696 : 	const unsigned DELTA = 1;
; 1697 : 
; 1698 : 	START(DATA_TREE) {

  00007	b8 05 00 00 00	 mov	 eax, 5
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00013	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00019	0f 85 b4 00 00
	00		 jne	 $LN170@test_remov
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00026	75 2e		 jne	 SHORT $LN180@test_remov
  00028	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00033	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003a	50		 push	 eax
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00040	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00047	52		 push	 edx
  00048	51		 push	 ecx
  00049	68 00 00 00 00	 push	 OFFSET $SG-100
  0004e	e8 00 00 00 00	 call	 _printf
  00053	83 c4 10	 add	 esp, 16			; 00000010H
$LN180@test_remov:
  00056	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005b	33 db		 xor	 ebx, ebx
  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00062	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00068	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  0006e	76 63		 jbe	 SHORT $LN170@test_remov
$LL172@test_remov:

; 1699 : 		unsigned key = REMOVE[i] + DELTA;

  00070	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  00073	8b 3c 9a	 mov	 edi, DWORD PTR [edx+ebx*4]

; 1700 : 		struct rbt_object key_obj;
; 1701 : 		struct rbt_object* obj;
; 1702 : 		key_obj.value = key;
; 1703 : 		obj = rbt_search(&tree, &key_obj); 

  00076	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?tree@@3Urbtree_t@@A
  0007c	47		 inc	 edi
  0007d	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  00083	74 27		 je	 SHORT $LN1262@test_remov
$LL190@test_remov:
  00085	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00088	3b f8		 cmp	 edi, eax
  0008a	7c 14		 jl	 SHORT $LN1265@test_remov
  0008c	7e 16		 jle	 SHORT $LN189@test_remov
  0008e	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00091	83 e6 fe	 and	 esi, -2			; fffffffeH
$LN187@test_remov:
  00094	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  0009a	75 e9		 jne	 SHORT $LL190@test_remov
  0009c	33 f6		 xor	 esi, esi

; 1704 : 		if (!obj)

  0009e	eb 14		 jmp	 SHORT $LN1291@test_remov
$LN1265@test_remov:

; 1700 : 		struct rbt_object key_obj;
; 1701 : 		struct rbt_object* obj;
; 1702 : 		key_obj.value = key;
; 1703 : 		obj = rbt_search(&tree, &key_obj); 

  000a0	8b 36		 mov	 esi, DWORD PTR [esi]
  000a2	eb f0		 jmp	 SHORT $LN187@test_remov
$LN189@test_remov:
  000a4	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  000aa	75 04		 jne	 SHORT $LN186@test_remov
$LN1262@test_remov:
  000ac	33 f6		 xor	 esi, esi

; 1704 : 		if (!obj)

  000ae	eb 04		 jmp	 SHORT $LN1291@test_remov

; 1700 : 		struct rbt_object key_obj;
; 1701 : 		struct rbt_object* obj;
; 1702 : 		key_obj.value = key;
; 1703 : 		obj = rbt_search(&tree, &key_obj); 

$LN186@test_remov:

; 1704 : 		if (!obj)

  000b0	85 f6		 test	 esi, esi
  000b2	75 05		 jne	 SHORT $LN169@test_remov
$LN1291@test_remov:

; 1705 : 			abort();

  000b4	e8 00 00 00 00	 call	 _abort
$LN169@test_remov:

; 1706 : 		if (dereference) {
; 1707 : 			if (obj->value != key)

  000b9	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  000bc	74 05		 je	 SHORT $LN167@test_remov

; 1708 : 				abort();

  000be	e8 00 00 00 00	 call	 _abort
$LN167@test_remov:

; 1709 : 		}
; 1710 : 		rbt_remove(&tree, obj);

  000c3	8b d6		 mov	 edx, esi
  000c5	e8 00 00 00 00	 call	 ?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_remove
  000ca	43		 inc	 ebx
  000cb	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  000d1	72 9d		 jb	 SHORT $LL172@test_remov
$LN170@test_remov:

; 1711 : 	} STOP();

  000d3	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1712 : 
; 1713 : 	START(DATA_HASHTABLE) {

  000d8	33 ff		 xor	 edi, edi
  000da	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_start_data@@3IA, edi ; the_start_data
  000e0	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, edi ; the_data
  000e6	0f 85 0e 01 00
	00		 jne	 $LN163@test_remov
  000ec	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_log@@3HA, edi ; the_log
  000f2	75 2e		 jne	 SHORT $LN197@test_remov
  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  000ff	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00106	50		 push	 eax
  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0010c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00113	52		 push	 edx
  00114	51		 push	 ecx
  00115	68 00 00 00 00	 push	 OFFSET $SG-100
  0011a	e8 00 00 00 00	 call	 _printf
  0011f	83 c4 10	 add	 esp, 16			; 00000010H
$LN197@test_remov:
  00122	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00127	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0012c	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00132	89 7d f8	 mov	 DWORD PTR _i$[ebp], edi
  00135	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  0013b	0f 86 b9 00 00
	00		 jbe	 $LN163@test_remov
$LL165@test_remov:

; 1714 : 		unsigned key = REMOVE[i] + DELTA;

  00141	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  00144	8b 34 ba	 mov	 esi, DWORD PTR [edx+edi*4]
  00147	46		 inc	 esi

; 1715 : 		unsigned hash_key = hash(key);

  00148	8b ce		 mov	 ecx, esi
  0014a	c1 e1 06	 shl	 ecx, 6
  0014d	8b c6		 mov	 eax, esi
  0014f	2b c1		 sub	 eax, ecx
  00151	8b d0		 mov	 edx, eax
  00153	c1 ea 11	 shr	 edx, 17			; 00000011H
  00156	33 c2		 xor	 eax, edx
  00158	8b c8		 mov	 ecx, eax
  0015a	c1 e1 09	 shl	 ecx, 9
  0015d	2b c1		 sub	 eax, ecx
  0015f	8b d0		 mov	 edx, eax
  00161	c1 e2 04	 shl	 edx, 4
  00164	33 c2		 xor	 eax, edx
  00166	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0016d	2b c1		 sub	 eax, ecx
  0016f	8b d0		 mov	 edx, eax
  00171	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00174	33 c2		 xor	 eax, edx

; 1716 : 		struct hashtable_object* obj;
; 1717 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  00176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0017c	8b c8		 mov	 ecx, eax
  0017e	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00181	33 c8		 xor	 ecx, eax
  00183	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00188	23 c1		 and	 eax, ecx
  0018a	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]
  0018d	8b 02		 mov	 eax, DWORD PTR [edx]
  0018f	85 c0		 test	 eax, eax
  00191	74 13		 je	 SHORT $LN206@test_remov
$LL207@test_remov:
  00193	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00196	75 08		 jne	 SHORT $LN205@test_remov
  00198	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  0019b	3b 73 10	 cmp	 esi, DWORD PTR [ebx+16]
  0019e	74 0a		 je	 SHORT $LN1231@test_remov
$LN205@test_remov:
  001a0	8b 00		 mov	 eax, DWORD PTR [eax]
  001a2	85 c0		 test	 eax, eax
  001a4	75 ed		 jne	 SHORT $LL207@test_remov
$LN206@test_remov:
  001a6	33 db		 xor	 ebx, ebx

; 1718 : 		if (!obj)

  001a8	eb 31		 jmp	 SHORT $LN1267@test_remov
$LN1231@test_remov:

; 1716 : 		struct hashtable_object* obj;
; 1717 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  001aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ac	8b 1a		 mov	 ebx, DWORD PTR [edx]
  001ae	85 c9		 test	 ecx, ecx
  001b0	74 0b		 je	 SHORT $LN216@test_remov
  001b2	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  001b5	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  001b8	8b 7d f8	 mov	 edi, DWORD PTR _i$[ebp]
  001bb	eb 06		 jmp	 SHORT $LN215@test_remov
$LN216@test_remov:
  001bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c0	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN215@test_remov:
  001c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c5	3b d8		 cmp	 ebx, eax
  001c7	74 03		 je	 SHORT $LN1323@test_remov
  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
$LN1323@test_remov:
  001cc	89 0a		 mov	 DWORD PTR [edx], ecx
  001ce	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  001d4	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1718 : 		if (!obj)

  001d7	85 db		 test	 ebx, ebx
  001d9	75 05		 jne	 SHORT $LN162@test_remov
$LN1267@test_remov:

; 1719 : 			abort();

  001db	e8 00 00 00 00	 call	 _abort
$LN162@test_remov:

; 1720 : 		if (dereference) {
; 1721 : 			if (obj->value != key)

  001e0	39 73 10	 cmp	 DWORD PTR [ebx+16], esi
  001e3	74 05		 je	 SHORT $LN164@test_remov

; 1722 : 				abort();

  001e5	e8 00 00 00 00	 call	 _abort
$LN164@test_remov:

; 1712 : 
; 1713 : 	START(DATA_HASHTABLE) {

  001ea	47		 inc	 edi
  001eb	89 7d f8	 mov	 DWORD PTR _i$[ebp], edi
  001ee	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  001f4	0f 82 47 ff ff
	ff		 jb	 $LL165@test_remov
$LN163@test_remov:

; 1723 : 		}
; 1724 : 	} STOP();

  001fa	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1725 : 
; 1726 : 	START(DATA_HASHDYN) {

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00209	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0020f	0f 85 32 01 00
	00		 jne	 $LN156@test_remov
  00215	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0021c	75 2f		 jne	 SHORT $LN221@test_remov
  0021e	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  00224	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00229	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00230	52		 push	 edx
  00231	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00237	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0023e	51		 push	 ecx
  0023f	50		 push	 eax
  00240	68 00 00 00 00	 push	 OFFSET $SG-100
  00245	e8 00 00 00 00	 call	 _printf
  0024a	83 c4 10	 add	 esp, 16			; 00000010H
$LN221@test_remov:
  0024d	8d 4d dc	 lea	 ecx, DWORD PTR _t$204721[ebp]
  00250	51		 push	 ecx
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00257	85 c0		 test	 eax, eax
  00259	75 11		 jne	 SHORT $LN227@test_remov
  0025b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0025f	66 0f 13 45 dc	 movlpd	 QWORD PTR $T204715[ebp], xmm0
  00264	8b 5d e0	 mov	 ebx, DWORD PTR $T204715[ebp+4]
  00267	8b 75 dc	 mov	 esi, DWORD PTR $T204715[ebp]
  0026a	eb 54		 jmp	 SHORT $LN228@test_remov
$LN227@test_remov:
  0026c	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00272	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00278	8b 55 e0	 mov	 edx, DWORD PTR _t$204721[ebp+4]
  0027b	8b 45 dc	 mov	 eax, DWORD PTR _t$204721[ebp]
  0027e	56		 push	 esi
  0027f	57		 push	 edi
  00280	52		 push	 edx
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 __alldvrm
  00287	6a 00		 push	 0
  00289	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0028e	53		 push	 ebx
  0028f	51		 push	 ecx
  00290	89 45 dc	 mov	 DWORD PTR tv3659[ebp], eax
  00293	89 55 e0	 mov	 DWORD PTR tv3659[ebp+4], edx
  00296	e8 00 00 00 00	 call	 __allmul
  0029b	56		 push	 esi
  0029c	57		 push	 edi
  0029d	52		 push	 edx
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 __alldiv
  002a4	8b 4d e0	 mov	 ecx, DWORD PTR tv3659[ebp+4]
  002a7	6a 00		 push	 0
  002a9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  002ae	8b da		 mov	 ebx, edx
  002b0	8b 55 dc	 mov	 edx, DWORD PTR tv3659[ebp]
  002b3	51		 push	 ecx
  002b4	52		 push	 edx
  002b5	8b f0		 mov	 esi, eax
  002b7	e8 00 00 00 00	 call	 __allmul
  002bc	03 f0		 add	 esi, eax
  002be	13 da		 adc	 ebx, edx
$LN228@test_remov:
  002c0	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  002c6	33 db		 xor	 ebx, ebx
  002c8	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  002ce	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  002d4	76 71		 jbe	 SHORT $LN156@test_remov
  002d6	8b 7d 08	 mov	 edi, DWORD PTR _REMOVE$[ebp]
  002d9	8d a4 24 00 00
	00 00		 npad	 7
$LL158@test_remov:

; 1727 : 		unsigned key = REMOVE[i] + DELTA;

  002e0	8b 0c 9f	 mov	 ecx, DWORD PTR [edi+ebx*4]
  002e3	41		 inc	 ecx

; 1728 : 		unsigned hash_key = hash(key);

  002e4	8b c1		 mov	 eax, ecx
  002e6	c1 e0 06	 shl	 eax, 6
  002e9	89 4d f0	 mov	 DWORD PTR _key$150165[ebp], ecx
  002ec	2b c8		 sub	 ecx, eax
  002ee	8b d1		 mov	 edx, ecx
  002f0	c1 ea 11	 shr	 edx, 17			; 00000011H
  002f3	33 ca		 xor	 ecx, edx
  002f5	8b c1		 mov	 eax, ecx
  002f7	c1 e0 09	 shl	 eax, 9
  002fa	2b c8		 sub	 ecx, eax
  002fc	8b d1		 mov	 edx, ecx
  002fe	c1 e2 04	 shl	 edx, 4
  00301	33 ca		 xor	 ecx, edx
  00303	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0030a	2b c8		 sub	 ecx, eax
  0030c	8b d1		 mov	 edx, ecx
  0030e	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00311	33 ca		 xor	 ecx, edx
  00313	8b c1		 mov	 eax, ecx
  00315	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00318	33 c1		 xor	 eax, ecx

; 1729 : 		struct hashtable_object* obj;
; 1730 : 		obj = (struct hashtable_object*)tommy_hashdyn_remove(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  0031a	8d 4d f0	 lea	 ecx, DWORD PTR _key$150165[ebp]
  0031d	51		 push	 ecx
  0031e	e8 00 00 00 00	 call	 _tommy_hashdyn_remove
  00323	8b f0		 mov	 esi, eax
  00325	83 c4 04	 add	 esp, 4

; 1731 : 		if (!obj)

  00328	85 f6		 test	 esi, esi
  0032a	75 05		 jne	 SHORT $LN155@test_remov

; 1732 : 			abort();

  0032c	e8 00 00 00 00	 call	 _abort
$LN155@test_remov:

; 1733 : 		if (dereference) {
; 1734 : 			if (obj->value != key)

  00331	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00334	3b 55 f0	 cmp	 edx, DWORD PTR _key$150165[ebp]
  00337	74 05		 je	 SHORT $LN157@test_remov

; 1735 : 				abort();

  00339	e8 00 00 00 00	 call	 _abort
$LN157@test_remov:

; 1725 : 
; 1726 : 	START(DATA_HASHDYN) {

  0033e	43		 inc	 ebx
  0033f	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00345	72 99		 jb	 SHORT $LL158@test_remov
$LN156@test_remov:

; 1736 : 		}
; 1737 : 	} STOP();

  00347	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1738 : 
; 1739 : 	START(DATA_HASHLIN) {

  0034c	b8 02 00 00 00	 mov	 eax, 2
  00351	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00356	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0035c	0f 85 2a 01 00
	00		 jne	 $LN149@test_remov
  00362	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00369	75 2e		 jne	 SHORT $LN232@test_remov
  0036b	a1 08 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  00370	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00376	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0037d	50		 push	 eax
  0037e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00383	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0038a	52		 push	 edx
  0038b	51		 push	 ecx
  0038c	68 00 00 00 00	 push	 OFFSET $SG-100
  00391	e8 00 00 00 00	 call	 _printf
  00396	83 c4 10	 add	 esp, 16			; 00000010H
$LN232@test_remov:
  00399	8d 55 dc	 lea	 edx, DWORD PTR _t$204748[ebp]
  0039c	52		 push	 edx
  0039d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  003a3	85 c0		 test	 eax, eax
  003a5	75 11		 jne	 SHORT $LN238@test_remov
  003a7	66 0f 57 c0	 xorpd	 xmm0, xmm0
  003ab	66 0f 13 45 dc	 movlpd	 QWORD PTR $T204742[ebp], xmm0
  003b0	8b 5d e0	 mov	 ebx, DWORD PTR $T204742[ebp+4]
  003b3	8b 75 dc	 mov	 esi, DWORD PTR $T204742[ebp]
  003b6	eb 54		 jmp	 SHORT $LN239@test_remov
$LN238@test_remov:
  003b8	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  003be	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  003c4	8b 45 e0	 mov	 eax, DWORD PTR _t$204748[ebp+4]
  003c7	8b 4d dc	 mov	 ecx, DWORD PTR _t$204748[ebp]
  003ca	56		 push	 esi
  003cb	57		 push	 edi
  003cc	50		 push	 eax
  003cd	51		 push	 ecx
  003ce	e8 00 00 00 00	 call	 __alldvrm
  003d3	6a 00		 push	 0
  003d5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003da	53		 push	 ebx
  003db	51		 push	 ecx
  003dc	89 45 dc	 mov	 DWORD PTR tv1148[ebp], eax
  003df	89 55 e0	 mov	 DWORD PTR tv1148[ebp+4], edx
  003e2	e8 00 00 00 00	 call	 __allmul
  003e7	56		 push	 esi
  003e8	57		 push	 edi
  003e9	52		 push	 edx
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 __alldiv
  003f0	6a 00		 push	 0
  003f2	8b da		 mov	 ebx, edx
  003f4	8b 55 e0	 mov	 edx, DWORD PTR tv1148[ebp+4]
  003f7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003fc	8b f0		 mov	 esi, eax
  003fe	8b 45 dc	 mov	 eax, DWORD PTR tv1148[ebp]
  00401	52		 push	 edx
  00402	50		 push	 eax
  00403	e8 00 00 00 00	 call	 __allmul
  00408	03 f0		 add	 esi, eax
  0040a	13 da		 adc	 ebx, edx
$LN239@test_remov:
  0040c	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00412	33 db		 xor	 ebx, ebx
  00414	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  0041a	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  00420	76 6a		 jbe	 SHORT $LN149@test_remov
  00422	8b 7d 08	 mov	 edi, DWORD PTR _REMOVE$[ebp]
$LL151@test_remov:

; 1740 : 		unsigned key = REMOVE[i] + DELTA;

  00425	8b 0c 9f	 mov	 ecx, DWORD PTR [edi+ebx*4]
  00428	41		 inc	 ecx

; 1741 : 		unsigned hash_key = hash(key);

  00429	8b d1		 mov	 edx, ecx
  0042b	89 4d f0	 mov	 DWORD PTR _key$150176[ebp], ecx
  0042e	c1 e2 06	 shl	 edx, 6
  00431	2b ca		 sub	 ecx, edx
  00433	8b c1		 mov	 eax, ecx
  00435	c1 e8 11	 shr	 eax, 17			; 00000011H
  00438	33 c8		 xor	 ecx, eax
  0043a	8b d1		 mov	 edx, ecx
  0043c	c1 e2 09	 shl	 edx, 9
  0043f	2b ca		 sub	 ecx, edx
  00441	8b c1		 mov	 eax, ecx
  00443	c1 e0 04	 shl	 eax, 4
  00446	33 c8		 xor	 ecx, eax
  00448	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0044f	2b ca		 sub	 ecx, edx
  00451	8b c1		 mov	 eax, ecx
  00453	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00456	33 c8		 xor	 ecx, eax
  00458	8b c1		 mov	 eax, ecx
  0045a	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  0045d	33 c1		 xor	 eax, ecx

; 1742 : 		struct hashtable_object* obj;
; 1743 : 		obj = (struct hashtable_object*)tommy_hashlin_remove(&hashlin, tommy_hashtable_compare, &key, hash_key);

  0045f	8d 4d f0	 lea	 ecx, DWORD PTR _key$150176[ebp]
  00462	51		 push	 ecx
  00463	e8 00 00 00 00	 call	 _tommy_hashlin_remove
  00468	8b f0		 mov	 esi, eax
  0046a	83 c4 04	 add	 esp, 4

; 1744 : 		if (!obj)

  0046d	85 f6		 test	 esi, esi
  0046f	75 05		 jne	 SHORT $LN148@test_remov

; 1745 : 			abort();

  00471	e8 00 00 00 00	 call	 _abort
$LN148@test_remov:

; 1746 : 		if (dereference) {
; 1747 : 			if (obj->value != key)

  00476	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00479	3b 55 f0	 cmp	 edx, DWORD PTR _key$150176[ebp]
  0047c	74 05		 je	 SHORT $LN150@test_remov

; 1748 : 				abort();

  0047e	e8 00 00 00 00	 call	 _abort
$LN150@test_remov:

; 1738 : 
; 1739 : 	START(DATA_HASHLIN) {

  00483	43		 inc	 ebx
  00484	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  0048a	72 99		 jb	 SHORT $LL151@test_remov
$LN149@test_remov:

; 1749 : 		}
; 1750 : 	} STOP();

  0048c	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1751 : 
; 1752 : 	START(DATA_TRIE) {

  00491	b8 03 00 00 00	 mov	 eax, 3
  00496	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0049b	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  004a1	0f 85 07 01 00
	00		 jne	 $LN142@test_remov
  004a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  004ae	75 2e		 jne	 SHORT $LN243@test_remov
  004b0	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  004b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  004bb	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  004c2	50		 push	 eax
  004c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  004c8	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  004cf	52		 push	 edx
  004d0	51		 push	 ecx
  004d1	68 00 00 00 00	 push	 OFFSET $SG-100
  004d6	e8 00 00 00 00	 call	 _printf
  004db	83 c4 10	 add	 esp, 16			; 00000010H
$LN243@test_remov:
  004de	8d 55 dc	 lea	 edx, DWORD PTR _t$204778[ebp]
  004e1	52		 push	 edx
  004e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  004e8	85 c0		 test	 eax, eax
  004ea	75 11		 jne	 SHORT $LN249@test_remov
  004ec	66 0f 57 c0	 xorpd	 xmm0, xmm0
  004f0	66 0f 13 45 dc	 movlpd	 QWORD PTR $T204769[ebp], xmm0
  004f5	8b 5d e0	 mov	 ebx, DWORD PTR $T204769[ebp+4]
  004f8	8b 75 dc	 mov	 esi, DWORD PTR $T204769[ebp]
  004fb	eb 54		 jmp	 SHORT $LN250@test_remov
$LN249@test_remov:
  004fd	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00503	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00509	8b 45 e0	 mov	 eax, DWORD PTR _t$204778[ebp+4]
  0050c	8b 4d dc	 mov	 ecx, DWORD PTR _t$204778[ebp]
  0050f	56		 push	 esi
  00510	57		 push	 edi
  00511	50		 push	 eax
  00512	51		 push	 ecx
  00513	e8 00 00 00 00	 call	 __alldvrm
  00518	6a 00		 push	 0
  0051a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0051f	53		 push	 ebx
  00520	51		 push	 ecx
  00521	89 45 dc	 mov	 DWORD PTR tv3638[ebp], eax
  00524	89 55 e0	 mov	 DWORD PTR tv3638[ebp+4], edx
  00527	e8 00 00 00 00	 call	 __allmul
  0052c	56		 push	 esi
  0052d	57		 push	 edi
  0052e	52		 push	 edx
  0052f	50		 push	 eax
  00530	e8 00 00 00 00	 call	 __alldiv
  00535	6a 00		 push	 0
  00537	8b da		 mov	 ebx, edx
  00539	8b 55 e0	 mov	 edx, DWORD PTR tv3638[ebp+4]
  0053c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00541	8b f0		 mov	 esi, eax
  00543	8b 45 dc	 mov	 eax, DWORD PTR tv3638[ebp]
  00546	52		 push	 edx
  00547	50		 push	 eax
  00548	e8 00 00 00 00	 call	 __allmul
  0054d	03 f0		 add	 esi, eax
  0054f	13 da		 adc	 ebx, edx
$LN250@test_remov:
  00551	33 ff		 xor	 edi, edi
  00553	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00559	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0055f	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00565	76 47		 jbe	 SHORT $LN142@test_remov
$LL144@test_remov:

; 1753 : 		unsigned key = REMOVE[i] + DELTA;

  00567	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  0056a	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]
  0056d	46		 inc	 esi

; 1754 : 		struct trie_object* obj;
; 1755 : 		obj = (struct trie_object*)tommy_trie_remove(&trie, key);

  0056e	8b d6		 mov	 edx, esi
  00570	c1 ea 1b	 shr	 edx, 27			; 0000001bH
  00573	8d 14 95 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[edx*4]
  0057a	8b c6		 mov	 eax, esi
  0057c	e8 00 00 00 00	 call	 ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ; trie_bucket_remove_existing
  00581	85 c0		 test	 eax, eax
  00583	75 04		 jne	 SHORT $LN252@test_remov
  00585	33 db		 xor	 ebx, ebx
  00587	eb 0d		 jmp	 SHORT $LN1271@test_remov
$LN252@test_remov:
  00589	ff 0d 80 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128
  0058f	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1756 : 		if (!obj)

  00592	85 db		 test	 ebx, ebx
  00594	75 05		 jne	 SHORT $LN141@test_remov
$LN1271@test_remov:

; 1757 : 			abort();

  00596	e8 00 00 00 00	 call	 _abort
$LN141@test_remov:

; 1758 : 		if (dereference) {
; 1759 : 			if (obj->value != key)

  0059b	39 73 10	 cmp	 DWORD PTR [ebx+16], esi
  0059e	74 05		 je	 SHORT $LN143@test_remov

; 1760 : 				abort();

  005a0	e8 00 00 00 00	 call	 _abort
$LN143@test_remov:

; 1751 : 
; 1752 : 	START(DATA_TRIE) {

  005a5	47		 inc	 edi
  005a6	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  005ac	72 b9		 jb	 SHORT $LL144@test_remov
$LN142@test_remov:

; 1761 : 		}
; 1762 : 	} STOP();

  005ae	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1763 : 
; 1764 : 	START(DATA_TRIE_INPLACE) {

  005b3	b8 04 00 00 00	 mov	 eax, 4
  005b8	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  005bd	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  005c3	0f 85 12 01 00
	00		 jne	 $LN135@test_remov
  005c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  005d0	75 2e		 jne	 SHORT $LN255@test_remov
  005d2	a1 10 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  005d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  005dd	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  005e4	50		 push	 eax
  005e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  005ea	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  005f1	52		 push	 edx
  005f2	51		 push	 ecx
  005f3	68 00 00 00 00	 push	 OFFSET $SG-100
  005f8	e8 00 00 00 00	 call	 _printf
  005fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN255@test_remov:
  00600	8d 55 dc	 lea	 edx, DWORD PTR _t$204807[ebp]
  00603	52		 push	 edx
  00604	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0060a	85 c0		 test	 eax, eax
  0060c	75 11		 jne	 SHORT $LN261@test_remov
  0060e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00612	66 0f 13 45 dc	 movlpd	 QWORD PTR $T204798[ebp], xmm0
  00617	8b 5d e0	 mov	 ebx, DWORD PTR $T204798[ebp+4]
  0061a	8b 75 dc	 mov	 esi, DWORD PTR $T204798[ebp]
  0061d	eb 54		 jmp	 SHORT $LN262@test_remov
$LN261@test_remov:
  0061f	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00625	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0062b	8b 45 e0	 mov	 eax, DWORD PTR _t$204807[ebp+4]
  0062e	8b 4d dc	 mov	 ecx, DWORD PTR _t$204807[ebp]
  00631	56		 push	 esi
  00632	57		 push	 edi
  00633	50		 push	 eax
  00634	51		 push	 ecx
  00635	e8 00 00 00 00	 call	 __alldvrm
  0063a	6a 00		 push	 0
  0063c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00641	53		 push	 ebx
  00642	51		 push	 ecx
  00643	89 45 dc	 mov	 DWORD PTR tv1441[ebp], eax
  00646	89 55 e0	 mov	 DWORD PTR tv1441[ebp+4], edx
  00649	e8 00 00 00 00	 call	 __allmul
  0064e	56		 push	 esi
  0064f	57		 push	 edi
  00650	52		 push	 edx
  00651	50		 push	 eax
  00652	e8 00 00 00 00	 call	 __alldiv
  00657	6a 00		 push	 0
  00659	8b da		 mov	 ebx, edx
  0065b	8b 55 e0	 mov	 edx, DWORD PTR tv1441[ebp+4]
  0065e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00663	8b f0		 mov	 esi, eax
  00665	8b 45 dc	 mov	 eax, DWORD PTR tv1441[ebp]
  00668	52		 push	 edx
  00669	50		 push	 eax
  0066a	e8 00 00 00 00	 call	 __allmul
  0066f	03 f0		 add	 esi, eax
  00671	13 da		 adc	 ebx, edx
$LN262@test_remov:
  00673	33 ff		 xor	 edi, edi
  00675	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  0067b	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00681	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00687	76 52		 jbe	 SHORT $LN135@test_remov
  00689	8d a4 24 00 00
	00 00		 npad	 7
$LL137@test_remov:

; 1765 : 		unsigned key = REMOVE[i] + DELTA;

  00690	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  00693	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]
  00696	46		 inc	 esi

; 1766 : 		struct trie_inplace_object* obj;
; 1767 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_remove(&trie_inplace, key);

  00697	8b d6		 mov	 edx, esi
  00699	c1 ea 1a	 shr	 edx, 26			; 0000001aH
  0069c	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[edx*4]
  006a3	50		 push	 eax
  006a4	8b d6		 mov	 edx, esi
  006a6	e8 00 00 00 00	 call	 ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ; trie_inplace_bucket_remove
  006ab	83 c4 04	 add	 esp, 4
  006ae	85 c0		 test	 eax, eax
  006b0	75 04		 jne	 SHORT $LN264@test_remov
  006b2	33 db		 xor	 ebx, ebx
  006b4	eb 0d		 jmp	 SHORT $LN1273@test_remov
$LN264@test_remov:
  006b6	ff 0d 00 01 00
	00		 dec	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  006bc	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1768 : 		if (!obj)

  006bf	85 db		 test	 ebx, ebx
  006c1	75 05		 jne	 SHORT $LN134@test_remov
$LN1273@test_remov:

; 1769 : 			abort();

  006c3	e8 00 00 00 00	 call	 _abort
$LN134@test_remov:

; 1770 : 		if (dereference) {
; 1771 : 			if (obj->value != key)

  006c8	39 73 20	 cmp	 DWORD PTR [ebx+32], esi
  006cb	74 05		 je	 SHORT $LN136@test_remov

; 1772 : 				abort();

  006cd	e8 00 00 00 00	 call	 _abort
$LN136@test_remov:

; 1763 : 
; 1764 : 	START(DATA_TRIE_INPLACE) {

  006d2	47		 inc	 edi
  006d3	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  006d9	72 b5		 jb	 SHORT $LL137@test_remov
$LN135@test_remov:

; 1773 : 		}
; 1774 : 	} STOP();

  006db	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1775 : 
; 1776 : 	START(DATA_KHASH) {

  006e0	b8 07 00 00 00	 mov	 eax, 7
  006e5	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  006ea	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  006f0	0f 85 8c 01 00
	00		 jne	 $LN128@test_remov
  006f6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  006fd	75 30		 jne	 SHORT $LN267@test_remov
  006ff	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00705	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0070b	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00712	51		 push	 ecx
  00713	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00719	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  00720	50		 push	 eax
  00721	52		 push	 edx
  00722	68 00 00 00 00	 push	 OFFSET $SG-100
  00727	e8 00 00 00 00	 call	 _printf
  0072c	83 c4 10	 add	 esp, 16			; 00000010H
$LN267@test_remov:
  0072f	8d 45 e4	 lea	 eax, DWORD PTR _t$204834[ebp]
  00732	50		 push	 eax
  00733	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00739	85 c0		 test	 eax, eax
  0073b	75 11		 jne	 SHORT $LN273@test_remov
  0073d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00741	66 0f 13 45 dc	 movlpd	 QWORD PTR $T204827[ebp], xmm0
  00746	8b 7d e0	 mov	 edi, DWORD PTR $T204827[ebp+4]
  00749	8b 75 dc	 mov	 esi, DWORD PTR $T204827[ebp]
  0074c	eb 54		 jmp	 SHORT $LN274@test_remov
$LN273@test_remov:
  0074e	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00754	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0075a	8b 4d e8	 mov	 ecx, DWORD PTR _t$204834[ebp+4]
  0075d	8b 55 e4	 mov	 edx, DWORD PTR _t$204834[ebp]
  00760	56		 push	 esi
  00761	57		 push	 edi
  00762	51		 push	 ecx
  00763	52		 push	 edx
  00764	e8 00 00 00 00	 call	 __alldvrm
  00769	6a 00		 push	 0
  0076b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00770	53		 push	 ebx
  00771	51		 push	 ecx
  00772	89 45 dc	 mov	 DWORD PTR tv1457[ebp], eax
  00775	89 55 e0	 mov	 DWORD PTR tv1457[ebp+4], edx
  00778	e8 00 00 00 00	 call	 __allmul
  0077d	56		 push	 esi
  0077e	57		 push	 edi
  0077f	52		 push	 edx
  00780	50		 push	 eax
  00781	e8 00 00 00 00	 call	 __alldiv
  00786	8b 4d dc	 mov	 ecx, DWORD PTR tv1457[ebp]
  00789	6a 00		 push	 0
  0078b	8b f0		 mov	 esi, eax
  0078d	8b 45 e0	 mov	 eax, DWORD PTR tv1457[ebp+4]
  00790	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00795	50		 push	 eax
  00796	51		 push	 ecx
  00797	8b fa		 mov	 edi, edx
  00799	e8 00 00 00 00	 call	 __allmul
  0079e	03 f0		 add	 esi, eax
  007a0	13 fa		 adc	 edi, edx
$LN274@test_remov:
  007a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  007a9	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  007af	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  007b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  007bc	0f 86 c0 00 00
	00		 jbe	 $LN128@test_remov
  007c2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  007c8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL130@test_remov:

; 1777 : 		unsigned key = REMOVE[i] + DELTA;

  007d0	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  007d3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  007d6	8b 1c 82	 mov	 ebx, DWORD PTR [edx+eax*4]
  007d9	43		 inc	 ebx

; 1778 : 		unsigned hash_key = hash(key);

  007da	8b cb		 mov	 ecx, ebx
  007dc	c1 e1 06	 shl	 ecx, 6
  007df	8b c3		 mov	 eax, ebx
  007e1	2b c1		 sub	 eax, ecx
  007e3	8b d0		 mov	 edx, eax
  007e5	c1 ea 11	 shr	 edx, 17			; 00000011H
  007e8	33 c2		 xor	 eax, edx
  007ea	8b c8		 mov	 ecx, eax
  007ec	c1 e1 09	 shl	 ecx, 9
  007ef	2b c1		 sub	 eax, ecx
  007f1	8b d0		 mov	 edx, eax
  007f3	c1 e2 04	 shl	 edx, 4
  007f6	33 c2		 xor	 eax, edx
  007f8	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  007ff	2b c1		 sub	 eax, ecx
  00801	8b d0		 mov	 edx, eax
  00803	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00806	33 c2		 xor	 eax, edx
  00808	8b c8		 mov	 ecx, eax
  0080a	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  0080d	33 c8		 xor	 ecx, eax

; 1779 : 		struct khash_object* obj;
; 1780 : 		khiter_t k;
; 1781 : 		k = kh_get(word, khash, hash_key);

  0080f	51		 push	 ecx
  00810	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word
  00815	8b f0		 mov	 esi, eax
  00817	83 c4 04	 add	 esp, 4

; 1782 : 		if (k == kh_end(khash))

  0081a	3b 37		 cmp	 esi, DWORD PTR [edi]
  0081c	75 0b		 jne	 SHORT $LN127@test_remov

; 1783 : 			abort();

  0081e	e8 00 00 00 00	 call	 _abort
  00823	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
$LN127@test_remov:

; 1784 : 		if (dereference) {
; 1785 : 			obj = kh_value(khash, k);

  00829	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0082c	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  0082f	89 45 f0	 mov	 DWORD PTR _obj$150209[ebp], eax

; 1786 : 		}
; 1787 : 		kh_del(word, khash, k);

  00832	3b 37		 cmp	 esi, DWORD PTR [edi]
  00834	74 27		 je	 SHORT $LN278@test_remov
  00836	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00839	8b ce		 mov	 ecx, esi
  0083b	c1 e9 04	 shr	 ecx, 4
  0083e	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00841	8b 10		 mov	 edx, DWORD PTR [eax]
  00843	83 e6 0f	 and	 esi, 15			; 0000000fH
  00846	03 f6		 add	 esi, esi
  00848	8b ce		 mov	 ecx, esi
  0084a	d3 ea		 shr	 edx, cl
  0084c	f6 c2 03	 test	 dl, 3
  0084f	75 0c		 jne	 SHORT $LN278@test_remov
  00851	ba 01 00 00 00	 mov	 edx, 1
  00856	d3 e2		 shl	 edx, cl
  00858	09 10		 or	 DWORD PTR [eax], edx
  0085a	ff 4f 04	 dec	 DWORD PTR [edi+4]
$LN278@test_remov:

; 1788 : 		if (dereference) {
; 1789 : 			if (obj->value != key)

  0085d	8b 45 f0	 mov	 eax, DWORD PTR _obj$150209[ebp]
  00860	39 18		 cmp	 DWORD PTR [eax], ebx
  00862	74 0b		 je	 SHORT $LN129@test_remov

; 1790 : 				abort();

  00864	e8 00 00 00 00	 call	 _abort
  00869	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
$LN129@test_remov:

; 1775 : 
; 1776 : 	START(DATA_KHASH) {

  0086f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00872	40		 inc	 eax
  00873	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00876	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0087c	0f 82 4e ff ff
	ff		 jb	 $LL130@test_remov
$LN128@test_remov:

; 1791 : 		}
; 1792 : 	} STOP();

  00882	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1793 : 
; 1794 : #ifdef USE_CGOOGLEDENSEHASH
; 1795 : 	START(DATA_CGOOGLE) {
; 1796 : 		unsigned key = REMOVE[i] + DELTA;
; 1797 : 		HTItem* ptr;
; 1798 : 		struct google_object* obj;
; 1799 : 		ptr = HashFind(cgoogledensehash, key);
; 1800 : 		if (!ptr)
; 1801 : 			abort();
; 1802 : 		obj = (struct google_object*)ptr->data;
; 1803 : 		HashDeleteLast(cgoogledensehash);
; 1804 : 		if (dereference) {
; 1805 : 			if (obj->value != key)
; 1806 : 				abort();
; 1807 : 		}
; 1808 : 	} STOP();
; 1809 : #endif
; 1810 : 
; 1811 : #ifdef USE_GOOGLEDENSEHASH
; 1812 : 	START(DATA_GOOGLEDENSEHASH) {

  00887	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0088c	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00891	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00897	0f 85 23 02 00
	00		 jne	 $LN120@test_remov
  0089d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  008a4	75 30		 jne	 SHORT $LN281@test_remov
  008a6	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  008ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  008b2	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  008b9	51		 push	 ecx
  008ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  008c0	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  008c7	50		 push	 eax
  008c8	52		 push	 edx
  008c9	68 00 00 00 00	 push	 OFFSET $SG-100
  008ce	e8 00 00 00 00	 call	 _printf
  008d3	83 c4 10	 add	 esp, 16			; 00000010H
$LN281@test_remov:
  008d6	8d 45 d4	 lea	 eax, DWORD PTR _t$204866[ebp]
  008d9	50		 push	 eax
  008da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  008e0	85 c0		 test	 eax, eax
  008e2	75 11		 jne	 SHORT $LN287@test_remov
  008e4	66 0f 57 c0	 xorpd	 xmm0, xmm0
  008e8	66 0f 13 45 dc	 movlpd	 QWORD PTR $T204859[ebp], xmm0
  008ed	8b 7d e0	 mov	 edi, DWORD PTR $T204859[ebp+4]
  008f0	8b 75 dc	 mov	 esi, DWORD PTR $T204859[ebp]
  008f3	eb 54		 jmp	 SHORT $LN288@test_remov
$LN287@test_remov:
  008f5	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  008fb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00901	8b 4d d8	 mov	 ecx, DWORD PTR _t$204866[ebp+4]
  00904	8b 55 d4	 mov	 edx, DWORD PTR _t$204866[ebp]
  00907	56		 push	 esi
  00908	57		 push	 edi
  00909	51		 push	 ecx
  0090a	52		 push	 edx
  0090b	e8 00 00 00 00	 call	 __alldvrm
  00910	6a 00		 push	 0
  00912	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00917	53		 push	 ebx
  00918	51		 push	 ecx
  00919	89 45 dc	 mov	 DWORD PTR tv1621[ebp], eax
  0091c	89 55 e0	 mov	 DWORD PTR tv1621[ebp+4], edx
  0091f	e8 00 00 00 00	 call	 __allmul
  00924	56		 push	 esi
  00925	57		 push	 edi
  00926	52		 push	 edx
  00927	50		 push	 eax
  00928	e8 00 00 00 00	 call	 __alldiv
  0092d	8b 4d dc	 mov	 ecx, DWORD PTR tv1621[ebp]
  00930	6a 00		 push	 0
  00932	8b f0		 mov	 esi, eax
  00934	8b 45 e0	 mov	 eax, DWORD PTR tv1621[ebp+4]
  00937	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0093c	50		 push	 eax
  0093d	51		 push	 ecx
  0093e	8b fa		 mov	 edi, edx
  00940	e8 00 00 00 00	 call	 __allmul
  00945	03 f0		 add	 esi, eax
  00947	13 fa		 adc	 edi, edx
$LN288@test_remov:
  00949	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00950	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00956	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  0095c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00963	0f 86 57 01 00
	00		 jbe	 $LN120@test_remov
$LN122@test_remov:

; 1813 : 		unsigned key = REMOVE[i] + DELTA;

  00969	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  0096c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 1814 : 		struct google_object* obj;
; 1815 : 		googledensehash_t::iterator ptr = googledensehash->find(key);

  0096f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00975	8b 1c 82	 mov	 ebx, DWORD PTR [edx+eax*4]
  00978	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0097b	43		 inc	 ebx
  0097c	2b 4e 20	 sub	 ecx, DWORD PTR [esi+32]
  0097f	89 5d f0	 mov	 DWORD PTR _key$150219[ebp], ebx
  00982	75 2c		 jne	 SHORT $LN294@test_remov
  00984	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00987	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0098a	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  0098d	8b f9		 mov	 edi, ecx
  0098f	3b f9		 cmp	 edi, ecx
  00991	74 65		 je	 SHORT $LN408@test_remov
  00993	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
$LL306@test_remov:
  00996	8b 07		 mov	 eax, DWORD PTR [edi]
  00998	3b d0		 cmp	 edx, eax
  0099a	74 0b		 je	 SHORT $LN304@test_remov
  0099c	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  009a0	76 56		 jbe	 SHORT $LN408@test_remov
  009a2	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  009a5	75 51		 jne	 SHORT $LN408@test_remov
$LN304@test_remov:
  009a7	83 c7 08	 add	 edi, 8
  009aa	3b f9		 cmp	 edi, ecx
  009ac	75 e8		 jne	 SHORT $LL306@test_remov
  009ae	eb 48		 jmp	 SHORT $LN408@test_remov
$LN294@test_remov:
  009b0	8d 4d cc	 lea	 ecx, DWORD PTR _pos$206008[ebp]
  009b3	51		 push	 ecx
  009b4	8d 45 f0	 lea	 eax, DWORD PTR _key$150219[ebp]
  009b7	8b fe		 mov	 edi, esi
  009b9	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  009be	8b 45 cc	 mov	 eax, DWORD PTR _pos$206008[ebp]
  009c1	83 f8 ff	 cmp	 eax, -1
  009c4	75 2c		 jne	 SHORT $LN293@test_remov
  009c6	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  009c9	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  009cc	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  009cf	8b f9		 mov	 edi, ecx
  009d1	3b f9		 cmp	 edi, ecx
  009d3	74 23		 je	 SHORT $LN408@test_remov
  009d5	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
$LL358@test_remov:
  009d8	8b 07		 mov	 eax, DWORD PTR [edi]
  009da	3b d0		 cmp	 edx, eax
  009dc	74 0b		 je	 SHORT $LN356@test_remov
  009de	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  009e2	76 14		 jbe	 SHORT $LN408@test_remov
  009e4	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  009e7	75 0f		 jne	 SHORT $LN408@test_remov
$LN356@test_remov:
  009e9	83 c7 08	 add	 edi, 8
  009ec	3b f9		 cmp	 edi, ecx
  009ee	75 e8		 jne	 SHORT $LL358@test_remov
  009f0	eb 06		 jmp	 SHORT $LN408@test_remov
$LN293@test_remov:
  009f2	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  009f5	8d 3c c1	 lea	 edi, DWORD PTR [ecx+eax*8]
$LN408@test_remov:

; 1816 : 		if (ptr == googledensehash->end())

  009f8	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  009fb	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  009fe	8d 14 d0	 lea	 edx, DWORD PTR [eax+edx*8]
  00a01	8b c2		 mov	 eax, edx
  00a03	3b c2		 cmp	 eax, edx
  00a05	74 1c		 je	 SHORT $LN499@test_remov
$LL462@test_remov:
  00a07	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a09	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00a0c	74 0b		 je	 SHORT $LN460@test_remov
  00a0e	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00a12	76 0c		 jbe	 SHORT $LN1312@test_remov
  00a14	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00a17	75 07		 jne	 SHORT $LN1312@test_remov
$LN460@test_remov:
  00a19	83 c0 08	 add	 eax, 8
  00a1c	3b c2		 cmp	 eax, edx
  00a1e	75 e7		 jne	 SHORT $LL462@test_remov
$LN1312@test_remov:
  00a20	8b 5d f0	 mov	 ebx, DWORD PTR _key$150219[ebp]
$LN499@test_remov:
  00a23	3b f8		 cmp	 edi, eax
  00a25	75 0b		 jne	 SHORT $LN119@test_remov

; 1817 : 			abort();

  00a27	e8 00 00 00 00	 call	 _abort
  00a2c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN119@test_remov:

; 1818 : 		obj = ptr->second;
; 1819 : 		googledensehash->erase(ptr);

  00a32	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00a35	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00a38	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00a3b	8d 14 d0	 lea	 edx, DWORD PTR [eax+edx*8]
  00a3e	8b c2		 mov	 eax, edx
  00a40	89 4d e8	 mov	 DWORD PTR _obj$150220[ebp], ecx
  00a43	3b c2		 cmp	 eax, edx
  00a45	74 24		 je	 SHORT $LN563@test_remov
  00a47	8b 5e 2c	 mov	 ebx, DWORD PTR [esi+44]
  00a4a	8d 9b 00 00 00
	00		 npad	 6
$LL526@test_remov:
  00a50	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a52	3b d9		 cmp	 ebx, ecx
  00a54	74 0b		 je	 SHORT $LN524@test_remov
  00a56	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00a5a	76 0c		 jbe	 SHORT $LN1307@test_remov
  00a5c	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00a5f	75 07		 jne	 SHORT $LN1307@test_remov
$LN524@test_remov:
  00a61	83 c0 08	 add	 eax, 8
  00a64	3b c2		 cmp	 eax, edx
  00a66	75 e8		 jne	 SHORT $LL526@test_remov
$LN1307@test_remov:
  00a68	8b 5d f0	 mov	 ebx, DWORD PTR _key$150219[ebp]
$LN563@test_remov:
  00a6b	3b f8		 cmp	 edi, eax
  00a6d	74 2d		 je	 SHORT $LN603@test_remov
  00a6f	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00a73	76 0e		 jbe	 SHORT $LN587@test_remov
  00a75	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00a78	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00a7a	75 07		 jne	 SHORT $LN587@test_remov
  00a7c	b8 01 00 00 00	 mov	 eax, 1
  00a81	eb 02		 jmp	 SHORT $LN588@test_remov
$LN587@test_remov:
  00a83	33 c0		 xor	 eax, eax
$LN588@test_remov:
  00a85	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00a88	89 17		 mov	 DWORD PTR [edi], edx
  00a8a	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00a91	84 c0		 test	 al, al
  00a93	75 07		 jne	 SHORT $LN603@test_remov
  00a95	ff 46 20	 inc	 DWORD PTR [esi+32]
  00a98	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
$LN603@test_remov:

; 1820 : 
; 1821 : 		/* force a resize when we reach 20% load factor */
; 1822 : 		googledensehash->resize(0);

  00a9c	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink

; 1823 : 
; 1824 : 		if (dereference) {
; 1825 : 			if (obj->value != key)

  00aa1	8b 45 e8	 mov	 eax, DWORD PTR _obj$150220[ebp]
  00aa4	39 18		 cmp	 DWORD PTR [eax], ebx
  00aa6	74 05		 je	 SHORT $LN121@test_remov

; 1826 : 				abort();

  00aa8	e8 00 00 00 00	 call	 _abort
$LN121@test_remov:

; 1793 : 
; 1794 : #ifdef USE_CGOOGLEDENSEHASH
; 1795 : 	START(DATA_CGOOGLE) {
; 1796 : 		unsigned key = REMOVE[i] + DELTA;
; 1797 : 		HTItem* ptr;
; 1798 : 		struct google_object* obj;
; 1799 : 		ptr = HashFind(cgoogledensehash, key);
; 1800 : 		if (!ptr)
; 1801 : 			abort();
; 1802 : 		obj = (struct google_object*)ptr->data;
; 1803 : 		HashDeleteLast(cgoogledensehash);
; 1804 : 		if (dereference) {
; 1805 : 			if (obj->value != key)
; 1806 : 				abort();
; 1807 : 		}
; 1808 : 	} STOP();
; 1809 : #endif
; 1810 : 
; 1811 : #ifdef USE_GOOGLEDENSEHASH
; 1812 : 	START(DATA_GOOGLEDENSEHASH) {

  00aad	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00ab0	40		 inc	 eax
  00ab1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00ab4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00aba	0f 82 a9 fe ff
	ff		 jb	 $LN122@test_remov
$LN120@test_remov:

; 1827 : 		}
; 1828 : 	} STOP();

  00ac0	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1829 : #endif
; 1830 : 
; 1831 : #ifdef USE_GOOGLEBTREE
; 1832 : 	START(DATA_GOOGLEBTREE) {

  00ac5	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00aca	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00acf	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00ad5	0f 85 3a 02 00
	00		 jne	 $LN113@test_remov
  00adb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00ae2	75 30		 jne	 SHORT $LN614@test_remov
  00ae4	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  00aea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00af0	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00af7	51		 push	 ecx
  00af8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00afe	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  00b05	50		 push	 eax
  00b06	52		 push	 edx
  00b07	68 00 00 00 00	 push	 OFFSET $SG-100
  00b0c	e8 00 00 00 00	 call	 _printf
  00b11	83 c4 10	 add	 esp, 16			; 00000010H
$LN614@test_remov:
  00b14	8d 45 ec	 lea	 eax, DWORD PTR _t$207166[ebp]
  00b17	50		 push	 eax
  00b18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00b1e	85 c0		 test	 eax, eax
  00b20	75 11		 jne	 SHORT $LN620@test_remov
  00b22	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00b26	66 0f 13 45 d4	 movlpd	 QWORD PTR $T207159[ebp], xmm0
  00b2b	8b 5d d8	 mov	 ebx, DWORD PTR $T207159[ebp+4]
  00b2e	8b 75 d4	 mov	 esi, DWORD PTR $T207159[ebp]
  00b31	eb 54		 jmp	 SHORT $LN621@test_remov
$LN620@test_remov:
  00b33	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00b39	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00b3f	8b 4d f0	 mov	 ecx, DWORD PTR _t$207166[ebp+4]
  00b42	8b 55 ec	 mov	 edx, DWORD PTR _t$207166[ebp]
  00b45	56		 push	 esi
  00b46	57		 push	 edi
  00b47	51		 push	 ecx
  00b48	52		 push	 edx
  00b49	e8 00 00 00 00	 call	 __alldvrm
  00b4e	6a 00		 push	 0
  00b50	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b55	53		 push	 ebx
  00b56	51		 push	 ecx
  00b57	89 45 dc	 mov	 DWORD PTR tv2171[ebp], eax
  00b5a	89 55 e0	 mov	 DWORD PTR tv2171[ebp+4], edx
  00b5d	e8 00 00 00 00	 call	 __allmul
  00b62	56		 push	 esi
  00b63	57		 push	 edi
  00b64	52		 push	 edx
  00b65	50		 push	 eax
  00b66	e8 00 00 00 00	 call	 __alldiv
  00b6b	8b 4d dc	 mov	 ecx, DWORD PTR tv2171[ebp]
  00b6e	6a 00		 push	 0
  00b70	8b f0		 mov	 esi, eax
  00b72	8b 45 e0	 mov	 eax, DWORD PTR tv2171[ebp+4]
  00b75	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b7a	50		 push	 eax
  00b7b	51		 push	 ecx
  00b7c	8b da		 mov	 ebx, edx
  00b7e	e8 00 00 00 00	 call	 __allmul
  00b83	03 f0		 add	 esi, eax
  00b85	13 da		 adc	 ebx, edx
$LN621@test_remov:
  00b87	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00b8e	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00b94	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00b9a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00ba1	0f 86 6e 01 00
	00		 jbe	 $LN113@test_remov
  00ba7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL115@test_remov:

; 1833 : 		unsigned key = REMOVE[i] + DELTA;

  00bb0	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  00bb3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 1834 : 		struct google_object* obj;
; 1835 : 		googlebtree_t::iterator ptr = googlebtree->find(key);

  00bb6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00bbc	8b 3c 82	 mov	 edi, DWORD PTR [edx+eax*4]
  00bbf	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00bc1	47		 inc	 edi
  00bc2	89 7d e8	 mov	 DWORD PTR _key$150231[ebp], edi
  00bc5	85 db		 test	 ebx, ebx
  00bc7	74 71		 je	 SHORT $LN752@test_remov
  00bc9	8b cb		 mov	 ecx, ebx
  00bcb	eb 03 8d 49 00	 npad	 5
$LL649@test_remov:
  00bd0	0f b6 71 03	 movzx	 esi, BYTE PTR [ecx+3]
  00bd4	33 c0		 xor	 eax, eax
  00bd6	85 f6		 test	 esi, esi
  00bd8	7e 12		 jle	 SHORT $LN1232@test_remov
  00bda	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00bdd	8d 49 00	 npad	 3
$LL664@test_remov:
  00be0	39 3a		 cmp	 DWORD PTR [edx], edi
  00be2	73 08		 jae	 SHORT $LN1232@test_remov
  00be4	40		 inc	 eax
  00be5	83 c2 08	 add	 edx, 8
  00be8	3b c6		 cmp	 eax, esi
  00bea	7c f4		 jl	 SHORT $LL664@test_remov
$LN1232@test_remov:
  00bec	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00bef	75 0f		 jne	 SHORT $LL1233@test_remov
  00bf1	8b 8c 81 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+256]
  00bf8	eb d6		 jmp	 SHORT $LL649@test_remov
  00bfa	8d 9b 00 00 00
	00		 npad	 6
$LL1233@test_remov:
  00c00	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00c04	3b c2		 cmp	 eax, edx
  00c06	75 1d		 jne	 SHORT $LN706@test_remov
  00c08	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00c0c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00c0f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00c12	74 ec		 je	 SHORT $LL1233@test_remov
$LN742@test_remov:
  00c14	85 db		 test	 ebx, ebx
  00c16	74 22		 je	 SHORT $LN752@test_remov
  00c18	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c1b	75 1d		 jne	 SHORT $LN752@test_remov
  00c1d	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00c23	eb 17		 jmp	 SHORT $LN764@test_remov
$LN706@test_remov:
  00c25	85 c9		 test	 ecx, ecx
  00c27	74 eb		 je	 SHORT $LN742@test_remov
  00c29	3b 7c c1 08	 cmp	 edi, DWORD PTR [ecx+eax*8+8]
  00c2d	72 e5		 jb	 SHORT $LN742@test_remov
  00c2f	89 45 d8	 mov	 DWORD PTR $T208312[ebp+4], eax
  00c32	89 4d d4	 mov	 DWORD PTR $T208312[ebp], ecx
  00c35	8d 45 d4	 lea	 eax, DWORD PTR $T208312[ebp]
  00c38	eb 41		 jmp	 SHORT $LN743@test_remov
$LN752@test_remov:
  00c3a	8b c3		 mov	 eax, ebx
$LN764@test_remov:
  00c3c	85 c0		 test	 eax, eax
  00c3e	74 1d		 je	 SHORT $LN748@test_remov
  00c40	85 db		 test	 ebx, ebx
  00c42	74 11		 je	 SHORT $LN768@test_remov
  00c44	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c47	75 0c		 jne	 SHORT $LN768@test_remov
  00c49	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00c4f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00c53	eb 0a		 jmp	 SHORT $LN749@test_remov
$LN768@test_remov:
  00c55	8b c3		 mov	 eax, ebx
  00c57	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00c5b	eb 02		 jmp	 SHORT $LN749@test_remov
$LN748@test_remov:
  00c5d	33 c9		 xor	 ecx, ecx
$LN749@test_remov:
  00c5f	85 db		 test	 ebx, ebx
  00c61	74 0d		 je	 SHORT $LN786@test_remov
  00c63	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c66	75 08		 jne	 SHORT $LN786@test_remov
  00c68	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00c6e	eb 02		 jmp	 SHORT $LN798@test_remov
$LN786@test_remov:
  00c70	8b c3		 mov	 eax, ebx
$LN798@test_remov:
  00c72	89 45 dc	 mov	 DWORD PTR $T208313[ebp], eax
  00c75	89 4d e0	 mov	 DWORD PTR $T208313[ebp+4], ecx
  00c78	8d 45 dc	 lea	 eax, DWORD PTR $T208313[ebp]
$LN743@test_remov:
  00c7b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c7e	8b 38		 mov	 edi, DWORD PTR [eax]
  00c80	89 4d d0	 mov	 DWORD PTR _ptr$150233[ebp+4], ecx

; 1836 : 		if (ptr == googlebtree->end())

  00c83	85 db		 test	 ebx, ebx
  00c85	74 0d		 je	 SHORT $LN812@test_remov
  00c87	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00c8a	75 08		 jne	 SHORT $LN812@test_remov
  00c8c	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00c92	eb 02		 jmp	 SHORT $LN824@test_remov
$LN812@test_remov:
  00c94	8b c3		 mov	 eax, ebx
$LN824@test_remov:
  00c96	85 c0		 test	 eax, eax
  00c98	74 1d		 je	 SHORT $LN808@test_remov
  00c9a	85 db		 test	 ebx, ebx
  00c9c	74 11		 je	 SHORT $LN828@test_remov
  00c9e	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00ca1	75 0c		 jne	 SHORT $LN828@test_remov
  00ca3	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  00ca9	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00cad	eb 0a		 jmp	 SHORT $LN809@test_remov
$LN828@test_remov:
  00caf	8b c3		 mov	 eax, ebx
  00cb1	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00cb5	eb 02		 jmp	 SHORT $LN809@test_remov
$LN808@test_remov:
  00cb7	33 c0		 xor	 eax, eax
$LN809@test_remov:
  00cb9	85 db		 test	 ebx, ebx
  00cbb	74 0b		 je	 SHORT $LN846@test_remov
  00cbd	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00cc0	75 06		 jne	 SHORT $LN846@test_remov
  00cc2	8b 9b 80 01 00
	00		 mov	 ebx, DWORD PTR [ebx+384]
$LN846@test_remov:
  00cc8	3b fb		 cmp	 edi, ebx
  00cca	75 09		 jne	 SHORT $LN112@test_remov
  00ccc	3b c8		 cmp	 ecx, eax
  00cce	75 05		 jne	 SHORT $LN112@test_remov

; 1837 : 			abort();

  00cd0	e8 00 00 00 00	 call	 _abort
$LN112@test_remov:

; 1838 : 		obj = ptr->second;

  00cd5	8b 4d d0	 mov	 ecx, DWORD PTR _ptr$150233[ebp+4]
  00cd8	8b 74 cf 0c	 mov	 esi, DWORD PTR [edi+ecx*8+12]

; 1839 : 		googlebtree->erase(ptr);

  00cdc	83 ec 08	 sub	 esp, 8
  00cdf	8b c4		 mov	 eax, esp
  00ce1	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00ce4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00cea	89 38		 mov	 DWORD PTR [eax], edi
  00cec	8d 45 c4	 lea	 eax, DWORD PTR $T204598[ebp]
  00cef	50		 push	 eax
  00cf0	51		 push	 ecx
  00cf1	e8 00 00 00 00	 call	 ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase

; 1840 : 
; 1841 : 		if (dereference) {
; 1842 : 			if (obj->value != key)

  00cf6	8b 55 e8	 mov	 edx, DWORD PTR _key$150231[ebp]
  00cf9	39 16		 cmp	 DWORD PTR [esi], edx
  00cfb	74 05		 je	 SHORT $LN114@test_remov

; 1843 : 				abort();

  00cfd	e8 00 00 00 00	 call	 _abort
$LN114@test_remov:

; 1829 : #endif
; 1830 : 
; 1831 : #ifdef USE_GOOGLEBTREE
; 1832 : 	START(DATA_GOOGLEBTREE) {

  00d02	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00d05	40		 inc	 eax
  00d06	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00d09	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00d0f	0f 82 9b fe ff
	ff		 jb	 $LL115@test_remov
$LN113@test_remov:

; 1844 : 		}
; 1845 : 	} STOP();

  00d15	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1846 : #endif
; 1847 : 
; 1848 : #ifdef USE_CPPMAP
; 1849 : 	START(DATA_CPPMAP) {

  00d1a	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00d1f	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00d24	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00d2a	0f 85 4f 01 00
	00		 jne	 $LN106@test_remov
  00d30	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00d37	75 2e		 jne	 SHORT $LN876@test_remov
  00d39	a1 38 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  00d3e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00d44	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00d4b	50		 push	 eax
  00d4c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00d51	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00d58	52		 push	 edx
  00d59	51		 push	 ecx
  00d5a	68 00 00 00 00	 push	 OFFSET $SG-100
  00d5f	e8 00 00 00 00	 call	 _printf
  00d64	83 c4 10	 add	 esp, 16			; 00000010H
$LN876@test_remov:
  00d67	8d 55 cc	 lea	 edx, DWORD PTR _t$208750[ebp]
  00d6a	52		 push	 edx
  00d6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00d71	85 c0		 test	 eax, eax
  00d73	75 11		 jne	 SHORT $LN882@test_remov
  00d75	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00d79	66 0f 13 45 d4	 movlpd	 QWORD PTR $T208743[ebp], xmm0
  00d7e	8b 5d d8	 mov	 ebx, DWORD PTR $T208743[ebp+4]
  00d81	8b 75 d4	 mov	 esi, DWORD PTR $T208743[ebp]
  00d84	eb 54		 jmp	 SHORT $LN883@test_remov
$LN882@test_remov:
  00d86	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00d8c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00d92	8b 45 d0	 mov	 eax, DWORD PTR _t$208750[ebp+4]
  00d95	8b 4d cc	 mov	 ecx, DWORD PTR _t$208750[ebp]
  00d98	56		 push	 esi
  00d99	57		 push	 edi
  00d9a	50		 push	 eax
  00d9b	51		 push	 ecx
  00d9c	e8 00 00 00 00	 call	 __alldvrm
  00da1	6a 00		 push	 0
  00da3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00da8	53		 push	 ebx
  00da9	51		 push	 ecx
  00daa	89 45 dc	 mov	 DWORD PTR tv2564[ebp], eax
  00dad	89 55 e0	 mov	 DWORD PTR tv2564[ebp+4], edx
  00db0	e8 00 00 00 00	 call	 __allmul
  00db5	56		 push	 esi
  00db6	57		 push	 edi
  00db7	52		 push	 edx
  00db8	50		 push	 eax
  00db9	e8 00 00 00 00	 call	 __alldiv
  00dbe	6a 00		 push	 0
  00dc0	8b da		 mov	 ebx, edx
  00dc2	8b 55 e0	 mov	 edx, DWORD PTR tv2564[ebp+4]
  00dc5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00dca	8b f0		 mov	 esi, eax
  00dcc	8b 45 dc	 mov	 eax, DWORD PTR tv2564[ebp]
  00dcf	52		 push	 edx
  00dd0	50		 push	 eax
  00dd1	e8 00 00 00 00	 call	 __allmul
  00dd6	03 f0		 add	 esi, eax
  00dd8	13 da		 adc	 ebx, edx
$LN883@test_remov:
  00dda	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00de1	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00de7	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00ded	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00df4	0f 86 85 00 00
	00		 jbe	 $LN106@test_remov
$LN108@test_remov:

; 1850 : 		unsigned key = REMOVE[i] + DELTA;

  00dfa	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  00dfd	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00e00	8b 34 91	 mov	 esi, DWORD PTR [ecx+edx*4]

; 1851 : 		struct cpp_object* obj;
; 1852 : 		cppmap_t::iterator ptr = cppmap->find(key);

  00e03	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  00e09	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00e0c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00e0f	46		 inc	 esi
  00e10	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00e14	75 14		 jne	 SHORT $LN893@test_remov
$LL894@test_remov:
  00e16	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00e19	73 05		 jae	 SHORT $LN892@test_remov
  00e1b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00e1e	eb 04		 jmp	 SHORT $LN891@test_remov
$LN892@test_remov:
  00e20	8b c8		 mov	 ecx, eax
  00e22	8b 00		 mov	 eax, DWORD PTR [eax]
$LN891@test_remov:
  00e24	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00e28	74 ec		 je	 SHORT $LL894@test_remov
$LN893@test_remov:
  00e2a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00e2d	89 4d e8	 mov	 DWORD PTR __Where$209010[ebp], ecx
  00e30	3b c8		 cmp	 ecx, eax
  00e32	74 0a		 je	 SHORT $LN887@test_remov
  00e34	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  00e37	72 05		 jb	 SHORT $LN887@test_remov
  00e39	8d 4d e8	 lea	 ecx, DWORD PTR __Where$209010[ebp]
  00e3c	eb 06		 jmp	 SHORT $LN888@test_remov
$LN887@test_remov:
  00e3e	89 45 f0	 mov	 DWORD PTR $T209015[ebp], eax
  00e41	8d 4d f0	 lea	 ecx, DWORD PTR $T209015[ebp]
$LN888@test_remov:
  00e44	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 1853 : 		if (ptr == cppmap->end())

  00e46	3b d8		 cmp	 ebx, eax
  00e48	75 0b		 jne	 SHORT $LN105@test_remov

; 1854 : 			abort();

  00e4a	e8 00 00 00 00	 call	 _abort
  00e4f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
$LN105@test_remov:

; 1855 : 		obj = ptr->second;

  00e55	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 1856 : 		cppmap->erase(ptr);

  00e58	53		 push	 ebx
  00e59	8d 45 e0	 lea	 eax, DWORD PTR $T204601[ebp]
  00e5c	50		 push	 eax
  00e5d	52		 push	 edx
  00e5e	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 1857 : 
; 1858 : 		if (dereference) {
; 1859 : 			if (obj->value != key)

  00e63	39 37		 cmp	 DWORD PTR [edi], esi
  00e65	74 05		 je	 SHORT $LN107@test_remov

; 1860 : 				abort();

  00e67	e8 00 00 00 00	 call	 _abort
$LN107@test_remov:

; 1846 : #endif
; 1847 : 
; 1848 : #ifdef USE_CPPMAP
; 1849 : 	START(DATA_CPPMAP) {

  00e6c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e6f	40		 inc	 eax
  00e70	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00e73	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00e79	0f 82 7b ff ff
	ff		 jb	 $LN108@test_remov
$LN106@test_remov:

; 1861 : 		}
; 1862 : 	} STOP();

  00e7f	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1863 : #endif
; 1864 : 
; 1865 : #ifdef USE_CPPUNORDEREDMAP
; 1866 : 	START(DATA_CPPUNORDEREDMAP) {

  00e84	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  00e89	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00e8e	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00e94	0f 85 d2 01 00
	00		 jne	 $LN99@test_remov
  00e9a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00ea1	75 30		 jne	 SHORT $LN975@test_remov
  00ea3	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  00ea9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00eaf	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00eb6	51		 push	 ecx
  00eb7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00ebd	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  00ec4	50		 push	 eax
  00ec5	52		 push	 edx
  00ec6	68 00 00 00 00	 push	 OFFSET $SG-100
  00ecb	e8 00 00 00 00	 call	 _printf
  00ed0	83 c4 10	 add	 esp, 16			; 00000010H
$LN975@test_remov:
  00ed3	8d 45 d4	 lea	 eax, DWORD PTR _t$209133[ebp]
  00ed6	50		 push	 eax
  00ed7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00edd	85 c0		 test	 eax, eax
  00edf	75 11		 jne	 SHORT $LN981@test_remov
  00ee1	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ee5	66 0f 13 45 cc	 movlpd	 QWORD PTR $T209126[ebp], xmm0
  00eea	8b 5d d0	 mov	 ebx, DWORD PTR $T209126[ebp+4]
  00eed	8b 75 cc	 mov	 esi, DWORD PTR $T209126[ebp]
  00ef0	eb 54		 jmp	 SHORT $LN982@test_remov
$LN981@test_remov:
  00ef2	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00ef8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00efe	8b 4d d8	 mov	 ecx, DWORD PTR _t$209133[ebp+4]
  00f01	8b 55 d4	 mov	 edx, DWORD PTR _t$209133[ebp]
  00f04	56		 push	 esi
  00f05	57		 push	 edi
  00f06	51		 push	 ecx
  00f07	52		 push	 edx
  00f08	e8 00 00 00 00	 call	 __alldvrm
  00f0d	6a 00		 push	 0
  00f0f	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f14	53		 push	 ebx
  00f15	51		 push	 ecx
  00f16	89 45 dc	 mov	 DWORD PTR tv2694[ebp], eax
  00f19	89 55 e0	 mov	 DWORD PTR tv2694[ebp+4], edx
  00f1c	e8 00 00 00 00	 call	 __allmul
  00f21	56		 push	 esi
  00f22	57		 push	 edi
  00f23	52		 push	 edx
  00f24	50		 push	 eax
  00f25	e8 00 00 00 00	 call	 __alldiv
  00f2a	8b 4d dc	 mov	 ecx, DWORD PTR tv2694[ebp]
  00f2d	6a 00		 push	 0
  00f2f	8b f0		 mov	 esi, eax
  00f31	8b 45 e0	 mov	 eax, DWORD PTR tv2694[ebp+4]
  00f34	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f39	50		 push	 eax
  00f3a	51		 push	 ecx
  00f3b	8b da		 mov	 ebx, edx
  00f3d	e8 00 00 00 00	 call	 __allmul
  00f42	03 f0		 add	 esi, eax
  00f44	13 da		 adc	 ebx, edx
$LN982@test_remov:
  00f46	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00f4d	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00f53	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00f59	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f60	0f 86 06 01 00
	00		 jbe	 $LN99@test_remov
  00f66	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00f6c	8d 64 24 00	 npad	 4
$LL101@test_remov:

; 1867 : 		unsigned key = REMOVE[i] + DELTA;

  00f70	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  00f73	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00f76	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00f79	40		 inc	 eax

; 1868 : 		struct cpp_object* obj;
; 1869 : 		cppunorderedmap_t::iterator ptr = cppunorderedmap->find(key);

  00f7a	8d 4d e8	 lea	 ecx, DWORD PTR _ptr$150261[ebp]
  00f7d	89 45 f0	 mov	 DWORD PTR _key$150259[ebp], eax
  00f80	51		 push	 ecx
  00f81	8d 45 f0	 lea	 eax, DWORD PTR _key$150259[ebp]
  00f84	8b cb		 mov	 ecx, ebx
  00f86	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1870 : 		if (ptr == cppunorderedmap->end())

  00f8b	8b 75 e8	 mov	 esi, DWORD PTR _ptr$150261[ebp]
  00f8e	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
  00f91	75 0b		 jne	 SHORT $LN98@test_remov

; 1871 : 			abort();

  00f93	e8 00 00 00 00	 call	 _abort
  00f98	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN98@test_remov:

; 1872 : 		obj = ptr->second;
; 1873 : 		cppunorderedmap->erase(ptr);

  00f9e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00fa1	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00fa4	8b c8		 mov	 ecx, eax
  00fa6	c1 e1 06	 shl	 ecx, 6
  00fa9	2b c1		 sub	 eax, ecx
  00fab	89 55 e0	 mov	 DWORD PTR _obj$150260[ebp], edx
  00fae	8b d0		 mov	 edx, eax
  00fb0	c1 ea 11	 shr	 edx, 17			; 00000011H
  00fb3	33 c2		 xor	 eax, edx
  00fb5	8b c8		 mov	 ecx, eax
  00fb7	c1 e1 09	 shl	 ecx, 9
  00fba	2b c1		 sub	 eax, ecx
  00fbc	8b d0		 mov	 edx, eax
  00fbe	c1 e2 04	 shl	 edx, 4
  00fc1	33 c2		 xor	 eax, edx
  00fc3	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00fca	2b c1		 sub	 eax, ecx
  00fcc	8b d0		 mov	 edx, eax
  00fce	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00fd1	33 c2		 xor	 eax, edx
  00fd3	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  00fd6	8b c8		 mov	 ecx, eax
  00fd8	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00fdb	33 c8		 xor	 ecx, eax
  00fdd	23 ca		 and	 ecx, edx
  00fdf	39 4b 24	 cmp	 DWORD PTR [ebx+36], ecx
  00fe2	77 09		 ja	 SHORT $LN1016@test_remov
  00fe4	d1 ea		 shr	 edx, 1
  00fe6	83 c8 ff	 or	 eax, -1
  00fe9	2b c2		 sub	 eax, edx
  00feb	03 c8		 add	 ecx, eax
$LN1016@test_remov:
  00fed	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00ff0	39 74 ca 04	 cmp	 DWORD PTR [edx+ecx*8+4], esi
  00ff4	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00ff7	75 1d		 jne	 SHORT $LN1039@test_remov
  00ff9	39 30		 cmp	 DWORD PTR [eax], esi
  00ffb	75 11		 jne	 SHORT $LN1038@test_remov
  00ffd	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01000	89 10		 mov	 DWORD PTR [eax], edx
  01002	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  01005	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01008	89 54 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], edx
  0100c	eb 10		 jmp	 SHORT $LN1035@test_remov
$LN1038@test_remov:
  0100e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01011	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01014	eb 08		 jmp	 SHORT $LN1035@test_remov
$LN1039@test_remov:
  01016	39 30		 cmp	 DWORD PTR [eax], esi
  01018	75 04		 jne	 SHORT $LN1035@test_remov
  0101a	8b 16		 mov	 edx, DWORD PTR [esi]
  0101c	89 10		 mov	 DWORD PTR [eax], edx
$LN1035@test_remov:
  0101e	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
  01021	74 21		 je	 SHORT $LN1112@test_remov
  01023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01026	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01028	89 08		 mov	 DWORD PTR [eax], ecx
  0102a	8b 16		 mov	 edx, DWORD PTR [esi]
  0102c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0102f	56		 push	 esi
  01030	89 42 04	 mov	 DWORD PTR [edx+4], eax
  01033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01038	83 c4 04	 add	 esp, 4
  0103b	ff 4b 08	 dec	 DWORD PTR [ebx+8]
  0103e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN1112@test_remov:

; 1874 : 
; 1875 : 		if (dereference) {
; 1876 : 			if (obj->value != key)

  01044	8b 4d f0	 mov	 ecx, DWORD PTR _key$150259[ebp]
  01047	8b 55 e0	 mov	 edx, DWORD PTR _obj$150260[ebp]
  0104a	39 0a		 cmp	 DWORD PTR [edx], ecx
  0104c	74 0b		 je	 SHORT $LN100@test_remov

; 1877 : 				abort();

  0104e	e8 00 00 00 00	 call	 _abort
  01053	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN100@test_remov:

; 1863 : #endif
; 1864 : 
; 1865 : #ifdef USE_CPPUNORDEREDMAP
; 1866 : 	START(DATA_CPPUNORDEREDMAP) {

  01059	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0105c	40		 inc	 eax
  0105d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01060	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01066	0f 82 04 ff ff
	ff		 jb	 $LL101@test_remov
$LN99@test_remov:

; 1878 : 		}
; 1879 : 	} STOP();

  0106c	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1880 : #endif
; 1881 : 
; 1882 : 	START(DATA_UTHASH) {

  01071	b8 08 00 00 00	 mov	 eax, 8
  01076	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0107b	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  01081	0f 85 9d 02 00
	00		 jne	 $LN92@test_remov
  01087	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0108e	75 2e		 jne	 SHORT $LN1147@test_remov
  01090	a1 20 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+32
  01095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0109b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  010a2	50		 push	 eax
  010a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  010a8	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  010af	52		 push	 edx
  010b0	51		 push	 ecx
  010b1	68 00 00 00 00	 push	 OFFSET $SG-100
  010b6	e8 00 00 00 00	 call	 _printf
  010bb	83 c4 10	 add	 esp, 16			; 00000010H
$LN1147@test_remov:
  010be	8d 55 d4	 lea	 edx, DWORD PTR _t$209853[ebp]
  010c1	52		 push	 edx
  010c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  010c8	85 c0		 test	 eax, eax
  010ca	75 11		 jne	 SHORT $LN1153@test_remov
  010cc	66 0f 57 c0	 xorpd	 xmm0, xmm0
  010d0	66 0f 13 45 cc	 movlpd	 QWORD PTR $T209847[ebp], xmm0
  010d5	8b 5d d0	 mov	 ebx, DWORD PTR $T209847[ebp+4]
  010d8	8b 75 cc	 mov	 esi, DWORD PTR $T209847[ebp]
  010db	eb 54		 jmp	 SHORT $LN1154@test_remov
$LN1153@test_remov:
  010dd	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  010e3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  010e9	8b 45 d8	 mov	 eax, DWORD PTR _t$209853[ebp+4]
  010ec	8b 4d d4	 mov	 ecx, DWORD PTR _t$209853[ebp]
  010ef	56		 push	 esi
  010f0	57		 push	 edi
  010f1	50		 push	 eax
  010f2	51		 push	 ecx
  010f3	e8 00 00 00 00	 call	 __alldvrm
  010f8	6a 00		 push	 0
  010fa	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  010ff	53		 push	 ebx
  01100	51		 push	 ecx
  01101	89 45 dc	 mov	 DWORD PTR tv3469[ebp], eax
  01104	89 55 e0	 mov	 DWORD PTR tv3469[ebp+4], edx
  01107	e8 00 00 00 00	 call	 __allmul
  0110c	56		 push	 esi
  0110d	57		 push	 edi
  0110e	52		 push	 edx
  0110f	50		 push	 eax
  01110	e8 00 00 00 00	 call	 __alldiv
  01115	6a 00		 push	 0
  01117	8b da		 mov	 ebx, edx
  01119	8b 55 e0	 mov	 edx, DWORD PTR tv3469[ebp+4]
  0111c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01121	8b f0		 mov	 esi, eax
  01123	8b 45 dc	 mov	 eax, DWORD PTR tv3469[ebp]
  01126	52		 push	 edx
  01127	50		 push	 eax
  01128	e8 00 00 00 00	 call	 __allmul
  0112d	03 f0		 add	 esi, eax
  0112f	13 da		 adc	 ebx, edx
$LN1154@test_remov:
  01131	33 ff		 xor	 edi, edi
  01133	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01139	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0113f	89 7d f8	 mov	 DWORD PTR _i$[ebp], edi
  01142	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01148	0f 86 d6 01 00
	00		 jbe	 $LN92@test_remov
  0114e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LL94@test_remov:

; 1883 : 		unsigned key = REMOVE[i] + DELTA;

  01154	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  01157	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]
  0115a	41		 inc	 ecx

; 1884 : 		struct uthash_object* obj;
; 1885 : 		HASH_FIND_INT(uthash, &key, obj);  

  0115b	33 f6		 xor	 esi, esi
  0115d	89 4d f0	 mov	 DWORD PTR _key$150273[ebp], ecx
  01160	85 db		 test	 ebx, ebx
  01162	0f 84 ce 00 00
	00		 je	 $LN1261@test_remov
  01168	0f be 45 f3	 movsx	 eax, BYTE PTR _key$150273[ebp+3]
  0116c	0f be 55 f2	 movsx	 edx, BYTE PTR _key$150273[ebp+2]
  01170	c1 e0 18	 shl	 eax, 24			; 00000018H
  01173	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01178	c1 e2 10	 shl	 edx, 16			; 00000010H
  0117b	03 c2		 add	 eax, edx
  0117d	0f be d5	 movsx	 edx, ch
  01180	0f be c9	 movsx	 ecx, cl
  01183	c1 e2 08	 shl	 edx, 8
  01186	03 d0		 add	 edx, eax
  01188	03 d1		 add	 edx, ecx
  0118a	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  01190	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  01196	8b c2		 mov	 eax, edx
  01198	c1 e0 08	 shl	 eax, 8
  0119b	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  011a0	2b ca		 sub	 ecx, edx
  011a2	33 c8		 xor	 ecx, eax
  011a4	8b f1		 mov	 esi, ecx
  011a6	c1 ee 0d	 shr	 esi, 13			; 0000000dH
  011a9	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  011ae	2b c1		 sub	 eax, ecx
  011b0	2b c2		 sub	 eax, edx
  011b2	33 c6		 xor	 eax, esi
  011b4	2b d1		 sub	 edx, ecx
  011b6	2b d0		 sub	 edx, eax
  011b8	8b f0		 mov	 esi, eax
  011ba	c1 ee 0c	 shr	 esi, 12			; 0000000cH
  011bd	33 d6		 xor	 edx, esi
  011bf	2b ca		 sub	 ecx, edx
  011c1	2b c8		 sub	 ecx, eax
  011c3	8b f2		 mov	 esi, edx
  011c5	c1 e6 10	 shl	 esi, 16			; 00000010H
  011c8	33 ce		 xor	 ecx, esi
  011ca	2b c1		 sub	 eax, ecx
  011cc	2b c2		 sub	 eax, edx
  011ce	8b f1		 mov	 esi, ecx
  011d0	c1 ee 05	 shr	 esi, 5
  011d3	33 c6		 xor	 eax, esi
  011d5	2b d1		 sub	 edx, ecx
  011d7	2b d0		 sub	 edx, eax
  011d9	8b f0		 mov	 esi, eax
  011db	c1 ee 03	 shr	 esi, 3
  011de	33 d6		 xor	 edx, esi
  011e0	2b ca		 sub	 ecx, edx
  011e2	2b c8		 sub	 ecx, eax
  011e4	8b f2		 mov	 esi, edx
  011e6	c1 e6 0a	 shl	 esi, 10			; 0000000aH
  011e9	33 ce		 xor	 ecx, esi
  011eb	8b 33		 mov	 esi, DWORD PTR [ebx]
  011ed	2b c1		 sub	 eax, ecx
  011ef	2b c2		 sub	 eax, edx
  011f1	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  011f4	33 c1		 xor	 eax, ecx
  011f6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  011f9	49		 dec	 ecx
  011fa	23 c1		 and	 eax, ecx
  011fc	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  011ff	8b 06		 mov	 eax, DWORD PTR [esi]
  01201	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  01204	85 c0		 test	 eax, eax
  01206	74 2c		 je	 SHORT $LN50@test_remov
  01208	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0120b	2b c1		 sub	 eax, ecx
  0120d	8b f0		 mov	 esi, eax
  0120f	85 f6		 test	 esi, esi
  01211	74 23		 je	 SHORT $LN1261@test_remov
  01213	b8 04 00 00 00	 mov	 eax, 4
$LL54@test_remov:
  01218	39 46 18	 cmp	 DWORD PTR [esi+24], eax
  0121b	75 0a		 jne	 SHORT $LN51@test_remov
  0121d	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01220	8b 12		 mov	 edx, DWORD PTR [edx]
  01222	3b 55 f0	 cmp	 edx, DWORD PTR _key$150273[ebp]
  01225	74 1a		 je	 SHORT $LN44@test_remov
$LN51@test_remov:
  01227	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  0122a	85 f6		 test	 esi, esi
  0122c	74 06		 je	 SHORT $LN50@test_remov
  0122e	2b f1		 sub	 esi, ecx
  01230	75 e6		 jne	 SHORT $LL54@test_remov
  01232	eb 02		 jmp	 SHORT $LN1261@test_remov
$LN50@test_remov:
  01234	33 f6		 xor	 esi, esi
$LN1261@test_remov:

; 1886 : 		if (!obj)
; 1887 : 			abort();

  01236	e8 00 00 00 00	 call	 _abort
  0123b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN44@test_remov:

; 1888 : 		HASH_DEL(uthash, obj);  

  01241	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01244	85 d2		 test	 edx, edx
  01246	75 2a		 jne	 SHORT $LN41@test_remov
  01248	39 56 08	 cmp	 DWORD PTR [esi+8], edx
  0124b	75 25		 jne	 SHORT $LN41@test_remov
  0124d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0124f	8b 08		 mov	 ecx, DWORD PTR [eax]
  01251	51		 push	 ecx
  01252	e8 00 00 00 00	 call	 _free
  01257	8b 13		 mov	 edx, DWORD PTR [ebx]
  01259	83 c4 04	 add	 esp, 4
  0125c	52		 push	 edx
  0125d	e8 00 00 00 00	 call	 _free
  01262	83 c4 04	 add	 esp, 4
  01265	33 db		 xor	 ebx, ebx
  01267	89 1d 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, ebx ; uthash
  0126d	e9 8f 00 00 00	 jmp	 $LN43@test_remov
$LN41@test_remov:
  01272	8b 03		 mov	 eax, DWORD PTR [ebx]
  01274	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01277	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  0127a	2b f9		 sub	 edi, ecx
  0127c	3b f7		 cmp	 esi, edi
  0127e	75 05		 jne	 SHORT $LN39@test_remov
  01280	03 d1		 add	 edx, ecx
  01282	89 50 10	 mov	 DWORD PTR [eax+16], edx
$LN39@test_remov:
  01285	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01288	85 c0		 test	 eax, eax
  0128a	74 0e		 je	 SHORT $LN36@test_remov
  0128c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0128e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01291	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01294	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  01298	eb 09		 jmp	 SHORT $LN34@test_remov
$LN36@test_remov:
  0129a	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0129d	89 1d 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, ebx ; uthash
$LN34@test_remov:
  012a3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  012a6	85 c0		 test	 eax, eax
  012a8	74 0c		 je	 SHORT $LN32@test_remov
  012aa	8b 13		 mov	 edx, DWORD PTR [ebx]
  012ac	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  012af	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  012b2	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
$LN32@test_remov:
  012b6	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  012b8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  012bb	8b 09		 mov	 ecx, DWORD PTR [ecx]
  012bd	48		 dec	 eax
  012be	23 46 1c	 and	 eax, DWORD PTR [esi+28]
  012c1	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  012c4	03 c0		 add	 eax, eax
  012c6	03 c0		 add	 eax, eax
  012c8	ff 4c 01 04	 dec	 DWORD PTR [ecx+eax+4]
  012cc	8b 13		 mov	 edx, DWORD PTR [ebx]
  012ce	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  012d2	8b 0a		 mov	 ecx, DWORD PTR [edx]
  012d4	39 34 08	 cmp	 DWORD PTR [eax+ecx], esi
  012d7	75 06		 jne	 SHORT $LN29@test_remov
  012d9	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  012dc	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
$LN29@test_remov:
  012df	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  012e2	85 c0		 test	 eax, eax
  012e4	74 06		 je	 SHORT $LN28@test_remov
  012e6	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  012e9	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN28@test_remov:
  012ec	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  012ef	85 c0		 test	 eax, eax
  012f1	74 06		 je	 SHORT $LN27@test_remov
  012f3	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  012f6	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN27@test_remov:
  012f9	8b 03		 mov	 eax, DWORD PTR [ebx]
  012fb	ff 48 0c	 dec	 DWORD PTR [eax+12]
  012fe	8b 7d f8	 mov	 edi, DWORD PTR _i$[ebp]
$LN43@test_remov:

; 1889 : 		if (dereference) {
; 1890 : 			if (obj->value != key)

  01301	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  01304	3b 45 f0	 cmp	 eax, DWORD PTR _key$150273[ebp]
  01307	74 0b		 je	 SHORT $LN93@test_remov

; 1891 : 				abort();

  01309	e8 00 00 00 00	 call	 _abort
  0130e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN93@test_remov:

; 1880 : #endif
; 1881 : 
; 1882 : 	START(DATA_UTHASH) {

  01314	47		 inc	 edi
  01315	89 7d f8	 mov	 DWORD PTR _i$[ebp], edi
  01318	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  0131e	0f 82 30 fe ff
	ff		 jb	 $LL94@test_remov
$LN92@test_remov:

; 1892 : 		}
; 1893 : 	} STOP();

  01324	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1894 : 
; 1895 : #ifdef USE_JUDY
; 1896 : 	START(DATA_JUDY) {

  01329	b8 09 00 00 00	 mov	 eax, 9
  0132e	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01333	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  01339	0f 85 1e 01 00
	00		 jne	 $LN21@test_remov
  0133f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01346	75 30		 jne	 SHORT $LN1156@test_remov
  01348	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+36
  0134e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01354	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  0135b	51		 push	 ecx
  0135c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  01362	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  01369	50		 push	 eax
  0136a	52		 push	 edx
  0136b	68 00 00 00 00	 push	 OFFSET $SG-100
  01370	e8 00 00 00 00	 call	 _printf
  01375	83 c4 10	 add	 esp, 16			; 00000010H
$LN1156@test_remov:
  01378	8d 45 cc	 lea	 eax, DWORD PTR _t$209878[ebp]
  0137b	50		 push	 eax
  0137c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01382	85 c0		 test	 eax, eax
  01384	75 11		 jne	 SHORT $LN1162@test_remov
  01386	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0138a	66 0f 13 45 cc	 movlpd	 QWORD PTR $T209870[ebp], xmm0
  0138f	8b 5d d0	 mov	 ebx, DWORD PTR $T209870[ebp+4]
  01392	8b 75 cc	 mov	 esi, DWORD PTR $T209870[ebp]
  01395	eb 54		 jmp	 SHORT $LN1163@test_remov
$LN1162@test_remov:
  01397	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0139d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  013a3	8b 4d d0	 mov	 ecx, DWORD PTR _t$209878[ebp+4]
  013a6	8b 55 cc	 mov	 edx, DWORD PTR _t$209878[ebp]
  013a9	56		 push	 esi
  013aa	57		 push	 edi
  013ab	51		 push	 ecx
  013ac	52		 push	 edx
  013ad	e8 00 00 00 00	 call	 __alldvrm
  013b2	6a 00		 push	 0
  013b4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013b9	53		 push	 ebx
  013ba	51		 push	 ecx
  013bb	89 45 dc	 mov	 DWORD PTR tv3441[ebp], eax
  013be	89 55 e0	 mov	 DWORD PTR tv3441[ebp+4], edx
  013c1	e8 00 00 00 00	 call	 __allmul
  013c6	56		 push	 esi
  013c7	57		 push	 edi
  013c8	52		 push	 edx
  013c9	50		 push	 eax
  013ca	e8 00 00 00 00	 call	 __alldiv
  013cf	8b 4d dc	 mov	 ecx, DWORD PTR tv3441[ebp]
  013d2	6a 00		 push	 0
  013d4	8b f0		 mov	 esi, eax
  013d6	8b 45 e0	 mov	 eax, DWORD PTR tv3441[ebp+4]
  013d9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013de	50		 push	 eax
  013df	51		 push	 ecx
  013e0	8b da		 mov	 ebx, edx
  013e2	e8 00 00 00 00	 call	 __allmul
  013e7	03 f0		 add	 esi, eax
  013e9	13 da		 adc	 ebx, edx
$LN1163@test_remov:
  013eb	33 ff		 xor	 edi, edi
  013ed	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  013f3	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  013f9	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  013ff	76 5c		 jbe	 SHORT $LN21@test_remov
$LL23@test_remov:

; 1897 : 		Word_t key = REMOVE[i] + DELTA;

  01401	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  01404	8b 34 ba	 mov	 esi, DWORD PTR [edx+edi*4]

; 1898 : 		struct judy_object* obj;
; 1899 : 		int r;
; 1900 : 		if (dereference) {
; 1901 : 			Pvoid_t PValue;
; 1902 : 			JLG(PValue, judy, key);

  01407	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judy@@3PAXA ; judy
  0140c	6a 00		 push	 0
  0140e	46		 inc	 esi
  0140f	56		 push	 esi
  01410	50		 push	 eax
  01411	e8 00 00 00 00	 call	 _JudyLGet
  01416	8b d8		 mov	 ebx, eax
  01418	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1903 : 			if (!PValue)

  0141b	85 db		 test	 ebx, ebx
  0141d	75 05		 jne	 SHORT $LN19@test_remov

; 1904 : 				abort();

  0141f	e8 00 00 00 00	 call	 _abort
$LN19@test_remov:

; 1905 : 			obj = *(struct judy_object**)PValue;

  01424	8b 1b		 mov	 ebx, DWORD PTR [ebx]

; 1906 : 		}
; 1907 : 		JLD(r, judy, key);

  01426	8d 4d ac	 lea	 ecx, DWORD PTR _J_Error$150406[ebp]
  01429	51		 push	 ecx
  0142a	56		 push	 esi
  0142b	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  01430	e8 00 00 00 00	 call	 _JudyLDel
  01435	83 c4 0c	 add	 esp, 12			; 0000000cH
  01438	83 f8 ff	 cmp	 eax, -1
  0143b	0f 84 92 00 00
	00		 je	 $LN1235@test_remov

; 1908 : 		if (r != 1)

  01441	83 f8 01	 cmp	 eax, 1
  01444	74 05		 je	 SHORT $LN17@test_remov

; 1909 : 			abort();

  01446	e8 00 00 00 00	 call	 _abort
$LN17@test_remov:

; 1910 : 		if (dereference) {
; 1911 : 			if (obj->value != key)

  0144b	39 33		 cmp	 DWORD PTR [ebx], esi
  0144d	74 05		 je	 SHORT $LN22@test_remov

; 1912 : 				abort();

  0144f	e8 00 00 00 00	 call	 _abort
$LN22@test_remov:

; 1894 : 
; 1895 : #ifdef USE_JUDY
; 1896 : 	START(DATA_JUDY) {

  01454	47		 inc	 edi
  01455	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  0145b	72 a4		 jb	 SHORT $LL23@test_remov
$LN21@test_remov:

; 1913 : 		}
; 1914 : 	} STOP();

  0145d	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1915 : #endif
; 1916 : 
; 1917 : #ifdef USE_JUDYARRAY
; 1918 : 	START(DATA_JUDYARRAY) {

  01462	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  01467	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0146c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  01472	0f 85 36 01 00
	00		 jne	 $LN11@test_remov
  01478	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0147f	75 30		 jne	 SHORT $LN1165@test_remov
  01481	8b 0d 28 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+40
  01487	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0148d	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  01494	51		 push	 ecx
  01495	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  0149b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  014a2	50		 push	 eax
  014a3	52		 push	 edx
  014a4	68 00 00 00 00	 push	 OFFSET $SG-100
  014a9	e8 00 00 00 00	 call	 _printf
  014ae	83 c4 10	 add	 esp, 16			; 00000010H
$LN1165@test_remov:
  014b1	8d 45 d4	 lea	 eax, DWORD PTR _t$209902[ebp]
  014b4	50		 push	 eax
  014b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  014bb	85 c0		 test	 eax, eax
  014bd	75 48		 jne	 SHORT $LN1171@test_remov
  014bf	66 0f 57 c0	 xorpd	 xmm0, xmm0
  014c3	66 0f 13 45 cc	 movlpd	 QWORD PTR $T209893[ebp], xmm0
  014c8	8b 5d d0	 mov	 ebx, DWORD PTR $T209893[ebp+4]
  014cb	8b 75 cc	 mov	 esi, DWORD PTR $T209893[ebp]
  014ce	e9 88 00 00 00	 jmp	 $LN1172@test_remov
$LN1235@test_remov:

; 1906 : 		}
; 1907 : 		JLD(r, judy, key);

  014d3	8b 55 b0	 mov	 edx, DWORD PTR _J_Error$150406[ebp+4]
  014d6	8b 45 ac	 mov	 eax, DWORD PTR _J_Error$150406[ebp]
  014d9	52		 push	 edx
  014da	50		 push	 eax
  014db	68 00 00 00 00	 push	 OFFSET $SG-114
  014e0	68 73 07 00 00	 push	 1907			; 00000773H
  014e5	68 00 00 00 00	 push	 OFFSET $SG-115
  014ea	68 00 00 00 00	 push	 OFFSET $SG-116
  014ef	e8 00 00 00 00	 call	 ___iob_func
  014f4	83 c0 40	 add	 eax, 64			; 00000040H
  014f7	50		 push	 eax
  014f8	e8 00 00 00 00	 call	 _fprintf
  014fd	83 c4 1c	 add	 esp, 28			; 0000001cH
  01500	6a 01		 push	 1
  01502	e8 00 00 00 00	 call	 _exit
$LN1326@test_remov:

; 1915 : #endif
; 1916 : 
; 1917 : #ifdef USE_JUDYARRAY
; 1918 : 	START(DATA_JUDYARRAY) {

$LN1171@test_remov:
  01507	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0150d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01513	8b 4d d8	 mov	 ecx, DWORD PTR _t$209902[ebp+4]
  01516	8b 55 d4	 mov	 edx, DWORD PTR _t$209902[ebp]
  01519	56		 push	 esi
  0151a	57		 push	 edi
  0151b	51		 push	 ecx
  0151c	52		 push	 edx
  0151d	e8 00 00 00 00	 call	 __alldvrm
  01522	6a 00		 push	 0
  01524	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01529	53		 push	 ebx
  0152a	51		 push	 ecx
  0152b	89 45 dc	 mov	 DWORD PTR tv3437[ebp], eax
  0152e	89 55 e0	 mov	 DWORD PTR tv3437[ebp+4], edx
  01531	e8 00 00 00 00	 call	 __allmul
  01536	56		 push	 esi
  01537	57		 push	 edi
  01538	52		 push	 edx
  01539	50		 push	 eax
  0153a	e8 00 00 00 00	 call	 __alldiv
  0153f	8b 4d dc	 mov	 ecx, DWORD PTR tv3437[ebp]
  01542	6a 00		 push	 0
  01544	8b f0		 mov	 esi, eax
  01546	8b 45 e0	 mov	 eax, DWORD PTR tv3437[ebp+4]
  01549	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0154e	50		 push	 eax
  0154f	51		 push	 ecx
  01550	8b da		 mov	 ebx, edx
  01552	e8 00 00 00 00	 call	 __allmul
  01557	03 f0		 add	 esi, eax
  01559	13 da		 adc	 ebx, edx
$LN1172@test_remov:
  0155b	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01561	33 db		 xor	 ebx, ebx
  01563	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01569	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  0156f	76 3d		 jbe	 SHORT $LN11@test_remov
  01571	8b 7d 08	 mov	 edi, DWORD PTR _REMOVE$[ebp]
$LL13@test_remov:

; 1919 : 		judyvalue key = REMOVE[i] + DELTA;

  01574	8b 14 9f	 mov	 edx, DWORD PTR [edi+ebx*4]

; 1920 : 		struct judyarray_object* obj;
; 1921 : 		JudySlot* pvalue;
; 1922 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  01577	8d 45 f0	 lea	 eax, DWORD PTR _key$150419[ebp]
  0157a	42		 inc	 edx
  0157b	50		 push	 eax
  0157c	89 55 f0	 mov	 DWORD PTR _key$150419[ebp], edx
  0157f	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  01584	8b f0		 mov	 esi, eax
  01586	83 c4 04	 add	 esp, 4

; 1923 : 		if (!pvalue)

  01589	85 f6		 test	 esi, esi
  0158b	75 05		 jne	 SHORT $LN10@test_remov

; 1924 : 			abort();

  0158d	e8 00 00 00 00	 call	 _abort
$LN10@test_remov:

; 1925 : 		obj = *(struct judyarray_object**)pvalue;

  01592	8b 36		 mov	 esi, DWORD PTR [esi]

; 1926 : 		judy_del(judyarray);

  01594	e8 00 00 00 00	 call	 ?judy_del@@YAPAIPAUJudy@@@Z ; judy_del

; 1927 : 		if (dereference) {
; 1928 : 			if (obj->value != key)

  01599	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0159b	3b 4d f0	 cmp	 ecx, DWORD PTR _key$150419[ebp]
  0159e	74 05		 je	 SHORT $LN12@test_remov

; 1929 : 				abort();

  015a0	e8 00 00 00 00	 call	 _abort
$LN12@test_remov:

; 1915 : #endif
; 1916 : 
; 1917 : #ifdef USE_JUDYARRAY
; 1918 : 	START(DATA_JUDYARRAY) {

  015a5	43		 inc	 ebx
  015a6	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  015ac	72 c6		 jb	 SHORT $LL13@test_remov
$LN11@test_remov:

; 1930 : 		}
; 1931 : 	} STOP();

  015ae	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1932 : #endif
; 1933 : 
; 1934 : 	START(DATA_NEDTRIE) {

  015b3	b8 06 00 00 00	 mov	 eax, 6
  015b8	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  015bd	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  015c3	0f 85 50 01 00
	00		 jne	 $LN4@test_remov
  015c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  015d0	75 2f		 jne	 SHORT $LN1174@test_remov
  015d2	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+24
  015d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  015dd	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  015e4	52		 push	 edx
  015e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  015eb	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  015f2	51		 push	 ecx
  015f3	50		 push	 eax
  015f4	68 00 00 00 00	 push	 OFFSET $SG-100
  015f9	e8 00 00 00 00	 call	 _printf
  015fe	83 c4 10	 add	 esp, 16			; 00000010H
$LN1174@test_remov:
  01601	8d 4d cc	 lea	 ecx, DWORD PTR _t$209925[ebp]
  01604	51		 push	 ecx
  01605	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0160b	85 c0		 test	 eax, eax
  0160d	75 11		 jne	 SHORT $LN1180@test_remov
  0160f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01613	66 0f 13 45 cc	 movlpd	 QWORD PTR $T209916[ebp], xmm0
  01618	8b 5d d0	 mov	 ebx, DWORD PTR $T209916[ebp+4]
  0161b	8b 75 cc	 mov	 esi, DWORD PTR $T209916[ebp]
  0161e	eb 54		 jmp	 SHORT $LN1181@test_remov
$LN1180@test_remov:
  01620	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01626	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0162c	8b 55 d0	 mov	 edx, DWORD PTR _t$209925[ebp+4]
  0162f	8b 45 cc	 mov	 eax, DWORD PTR _t$209925[ebp]
  01632	56		 push	 esi
  01633	57		 push	 edi
  01634	52		 push	 edx
  01635	50		 push	 eax
  01636	e8 00 00 00 00	 call	 __alldvrm
  0163b	6a 00		 push	 0
  0163d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01642	53		 push	 ebx
  01643	51		 push	 ecx
  01644	89 45 dc	 mov	 DWORD PTR tv3433[ebp], eax
  01647	89 55 e0	 mov	 DWORD PTR tv3433[ebp+4], edx
  0164a	e8 00 00 00 00	 call	 __allmul
  0164f	56		 push	 esi
  01650	57		 push	 edi
  01651	52		 push	 edx
  01652	50		 push	 eax
  01653	e8 00 00 00 00	 call	 __alldiv
  01658	8b 4d e0	 mov	 ecx, DWORD PTR tv3433[ebp+4]
  0165b	6a 00		 push	 0
  0165d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01662	8b da		 mov	 ebx, edx
  01664	8b 55 dc	 mov	 edx, DWORD PTR tv3433[ebp]
  01667	51		 push	 ecx
  01668	52		 push	 edx
  01669	8b f0		 mov	 esi, eax
  0166b	e8 00 00 00 00	 call	 __allmul
  01670	03 f0		 add	 esi, eax
  01672	13 da		 adc	 ebx, edx
$LN1181@test_remov:
  01674	33 ff		 xor	 edi, edi
  01676	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  0167c	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01682	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01688	0f 86 8b 00 00
	00		 jbe	 $LN4@test_remov
$LN6@test_remov:

; 1935 : 		unsigned key = REMOVE[i] + DELTA;

  0168e	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01691	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  01694	46		 inc	 esi

; 1936 : 		struct nedtrie_object key_obj;
; 1937 : 		struct nedtrie_object* obj;
; 1938 : 		key_obj.value = key;
; 1939 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  01695	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, 0
  0169c	75 04		 jne	 SHORT $LN1190@test_remov
$LN1237@test_remov:
  0169e	33 db		 xor	 ebx, ebx
  016a0	eb 54		 jmp	 SHORT $LN1286@test_remov
$LN1190@test_remov:
  016a2	8b ce		 mov	 ecx, esi
  016a4	83 c9 01	 or	 ecx, 1
  016a7	0f bd d1	 bsr	 edx, ecx
  016aa	8b ca		 mov	 ecx, edx
  016ac	8b 04 8d 04 00
	00 00		 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  016b3	89 55 e0	 mov	 DWORD PTR _bitpos$209949[ebp], edx
  016b6	85 c0		 test	 eax, eax
  016b8	75 04		 jne	 SHORT $LN1189@test_remov
  016ba	33 db		 xor	 ebx, ebx
  016bc	eb 38		 jmp	 SHORT $LN1286@test_remov
$LN1189@test_remov:
  016be	ba 01 00 00 00	 mov	 edx, 1
  016c3	d3 e2		 shl	 edx, cl
  016c5	39 70 14	 cmp	 DWORD PTR [eax+20], esi
  016c8	74 1f		 je	 SHORT $end$209966
  016ca	8d 9b 00 00 00
	00		 npad	 6
$LL1188@test_remov:
  016d0	d1 ea		 shr	 edx, 1
  016d2	8b ce		 mov	 ecx, esi
  016d4	23 ca		 and	 ecx, edx
  016d6	f7 d9		 neg	 ecx
  016d8	1b c9		 sbb	 ecx, ecx
  016da	f7 d9		 neg	 ecx
  016dc	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  016e0	85 c0		 test	 eax, eax
  016e2	74 ba		 je	 SHORT $LN1237@test_remov
  016e4	39 70 14	 cmp	 DWORD PTR [eax+20], esi
  016e7	75 e7		 jne	 SHORT $LL1188@test_remov
$end$209966:
  016e9	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  016ec	85 db		 test	 ebx, ebx
  016ee	75 0b		 jne	 SHORT $LN3@test_remov
  016f0	8b d8		 mov	 ebx, eax

; 1940 : 		if (!obj)

  016f2	85 db		 test	 ebx, ebx
  016f4	75 05		 jne	 SHORT $LN3@test_remov
$LN1286@test_remov:

; 1941 : 			abort();

  016f6	e8 00 00 00 00	 call	 _abort
$LN3@test_remov:

; 1942 : 		NEDTRIE_REMOVE(nedtrie_t, &nedtrie, obj);

  016fb	8b d3		 mov	 edx, ebx
  016fd	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_REMOVE

; 1943 : 		if (dereference) {
; 1944 : 			if (obj->value != key)

  01702	39 73 14	 cmp	 DWORD PTR [ebx+20], esi
  01705	74 05		 je	 SHORT $LN5@test_remov

; 1945 : 				abort();

  01707	e8 00 00 00 00	 call	 _abort
$LN5@test_remov:

; 1932 : #endif
; 1933 : 
; 1934 : 	START(DATA_NEDTRIE) {

  0170c	47		 inc	 edi
  0170d	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  01713	0f 82 75 ff ff
	ff		 jb	 $LN6@test_remov
$LN4@test_remov:

; 1946 : 		}
; 1947 : 	} STOP();

  01719	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1948 : }

  0171e	5f		 pop	 edi
  0171f	5e		 pop	 esi
  01720	5b		 pop	 ebx
  01721	8b e5		 mov	 esp, ebp
  01723	5d		 pop	 ebp
  01724	c3		 ret	 0
$LN1322@test_remov:
?test_remove@@YAXPAI@Z ENDP				; test_remove
_TEXT	ENDS
PUBLIC	?test_change@@YAXPAI0@Z				; test_change
; Function compile flags: /Ogtp
;	COMDAT ?test_change@@YAXPAI0@Z
_TEXT	SEGMENT
$T216124 = -160						; size = 12
$T215844 = -148						; size = 12
$T215852 = -136						; size = 12
_key_obj$150131 = -124					; size = 40
_J_Error$150105 = -108					; size = 24
_J_Error$150098 = -108					; size = 24
$T216237 = -100						; size = 16
$T216603 = -84						; size = 12
$T215889 = -84						; size = 12
_pos$216098 = -72					; size = 8
_pos$211789 = -64					; size = 8
$T210101 = -64						; size = 8
_t$210614 = -56						; size = 8
_pos$216229 = -48					; size = 8
_ptr$149780 = -48					; size = 8
_t$210578 = -40						; size = 8
$T213330 = -36						; size = 4
$T210107 = -36						; size = 4
$T210104 = -36						; size = 4
__he_bkt_i$150064 = -32					; size = 4
_key$149863 = -32					; size = 4
_obj$149756 = -32					; size = 4
$T215836 = -28						; size = 4
_count$210440 = -28					; size = 4
__he_new_buckets$150067 = -28				; size = 4
_r$149745 = -28						; size = 4
_key$149717 = -28					; size = 4
_key$149708 = -28					; size = 4
tv7597 = -24						; size = 4
tv7454 = -24						; size = 4
tv7403 = -24						; size = 4
_key$149779 = -24					; size = 4
tv7146 = -20						; size = 4
tv4236 = -16						; size = 8
tv4175 = -16						; size = 8
tv2811 = -16						; size = 8
$T210607 = -16						; size = 8
$T210571 = -16						; size = 8
$T210503 = -16						; size = 8
_t$210510 = -16						; size = 8
$T210470 = -16						; size = 8
_t$210477 = -16						; size = 8
$T210336 = -16						; size = 8
_t$210343 = -16						; size = 8
$T210261 = -16						; size = 8
_t$210268 = -16						; size = 8
tv597 = -16						; size = 8
tv546 = -16						; size = 8
tv369 = -16						; size = 8
$T214524 = -12						; size = 4
__he_hh_nxt$150066 = -12				; size = 4
_ptr$149836 = -12					; size = 4
_ptr$149808 = -12					; size = 4
_i$ = -8						; size = 4
tv7627 = -4						; size = 4
tv7494 = -4						; size = 4
tv7361 = -4						; size = 4
tv7253 = -4						; size = 4
_count$210433 = -4					; size = 4
_key$150118 = -4					; size = 4
_key$149835 = -4					; size = 4
_key$149807 = -4					; size = 4
_key$149753 = -4					; size = 4
_obj$149746 = -4					; size = 4
_REMOVE$ = 8						; size = 4
_INSERT$ = 12						; size = 4
?test_change@@YAXPAI0@Z PROC				; test_change, COMDAT

; 1426 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	53		 push	 ebx

; 1427 : 	unsigned i;
; 1428 : 
; 1429 : 	const unsigned DELTA = 1;
; 1430 : 
; 1431 : 	START(DATA_TREE) {

  0000a	b8 05 00 00 00	 mov	 eax, 5
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0001c	0f 85 c6 00 00
	00		 jne	 $LN194@test_chang
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00029	75 2e		 jne	 SHORT $LN206@test_chang
  0002b	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00036	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003d	50		 push	 eax
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00043	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0004a	52		 push	 edx
  0004b	51		 push	 ecx
  0004c	68 00 00 00 00	 push	 OFFSET $SG-100
  00051	e8 00 00 00 00	 call	 _printf
  00056	83 c4 10	 add	 esp, 16			; 00000010H
$LN206@test_chang:
  00059	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005e	33 db		 xor	 ebx, ebx
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00065	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  0006b	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  00071	76 75		 jbe	 SHORT $LN194@test_chang
  00073	8b 75 0c	 mov	 esi, DWORD PTR _INSERT$[ebp]
  00076	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00079	2b c6		 sub	 eax, esi
  0007b	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  0007e	8b ff		 npad	 2
$LL196@test_chang:

; 1432 : 		unsigned key = REMOVE[i];
; 1433 : 		struct rbt_object key_obj;
; 1434 : 		struct rbt_object* obj;
; 1435 : 		key_obj.value = REMOVE[i];
; 1436 : 		obj = rbt_search(&tree, &key_obj); 

  00080	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?tree@@3Urbtree_t@@A
  00086	8b 55 ec	 mov	 edx, DWORD PTR tv7146[ebp]
  00089	8b 0c 32	 mov	 ecx, DWORD PTR [edx+esi]
  0008c	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  00092	74 27		 je	 SHORT $LN1368@test_chang
$LL216@test_chang:
  00094	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00097	3b c8		 cmp	 ecx, eax
  00099	7c 14		 jl	 SHORT $LN1371@test_chang
  0009b	7e 16		 jle	 SHORT $LN215@test_chang
  0009d	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  000a0	83 e7 fe	 and	 edi, -2			; fffffffeH
$LN213@test_chang:
  000a3	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  000a9	75 e9		 jne	 SHORT $LL216@test_chang
  000ab	33 ff		 xor	 edi, edi

; 1437 : 		if (!obj)

  000ad	eb 14		 jmp	 SHORT $LN1389@test_chang
$LN1371@test_chang:

; 1432 : 		unsigned key = REMOVE[i];
; 1433 : 		struct rbt_object key_obj;
; 1434 : 		struct rbt_object* obj;
; 1435 : 		key_obj.value = REMOVE[i];
; 1436 : 		obj = rbt_search(&tree, &key_obj); 

  000af	8b 3f		 mov	 edi, DWORD PTR [edi]
  000b1	eb f0		 jmp	 SHORT $LN213@test_chang
$LN215@test_chang:
  000b3	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  000b9	75 04		 jne	 SHORT $LN212@test_chang
$LN1368@test_chang:
  000bb	33 ff		 xor	 edi, edi

; 1437 : 		if (!obj)

  000bd	eb 04		 jmp	 SHORT $LN1389@test_chang

; 1432 : 		unsigned key = REMOVE[i];
; 1433 : 		struct rbt_object key_obj;
; 1434 : 		struct rbt_object* obj;
; 1435 : 		key_obj.value = REMOVE[i];
; 1436 : 		obj = rbt_search(&tree, &key_obj); 

$LN212@test_chang:

; 1437 : 		if (!obj)

  000bf	85 ff		 test	 edi, edi
  000c1	75 05		 jne	 SHORT $LN193@test_chang
$LN1389@test_chang:

; 1438 : 			abort();

  000c3	e8 00 00 00 00	 call	 _abort
$LN193@test_chang:

; 1439 : 		rbt_remove(&tree, obj);

  000c8	8b d7		 mov	 edx, edi
  000ca	e8 00 00 00 00	 call	 ?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_remove

; 1440 : 
; 1441 : 		key = INSERT[i] + DELTA;  

  000cf	8b 06		 mov	 eax, DWORD PTR [esi]
  000d1	40		 inc	 eax

; 1442 : 		obj->value = key;

  000d2	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1443 : 		rbt_insert(&tree, obj);

  000d5	8b c7		 mov	 eax, edi
  000d7	e8 00 00 00 00	 call	 ?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_insert
  000dc	43		 inc	 ebx
  000dd	83 c6 04	 add	 esi, 4
  000e0	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  000e6	72 98		 jb	 SHORT $LL196@test_chang
$LN194@test_chang:

; 1444 : 	} STOP();

  000e8	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1445 : 
; 1446 : 	START(DATA_HASHTABLE) {

  000ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_data@@3IA, 0 ; the_data
  000f4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 0 ; the_start_data
  000fe	0f 85 a8 01 00
	00		 jne	 $LN189@test_chang
  00104	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0010b	75 30		 jne	 SHORT $LN223@test_chang
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA
  00113	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00119	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00120	51		 push	 ecx
  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00127	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0012e	50		 push	 eax
  0012f	52		 push	 edx
  00130	68 00 00 00 00	 push	 OFFSET $SG-100
  00135	e8 00 00 00 00	 call	 _printf
  0013a	83 c4 10	 add	 esp, 16			; 00000010H
$LN223@test_chang:
  0013d	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00142	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00149	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0014e	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00154	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0015b	0f 86 4b 01 00
	00		 jbe	 $LN189@test_chang
  00161	8b 5d 0c	 mov	 ebx, DWORD PTR _INSERT$[ebp]
  00164	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00167	2b c3		 sub	 eax, ebx
  00169	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  0016c	eb 05		 jmp	 SHORT $LN191@test_chang
  0016e	8b ff		 npad	 2
$LL1427@test_chang:
  00170	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN191@test_chang:

; 1447 : 		unsigned key = REMOVE[i];

  00173	8b 14 18	 mov	 edx, DWORD PTR [eax+ebx]

; 1448 : 		unsigned hash_key = hash(key);

  00176	8b ca		 mov	 ecx, edx
  00178	c1 e1 06	 shl	 ecx, 6
  0017b	8b c2		 mov	 eax, edx
  0017d	2b c1		 sub	 eax, ecx
  0017f	8b c8		 mov	 ecx, eax
  00181	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00184	33 c1		 xor	 eax, ecx
  00186	8b c8		 mov	 ecx, eax
  00188	c1 e1 09	 shl	 ecx, 9
  0018b	2b c1		 sub	 eax, ecx

; 1449 : 		struct hashtable_object* obj;
; 1450 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  0018d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00193	8b c8		 mov	 ecx, eax
  00195	c1 e1 04	 shl	 ecx, 4
  00198	33 c1		 xor	 eax, ecx
  0019a	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  001a1	2b c1		 sub	 eax, ecx
  001a3	8b c8		 mov	 ecx, eax
  001a5	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  001a8	33 c1		 xor	 eax, ecx
  001aa	8b c8		 mov	 ecx, eax
  001ac	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  001af	33 c8		 xor	 ecx, eax
  001b1	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  001b6	23 c1		 and	 eax, ecx
  001b8	8d 3c 86	 lea	 edi, DWORD PTR [esi+eax*4]
  001bb	8b 07		 mov	 eax, DWORD PTR [edi]
  001bd	85 c0		 test	 eax, eax
  001bf	74 13		 je	 SHORT $LN232@test_chang
$LL233@test_chang:
  001c1	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  001c4	75 08		 jne	 SHORT $LN231@test_chang
  001c6	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  001c9	3b 56 10	 cmp	 edx, DWORD PTR [esi+16]
  001cc	74 0a		 je	 SHORT $LN1325@test_chang
$LN231@test_chang:
  001ce	8b 00		 mov	 eax, DWORD PTR [eax]
  001d0	85 c0		 test	 eax, eax
  001d2	75 ed		 jne	 SHORT $LL233@test_chang
$LN232@test_chang:
  001d4	33 ff		 xor	 edi, edi

; 1451 : 		if (!obj)

  001d6	eb 3b		 jmp	 SHORT $LN1373@test_chang
$LN1325@test_chang:

; 1449 : 		struct hashtable_object* obj;
; 1450 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  001d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001da	8b 17		 mov	 edx, DWORD PTR [edi]
  001dc	85 c9		 test	 ecx, ecx
  001de	74 08		 je	 SHORT $LN242@test_chang
  001e0	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001e3	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  001e6	eb 06		 jmp	 SHORT $LN241@test_chang
$LN242@test_chang:
  001e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001eb	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN241@test_chang:
  001ee	3b d0		 cmp	 edx, eax
  001f0	8b 10		 mov	 edx, DWORD PTR [eax]
  001f2	75 0d		 jne	 SHORT $LN240@test_chang
  001f4	89 17		 mov	 DWORD PTR [edi], edx
  001f6	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  001fc	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  001ff	eb 0e		 jmp	 SHORT $LN234@test_chang
$LN240@test_chang:
  00201	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00204	89 11		 mov	 DWORD PTR [ecx], edx
  00206	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  0020c	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
$LN234@test_chang:

; 1451 : 		if (!obj)

  0020f	85 ff		 test	 edi, edi
  00211	75 05		 jne	 SHORT $LN188@test_chang
$LN1373@test_chang:

; 1452 : 			abort();

  00213	e8 00 00 00 00	 call	 _abort
$LN188@test_chang:

; 1453 : 
; 1454 : 		key = INSERT[i] + DELTA;

  00218	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0021a	41		 inc	 ecx

; 1455 : 		hash_key = hash(key);

  0021b	8b d1		 mov	 edx, ecx
  0021d	c1 e2 06	 shl	 edx, 6
  00220	8b c1		 mov	 eax, ecx
  00222	2b c2		 sub	 eax, edx
  00224	8b d0		 mov	 edx, eax
  00226	c1 ea 11	 shr	 edx, 17			; 00000011H
  00229	33 c2		 xor	 eax, edx
  0022b	8b d0		 mov	 edx, eax
  0022d	c1 e2 09	 shl	 edx, 9
  00230	2b c2		 sub	 eax, edx
  00232	8b d0		 mov	 edx, eax
  00234	c1 e2 04	 shl	 edx, 4
  00237	33 c2		 xor	 eax, edx
  00239	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00240	2b c2		 sub	 eax, edx
  00242	8b d0		 mov	 edx, eax
  00244	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00247	33 c2		 xor	 eax, edx
  00249	8b d0		 mov	 edx, eax
  0024b	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0024e	33 d0		 xor	 edx, eax

; 1456 : 		obj->value = key;

  00250	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 1457 : 		tommy_hashtable_insert(&hashtable, &obj->node, obj, hash_key);

  00253	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0025e	23 c2		 and	 eax, edx
  00260	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00263	8b 01		 mov	 eax, DWORD PTR [ecx]
  00265	85 c0		 test	 eax, eax
  00267	74 16		 je	 SHORT $LN252@test_chang
  00269	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026c	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0026f	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00272	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00275	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0027b	89 38		 mov	 DWORD PTR [eax], edi
  0027d	eb 0b		 jmp	 SHORT $LN259@test_chang
$LN252@test_chang:
  0027f	89 7f 04	 mov	 DWORD PTR [edi+4], edi
  00282	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00288	89 39		 mov	 DWORD PTR [ecx], edi
$LN259@test_chang:

; 1445 : 
; 1446 : 	START(DATA_HASHTABLE) {

  0028a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0028d	40		 inc	 eax

; 1457 : 		tommy_hashtable_insert(&hashtable, &obj->node, obj, hash_key);

  0028e	89 7f 08	 mov	 DWORD PTR [edi+8], edi
  00291	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  00294	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  0029a	83 c3 04	 add	 ebx, 4
  0029d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  002a0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  002a6	0f 82 c4 fe ff
	ff		 jb	 $LL1427@test_chang
$LN189@test_chang:

; 1458 : 	} STOP();

  002ac	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1459 : 
; 1460 : 	START(DATA_HASHDYN) {

  002b1	b8 01 00 00 00	 mov	 eax, 1
  002b6	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  002bb	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  002c1	0f 85 de 01 00
	00		 jne	 $LN184@test_chang
  002c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  002ce	75 30		 jne	 SHORT $LN261@test_chang
  002d0	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  002d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  002dc	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  002e3	51		 push	 ecx
  002e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  002ea	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  002f1	50		 push	 eax
  002f2	52		 push	 edx
  002f3	68 00 00 00 00	 push	 OFFSET $SG-100
  002f8	e8 00 00 00 00	 call	 _printf
  002fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN261@test_chang:
  00300	8d 45 f0	 lea	 eax, DWORD PTR _t$210268[ebp]
  00303	50		 push	 eax
  00304	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0030a	85 c0		 test	 eax, eax
  0030c	75 11		 jne	 SHORT $LN267@test_chang
  0030e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00312	66 0f 13 45 f0	 movlpd	 QWORD PTR $T210261[ebp], xmm0
  00317	8b 5d f4	 mov	 ebx, DWORD PTR $T210261[ebp+4]
  0031a	8b 7d f0	 mov	 edi, DWORD PTR $T210261[ebp]
  0031d	eb 54		 jmp	 SHORT $LN268@test_chang
$LN267@test_chang:
  0031f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00325	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0032b	8b 4d f4	 mov	 ecx, DWORD PTR _t$210268[ebp+4]
  0032e	8b 55 f0	 mov	 edx, DWORD PTR _t$210268[ebp]
  00331	57		 push	 edi
  00332	56		 push	 esi
  00333	51		 push	 ecx
  00334	52		 push	 edx
  00335	e8 00 00 00 00	 call	 __alldvrm
  0033a	6a 00		 push	 0
  0033c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00341	53		 push	 ebx
  00342	51		 push	 ecx
  00343	89 45 f0	 mov	 DWORD PTR tv2811[ebp], eax
  00346	89 55 f4	 mov	 DWORD PTR tv2811[ebp+4], edx
  00349	e8 00 00 00 00	 call	 __allmul
  0034e	57		 push	 edi
  0034f	56		 push	 esi
  00350	52		 push	 edx
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 __alldiv
  00357	8b 4d f0	 mov	 ecx, DWORD PTR tv2811[ebp]
  0035a	6a 00		 push	 0
  0035c	8b f8		 mov	 edi, eax
  0035e	8b 45 f4	 mov	 eax, DWORD PTR tv2811[ebp+4]
  00361	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00366	50		 push	 eax
  00367	51		 push	 ecx
  00368	8b da		 mov	 ebx, edx
  0036a	e8 00 00 00 00	 call	 __allmul
  0036f	03 f8		 add	 edi, eax
  00371	13 da		 adc	 ebx, edx
$LN268@test_chang:
  00373	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  0037a	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00380	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00386	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0038d	0f 86 12 01 00
	00		 jbe	 $LN184@test_chang
  00393	8b 5d 0c	 mov	 ebx, DWORD PTR _INSERT$[ebp]
  00396	8b 75 08	 mov	 esi, DWORD PTR _REMOVE$[ebp]
  00399	2b f3		 sub	 esi, ebx
  0039b	eb 03 8d 49 00	 npad	 5
$LL186@test_chang:

; 1461 : 		unsigned key = REMOVE[i];

  003a0	8b 0c 1e	 mov	 ecx, DWORD PTR [esi+ebx]

; 1462 : 		unsigned hash_key = hash(key);

  003a3	8b d1		 mov	 edx, ecx
  003a5	89 4d e4	 mov	 DWORD PTR _key$149708[ebp], ecx
  003a8	c1 e2 06	 shl	 edx, 6
  003ab	2b ca		 sub	 ecx, edx
  003ad	8b c1		 mov	 eax, ecx
  003af	c1 e8 11	 shr	 eax, 17			; 00000011H
  003b2	33 c8		 xor	 ecx, eax
  003b4	8b d1		 mov	 edx, ecx
  003b6	c1 e2 09	 shl	 edx, 9
  003b9	2b ca		 sub	 ecx, edx
  003bb	8b c1		 mov	 eax, ecx
  003bd	c1 e0 04	 shl	 eax, 4
  003c0	33 c8		 xor	 ecx, eax
  003c2	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  003c9	2b ca		 sub	 ecx, edx
  003cb	8b c1		 mov	 eax, ecx
  003cd	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  003d0	33 c8		 xor	 ecx, eax
  003d2	8b c1		 mov	 eax, ecx
  003d4	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  003d7	33 c1		 xor	 eax, ecx

; 1463 : 		struct hashtable_object* obj;
; 1464 : 		obj = (struct hashtable_object*)tommy_hashdyn_remove(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  003d9	8d 4d e4	 lea	 ecx, DWORD PTR _key$149708[ebp]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 _tommy_hashdyn_remove
  003e2	8b f8		 mov	 edi, eax
  003e4	83 c4 04	 add	 esp, 4

; 1465 : 		if (!obj)

  003e7	85 ff		 test	 edi, edi
  003e9	75 05		 jne	 SHORT $LN183@test_chang

; 1466 : 			abort();

  003eb	e8 00 00 00 00	 call	 _abort
$LN183@test_chang:

; 1467 : 
; 1468 : 		key = INSERT[i] + DELTA;

  003f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  003f2	41		 inc	 ecx

; 1469 : 		hash_key = hash(key);

  003f3	8b d1		 mov	 edx, ecx
  003f5	c1 e2 06	 shl	 edx, 6
  003f8	8b c1		 mov	 eax, ecx
  003fa	2b c2		 sub	 eax, edx
  003fc	8b d0		 mov	 edx, eax
  003fe	c1 ea 11	 shr	 edx, 17			; 00000011H
  00401	33 c2		 xor	 eax, edx
  00403	8b d0		 mov	 edx, eax
  00405	c1 e2 09	 shl	 edx, 9
  00408	2b c2		 sub	 eax, edx
  0040a	8b d0		 mov	 edx, eax
  0040c	c1 e2 04	 shl	 edx, 4
  0040f	33 c2		 xor	 eax, edx
  00411	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00418	2b c2		 sub	 eax, edx
  0041a	8b d0		 mov	 edx, eax
  0041c	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0041f	33 c2		 xor	 eax, edx
  00421	8b d0		 mov	 edx, eax
  00423	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00426	33 d0		 xor	 edx, eax

; 1470 : 		obj->value = key;

  00428	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 1471 : 		tommy_hashdyn_insert(&hashdyn, &obj->node, obj, hash_key);

  0042b	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  00430	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00436	23 c2		 and	 eax, edx
  00438	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  0043b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0043d	85 c0		 test	 eax, eax
  0043f	74 16		 je	 SHORT $LN277@test_chang
  00441	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00444	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00447	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0044a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0044d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00453	89 38		 mov	 DWORD PTR [eax], edi
  00455	eb 0b		 jmp	 SHORT $LN284@test_chang
$LN277@test_chang:
  00457	89 7f 04	 mov	 DWORD PTR [edi+4], edi
  0045a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00460	89 39		 mov	 DWORD PTR [ecx], edi
$LN284@test_chang:
  00462	89 7f 08	 mov	 DWORD PTR [edi+8], edi
  00465	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  00468	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  0046d	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00473	40		 inc	 eax
  00474	d1 e9		 shr	 ecx, 1
  00476	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0047b	3b c1		 cmp	 eax, ecx
  0047d	72 10		 jb	 SHORT $LN185@test_chang
  0047f	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00485	42		 inc	 edx
  00486	52		 push	 edx
  00487	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0048c	83 c4 04	 add	 esp, 4
$LN185@test_chang:

; 1459 : 
; 1460 : 	START(DATA_HASHDYN) {

  0048f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00492	40		 inc	 eax
  00493	83 c3 04	 add	 ebx, 4
  00496	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00499	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0049f	0f 82 fb fe ff
	ff		 jb	 $LL186@test_chang
$LN184@test_chang:

; 1472 : 	} STOP();

  004a5	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1473 : 
; 1474 : 	START(DATA_HASHLIN) {

  004aa	b8 02 00 00 00	 mov	 eax, 2
  004af	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  004b4	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  004ba	0f 85 27 02 00
	00		 jne	 $LN179@test_chang
  004c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  004c7	75 2e		 jne	 SHORT $LN289@test_chang
  004c9	a1 08 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  004ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  004d4	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  004db	50		 push	 eax
  004dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  004e1	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  004e8	52		 push	 edx
  004e9	51		 push	 ecx
  004ea	68 00 00 00 00	 push	 OFFSET $SG-100
  004ef	e8 00 00 00 00	 call	 _printf
  004f4	83 c4 10	 add	 esp, 16			; 00000010H
$LN289@test_chang:
  004f7	8d 55 f0	 lea	 edx, DWORD PTR _t$210343[ebp]
  004fa	52		 push	 edx
  004fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00501	85 c0		 test	 eax, eax
  00503	75 11		 jne	 SHORT $LN295@test_chang
  00505	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00509	66 0f 13 45 f0	 movlpd	 QWORD PTR $T210336[ebp], xmm0
  0050e	8b 5d f4	 mov	 ebx, DWORD PTR $T210336[ebp+4]
  00511	8b 7d f0	 mov	 edi, DWORD PTR $T210336[ebp]
  00514	eb 54		 jmp	 SHORT $LN296@test_chang
$LN295@test_chang:
  00516	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0051c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00522	8b 45 f4	 mov	 eax, DWORD PTR _t$210343[ebp+4]
  00525	8b 4d f0	 mov	 ecx, DWORD PTR _t$210343[ebp]
  00528	57		 push	 edi
  00529	56		 push	 esi
  0052a	50		 push	 eax
  0052b	51		 push	 ecx
  0052c	e8 00 00 00 00	 call	 __alldvrm
  00531	6a 00		 push	 0
  00533	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00538	53		 push	 ebx
  00539	51		 push	 ecx
  0053a	89 45 f0	 mov	 DWORD PTR tv4236[ebp], eax
  0053d	89 55 f4	 mov	 DWORD PTR tv4236[ebp+4], edx
  00540	e8 00 00 00 00	 call	 __allmul
  00545	57		 push	 edi
  00546	56		 push	 esi
  00547	52		 push	 edx
  00548	50		 push	 eax
  00549	e8 00 00 00 00	 call	 __alldiv
  0054e	6a 00		 push	 0
  00550	8b da		 mov	 ebx, edx
  00552	8b 55 f4	 mov	 edx, DWORD PTR tv4236[ebp+4]
  00555	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0055a	8b f8		 mov	 edi, eax
  0055c	8b 45 f0	 mov	 eax, DWORD PTR tv4236[ebp]
  0055f	52		 push	 edx
  00560	50		 push	 eax
  00561	e8 00 00 00 00	 call	 __allmul
  00566	03 f8		 add	 edi, eax
  00568	13 da		 adc	 ebx, edx
$LN296@test_chang:
  0056a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00571	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00577	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0057d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00584	0f 86 5d 01 00
	00		 jbe	 $LN179@test_chang
  0058a	8b 75 0c	 mov	 esi, DWORD PTR _INSERT$[ebp]
  0058d	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00590	2b c6		 sub	 eax, esi
  00592	89 75 fc	 mov	 DWORD PTR tv7253[ebp], esi
  00595	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  00598	eb 09		 jmp	 SHORT $LN181@test_chang
  0059a	8d 9b 00 00 00
	00		 npad	 6
$LL1428@test_chang:
  005a0	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN181@test_chang:

; 1475 : 		unsigned key = REMOVE[i];

  005a3	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]

; 1476 : 		unsigned hash_key = hash(key);

  005a6	8b d1		 mov	 edx, ecx
  005a8	89 4d e4	 mov	 DWORD PTR _key$149717[ebp], ecx
  005ab	c1 e2 06	 shl	 edx, 6
  005ae	2b ca		 sub	 ecx, edx
  005b0	8b c1		 mov	 eax, ecx
  005b2	c1 e8 11	 shr	 eax, 17			; 00000011H
  005b5	33 c8		 xor	 ecx, eax
  005b7	8b d1		 mov	 edx, ecx
  005b9	c1 e2 09	 shl	 edx, 9
  005bc	2b ca		 sub	 ecx, edx
  005be	8b c1		 mov	 eax, ecx
  005c0	c1 e0 04	 shl	 eax, 4
  005c3	33 c8		 xor	 ecx, eax
  005c5	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  005cc	2b ca		 sub	 ecx, edx
  005ce	8b c1		 mov	 eax, ecx
  005d0	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  005d3	33 c8		 xor	 ecx, eax
  005d5	8b c1		 mov	 eax, ecx
  005d7	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  005da	33 c1		 xor	 eax, ecx

; 1477 : 		struct hashtable_object* obj;
; 1478 : 		obj = (struct hashtable_object*)tommy_hashlin_remove(&hashlin, tommy_hashtable_compare, &key, hash_key);

  005dc	8d 4d e4	 lea	 ecx, DWORD PTR _key$149717[ebp]
  005df	51		 push	 ecx
  005e0	e8 00 00 00 00	 call	 _tommy_hashlin_remove
  005e5	8b f8		 mov	 edi, eax
  005e7	83 c4 04	 add	 esp, 4

; 1479 : 		if (!obj)

  005ea	85 ff		 test	 edi, edi
  005ec	75 05		 jne	 SHORT $LN178@test_chang

; 1480 : 			abort();

  005ee	e8 00 00 00 00	 call	 _abort
$LN178@test_chang:

; 1481 : 
; 1482 : 		key = INSERT[i] + DELTA;

  005f3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  005f5	41		 inc	 ecx

; 1483 : 		hash_key = hash(key);

  005f6	8b d1		 mov	 edx, ecx
  005f8	c1 e2 06	 shl	 edx, 6
  005fb	8b c1		 mov	 eax, ecx
  005fd	2b c2		 sub	 eax, edx
  005ff	8b d0		 mov	 edx, eax
  00601	c1 ea 11	 shr	 edx, 17			; 00000011H
  00604	33 c2		 xor	 eax, edx
  00606	8b d0		 mov	 edx, eax
  00608	c1 e2 09	 shl	 edx, 9
  0060b	2b c2		 sub	 eax, edx
  0060d	8b d0		 mov	 edx, eax
  0060f	c1 e2 04	 shl	 edx, 4
  00612	33 c2		 xor	 eax, edx
  00614	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0061b	2b c2		 sub	 eax, edx
  0061d	8b d0		 mov	 edx, eax
  0061f	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00622	33 c2		 xor	 eax, edx
  00624	8b d0		 mov	 edx, eax
  00626	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00629	33 d0		 xor	 edx, eax

; 1484 : 		obj->value = key;

  0062b	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 1485 : 		tommy_hashlin_insert(&hashlin, &obj->node, obj, hash_key);

  0062e	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  00635	74 2d		 je	 SHORT $LN304@test_chang
  00637	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  0063c	23 c2		 and	 eax, edx
  0063e	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  00644	72 1e		 jb	 SHORT $LN304@test_chang
  00646	83 f8 40	 cmp	 eax, 64			; 00000040H
  00649	73 08		 jae	 SHORT $LN308@test_chang
  0064b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00651	eb 3e		 jmp	 SHORT $LN1431@test_chang
$LN308@test_chang:
  00653	0f bd c8	 bsr	 ecx, eax
  00656	bb 01 00 00 00	 mov	 ebx, 1
  0065b	d3 e3		 shl	 ebx, cl
  0065d	89 4d fc	 mov	 DWORD PTR _count$210433[ebp], ecx
  00660	2b c3		 sub	 eax, ebx
  00662	eb 26		 jmp	 SHORT $LN1432@test_chang
$LN304@test_chang:
  00664	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00669	23 c2		 and	 eax, edx
  0066b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0066e	73 08		 jae	 SHORT $LN313@test_chang
  00670	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00676	eb 19		 jmp	 SHORT $LN1431@test_chang
$LN313@test_chang:
  00678	0f bd c8	 bsr	 ecx, eax
  0067b	be 01 00 00 00	 mov	 esi, 1
  00680	d3 e6		 shl	 esi, cl
  00682	89 4d e4	 mov	 DWORD PTR _count$210440[ebp], ecx
  00685	2b c6		 sub	 eax, esi
  00687	8b 75 fc	 mov	 esi, DWORD PTR tv7253[ebp]
$LN1432@test_chang:
  0068a	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
$LN1431@test_chang:
  00691	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00694	8b c8		 mov	 ecx, eax
  00696	8b 01		 mov	 eax, DWORD PTR [ecx]
  00698	85 c0		 test	 eax, eax
  0069a	74 16		 je	 SHORT $LN319@test_chang
  0069c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0069f	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  006a2	89 78 04	 mov	 DWORD PTR [eax+4], edi
  006a5	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  006a8	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  006ae	89 38		 mov	 DWORD PTR [eax], edi
  006b0	eb 0b		 jmp	 SHORT $LN326@test_chang
$LN319@test_chang:
  006b2	89 7f 04	 mov	 DWORD PTR [edi+4], edi
  006b5	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  006bb	89 39		 mov	 DWORD PTR [ecx], edi
$LN326@test_chang:
  006bd	89 7f 08	 mov	 DWORD PTR [edi+8], edi
  006c0	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  006c3	ff 05 a0 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  006c9	e8 00 00 00 00	 call	 ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_grow_step
  006ce	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  006d1	40		 inc	 eax
  006d2	83 c6 04	 add	 esi, 4
  006d5	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  006d8	89 75 fc	 mov	 DWORD PTR tv7253[ebp], esi
  006db	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  006e1	0f 82 b9 fe ff
	ff		 jb	 $LL1428@test_chang
$LN179@test_chang:

; 1486 : 	} STOP();

  006e7	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1487 : 
; 1488 : 	START(DATA_TRIE) {

  006ec	b8 03 00 00 00	 mov	 eax, 3
  006f1	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  006f6	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  006fc	0f 85 32 01 00
	00		 jne	 $LN174@test_chang
  00702	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00709	75 30		 jne	 SHORT $LN328@test_chang
  0070b	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  00711	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00717	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  0071e	51		 push	 ecx
  0071f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00725	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0072c	50		 push	 eax
  0072d	52		 push	 edx
  0072e	68 00 00 00 00	 push	 OFFSET $SG-100
  00733	e8 00 00 00 00	 call	 _printf
  00738	83 c4 10	 add	 esp, 16			; 00000010H
$LN328@test_chang:
  0073b	8d 45 f0	 lea	 eax, DWORD PTR _t$210477[ebp]
  0073e	50		 push	 eax
  0073f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00745	85 c0		 test	 eax, eax
  00747	75 11		 jne	 SHORT $LN334@test_chang
  00749	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0074d	66 0f 13 45 f0	 movlpd	 QWORD PTR $T210470[ebp], xmm0
  00752	8b 5d f4	 mov	 ebx, DWORD PTR $T210470[ebp+4]
  00755	8b 7d f0	 mov	 edi, DWORD PTR $T210470[ebp]
  00758	eb 54		 jmp	 SHORT $LN335@test_chang
$LN334@test_chang:
  0075a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00760	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00766	8b 4d f4	 mov	 ecx, DWORD PTR _t$210477[ebp+4]
  00769	8b 55 f0	 mov	 edx, DWORD PTR _t$210477[ebp]
  0076c	57		 push	 edi
  0076d	56		 push	 esi
  0076e	51		 push	 ecx
  0076f	52		 push	 edx
  00770	e8 00 00 00 00	 call	 __alldvrm
  00775	6a 00		 push	 0
  00777	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0077c	53		 push	 ebx
  0077d	51		 push	 ecx
  0077e	89 45 f0	 mov	 DWORD PTR tv369[ebp], eax
  00781	89 55 f4	 mov	 DWORD PTR tv369[ebp+4], edx
  00784	e8 00 00 00 00	 call	 __allmul
  00789	57		 push	 edi
  0078a	56		 push	 esi
  0078b	52		 push	 edx
  0078c	50		 push	 eax
  0078d	e8 00 00 00 00	 call	 __alldiv
  00792	8b 4d f0	 mov	 ecx, DWORD PTR tv369[ebp]
  00795	6a 00		 push	 0
  00797	8b f8		 mov	 edi, eax
  00799	8b 45 f4	 mov	 eax, DWORD PTR tv369[ebp+4]
  0079c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007a1	50		 push	 eax
  007a2	51		 push	 ecx
  007a3	8b da		 mov	 ebx, edx
  007a5	e8 00 00 00 00	 call	 __allmul
  007aa	03 f8		 add	 edi, eax
  007ac	13 da		 adc	 ebx, edx
$LN335@test_chang:
  007ae	33 f6		 xor	 esi, esi
  007b0	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  007b6	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  007bc	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  007c2	76 70		 jbe	 SHORT $LN174@test_chang
  007c4	8b 5d 0c	 mov	 ebx, DWORD PTR _INSERT$[ebp]
  007c7	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  007ca	2b c3		 sub	 eax, ebx
  007cc	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  007cf	90		 npad	 1
$LL176@test_chang:

; 1489 : 		unsigned key = REMOVE[i];

  007d0	8b 55 ec	 mov	 edx, DWORD PTR tv7146[ebp]
  007d3	8b 04 1a	 mov	 eax, DWORD PTR [edx+ebx]

; 1490 : 		struct trie_object* obj;
; 1491 : 		obj = (struct trie_object*)tommy_trie_remove(&trie, key);

  007d6	8b c8		 mov	 ecx, eax
  007d8	c1 e9 1b	 shr	 ecx, 27			; 0000001bH
  007db	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[ecx*4]
  007e2	e8 00 00 00 00	 call	 ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ; trie_bucket_remove_existing
  007e7	85 c0		 test	 eax, eax
  007e9	75 04		 jne	 SHORT $LN337@test_chang
  007eb	33 ff		 xor	 edi, edi
  007ed	eb 0d		 jmp	 SHORT $LN1377@test_chang
$LN337@test_chang:
  007ef	ff 0d 80 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128
  007f5	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1492 : 		if (!obj)

  007f8	85 ff		 test	 edi, edi
  007fa	75 05		 jne	 SHORT $LN173@test_chang
$LN1377@test_chang:

; 1493 : 			abort();

  007fc	e8 00 00 00 00	 call	 _abort
$LN173@test_chang:

; 1494 : 
; 1495 : 		key = INSERT[i] + DELTA;

  00801	8b 03		 mov	 eax, DWORD PTR [ebx]
  00803	40		 inc	 eax

; 1496 : 		obj->value = key;
; 1497 : 		tommy_trie_insert(&trie, &obj->node, obj, key);

  00804	50		 push	 eax
  00805	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00808	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0080b	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  0080e	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  00815	57		 push	 edi
  00816	52		 push	 edx
  00817	89 7f 08	 mov	 DWORD PTR [edi+8], edi
  0081a	e8 00 00 00 00	 call	 ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ; trie_bucket_insert
  0081f	ff 05 80 00 00
	00		 inc	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128
  00825	46		 inc	 esi
  00826	83 c4 0c	 add	 esp, 12			; 0000000cH
  00829	83 c3 04	 add	 ebx, 4
  0082c	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00832	72 9c		 jb	 SHORT $LL176@test_chang
$LN174@test_chang:

; 1498 : 	} STOP();

  00834	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1499 : 
; 1500 : 	START(DATA_TRIE_INPLACE) {

  00839	b8 04 00 00 00	 mov	 eax, 4
  0083e	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00843	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00849	0f 85 a3 01 00
	00		 jne	 $LN169@test_chang
  0084f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00856	75 2e		 jne	 SHORT $LN342@test_chang
  00858	a1 10 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  0085d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00863	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0086a	50		 push	 eax
  0086b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00870	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00877	52		 push	 edx
  00878	51		 push	 ecx
  00879	68 00 00 00 00	 push	 OFFSET $SG-100
  0087e	e8 00 00 00 00	 call	 _printf
  00883	83 c4 10	 add	 esp, 16			; 00000010H
$LN342@test_chang:
  00886	8d 55 f0	 lea	 edx, DWORD PTR _t$210510[ebp]
  00889	52		 push	 edx
  0088a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00890	85 c0		 test	 eax, eax
  00892	75 11		 jne	 SHORT $LN348@test_chang
  00894	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00898	66 0f 13 45 f0	 movlpd	 QWORD PTR $T210503[ebp], xmm0
  0089d	8b 7d f4	 mov	 edi, DWORD PTR $T210503[ebp+4]
  008a0	8b 75 f0	 mov	 esi, DWORD PTR $T210503[ebp]
  008a3	eb 54		 jmp	 SHORT $LN349@test_chang
$LN348@test_chang:
  008a5	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  008ab	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  008b1	8b 45 f4	 mov	 eax, DWORD PTR _t$210510[ebp+4]
  008b4	8b 4d f0	 mov	 ecx, DWORD PTR _t$210510[ebp]
  008b7	56		 push	 esi
  008b8	57		 push	 edi
  008b9	50		 push	 eax
  008ba	51		 push	 ecx
  008bb	e8 00 00 00 00	 call	 __alldvrm
  008c0	6a 00		 push	 0
  008c2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  008c7	53		 push	 ebx
  008c8	51		 push	 ecx
  008c9	89 45 f0	 mov	 DWORD PTR tv4175[ebp], eax
  008cc	89 55 f4	 mov	 DWORD PTR tv4175[ebp+4], edx
  008cf	e8 00 00 00 00	 call	 __allmul
  008d4	56		 push	 esi
  008d5	57		 push	 edi
  008d6	52		 push	 edx
  008d7	50		 push	 eax
  008d8	e8 00 00 00 00	 call	 __alldiv
  008dd	6a 00		 push	 0
  008df	8b fa		 mov	 edi, edx
  008e1	8b 55 f4	 mov	 edx, DWORD PTR tv4175[ebp+4]
  008e4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  008e9	8b f0		 mov	 esi, eax
  008eb	8b 45 f0	 mov	 eax, DWORD PTR tv4175[ebp]
  008ee	52		 push	 edx
  008ef	50		 push	 eax
  008f0	e8 00 00 00 00	 call	 __allmul
  008f5	03 f0		 add	 esi, eax
  008f7	13 fa		 adc	 edi, edx
$LN349@test_chang:
  008f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00900	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00906	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  0090c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00913	0f 86 d9 00 00
	00		 jbe	 $LN169@test_chang
  00919	8b 45 0c	 mov	 eax, DWORD PTR _INSERT$[ebp]
  0091c	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  0091f	8b f0		 mov	 esi, eax
  00921	2b c8		 sub	 ecx, eax
  00923	89 75 fc	 mov	 DWORD PTR tv7361[ebp], esi
  00926	89 4d ec	 mov	 DWORD PTR tv7146[ebp], ecx
  00929	eb 08		 jmp	 SHORT $LN171@test_chang
  0092b	eb 03 8d 49 00	 npad	 5
$LL1429@test_chang:
  00930	8b 4d ec	 mov	 ecx, DWORD PTR tv7146[ebp]
$LN171@test_chang:

; 1501 : 		unsigned key = REMOVE[i];

  00933	8b 14 31	 mov	 edx, DWORD PTR [ecx+esi]

; 1502 : 		struct trie_inplace_object* obj;
; 1503 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_remove(&trie_inplace, key);

  00936	8b ca		 mov	 ecx, edx
  00938	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  0093b	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[ecx*4]
  00942	50		 push	 eax
  00943	e8 00 00 00 00	 call	 ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ; trie_inplace_bucket_remove
  00948	83 c4 04	 add	 esp, 4
  0094b	85 c0		 test	 eax, eax
  0094d	75 04		 jne	 SHORT $LN351@test_chang
  0094f	33 ff		 xor	 edi, edi
  00951	eb 0d		 jmp	 SHORT $LN1379@test_chang
$LN351@test_chang:
  00953	ff 0d 00 01 00
	00		 dec	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00959	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1504 : 		if (!obj)

  0095c	85 ff		 test	 edi, edi
  0095e	75 05		 jne	 SHORT $LN168@test_chang
$LN1379@test_chang:

; 1505 : 			abort();

  00960	e8 00 00 00 00	 call	 _abort
$LN168@test_chang:

; 1506 : 
; 1507 : 		key = INSERT[i] + DELTA;

  00965	8b 06		 mov	 eax, DWORD PTR [esi]
  00967	40		 inc	 eax

; 1508 : 		obj->value = key;
; 1509 : 		tommy_trie_inplace_insert(&trie_inplace, &obj->node, obj, key);

  00968	8b d0		 mov	 edx, eax
  0096a	c1 ea 1a	 shr	 edx, 26			; 0000001aH
  0096d	89 47 20	 mov	 DWORD PTR [edi+32], eax
  00970	89 7f 08	 mov	 DWORD PTR [edi+8], edi
  00973	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00976	66 0f ef c0	 pxor	 xmm0, xmm0
  0097a	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
  0097f	8d 1c 95 00 00
	00 00		 lea	 ebx, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[edx*4]
  00986	66 0f d6 47 18	 movq	 QWORD PTR [edi+24], xmm0
  0098b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0098d	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00992	85 d2		 test	 edx, edx
  00994	74 19		 je	 SHORT $LN1367@test_chang
$LN362@test_chang:
  00996	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  00999	74 21		 je	 SHORT $LN360@test_chang
  0099b	8b f0		 mov	 esi, eax
  0099d	d3 ee		 shr	 esi, cl
  0099f	83 e9 02	 sub	 ecx, 2
  009a2	83 e6 03	 and	 esi, 3
  009a5	8d 5c b2 10	 lea	 ebx, DWORD PTR [edx+esi*4+16]
  009a9	8b 13		 mov	 edx, DWORD PTR [ebx]
  009ab	85 d2		 test	 edx, edx
  009ad	75 e7		 jne	 SHORT $LN362@test_chang
$LN1367@test_chang:
  009af	89 7f 04	 mov	 DWORD PTR [edi+4], edi
  009b2	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  009b8	89 3b		 mov	 DWORD PTR [ebx], edi
  009ba	eb 14		 jmp	 SHORT $LN367@test_chang
$LN360@test_chang:
  009bc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  009bf	89 47 04	 mov	 DWORD PTR [edi+4], eax
  009c2	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  009c5	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  009c8	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  009ce	89 39		 mov	 DWORD PTR [ecx], edi
$LN367@test_chang:

; 1499 : 
; 1500 : 	START(DATA_TRIE_INPLACE) {

  009d0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  009d3	8b 75 fc	 mov	 esi, DWORD PTR tv7361[ebp]

; 1508 : 		obj->value = key;
; 1509 : 		tommy_trie_inplace_insert(&trie_inplace, &obj->node, obj, key);

  009d6	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  009dc	40		 inc	 eax
  009dd	83 c6 04	 add	 esi, 4
  009e0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  009e3	89 75 fc	 mov	 DWORD PTR tv7361[ebp], esi
  009e6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  009ec	0f 82 3e ff ff
	ff		 jb	 $LL1429@test_chang
$LN169@test_chang:

; 1510 : 	} STOP();

  009f2	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1511 : 
; 1512 : 	START(DATA_KHASH) {

  009f7	b8 07 00 00 00	 mov	 eax, 7
  009fc	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00a01	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00a07	0f 85 ec 01 00
	00		 jne	 $LN164@test_chang
  00a0d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00a14	75 2f		 jne	 SHORT $LN369@test_chang
  00a16	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00a1c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00a21	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00a28	52		 push	 edx
  00a29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00a2f	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00a36	51		 push	 ecx
  00a37	50		 push	 eax
  00a38	68 00 00 00 00	 push	 OFFSET $SG-100
  00a3d	e8 00 00 00 00	 call	 _printf
  00a42	83 c4 10	 add	 esp, 16			; 00000010H
$LN369@test_chang:
  00a45	8d 4d d8	 lea	 ecx, DWORD PTR _t$210578[ebp]
  00a48	51		 push	 ecx
  00a49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00a4f	85 c0		 test	 eax, eax
  00a51	75 11		 jne	 SHORT $LN375@test_chang
  00a53	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00a57	66 0f 13 45 f0	 movlpd	 QWORD PTR $T210571[ebp], xmm0
  00a5c	8b 7d f4	 mov	 edi, DWORD PTR $T210571[ebp+4]
  00a5f	8b 75 f0	 mov	 esi, DWORD PTR $T210571[ebp]
  00a62	eb 54		 jmp	 SHORT $LN376@test_chang
$LN375@test_chang:
  00a64	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00a6a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00a70	8b 55 dc	 mov	 edx, DWORD PTR _t$210578[ebp+4]
  00a73	8b 45 d8	 mov	 eax, DWORD PTR _t$210578[ebp]
  00a76	56		 push	 esi
  00a77	57		 push	 edi
  00a78	52		 push	 edx
  00a79	50		 push	 eax
  00a7a	e8 00 00 00 00	 call	 __alldvrm
  00a7f	6a 00		 push	 0
  00a81	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a86	53		 push	 ebx
  00a87	51		 push	 ecx
  00a88	89 45 f0	 mov	 DWORD PTR tv546[ebp], eax
  00a8b	89 55 f4	 mov	 DWORD PTR tv546[ebp+4], edx
  00a8e	e8 00 00 00 00	 call	 __allmul
  00a93	56		 push	 esi
  00a94	57		 push	 edi
  00a95	52		 push	 edx
  00a96	50		 push	 eax
  00a97	e8 00 00 00 00	 call	 __alldiv
  00a9c	8b 4d f4	 mov	 ecx, DWORD PTR tv546[ebp+4]
  00a9f	6a 00		 push	 0
  00aa1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00aa6	8b fa		 mov	 edi, edx
  00aa8	8b 55 f0	 mov	 edx, DWORD PTR tv546[ebp]
  00aab	51		 push	 ecx
  00aac	52		 push	 edx
  00aad	8b f0		 mov	 esi, eax
  00aaf	e8 00 00 00 00	 call	 __allmul
  00ab4	03 f0		 add	 esi, eax
  00ab6	13 fa		 adc	 edi, edx
$LN376@test_chang:
  00ab8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00abf	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00ac5	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  00acb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00ad2	0f 86 21 01 00
	00		 jbe	 $LN164@test_chang
  00ad8	8b 75 0c	 mov	 esi, DWORD PTR _INSERT$[ebp]
  00adb	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00ade	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00ae4	2b c6		 sub	 eax, esi
  00ae6	89 75 e8	 mov	 DWORD PTR tv7403[ebp], esi
  00ae9	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  00aec	eb 05		 jmp	 SHORT $LN166@test_chang
  00aee	8b ff		 npad	 2
$LL1404@test_chang:
  00af0	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN166@test_chang:

; 1513 : 		unsigned key = REMOVE[i];
; 1514 : 		unsigned hash_key = hash(key);

  00af3	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00af6	8b c8		 mov	 ecx, eax
  00af8	c1 e1 06	 shl	 ecx, 6
  00afb	2b c1		 sub	 eax, ecx
  00afd	8b d0		 mov	 edx, eax
  00aff	c1 ea 11	 shr	 edx, 17			; 00000011H
  00b02	33 c2		 xor	 eax, edx
  00b04	8b c8		 mov	 ecx, eax
  00b06	c1 e1 09	 shl	 ecx, 9
  00b09	2b c1		 sub	 eax, ecx
  00b0b	8b d0		 mov	 edx, eax
  00b0d	c1 e2 04	 shl	 edx, 4
  00b10	33 c2		 xor	 eax, edx
  00b12	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00b19	2b c1		 sub	 eax, ecx
  00b1b	8b d0		 mov	 edx, eax
  00b1d	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00b20	33 c2		 xor	 eax, edx
  00b22	8b c8		 mov	 ecx, eax
  00b24	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00b27	33 c8		 xor	 ecx, eax

; 1515 : 		khiter_t k;
; 1516 : 		int r;
; 1517 : 		struct khash_object* obj;
; 1518 : 		k = kh_get(word, khash, hash_key);

  00b29	51		 push	 ecx
  00b2a	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word
  00b2f	8b f8		 mov	 edi, eax
  00b31	83 c4 04	 add	 esp, 4

; 1519 : 		if (k == kh_end(khash))

  00b34	3b 3b		 cmp	 edi, DWORD PTR [ebx]
  00b36	75 0b		 jne	 SHORT $LN163@test_chang

; 1520 : 			abort();

  00b38	e8 00 00 00 00	 call	 _abort
  00b3d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
$LN163@test_chang:

; 1521 : 		obj = kh_value(khash, k);

  00b43	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00b46	8b 04 ba	 mov	 eax, DWORD PTR [edx+edi*4]
  00b49	89 45 fc	 mov	 DWORD PTR _obj$149746[ebp], eax

; 1522 : 		kh_del(word, khash, k);

  00b4c	3b 3b		 cmp	 edi, DWORD PTR [ebx]
  00b4e	74 27		 je	 SHORT $LN380@test_chang
  00b50	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00b53	8b cf		 mov	 ecx, edi
  00b55	c1 e9 04	 shr	 ecx, 4
  00b58	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00b5b	83 e7 0f	 and	 edi, 15			; 0000000fH
  00b5e	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  00b61	03 ff		 add	 edi, edi
  00b63	8b cf		 mov	 ecx, edi
  00b65	d3 e8		 shr	 eax, cl
  00b67	a8 03		 test	 al, 3
  00b69	75 0c		 jne	 SHORT $LN380@test_chang
  00b6b	ba 01 00 00 00	 mov	 edx, 1
  00b70	d3 e2		 shl	 edx, cl
  00b72	09 16		 or	 DWORD PTR [esi], edx
  00b74	ff 4b 04	 dec	 DWORD PTR [ebx+4]
$LN380@test_chang:

; 1523 : 
; 1524 : 		key = INSERT[i] + DELTA;

  00b77	8b 75 e8	 mov	 esi, DWORD PTR tv7403[ebp]
  00b7a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00b7c	41		 inc	 ecx

; 1525 : 		hash_key = hash(key);

  00b7d	8b d1		 mov	 edx, ecx
  00b7f	c1 e2 06	 shl	 edx, 6
  00b82	8b c1		 mov	 eax, ecx
  00b84	2b c2		 sub	 eax, edx
  00b86	8b d0		 mov	 edx, eax
  00b88	c1 ea 11	 shr	 edx, 17			; 00000011H
  00b8b	33 c2		 xor	 eax, edx
  00b8d	8b d0		 mov	 edx, eax
  00b8f	c1 e2 09	 shl	 edx, 9
  00b92	2b c2		 sub	 eax, edx
  00b94	8b d0		 mov	 edx, eax
  00b96	c1 e2 04	 shl	 edx, 4
  00b99	33 c2		 xor	 eax, edx
  00b9b	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00ba2	2b c2		 sub	 eax, edx
  00ba4	8b d0		 mov	 edx, eax
  00ba6	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00ba9	33 c2		 xor	 eax, edx

; 1526 : 		obj->value = key;

  00bab	8b 55 fc	 mov	 edx, DWORD PTR _obj$149746[ebp]
  00bae	89 0a		 mov	 DWORD PTR [edx], ecx
  00bb0	8b d0		 mov	 edx, eax

; 1527 : 		k = kh_put(word, khash, hash_key, &r);

  00bb2	8d 4d e4	 lea	 ecx, DWORD PTR _r$149745[ebp]
  00bb5	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00bb8	51		 push	 ecx
  00bb9	33 d0		 xor	 edx, eax
  00bbb	52		 push	 edx
  00bbc	e8 00 00 00 00	 call	 ?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z ; kh_put_word
  00bc1	83 c4 08	 add	 esp, 8

; 1528 : 		if (!r)

  00bc4	83 7d e4 00	 cmp	 DWORD PTR _r$149745[ebp], 0
  00bc8	8b f8		 mov	 edi, eax
  00bca	75 05		 jne	 SHORT $LN162@test_chang

; 1529 : 			abort();

  00bcc	e8 00 00 00 00	 call	 _abort
$LN162@test_chang:

; 1530 : 		kh_value(khash, k) = obj;

  00bd1	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00bd7	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00bda	8b 4d fc	 mov	 ecx, DWORD PTR _obj$149746[ebp]
  00bdd	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
  00be0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00be3	40		 inc	 eax
  00be4	83 c6 04	 add	 esi, 4
  00be7	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00bea	89 75 e8	 mov	 DWORD PTR tv7403[ebp], esi
  00bed	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00bf3	0f 82 f7 fe ff
	ff		 jb	 $LL1404@test_chang
$LN164@test_chang:

; 1531 : 	} STOP();

  00bf9	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1532 : 
; 1533 : #ifdef USE_CGOOGLEDENSEHASH
; 1534 : 	START(DATA_CGOOGLE) {
; 1535 : 		unsigned key = REMOVE[i];
; 1536 : 		HTItem* ptr;
; 1537 : 		struct google_object* obj;
; 1538 : 		u_long ptr_value;
; 1539 : 		ptr = HashFind(cgoogledensehash, key);
; 1540 : 		if (!ptr)
; 1541 : 			abort();
; 1542 : 		obj = (void*)ptr->data;
; 1543 : 		HashDeleteLast(cgoogledensehash);
; 1544 : 
; 1545 : 		key = INSERT[i] + DELTA;
; 1546 : 		obj->value = key;
; 1547 : 		ptr_value = (u_long)obj;
; 1548 : 		ptr = HashInsert(cgoogledensehash, key, ptr_value);
; 1549 : 		if (!ptr)
; 1550 : 			abort();
; 1551 : 	} STOP();
; 1552 : #endif
; 1553 : 
; 1554 : #ifdef USE_GOOGLEDENSEHASH
; 1555 : 	START(DATA_GOOGLEDENSEHASH) {

  00bfe	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00c03	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00c08	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00c0e	0f 85 62 03 00
	00		 jne	 $LN158@test_chang
  00c14	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00c1b	75 2f		 jne	 SHORT $LN385@test_chang
  00c1d	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  00c23	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00c28	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00c2f	52		 push	 edx
  00c30	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00c36	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00c3d	51		 push	 ecx
  00c3e	50		 push	 eax
  00c3f	68 00 00 00 00	 push	 OFFSET $SG-100
  00c44	e8 00 00 00 00	 call	 _printf
  00c49	83 c4 10	 add	 esp, 16			; 00000010H
$LN385@test_chang:
  00c4c	8d 4d c8	 lea	 ecx, DWORD PTR _t$210614[ebp]
  00c4f	51		 push	 ecx
  00c50	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00c56	85 c0		 test	 eax, eax
  00c58	75 11		 jne	 SHORT $LN391@test_chang
  00c5a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00c5e	66 0f 13 45 f0	 movlpd	 QWORD PTR $T210607[ebp], xmm0
  00c63	8b 7d f4	 mov	 edi, DWORD PTR $T210607[ebp+4]
  00c66	8b 75 f0	 mov	 esi, DWORD PTR $T210607[ebp]
  00c69	eb 54		 jmp	 SHORT $LN392@test_chang
$LN391@test_chang:
  00c6b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00c71	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00c77	8b 55 cc	 mov	 edx, DWORD PTR _t$210614[ebp+4]
  00c7a	8b 45 c8	 mov	 eax, DWORD PTR _t$210614[ebp]
  00c7d	56		 push	 esi
  00c7e	57		 push	 edi
  00c7f	52		 push	 edx
  00c80	50		 push	 eax
  00c81	e8 00 00 00 00	 call	 __alldvrm
  00c86	6a 00		 push	 0
  00c88	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c8d	53		 push	 ebx
  00c8e	51		 push	 ecx
  00c8f	89 45 f0	 mov	 DWORD PTR tv597[ebp], eax
  00c92	89 55 f4	 mov	 DWORD PTR tv597[ebp+4], edx
  00c95	e8 00 00 00 00	 call	 __allmul
  00c9a	56		 push	 esi
  00c9b	57		 push	 edi
  00c9c	52		 push	 edx
  00c9d	50		 push	 eax
  00c9e	e8 00 00 00 00	 call	 __alldiv
  00ca3	8b 4d f4	 mov	 ecx, DWORD PTR tv597[ebp+4]
  00ca6	6a 00		 push	 0
  00ca8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00cad	8b fa		 mov	 edi, edx
  00caf	8b 55 f0	 mov	 edx, DWORD PTR tv597[ebp]
  00cb2	51		 push	 ecx
  00cb3	52		 push	 edx
  00cb4	8b f0		 mov	 esi, eax
  00cb6	e8 00 00 00 00	 call	 __allmul
  00cbb	03 f0		 add	 esi, eax
  00cbd	13 fa		 adc	 edi, edx
$LN392@test_chang:
  00cbf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00cc6	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00ccc	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  00cd2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00cd9	0f 86 97 02 00
	00		 jbe	 $LN158@test_chang
  00cdf	8b 4d 0c	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  00ce2	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00ce5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00ceb	2b c1		 sub	 eax, ecx
  00ced	89 4d e8	 mov	 DWORD PTR tv7454[ebp], ecx
  00cf0	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  00cf3	eb 03		 jmp	 SHORT $LN160@test_chang
$LL1402@test_chang:
  00cf5	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN160@test_chang:

; 1556 : 		unsigned key = REMOVE[i];

  00cf8	8b 4d e8	 mov	 ecx, DWORD PTR tv7454[ebp]
  00cfb	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]

; 1557 : 		googledensehash_t::iterator ptr = googledensehash->find(key);

  00cfe	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00d01	2b 4f 20	 sub	 ecx, DWORD PTR [edi+32]
  00d04	89 55 fc	 mov	 DWORD PTR _key$149753[ebp], edx
  00d07	75 31		 jne	 SHORT $LN398@test_chang
  00d09	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00d0c	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00d0f	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  00d12	8b d9		 mov	 ebx, ecx
  00d14	3b d9		 cmp	 ebx, ecx
  00d16	74 65		 je	 SHORT $LN512@test_chang
  00d18	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  00d1b	eb 03 8d 49 00	 npad	 5
$LL410@test_chang:
  00d20	8b 03		 mov	 eax, DWORD PTR [ebx]
  00d22	3b f0		 cmp	 esi, eax
  00d24	74 0b		 je	 SHORT $LN408@test_chang
  00d26	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00d2a	76 51		 jbe	 SHORT $LN512@test_chang
  00d2c	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00d2f	75 4c		 jne	 SHORT $LN512@test_chang
$LN408@test_chang:
  00d31	83 c3 08	 add	 ebx, 8
  00d34	3b d9		 cmp	 ebx, ecx
  00d36	75 e8		 jne	 SHORT $LL410@test_chang
  00d38	eb 43		 jmp	 SHORT $LN512@test_chang
$LN398@test_chang:
  00d3a	8d 4d c0	 lea	 ecx, DWORD PTR _pos$211789[ebp]
  00d3d	51		 push	 ecx
  00d3e	8d 45 fc	 lea	 eax, DWORD PTR _key$149753[ebp]
  00d41	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00d46	8b 45 c0	 mov	 eax, DWORD PTR _pos$211789[ebp]
  00d49	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00d4c	83 f8 ff	 cmp	 eax, -1
  00d4f	75 29		 jne	 SHORT $LN397@test_chang
  00d51	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00d54	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  00d57	8b d9		 mov	 ebx, ecx
  00d59	3b d9		 cmp	 ebx, ecx
  00d5b	74 20		 je	 SHORT $LN512@test_chang
  00d5d	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
$LL462@test_chang:
  00d60	8b 03		 mov	 eax, DWORD PTR [ebx]
  00d62	3b f0		 cmp	 esi, eax
  00d64	74 0b		 je	 SHORT $LN460@test_chang
  00d66	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00d6a	76 11		 jbe	 SHORT $LN512@test_chang
  00d6c	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00d6f	75 0c		 jne	 SHORT $LN512@test_chang
$LN460@test_chang:
  00d71	83 c3 08	 add	 ebx, 8
  00d74	3b d9		 cmp	 ebx, ecx
  00d76	75 e8		 jne	 SHORT $LL462@test_chang
  00d78	eb 03		 jmp	 SHORT $LN512@test_chang
$LN397@test_chang:
  00d7a	8d 1c c2	 lea	 ebx, DWORD PTR [edx+eax*8]
$LN512@test_chang:

; 1558 : 		struct google_object* obj;
; 1559 : 		if (ptr == googledensehash->end())

  00d7d	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00d80	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  00d83	8b c2		 mov	 eax, edx
  00d85	3b c2		 cmp	 eax, edx
  00d87	74 20		 je	 SHORT $LN603@test_chang
  00d89	8d a4 24 00 00
	00 00		 npad	 7
$LL566@test_chang:
  00d90	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d92	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  00d95	74 0b		 je	 SHORT $LN564@test_chang
  00d97	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00d9b	76 0c		 jbe	 SHORT $LN603@test_chang
  00d9d	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00da0	75 07		 jne	 SHORT $LN603@test_chang
$LN564@test_chang:
  00da2	83 c0 08	 add	 eax, 8
  00da5	3b c2		 cmp	 eax, edx
  00da7	75 e7		 jne	 SHORT $LL566@test_chang
$LN603@test_chang:
  00da9	3b d8		 cmp	 ebx, eax
  00dab	75 0b		 jne	 SHORT $LN157@test_chang

; 1560 : 			abort();

  00dad	e8 00 00 00 00	 call	 _abort
  00db2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN157@test_chang:

; 1561 : 		obj = ptr->second;

  00db8	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 1562 : 		googledensehash->erase(ptr);

  00dbb	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00dbe	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00dc1	89 55 e0	 mov	 DWORD PTR _obj$149756[ebp], edx
  00dc4	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00dc7	8b c2		 mov	 eax, edx
  00dc9	3b c2		 cmp	 eax, edx
  00dcb	74 1b		 je	 SHORT $LN667@test_chang
  00dcd	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
$LL630@test_chang:
  00dd0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00dd2	3b f1		 cmp	 esi, ecx
  00dd4	74 0b		 je	 SHORT $LN628@test_chang
  00dd6	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00dda	76 0c		 jbe	 SHORT $LN667@test_chang
  00ddc	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00ddf	75 07		 jne	 SHORT $LN667@test_chang
$LN628@test_chang:
  00de1	83 c0 08	 add	 eax, 8
  00de4	3b c2		 cmp	 eax, edx
  00de6	75 e8		 jne	 SHORT $LL630@test_chang
$LN667@test_chang:
  00de8	3b d8		 cmp	 ebx, eax
  00dea	74 2d		 je	 SHORT $LN707@test_chang
  00dec	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00df0	76 0e		 jbe	 SHORT $LN691@test_chang
  00df2	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  00df5	3b 13		 cmp	 edx, DWORD PTR [ebx]
  00df7	75 07		 jne	 SHORT $LN691@test_chang
  00df9	b8 01 00 00 00	 mov	 eax, 1
  00dfe	eb 02		 jmp	 SHORT $LN692@test_chang
$LN691@test_chang:
  00e00	33 c0		 xor	 eax, eax
$LN692@test_chang:
  00e02	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00e05	89 0b		 mov	 DWORD PTR [ebx], ecx
  00e07	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00e0e	84 c0		 test	 al, al
  00e10	75 07		 jne	 SHORT $LN707@test_chang
  00e12	ff 47 20	 inc	 DWORD PTR [edi+32]
  00e15	c6 47 10 01	 mov	 BYTE PTR [edi+16], 1
$LN707@test_chang:

; 1563 : 
; 1564 : 		key = INSERT[i] + DELTA;

  00e19	8b 55 e8	 mov	 edx, DWORD PTR tv7454[ebp]
  00e1c	8b 32		 mov	 esi, DWORD PTR [edx]

; 1565 : 		obj->value = key;

  00e1e	8b 45 e0	 mov	 eax, DWORD PTR _obj$149756[ebp]
  00e21	46		 inc	 esi

; 1566 : 		(*googledensehash)[key] = obj;

  00e22	8d 4d d0	 lea	 ecx, DWORD PTR _pos$216229[ebp]
  00e25	89 30		 mov	 DWORD PTR [eax], esi
  00e27	51		 push	 ecx
  00e28	8d 45 fc	 lea	 eax, DWORD PTR _key$149753[ebp]
  00e2b	89 75 fc	 mov	 DWORD PTR _key$149753[ebp], esi
  00e2e	8b df		 mov	 ebx, edi
  00e30	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00e35	8b 45 d0	 mov	 eax, DWORD PTR _pos$216229[ebp]
  00e38	83 f8 ff	 cmp	 eax, -1
  00e3b	74 0b		 je	 SHORT $LN714@test_chang
  00e3d	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00e40	8d 1c c2	 lea	 ebx, DWORD PTR [edx+eax*8]
  00e43	e9 11 01 00 00	 jmp	 $LN711@test_chang
$LN714@test_chang:
  00e48	57		 push	 edi
  00e49	b8 01 00 00 00	 mov	 eax, 1
  00e4e	e8 00 00 00 00	 call	 ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
  00e53	84 c0		 test	 al, al
  00e55	0f 84 aa 00 00
	00		 je	 $LN712@test_chang
  00e5b	8d 45 b8	 lea	 eax, DWORD PTR _pos$216098[ebp]
  00e5e	50		 push	 eax
  00e5f	8d 45 e4	 lea	 eax, DWORD PTR $T215836[ebp]
  00e62	8b fb		 mov	 edi, ebx
  00e64	89 75 e4	 mov	 DWORD PTR $T215836[ebp], esi
  00e67	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00e6c	8b 4d b8	 mov	 ecx, DWORD PTR _pos$216098[ebp]
  00e6f	83 f9 ff	 cmp	 ecx, -1
  00e72	74 1c		 je	 SHORT $LN748@test_chang
  00e74	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00e77	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00e7a	89 9d 6c ff ff
	ff		 mov	 DWORD PTR $T215844[ebp], ebx
  00e80	89 8d 70 ff ff
	ff		 mov	 DWORD PTR $T215844[ebp+4], ecx
  00e86	f3 0f 7e 85 6c
	ff ff ff	 movq	 xmm0, QWORD PTR $T215844[ebp]
  00e8e	eb 62		 jmp	 SHORT $LN1433@test_chang
$LN748@test_chang:
  00e90	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00e93	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00e96	2b c8		 sub	 ecx, eax
  00e98	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00e9e	0f 83 0d 01 00
	00		 jae	 $LN1326@test_chang
  00ea4	8b 4d bc	 mov	 ecx, DWORD PTR _pos$216098[ebp+4]
  00ea7	85 c0		 test	 eax, eax
  00ea9	74 11		 je	 SHORT $LN820@test_chang
  00eab	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  00eae	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00eb1	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  00eb4	75 06		 jne	 SHORT $LN820@test_chang
  00eb6	48		 dec	 eax
  00eb7	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00eba	eb 07		 jmp	 SHORT $LN819@test_chang
$LN820@test_chang:
  00ebc	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00ebf	40		 inc	 eax
  00ec0	89 43 24	 mov	 DWORD PTR [ebx+36], eax
$LN819@test_chang:
  00ec3	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00ec6	03 c9		 add	 ecx, ecx
  00ec8	03 c9		 add	 ecx, ecx
  00eca	03 c9		 add	 ecx, ecx
  00ecc	03 c1		 add	 eax, ecx
  00ece	74 09		 je	 SHORT $LN906@test_chang
  00ed0	89 30		 mov	 DWORD PTR [eax], esi
  00ed2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN906@test_chang:
  00ed9	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00edc	03 c8		 add	 ecx, eax
  00ede	89 9d 78 ff ff
	ff		 mov	 DWORD PTR $T215852[ebp], ebx
  00ee4	89 8d 7c ff ff
	ff		 mov	 DWORD PTR $T215852[ebp+4], ecx
  00eea	f3 0f 7e 85 78
	ff ff ff	 movq	 xmm0, QWORD PTR $T215852[ebp]
$LN1433@test_chang:
  00ef2	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  00ef5	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00ef8	66 0f d6 45 9c	 movq	 QWORD PTR $T216237[ebp], xmm0
  00efd	8b 5d a0	 mov	 ebx, DWORD PTR $T216237[ebp+4]
  00f00	89 45 a4	 mov	 DWORD PTR $T216237[ebp+8], eax
  00f03	eb 4e		 jmp	 SHORT $LN1434@test_chang
$LN712@test_chang:
  00f05	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00f08	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00f0b	2b c8		 sub	 ecx, eax
  00f0d	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00f13	0f 83 c9 00 00
	00		 jae	 $LN1327@test_chang
  00f19	8b 4d d4	 mov	 ecx, DWORD PTR _pos$216229[ebp+4]
  00f1c	85 c0		 test	 eax, eax
  00f1e	74 11		 je	 SHORT $LN1011@test_chang
  00f20	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  00f23	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00f26	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  00f29	75 06		 jne	 SHORT $LN1011@test_chang
  00f2b	48		 dec	 eax
  00f2c	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00f2f	eb 07		 jmp	 SHORT $LN1010@test_chang
$LN1011@test_chang:
  00f31	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00f34	40		 inc	 eax
  00f35	89 43 24	 mov	 DWORD PTR [ebx+36], eax
$LN1010@test_chang:
  00f38	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00f3b	03 c9		 add	 ecx, ecx
  00f3d	03 c9		 add	 ecx, ecx
  00f3f	03 c9		 add	 ecx, ecx
  00f41	03 c1		 add	 eax, ecx
  00f43	74 09		 je	 SHORT $LN1097@test_chang
  00f45	89 30		 mov	 DWORD PTR [eax], esi
  00f47	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN1097@test_chang:
  00f4e	8b 5b 34	 mov	 ebx, DWORD PTR [ebx+52]
  00f51	03 d9		 add	 ebx, ecx
$LN1434@test_chang:
  00f53	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN711@test_chang:
  00f59	8b 45 e0	 mov	 eax, DWORD PTR _obj$149756[ebp]
  00f5c	83 45 e8 04	 add	 DWORD PTR tv7454[ebp], 4
  00f60	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00f63	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00f66	40		 inc	 eax
  00f67	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00f6a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00f70	0f 82 7f fd ff
	ff		 jb	 $LL1402@test_chang
$LN158@test_chang:

; 1567 : 	} STOP();

  00f76	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1568 : #endif
; 1569 : 
; 1570 : #ifdef USE_GOOGLEBTREE
; 1571 : 	START(DATA_GOOGLEBTREE) {

  00f7b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00f80	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  00f85	85 c0		 test	 eax, eax
  00f87	0f 84 73 01 00
	00		 je	 $LN153@test_chang
  00f8d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00f94	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f9b	0f 86 5f 01 00
	00		 jbe	 $LN153@test_chang
  00fa1	8b 4d 0c	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  00fa4	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00fa7	2b c1		 sub	 eax, ecx
  00fa9	89 4d fc	 mov	 DWORD PTR tv7494[ebp], ecx
  00fac	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  00faf	eb 62		 jmp	 SHORT $LN155@test_chang
$LN1326@test_chang:

; 1566 : 		(*googledensehash)[key] = obj;

  00fb1	8d 4d dc	 lea	 ecx, DWORD PTR $T213330[ebp]
  00fb4	51		 push	 ecx
  00fb5	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T216124[ebp]
  00fbb	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T213330[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  00fc2	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00fc7	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  00fcc	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T216124[ebp]
  00fd2	52		 push	 edx
  00fd3	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T216124[ebp], OFFSET ??_7length_error@std@@6B@
  00fdd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1436@test_chang:
$LN1327@test_chang:
  00fe2	8d 45 f4	 lea	 eax, DWORD PTR $T214524[ebp]
  00fe5	50		 push	 eax
  00fe6	8d 4d ac	 lea	 ecx, DWORD PTR $T215889[ebp]
  00fe9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T214524[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  00ff0	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00ff5	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  00ffa	8d 4d ac	 lea	 ecx, DWORD PTR $T215889[ebp]
  00ffd	51		 push	 ecx
  00ffe	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T215889[ebp], OFFSET ??_7length_error@std@@6B@
  01005	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1437@test_chang:
  0100a	8d 9b 00 00 00
	00		 npad	 6
$LL1400@test_chang:

; 1568 : #endif
; 1569 : 
; 1570 : #ifdef USE_GOOGLEBTREE
; 1571 : 	START(DATA_GOOGLEBTREE) {

  01010	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN155@test_chang:

; 1572 : 		unsigned key = REMOVE[i];

  01013	8b 55 fc	 mov	 edx, DWORD PTR tv7494[ebp]
  01016	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]

; 1573 : 		googlebtree_t::iterator ptr = googlebtree->find(key);

  01019	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  0101f	83 ec 08	 sub	 esp, 8
  01022	89 45 e8	 mov	 DWORD PTR _key$149779[ebp], eax
  01025	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01027	8b f4		 mov	 esi, esp
  01029	83 ec 08	 sub	 esp, 8
  0102c	8b c4		 mov	 eax, esp
  0102e	8d 7d e8	 lea	 edi, DWORD PTR _key$149779[ebp]
  01031	89 08		 mov	 DWORD PTR [eax], ecx
  01033	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0103a	e8 00 00 00 00	 call	 ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  0103f	8d 45 d0	 lea	 eax, DWORD PTR _ptr$149780[ebp]
  01042	8b d3		 mov	 edx, ebx
  01044	e8 00 00 00 00	 call	 ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end

; 1574 : 		struct google_object* obj;
; 1575 : 		if (ptr == googlebtree->end())

  01049	8b 03		 mov	 eax, DWORD PTR [ebx]
  0104b	85 c0		 test	 eax, eax
  0104d	74 0d		 je	 SHORT $LN1175@test_chang
  0104f	80 38 00	 cmp	 BYTE PTR [eax], 0
  01052	75 08		 jne	 SHORT $LN1175@test_chang
  01054	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  0105a	eb 02		 jmp	 SHORT $LN1187@test_chang
$LN1175@test_chang:
  0105c	8b c8		 mov	 ecx, eax
$LN1187@test_chang:
  0105e	85 c9		 test	 ecx, ecx
  01060	74 1d		 je	 SHORT $LN1171@test_chang
  01062	85 c0		 test	 eax, eax
  01064	74 11		 je	 SHORT $LN1191@test_chang
  01066	80 38 00	 cmp	 BYTE PTR [eax], 0
  01069	75 0c		 jne	 SHORT $LN1191@test_chang
  0106b	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  01071	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  01075	eb 0a		 jmp	 SHORT $LN1172@test_chang
$LN1191@test_chang:
  01077	8b c8		 mov	 ecx, eax
  01079	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0107d	eb 02		 jmp	 SHORT $LN1172@test_chang
$LN1171@test_chang:
  0107f	33 c9		 xor	 ecx, ecx
$LN1172@test_chang:
  01081	85 c0		 test	 eax, eax
  01083	74 0b		 je	 SHORT $LN1209@test_chang
  01085	80 38 00	 cmp	 BYTE PTR [eax], 0
  01088	75 06		 jne	 SHORT $LN1209@test_chang
  0108a	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
$LN1209@test_chang:
  01090	8b 75 d0	 mov	 esi, DWORD PTR _ptr$149780[ebp]
  01093	8b 7d d4	 mov	 edi, DWORD PTR _ptr$149780[ebp+4]
  01096	3b f0		 cmp	 esi, eax
  01098	75 09		 jne	 SHORT $LN152@test_chang
  0109a	3b f9		 cmp	 edi, ecx
  0109c	75 05		 jne	 SHORT $LN152@test_chang

; 1576 : 			abort();

  0109e	e8 00 00 00 00	 call	 _abort
$LN152@test_chang:

; 1577 : 		obj = ptr->second;

  010a3	8b 5c fe 0c	 mov	 ebx, DWORD PTR [esi+edi*8+12]

; 1578 : 		googlebtree->erase(ptr);

  010a7	83 ec 08	 sub	 esp, 8
  010aa	8b c4		 mov	 eax, esp
  010ac	8d 55 c0	 lea	 edx, DWORD PTR $T210101[ebp]
  010af	89 30		 mov	 DWORD PTR [eax], esi
  010b1	89 78 04	 mov	 DWORD PTR [eax+4], edi
  010b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  010b9	52		 push	 edx
  010ba	50		 push	 eax
  010bb	e8 00 00 00 00	 call	 ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase

; 1579 : 
; 1580 : 		key = INSERT[i] + DELTA;

  010c0	8b 4d fc	 mov	 ecx, DWORD PTR tv7494[ebp]
  010c3	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1581 : 		obj->value = key;
; 1582 : 		(*googlebtree)[key] = obj;

  010c5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  010cb	40		 inc	 eax
  010cc	89 45 e8	 mov	 DWORD PTR _key$149779[ebp], eax
  010cf	8d 55 e8	 lea	 edx, DWORD PTR _key$149779[ebp]
  010d2	89 03		 mov	 DWORD PTR [ebx], eax
  010d4	52		 push	 edx
  010d5	8b c2		 mov	 eax, edx
  010d7	50		 push	 eax
  010d8	8d 75 ac	 lea	 esi, DWORD PTR $T216603[ebp]
  010db	e8 00 00 00 00	 call	 ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
  010e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  010e3	8b 10		 mov	 edx, DWORD PTR [eax]
  010e5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  010e8	83 45 fc 04	 add	 DWORD PTR tv7494[ebp], 4
  010ec	40		 inc	 eax
  010ed	89 5c ca 0c	 mov	 DWORD PTR [edx+ecx*8+12], ebx
  010f1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  010f4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  010fa	0f 82 10 ff ff
	ff		 jb	 $LL1400@test_chang
$LN153@test_chang:

; 1583 : 	} STOP();

  01100	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1584 : #endif
; 1585 : 
; 1586 : #ifdef USE_CPPMAP
; 1587 : 	START(DATA_CPPMAP) {

  01105	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  0110a	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  0110f	85 c0		 test	 eax, eax
  01111	74 7d		 je	 SHORT $LN148@test_chang
  01113	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  0111a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01121	76 6d		 jbe	 SHORT $LN148@test_chang
  01123	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  01126	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01129	2b c7		 sub	 eax, edi
  0112b	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  0112e	eb 03		 jmp	 SHORT $LN150@test_chang
$LL1405@test_chang:
  01130	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN150@test_chang:

; 1588 : 		unsigned key = REMOVE[i];

  01133	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]

; 1589 : 		cppmap_t::iterator ptr = cppmap->find(key);

  01136	8d 4d fc	 lea	 ecx, DWORD PTR _key$149807[ebp]
  01139	89 45 fc	 mov	 DWORD PTR _key$149807[ebp], eax
  0113c	51		 push	 ecx
  0113d	8d 45 f4	 lea	 eax, DWORD PTR _ptr$149808[ebp]
  01140	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find

; 1590 : 		struct cpp_object* obj;
; 1591 : 		if (ptr == cppmap->end())

  01145	8b 5d f4	 mov	 ebx, DWORD PTR _ptr$149808[ebp]
  01148	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  0114e	3b 5a 04	 cmp	 ebx, DWORD PTR [edx+4]
  01151	75 05		 jne	 SHORT $LN147@test_chang

; 1592 : 			abort();

  01153	e8 00 00 00 00	 call	 _abort
$LN147@test_chang:

; 1593 : 		obj = ptr->second;
; 1594 : 		cppmap->erase(ptr);

  01158	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  0115e	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  01161	53		 push	 ebx
  01162	8d 45 dc	 lea	 eax, DWORD PTR $T210104[ebp]
  01165	50		 push	 eax
  01166	51		 push	 ecx
  01167	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 1595 : 
; 1596 : 		key = INSERT[i] + DELTA;

  0116c	8b 07		 mov	 eax, DWORD PTR [edi]
  0116e	40		 inc	 eax

; 1597 : 		obj->value = key;
; 1598 : 		(*cppmap)[key] = obj;

  0116f	8d 55 fc	 lea	 edx, DWORD PTR _key$149807[ebp]
  01172	89 45 fc	 mov	 DWORD PTR _key$149807[ebp], eax
  01175	89 06		 mov	 DWORD PTR [esi], eax
  01177	e8 00 00 00 00	 call	 ??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
  0117c	89 30		 mov	 DWORD PTR [eax], esi
  0117e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01181	40		 inc	 eax
  01182	83 c7 04	 add	 edi, 4
  01185	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01188	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0118e	72 a0		 jb	 SHORT $LL1405@test_chang
$LN148@test_chang:

; 1599 : 	} STOP();

  01190	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1600 : #endif
; 1601 : 
; 1602 : #ifdef USE_CPPUNORDEREDMAP
; 1603 : 	START(DATA_CPPUNORDEREDMAP) {

  01195	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  0119a	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  0119f	85 c0		 test	 eax, eax
  011a1	74 78		 je	 SHORT $LN143@test_chang
  011a3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  011aa	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  011b1	76 68		 jbe	 SHORT $LN143@test_chang
  011b3	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  011b6	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  011b9	2b c7		 sub	 eax, edi
  011bb	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  011be	eb 03		 jmp	 SHORT $LN145@test_chang
$LL1406@test_chang:
  011c0	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN145@test_chang:

; 1604 : 		unsigned key = REMOVE[i];

  011c3	8b 14 38	 mov	 edx, DWORD PTR [eax+edi]

; 1605 : 		cppunorderedmap_t::iterator ptr = cppunorderedmap->find(key);

  011c6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  011cc	8d 45 f4	 lea	 eax, DWORD PTR _ptr$149836[ebp]
  011cf	50		 push	 eax
  011d0	8d 45 fc	 lea	 eax, DWORD PTR _key$149835[ebp]
  011d3	8b ce		 mov	 ecx, esi
  011d5	89 55 fc	 mov	 DWORD PTR _key$149835[ebp], edx
  011d8	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1606 : 		struct cpp_object* obj;
; 1607 : 		if (ptr == cppunorderedmap->end())

  011dd	8b 5d f4	 mov	 ebx, DWORD PTR _ptr$149836[ebp]
  011e0	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  011e3	75 05		 jne	 SHORT $LN142@test_chang

; 1608 : 			abort();

  011e5	e8 00 00 00 00	 call	 _abort
$LN142@test_chang:

; 1609 : 		obj = ptr->second;

  011ea	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1610 : 		cppunorderedmap->erase(ptr);

  011ed	53		 push	 ebx
  011ee	8d 4d dc	 lea	 ecx, DWORD PTR $T210107[ebp]
  011f1	51		 push	 ecx
  011f2	e8 00 00 00 00	 call	 ?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 1611 : 
; 1612 : 		key = INSERT[i] + DELTA;

  011f7	8b 07		 mov	 eax, DWORD PTR [edi]
  011f9	40		 inc	 eax
  011fa	89 45 fc	 mov	 DWORD PTR _key$149835[ebp], eax

; 1613 : 		obj->value = key;

  011fd	89 06		 mov	 DWORD PTR [esi], eax

; 1614 : 		(*cppunorderedmap)[key] = obj;

  011ff	8d 45 fc	 lea	 eax, DWORD PTR _key$149835[ebp]
  01202	e8 00 00 00 00	 call	 ??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
  01207	89 30		 mov	 DWORD PTR [eax], esi
  01209	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0120c	40		 inc	 eax
  0120d	83 c7 04	 add	 edi, 4
  01210	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01213	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01219	72 a5		 jb	 SHORT $LL1406@test_chang
$LN143@test_chang:

; 1615 : 	} STOP();

  0121b	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1616 : #endif
; 1617 : 
; 1618 : 	START(DATA_UTHASH) {

  01220	b8 08 00 00 00	 mov	 eax, 8
  01225	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  0122a	85 c0		 test	 eax, eax
  0122c	0f 84 ee 04 00
	00		 je	 $LN138@test_chang
  01232	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  01239	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01240	0f 86 da 04 00
	00		 jbe	 $LN138@test_chang
  01246	8b 4d 0c	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  01249	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  0124c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01252	2b c1		 sub	 eax, ecx
  01254	89 4d fc	 mov	 DWORD PTR tv7627[ebp], ecx
  01257	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  0125a	eb 07		 jmp	 SHORT $LN140@test_chang
  0125c	8d 64 24 00	 npad	 4
$LL1395@test_chang:
  01260	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN140@test_chang:

; 1619 : 		unsigned key = REMOVE[i];

  01263	8b 55 fc	 mov	 edx, DWORD PTR tv7627[ebp]
  01266	8b 1c 10	 mov	 ebx, DWORD PTR [eax+edx]

; 1620 : 		struct uthash_object* obj;
; 1621 : 		HASH_FIND_INT(uthash, &key, obj);

  01269	33 ff		 xor	 edi, edi
  0126b	89 5d e0	 mov	 DWORD PTR _key$149863[ebp], ebx
  0126e	85 f6		 test	 esi, esi
  01270	0f 84 cb 00 00
	00		 je	 $LN1366@test_chang
  01276	0f be 45 e3	 movsx	 eax, BYTE PTR _key$149863[ebp+3]
  0127a	0f be 4d e2	 movsx	 ecx, BYTE PTR _key$149863[ebp+2]
  0127e	c1 e0 18	 shl	 eax, 24			; 00000018H
  01281	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01286	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01289	03 c1		 add	 eax, ecx
  0128b	0f be d7	 movsx	 edx, bh
  0128e	c1 e2 08	 shl	 edx, 8
  01291	03 d0		 add	 edx, eax
  01293	0f be cb	 movsx	 ecx, bl
  01296	03 d1		 add	 edx, ecx
  01298	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  0129e	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  012a4	8b c2		 mov	 eax, edx
  012a6	c1 e0 08	 shl	 eax, 8
  012a9	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  012ae	2b ca		 sub	 ecx, edx
  012b0	33 c8		 xor	 ecx, eax
  012b2	8b f9		 mov	 edi, ecx
  012b4	c1 ef 0d	 shr	 edi, 13			; 0000000dH
  012b7	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  012bc	2b c1		 sub	 eax, ecx
  012be	2b c2		 sub	 eax, edx
  012c0	33 c7		 xor	 eax, edi
  012c2	2b d1		 sub	 edx, ecx
  012c4	2b d0		 sub	 edx, eax
  012c6	8b f8		 mov	 edi, eax
  012c8	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  012cb	33 d7		 xor	 edx, edi
  012cd	2b ca		 sub	 ecx, edx
  012cf	2b c8		 sub	 ecx, eax
  012d1	8b fa		 mov	 edi, edx
  012d3	c1 e7 10	 shl	 edi, 16			; 00000010H
  012d6	33 cf		 xor	 ecx, edi
  012d8	2b c1		 sub	 eax, ecx
  012da	2b c2		 sub	 eax, edx
  012dc	8b f9		 mov	 edi, ecx
  012de	c1 ef 05	 shr	 edi, 5
  012e1	33 c7		 xor	 eax, edi
  012e3	2b d1		 sub	 edx, ecx
  012e5	2b d0		 sub	 edx, eax
  012e7	8b f8		 mov	 edi, eax
  012e9	c1 ef 03	 shr	 edi, 3
  012ec	33 d7		 xor	 edx, edi
  012ee	2b ca		 sub	 ecx, edx
  012f0	2b c8		 sub	 ecx, eax
  012f2	8b fa		 mov	 edi, edx
  012f4	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  012f7	33 cf		 xor	 ecx, edi
  012f9	8b 3e		 mov	 edi, DWORD PTR [esi]
  012fb	2b c1		 sub	 eax, ecx
  012fd	2b c2		 sub	 eax, edx
  012ff	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  01302	33 c1		 xor	 eax, ecx
  01304	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  01307	49		 dec	 ecx
  01308	23 c1		 and	 eax, ecx
  0130a	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0130d	8b 07		 mov	 eax, DWORD PTR [edi]
  0130f	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  01312	85 c0		 test	 eax, eax
  01314	74 29		 je	 SHORT $LN96@test_chang
  01316	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  01319	2b c1		 sub	 eax, ecx
  0131b	8b f8		 mov	 edi, eax
  0131d	85 ff		 test	 edi, edi
  0131f	74 20		 je	 SHORT $LN1366@test_chang
  01321	b8 04 00 00 00	 mov	 eax, 4
$LL100@test_chang:
  01326	39 47 18	 cmp	 DWORD PTR [edi+24], eax
  01329	75 07		 jne	 SHORT $LN97@test_chang
  0132b	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0132e	39 1a		 cmp	 DWORD PTR [edx], ebx
  01330	74 1a		 je	 SHORT $LN90@test_chang
$LN97@test_chang:
  01332	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  01335	85 ff		 test	 edi, edi
  01337	74 06		 je	 SHORT $LN96@test_chang
  01339	2b f9		 sub	 edi, ecx
  0133b	75 e9		 jne	 SHORT $LL100@test_chang
  0133d	eb 02		 jmp	 SHORT $LN1366@test_chang
$LN96@test_chang:
  0133f	33 ff		 xor	 edi, edi
$LN1366@test_chang:

; 1622 : 		if (!obj)
; 1623 : 			abort();

  01341	e8 00 00 00 00	 call	 _abort
  01346	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN90@test_chang:

; 1624 : 		HASH_DEL(uthash, obj);

  0134c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0134f	85 d2		 test	 edx, edx
  01351	75 2a		 jne	 SHORT $LN87@test_chang
  01353	39 57 08	 cmp	 DWORD PTR [edi+8], edx
  01356	75 25		 jne	 SHORT $LN87@test_chang
  01358	8b 06		 mov	 eax, DWORD PTR [esi]
  0135a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0135c	51		 push	 ecx
  0135d	e8 00 00 00 00	 call	 _free
  01362	8b 16		 mov	 edx, DWORD PTR [esi]
  01364	83 c4 04	 add	 esp, 4
  01367	52		 push	 edx
  01368	e8 00 00 00 00	 call	 _free
  0136d	83 c4 04	 add	 esp, 4
  01370	33 f6		 xor	 esi, esi
  01372	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
  01378	e9 8c 00 00 00	 jmp	 $LN89@test_chang
$LN87@test_chang:
  0137d	8b 06		 mov	 eax, DWORD PTR [esi]
  0137f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01382	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  01385	2b d9		 sub	 ebx, ecx
  01387	3b fb		 cmp	 edi, ebx
  01389	75 05		 jne	 SHORT $LN85@test_chang
  0138b	03 d1		 add	 edx, ecx
  0138d	89 50 10	 mov	 DWORD PTR [eax+16], edx
$LN85@test_chang:
  01390	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  01393	85 c0		 test	 eax, eax
  01395	74 0e		 je	 SHORT $LN82@test_chang
  01397	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01399	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0139c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0139f	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  013a3	eb 09		 jmp	 SHORT $LN80@test_chang
$LN82@test_chang:
  013a5	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  013a8	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
$LN80@test_chang:
  013ae	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  013b1	85 c0		 test	 eax, eax
  013b3	74 0c		 je	 SHORT $LN78@test_chang
  013b5	8b 16		 mov	 edx, DWORD PTR [esi]
  013b7	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  013ba	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  013bd	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
$LN78@test_chang:
  013c1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  013c3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  013c6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  013c8	48		 dec	 eax
  013c9	23 47 1c	 and	 eax, DWORD PTR [edi+28]
  013cc	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  013cf	03 c0		 add	 eax, eax
  013d1	03 c0		 add	 eax, eax
  013d3	ff 4c 01 04	 dec	 DWORD PTR [ecx+eax+4]
  013d7	8b 16		 mov	 edx, DWORD PTR [esi]
  013d9	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  013dd	8b 0a		 mov	 ecx, DWORD PTR [edx]
  013df	39 3c 08	 cmp	 DWORD PTR [eax+ecx], edi
  013e2	75 06		 jne	 SHORT $LN75@test_chang
  013e4	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  013e7	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
$LN75@test_chang:
  013ea	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  013ed	85 c0		 test	 eax, eax
  013ef	74 06		 je	 SHORT $LN74@test_chang
  013f1	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  013f4	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN74@test_chang:
  013f7	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  013fa	85 c0		 test	 eax, eax
  013fc	74 06		 je	 SHORT $LN73@test_chang
  013fe	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  01401	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN73@test_chang:
  01404	8b 06		 mov	 eax, DWORD PTR [esi]
  01406	ff 48 0c	 dec	 DWORD PTR [eax+12]
$LN89@test_chang:

; 1625 : 
; 1626 : 		key = INSERT[i] + DELTA;

  01409	8b 45 fc	 mov	 eax, DWORD PTR tv7627[ebp]
  0140c	8b 00		 mov	 eax, DWORD PTR [eax]
  0140e	40		 inc	 eax

; 1627 : 		obj->value = key;

  0140f	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  01412	89 03		 mov	 DWORD PTR [ebx], eax

; 1628 : 		HASH_ADD_INT(uthash, value, obj);

  01414	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0141b	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  0141e	c7 47 18 04 00
	00 00		 mov	 DWORD PTR [edi+24], 4
  01425	85 f6		 test	 esi, esi
  01427	0f 85 89 00 00
	00		 jne	 $LN69@test_chang
  0142d	8b f7		 mov	 esi, edi
  0142f	6a 2c		 push	 44			; 0000002cH
  01431	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
  01437	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0143e	e8 00 00 00 00	 call	 _malloc
  01443	83 c4 04	 add	 esp, 4
  01446	89 07		 mov	 DWORD PTR [edi], eax
  01448	85 c0		 test	 eax, eax
  0144a	0f 84 bb 03 00
	00		 je	 $LN1329@test_chang
  01450	6a 2c		 push	 44			; 0000002cH
  01452	6a 00		 push	 0
  01454	50		 push	 eax
  01455	e8 00 00 00 00	 call	 _memset
  0145a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0145c	89 79 10	 mov	 DWORD PTR [ecx+16], edi
  0145f	8b 17		 mov	 edx, DWORD PTR [edi]
  01461	c7 42 04 20 00
	00 00		 mov	 DWORD PTR [edx+4], 32	; 00000020H
  01468	8b 07		 mov	 eax, DWORD PTR [edi]
  0146a	c7 40 08 05 00
	00 00		 mov	 DWORD PTR [eax+8], 5
  01471	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01473	83 c4 0c	 add	 esp, 12			; 0000000cH
  01476	68 80 01 00 00	 push	 384			; 00000180H
  0147b	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  01482	e8 00 00 00 00	 call	 _malloc
  01487	8b 17		 mov	 edx, DWORD PTR [edi]
  01489	89 02		 mov	 DWORD PTR [edx], eax
  0148b	8b 07		 mov	 eax, DWORD PTR [edi]
  0148d	83 c4 04	 add	 esp, 4
  01490	83 38 00	 cmp	 DWORD PTR [eax], 0
  01493	0f 84 72 03 00
	00		 je	 $LN1329@test_chang
  01499	8b 00		 mov	 eax, DWORD PTR [eax]
  0149b	68 80 01 00 00	 push	 384			; 00000180H
  014a0	6a 00		 push	 0
  014a2	50		 push	 eax
  014a3	e8 00 00 00 00	 call	 _memset
  014a8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  014aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  014ad	c7 41 28 e1 1f
	11 a0		 mov	 DWORD PTR [ecx+40], -1609490463 ; a0111fe1H
  014b4	eb 18		 jmp	 SHORT $LN63@test_chang
$LN69@test_chang:
  014b6	8b 16		 mov	 edx, DWORD PTR [esi]
  014b8	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  014bb	89 78 08	 mov	 DWORD PTR [eax+8], edi
  014be	8b 06		 mov	 eax, DWORD PTR [esi]
  014c0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  014c3	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  014c6	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  014c9	8b 16		 mov	 edx, DWORD PTR [esi]
  014cb	89 7a 10	 mov	 DWORD PTR [edx+16], edi
$LN63@test_chang:
  014ce	8b 06		 mov	 eax, DWORD PTR [esi]
  014d0	ff 40 0c	 inc	 DWORD PTR [eax+12]
  014d3	8b 06		 mov	 eax, DWORD PTR [esi]
  014d5	89 07		 mov	 DWORD PTR [edi], eax
  014d7	ba f3 be ed fe	 mov	 edx, -17973517		; feedbef3H
  014dc	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  014df	0f be 43 03	 movsx	 eax, BYTE PTR [ebx+3]
  014e3	0f be 4b 02	 movsx	 ecx, BYTE PTR [ebx+2]
  014e7	c1 e0 18	 shl	 eax, 24			; 00000018H
  014ea	c1 e1 10	 shl	 ecx, 16			; 00000010H
  014ed	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  014f2	03 c1		 add	 eax, ecx
  014f4	0f be 4b 01	 movsx	 ecx, BYTE PTR [ebx+1]
  014f8	c1 e1 08	 shl	 ecx, 8
  014fb	03 c1		 add	 eax, ecx
  014fd	0f be 0b	 movsx	 ecx, BYTE PTR [ebx]
  01500	03 c8		 add	 ecx, eax
  01502	81 c1 54 c7 da
	62		 add	 ecx, 1658505044		; 62dac754H
  01508	81 f1 6d f7 07
	00		 xor	 ecx, 522093		; 0007f76dH
  0150e	8b d9		 mov	 ebx, ecx
  01510	c1 e3 08	 shl	 ebx, 8
  01513	b8 c6 ba 49 9f	 mov	 eax, -1622558010	; 9f49bac6H
  01518	2b c1		 sub	 eax, ecx
  0151a	33 c3		 xor	 eax, ebx
  0151c	2b d0		 sub	 edx, eax
  0151e	2b d1		 sub	 edx, ecx
  01520	8b d8		 mov	 ebx, eax
  01522	c1 eb 0d	 shr	 ebx, 13			; 0000000dH
  01525	33 d3		 xor	 edx, ebx
  01527	2b ca		 sub	 ecx, edx
  01529	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  0152c	2b c8		 sub	 ecx, eax
  0152e	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  01531	33 ca		 xor	 ecx, edx
  01533	2b c1		 sub	 eax, ecx
  01535	2b 47 1c	 sub	 eax, DWORD PTR [edi+28]
  01538	8b d1		 mov	 edx, ecx
  0153a	c1 e2 10	 shl	 edx, 16			; 00000010H
  0153d	33 c2		 xor	 eax, edx
  0153f	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01542	2b d0		 sub	 edx, eax
  01544	2b d1		 sub	 edx, ecx
  01546	8b d8		 mov	 ebx, eax
  01548	c1 eb 05	 shr	 ebx, 5
  0154b	33 d3		 xor	 edx, ebx
  0154d	2b ca		 sub	 ecx, edx
  0154f	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01552	2b c8		 sub	 ecx, eax
  01554	c1 ea 03	 shr	 edx, 3
  01557	33 ca		 xor	 ecx, edx
  01559	2b c1		 sub	 eax, ecx
  0155b	2b 47 1c	 sub	 eax, DWORD PTR [edi+28]
  0155e	8b d1		 mov	 edx, ecx
  01560	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  01563	33 c2		 xor	 eax, edx
  01565	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01568	2b d0		 sub	 edx, eax
  0156a	2b d1		 sub	 edx, ecx
  0156c	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  0156f	33 d0		 xor	 edx, eax
  01571	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01574	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01576	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01579	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0157b	48		 dec	 eax
  0157c	23 c2		 and	 eax, edx
  0157e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01581	03 c0		 add	 eax, eax
  01583	03 c0		 add	 eax, eax
  01585	ff 44 01 04	 inc	 DWORD PTR [ecx+eax+4]
  01589	8b 16		 mov	 edx, DWORD PTR [esi]
  0158b	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  0158f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01591	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  01594	89 57 10	 mov	 DWORD PTR [edi+16], edx
  01597	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  0159e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  015a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  015a2	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  015a5	85 c9		 test	 ecx, ecx
  015a7	74 03		 je	 SHORT $LN35@test_chang
  015a9	89 79 0c	 mov	 DWORD PTR [ecx+12], edi
$LN35@test_chang:
  015ac	8b 0e		 mov	 ecx, DWORD PTR [esi]
  015ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  015b0	89 3c 10	 mov	 DWORD PTR [eax+edx], edi
  015b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  015b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  015b7	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  015bb	8d 4c 89 05	 lea	 ecx, DWORD PTR [ecx+ecx*4+5]
  015bf	03 c9		 add	 ecx, ecx
  015c1	39 4c 10 04	 cmp	 DWORD PTR [eax+edx+4], ecx
  015c5	0f 82 3e 01 00
	00		 jb	 $LN31@test_chang
  015cb	8b 07		 mov	 eax, DWORD PTR [edi]
  015cd	83 78 24 01	 cmp	 DWORD PTR [eax+36], 1
  015d1	0f 84 32 01 00
	00		 je	 $LN31@test_chang
  015d7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  015da	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  015dd	03 db		 add	 ebx, ebx
  015df	03 db		 add	 ebx, ebx
  015e1	03 db		 add	 ebx, ebx
  015e3	53		 push	 ebx
  015e4	e8 00 00 00 00	 call	 _malloc
  015e9	83 c4 04	 add	 esp, 4
  015ec	89 45 e4	 mov	 DWORD PTR __he_new_buckets$150067[ebp], eax
  015ef	85 c0		 test	 eax, eax
  015f1	0f 84 14 02 00
	00		 je	 $LN1329@test_chang
  015f7	53		 push	 ebx
  015f8	6a 00		 push	 0
  015fa	50		 push	 eax
  015fb	e8 00 00 00 00	 call	 _memset
  01600	8b 07		 mov	 eax, DWORD PTR [edi]
  01602	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01605	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01608	41		 inc	 ecx
  01609	8b da		 mov	 ebx, edx
  0160b	d3 eb		 shr	 ebx, cl
  0160d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01610	8d 4c 09 ff	 lea	 ecx, DWORD PTR [ecx+ecx-1]
  01614	23 ca		 and	 ecx, edx
  01616	83 c4 0c	 add	 esp, 12			; 0000000cH
  01619	f7 d9		 neg	 ecx
  0161b	1b c9		 sbb	 ecx, ecx
  0161d	f7 d9		 neg	 ecx
  0161f	03 d9		 add	 ebx, ecx
  01621	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  01624	8b 17		 mov	 edx, DWORD PTR [edi]
  01626	33 c0		 xor	 eax, eax
  01628	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  0162b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0162d	89 45 e0	 mov	 DWORD PTR __he_bkt_i$150064[ebp], eax
  01630	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  01633	0f 86 86 00 00
	00		 jbe	 $LN27@test_chang
  01639	89 45 e8	 mov	 DWORD PTR tv7597[ebp], eax
  0163c	8d 64 24 00	 npad	 4
$LL29@test_chang:
  01640	8b 17		 mov	 edx, DWORD PTR [edi]
  01642	8b 02		 mov	 eax, DWORD PTR [edx]
  01644	8b 4d e8	 mov	 ecx, DWORD PTR tv7597[ebp]
  01647	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  0164a	85 db		 test	 ebx, ebx
  0164c	74 5f		 je	 SHORT $LN28@test_chang
  0164e	8b ff		 npad	 2
$LL26@test_chang:
  01650	8b 07		 mov	 eax, DWORD PTR [edi]
  01652	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01655	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  01658	8d 44 00 ff	 lea	 eax, DWORD PTR [eax+eax-1]
  0165c	23 43 1c	 and	 eax, DWORD PTR [ebx+28]
  0165f	89 55 f4	 mov	 DWORD PTR __he_hh_nxt$150066[ebp], edx
  01662	8b 55 e4	 mov	 edx, DWORD PTR __he_new_buckets$150067[ebp]
  01665	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01668	ff 44 8a 04	 inc	 DWORD PTR [edx+ecx*4+4]
  0166c	8b 07		 mov	 eax, DWORD PTR [edi]
  0166e	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  01671	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01674	3b 50 18	 cmp	 edx, DWORD PTR [eax+24]
  01677	76 16		 jbe	 SHORT $LN21@test_chang
  01679	ff 40 1c	 inc	 DWORD PTR [eax+28]
  0167c	8b 37		 mov	 esi, DWORD PTR [edi]
  0167e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01681	33 d2		 xor	 edx, edx
  01683	f7 76 18	 div	 DWORD PTR [esi+24]
  01686	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  0168c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN21@test_chang:
  0168f	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  01696	8b 01		 mov	 eax, DWORD PTR [ecx]
  01698	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0169b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0169d	85 c0		 test	 eax, eax
  0169f	74 03		 je	 SHORT $LN20@test_chang
  016a1	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
$LN20@test_chang:
  016a4	89 19		 mov	 DWORD PTR [ecx], ebx
  016a6	8b 5d f4	 mov	 ebx, DWORD PTR __he_hh_nxt$150066[ebp]
  016a9	85 db		 test	 ebx, ebx
  016ab	75 a3		 jne	 SHORT $LL26@test_chang
$LN28@test_chang:
  016ad	8b 45 e0	 mov	 eax, DWORD PTR __he_bkt_i$150064[ebp]
  016b0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  016b2	83 45 e8 0c	 add	 DWORD PTR tv7597[ebp], 12 ; 0000000cH
  016b6	40		 inc	 eax
  016b7	89 45 e0	 mov	 DWORD PTR __he_bkt_i$150064[ebp], eax
  016ba	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  016bd	72 81		 jb	 SHORT $LL29@test_chang
$LN27@test_chang:
  016bf	8b 17		 mov	 edx, DWORD PTR [edi]
  016c1	8b 02		 mov	 eax, DWORD PTR [edx]
  016c3	50		 push	 eax
  016c4	e8 00 00 00 00	 call	 _free
  016c9	8b 07		 mov	 eax, DWORD PTR [edi]
  016cb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  016ce	03 c9		 add	 ecx, ecx
  016d0	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  016d3	8b 07		 mov	 eax, DWORD PTR [edi]
  016d5	8b 4d e4	 mov	 ecx, DWORD PTR __he_new_buckets$150067[ebp]
  016d8	ba 01 00 00 00	 mov	 edx, 1
  016dd	01 50 08	 add	 DWORD PTR [eax+8], edx
  016e0	8b 07		 mov	 eax, DWORD PTR [edi]
  016e2	89 08		 mov	 DWORD PTR [eax], ecx
  016e4	8b 07		 mov	 eax, DWORD PTR [edi]
  016e6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  016e9	d1 e9		 shr	 ecx, 1
  016eb	83 c4 04	 add	 esp, 4
  016ee	39 48 1c	 cmp	 DWORD PTR [eax+28], ecx
  016f1	76 07		 jbe	 SHORT $LN200@test_chang
  016f3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  016f6	03 ca		 add	 ecx, edx
  016f8	eb 02		 jmp	 SHORT $LN201@test_chang
$LN200@test_chang:
  016fa	33 c9		 xor	 ecx, ecx
$LN201@test_chang:
  016fc	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  016ff	8b 3f		 mov	 edi, DWORD PTR [edi]
  01701	39 57 20	 cmp	 DWORD PTR [edi+32], edx
  01704	76 03		 jbe	 SHORT $LN31@test_chang
  01706	89 57 24	 mov	 DWORD PTR [edi+36], edx
$LN31@test_chang:

; 1616 : #endif
; 1617 : 
; 1618 : 	START(DATA_UTHASH) {

  01709	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0170c	83 45 fc 04	 add	 DWORD PTR tv7627[ebp], 4
  01710	40		 inc	 eax
  01711	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01714	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0171a	0f 82 40 fb ff
	ff		 jb	 $LL1395@test_chang
$LN138@test_chang:

; 1629 : 	} STOP();

  01720	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1630 : 
; 1631 : #ifdef USE_JUDY
; 1632 : 	START(DATA_JUDY) {

  01725	b8 09 00 00 00	 mov	 eax, 9
  0172a	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  0172f	85 c0		 test	 eax, eax
  01731	0f 84 a2 00 00
	00		 je	 $LN15@test_chang
  01737	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  0173e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01745	0f 86 8e 00 00
	00		 jbe	 $LN15@test_chang
  0174b	8b 5d 0c	 mov	 ebx, DWORD PTR _INSERT$[ebp]
  0174e	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01751	2b c3		 sub	 eax, ebx
  01753	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  01756	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL17@test_chang:

; 1633 : 		Word_t key = REMOVE[i];

  01760	8b 55 ec	 mov	 edx, DWORD PTR tv7146[ebp]
  01763	8b 3c 1a	 mov	 edi, DWORD PTR [edx+ebx]

; 1634 : 		struct judy_object* obj;
; 1635 : 		int r;
; 1636 : 		Pvoid_t PValue;
; 1637 : 		JLG(PValue, judy, key);

  01766	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judy@@3PAXA ; judy
  0176b	6a 00		 push	 0
  0176d	57		 push	 edi
  0176e	50		 push	 eax
  0176f	e8 00 00 00 00	 call	 _JudyLGet
  01774	8b f0		 mov	 esi, eax
  01776	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 		if (!PValue)

  01779	85 f6		 test	 esi, esi
  0177b	75 05		 jne	 SHORT $LN14@test_chang

; 1639 : 			abort();

  0177d	e8 00 00 00 00	 call	 _abort
$LN14@test_chang:

; 1640 : 		obj = *(struct judy_object**)PValue;

  01782	8b 36		 mov	 esi, DWORD PTR [esi]

; 1641 : 		JLD(r, judy, key);

  01784	8d 4d 94	 lea	 ecx, DWORD PTR _J_Error$150098[ebp]
  01787	51		 push	 ecx
  01788	57		 push	 edi
  01789	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  0178e	e8 00 00 00 00	 call	 _JudyLDel
  01793	83 c4 0c	 add	 esp, 12			; 0000000cH
  01796	83 f8 ff	 cmp	 eax, -1
  01799	74 77		 je	 SHORT $LN1332@test_chang

; 1642 : 		if (r != 1)

  0179b	83 f8 01	 cmp	 eax, 1
  0179e	74 05		 je	 SHORT $LN12@test_chang

; 1643 : 			abort();

  017a0	e8 00 00 00 00	 call	 _abort
$LN12@test_chang:

; 1644 : 
; 1645 : 		key = INSERT[i] + DELTA;

  017a5	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1646 : 		obj->value = key;
; 1647 : 		JLI(PValue, judy, key);

  017a7	8d 55 94	 lea	 edx, DWORD PTR _J_Error$150105[ebp]
  017aa	40		 inc	 eax
  017ab	52		 push	 edx
  017ac	50		 push	 eax
  017ad	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  017b2	89 06		 mov	 DWORD PTR [esi], eax
  017b4	e8 00 00 00 00	 call	 _JudyLIns
  017b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  017bc	83 f8 ff	 cmp	 eax, -1
  017bf	0f 84 81 00 00
	00		 je	 $LN1333@test_chang

; 1648 : 		*(struct judy_object**)PValue = obj;

  017c5	89 30		 mov	 DWORD PTR [eax], esi
  017c7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  017ca	40		 inc	 eax
  017cb	83 c3 04	 add	 ebx, 4
  017ce	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  017d1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  017d7	72 87		 jb	 SHORT $LL17@test_chang
$LN15@test_chang:

; 1649 : 	} STOP();

  017d9	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1650 : #endif
; 1651 : 
; 1652 : #ifdef USE_JUDYARRAY
; 1653 : 	START(DATA_JUDYARRAY) {

  017de	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  017e3	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  017e8	85 c0		 test	 eax, eax
  017ea	0f 84 bd 00 00
	00		 je	 $LN7@test_chang
  017f0	33 db		 xor	 ebx, ebx
  017f2	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  017f8	0f 86 af 00 00
	00		 jbe	 $LN7@test_chang
  017fe	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  01801	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01804	2b c7		 sub	 eax, edi
  01806	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
  01809	eb 5c		 jmp	 SHORT $LN9@test_chang
$LN1329@test_chang:

; 1628 : 		HASH_ADD_INT(uthash, value, obj);

  0180b	6a ff		 push	 -1
  0180d	e8 00 00 00 00	 call	 _exit
$LN1438@test_chang:
$LN1332@test_chang:

; 1641 : 		JLD(r, judy, key);

  01812	8b 45 98	 mov	 eax, DWORD PTR _J_Error$150098[ebp+4]
  01815	8b 4d 94	 mov	 ecx, DWORD PTR _J_Error$150098[ebp]
  01818	50		 push	 eax
  01819	51		 push	 ecx
  0181a	68 00 00 00 00	 push	 OFFSET $SG-108
  0181f	68 69 06 00 00	 push	 1641			; 00000669H
  01824	68 00 00 00 00	 push	 OFFSET $SG-109
  01829	68 00 00 00 00	 push	 OFFSET $SG-110
$LN1435@test_chang:
  0182e	e8 00 00 00 00	 call	 ___iob_func
  01833	83 c0 40	 add	 eax, 64			; 00000040H
  01836	50		 push	 eax
  01837	e8 00 00 00 00	 call	 _fprintf
  0183c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0183f	6a 01		 push	 1
  01841	e8 00 00 00 00	 call	 _exit
$LN1439@test_chang:
$LN1333@test_chang:

; 1646 : 		obj->value = key;
; 1647 : 		JLI(PValue, judy, key);

  01846	8b 55 98	 mov	 edx, DWORD PTR _J_Error$150105[ebp+4]
  01849	8b 45 94	 mov	 eax, DWORD PTR _J_Error$150105[ebp]
  0184c	52		 push	 edx
  0184d	50		 push	 eax
  0184e	68 00 00 00 00	 push	 OFFSET $SG-111
  01853	68 6f 06 00 00	 push	 1647			; 0000066fH
  01858	68 00 00 00 00	 push	 OFFSET $SG-112
  0185d	68 00 00 00 00	 push	 OFFSET $SG-113
  01862	eb ca		 jmp	 SHORT $LN1435@test_chang
$LL1411@test_chang:

; 1650 : #endif
; 1651 : 
; 1652 : #ifdef USE_JUDYARRAY
; 1653 : 	START(DATA_JUDYARRAY) {

  01864	8b 45 ec	 mov	 eax, DWORD PTR tv7146[ebp]
$LN9@test_chang:

; 1654 : 		judyvalue key = REMOVE[i];

  01867	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]

; 1655 : 		struct judyarray_object* obj;
; 1656 : 		JudySlot* pvalue;
; 1657 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  0186a	8d 55 fc	 lea	 edx, DWORD PTR _key$150118[ebp]
  0186d	52		 push	 edx
  0186e	89 4d fc	 mov	 DWORD PTR _key$150118[ebp], ecx
  01871	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  01876	8b f0		 mov	 esi, eax
  01878	83 c4 04	 add	 esp, 4

; 1658 : 		if (!pvalue)

  0187b	85 f6		 test	 esi, esi
  0187d	75 05		 jne	 SHORT $LN6@test_chang

; 1659 : 			abort();

  0187f	e8 00 00 00 00	 call	 _abort
$LN6@test_chang:

; 1660 : 		obj = *(struct judyarray_object**)pvalue;

  01884	8b 36		 mov	 esi, DWORD PTR [esi]

; 1661 : 		judy_del(judyarray);

  01886	e8 00 00 00 00	 call	 ?judy_del@@YAPAIPAUJudy@@@Z ; judy_del

; 1662 : 
; 1663 : 		key = INSERT[i] + DELTA;

  0188b	8b 07		 mov	 eax, DWORD PTR [edi]
  0188d	40		 inc	 eax
  0188e	89 45 fc	 mov	 DWORD PTR _key$150118[ebp], eax

; 1664 : 		obj->value = key;

  01891	89 06		 mov	 DWORD PTR [esi], eax

; 1665 : 		pvalue = judy_cell(judyarray, (uchar*)&key, 0);

  01893	8d 45 fc	 lea	 eax, DWORD PTR _key$150118[ebp]
  01896	50		 push	 eax
  01897	e8 00 00 00 00	 call	 ?judy_cell@@YAPAIPAUJudy@@PAEI@Z ; judy_cell
  0189c	43		 inc	 ebx
  0189d	83 c4 04	 add	 esp, 4
  018a0	83 c7 04	 add	 edi, 4

; 1666 : 		*(struct judyarray_object**)pvalue = obj;

  018a3	89 30		 mov	 DWORD PTR [eax], esi
  018a5	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  018ab	72 b7		 jb	 SHORT $LL1411@test_chang
$LN7@test_chang:

; 1667 : 	} STOP();

  018ad	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1668 : #endif
; 1669 : 
; 1670 : 	START(DATA_NEDTRIE) {

  018b2	b8 06 00 00 00	 mov	 eax, 6
  018b7	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  018bc	85 c0		 test	 eax, eax
  018be	74 4f		 je	 SHORT $LN2@test_chang
  018c0	33 db		 xor	 ebx, ebx
  018c2	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  018c8	76 45		 jbe	 SHORT $LN2@test_chang
  018ca	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  018cd	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  018d0	2b c7		 sub	 eax, edi
  018d2	89 45 ec	 mov	 DWORD PTR tv7146[ebp], eax
$LL4@test_chang:

; 1671 : 		unsigned key = REMOVE[i];
; 1672 : 		struct nedtrie_object key_obj;
; 1673 : 		struct nedtrie_object* obj;
; 1674 : 		key_obj.value = key;

  018d5	8b 4d ec	 mov	 ecx, DWORD PTR tv7146[ebp]
  018d8	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]

; 1675 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  018db	8d 45 84	 lea	 eax, DWORD PTR _key_obj$150131[ebp]
  018de	89 55 98	 mov	 DWORD PTR _key_obj$150131[ebp+20], edx
  018e1	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z ; nedtrie_t_NEDTRIE_FIND
  018e6	8b f0		 mov	 esi, eax

; 1676 : 		if (!obj)

  018e8	85 f6		 test	 esi, esi
  018ea	75 05		 jne	 SHORT $LN1@test_chang

; 1677 : 			abort();

  018ec	e8 00 00 00 00	 call	 _abort
$LN1@test_chang:

; 1678 : 		NEDTRIE_REMOVE(nedtrie_t, &nedtrie, obj);

  018f1	8b d6		 mov	 edx, esi
  018f3	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_REMOVE

; 1679 : 
; 1680 : 		key = INSERT[i] + DELTA;

  018f8	8b 07		 mov	 eax, DWORD PTR [edi]
  018fa	40		 inc	 eax

; 1681 : 		obj->value = key;

  018fb	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1682 : 		NEDTRIE_INSERT(nedtrie_t, &nedtrie, obj);

  018fe	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_INSERT
  01903	43		 inc	 ebx
  01904	83 c7 04	 add	 edi, 4
  01907	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  0190d	72 c6		 jb	 SHORT $LL4@test_chang
$LN2@test_chang:

; 1683 : 	} STOP();

  0190f	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1684 : }

  01914	5f		 pop	 edi
  01915	5e		 pop	 esi
  01916	5b		 pop	 ebx
  01917	8b e5		 mov	 esp, ebp
  01919	5d		 pop	 ebp
  0191a	c3		 ret	 0
$LN1430@test_chang:
?test_change@@YAXPAI0@Z ENDP				; test_change
_TEXT	ENDS
PUBLIC	?test_insert@@YAXPAI@Z				; test_insert
; Function compile flags: /Ogtp
;	COMDAT ?test_insert@@YAXPAI@Z
_TEXT	SEGMENT
_J_Error$148522 = -132					; size = 24
$T220295 = -124						; size = 16
$T220755 = -108						; size = 12
$T220561 = -108						; size = 12
$T220501 = -96						; size = 12
$T220552 = -84						; size = 12
$T220544 = -72						; size = 12
$T221816 = -60						; size = 8
$T221793 = -60						; size = 8
$T221770 = -60						; size = 8
_t$221800 = -60						; size = 8
$T221747 = -60						; size = 8
$T221718 = -60						; size = 8
$T221112 = -60						; size = 8
$T221021 = -60						; size = 8
$T220774 = -60						; size = 8
$T220725 = -60						; size = 8
_pos$220253 = -60					; size = 8
_t$221823 = -52						; size = 8
_t$221777 = -52						; size = 8
_t$221754 = -52						; size = 8
_t$221118 = -52						; size = 8
_t$220781 = -52						; size = 8
_t$220732 = -52						; size = 8
_pos$220361 = -52					; size = 8
$T221720 = -44						; size = 8
_t$217315 = -44						; size = 8
tv3500 = -36						; size = 8
tv3488 = -36						; size = 8
tv3474 = -36						; size = 8
tv3469 = -36						; size = 8
tv3451 = -36						; size = 8
tv3381 = -36						; size = 8
tv2603 = -36						; size = 8
tv1188 = -36						; size = 8
$T217308 = -36						; size = 8
$T217281 = -36						; size = 8
tv1085 = -36						; size = 8
tv995 = -36						; size = 8
tv960 = -36						; size = 8
$T217217 = -36						; size = 8
$T217188 = -36						; size = 8
$T217056 = -36						; size = 8
$T216983 = -36						; size = 8
tv292 = -36						; size = 8
tv69 = -36						; size = 8
tv5725 = -32						; size = 4
$T221101 = -32						; size = 4
$T218971 = -32						; size = 4
_key$148535 = -32					; size = 4
__he_hh_nxt$148492 = -32				; size = 4
_key$148398 = -32					; size = 4
_t$217288 = -28						; size = 8
_t$217224 = -28						; size = 8
_t$217195 = -28						; size = 8
_t$217065 = -28						; size = 8
_t$216990 = -28						; size = 8
$T221735 = -24						; size = 4
$T221024 = -24						; size = 4
$T217777 = -24						; size = 4
tv5783 = -20						; size = 4
tv5754 = -20						; size = 4
$T220536 = -20						; size = 4
_count$217147 = -20					; size = 4
__he_new_buckets$148493 = -20				; size = 4
_key$148380 = -20					; size = 4
_r$148374 = -20						; size = 4
tv5696 = -16						; size = 4
__Where$221624 = -16					; size = 4
__he_bkt_i$148490 = -16					; size = 4
tv5800 = -12						; size = 4
tv5771 = -12						; size = 4
tv5742 = -12						; size = 4
tv5713 = -12						; size = 4
tv5684 = -12						; size = 4
tv5488 = -12						; size = 4
$T217249 = -12						; size = 4
_count$217161 = -8					; size = 4
_key$148386 = -8					; size = 4
_i$ = -8						; size = 4
_INSERT$ = 8						; size = 4
?test_insert@@YAXPAI@Z PROC				; test_insert, COMDAT

; 906  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx

; 907  : 	unsigned i;
; 908  : 
; 909  : 	START(DATA_TREE) {

  0000a	b8 05 00 00 00	 mov	 eax, 5
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0001c	75 71		 jne	 SHORT $LN113@test_inser
  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00025	75 2e		 jne	 SHORT $LN121@test_inser
  00027	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00032	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00039	50		 push	 eax
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0003f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00046	52		 push	 edx
  00047	51		 push	 ecx
  00048	68 00 00 00 00	 push	 OFFSET $SG-100
  0004d	e8 00 00 00 00	 call	 _printf
  00052	83 c4 10	 add	 esp, 16			; 00000010H
$LN121@test_inser:
  00055	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00060	33 f6		 xor	 esi, esi
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00067	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  0006d	85 db		 test	 ebx, ebx
  0006f	74 1e		 je	 SHORT $LN113@test_inser
  00071	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?RBTREE@@3PAUrbt_object@@A ; RBTREE
$LL115@test_inser:

; 910  : 		unsigned key = INSERT[i];
; 911  : 		RBTREE[i].value = key;

  00077	8b 55 08	 mov	 edx, DWORD PTR _INSERT$[ebp]
  0007a	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  0007d	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 912  : 		rbt_insert(&tree, &RBTREE[i]);

  00080	8b c7		 mov	 eax, edi
  00082	e8 00 00 00 00	 call	 ?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_insert
  00087	46		 inc	 esi
  00088	83 c7 1c	 add	 edi, 28			; 0000001cH
  0008b	3b f3		 cmp	 esi, ebx
  0008d	72 e8		 jb	 SHORT $LL115@test_inser
$LN113@test_inser:

; 913  : 	} STOP();

  0008f	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 914  : 
; 915  : 	START(DATA_HASHTABLE) {

  00094	33 db		 xor	 ebx, ebx
  00096	89 1d 00 00 00
	00		 mov	 DWORD PTR ?the_start_data@@3IA, ebx ; the_start_data
  0009c	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, ebx ; the_data
  000a2	0f 85 e9 00 00
	00		 jne	 $LN109@test_inser
  000a8	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_log@@3HA, ebx ; the_log
  000ae	75 30		 jne	 SHORT $LN127@test_inser
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA
  000b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  000bc	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  000c3	51		 push	 ecx
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  000ca	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	68 00 00 00 00	 push	 OFFSET $SG-100
  000d8	e8 00 00 00 00	 call	 _printf
  000dd	83 c4 10	 add	 esp, 16			; 00000010H
$LN127@test_inser:
  000e0	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  000e5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  000eb	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  000f0	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  000f6	3b f3		 cmp	 esi, ebx
  000f8	0f 86 93 00 00
	00		 jbe	 $LN109@test_inser
  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HASHTABLE@@3PAUhashtable_object@@A ; HASHTABLE
$LL111@test_inser:

; 916  : 		unsigned key = INSERT[i];

  00104	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00107	8b 3c 98	 mov	 edi, DWORD PTR [eax+ebx*4]

; 917  : 		unsigned hash_key = hash(key);

  0010a	8b d7		 mov	 edx, edi
  0010c	c1 e2 06	 shl	 edx, 6
  0010f	8b c7		 mov	 eax, edi
  00111	2b c2		 sub	 eax, edx
  00113	8b d0		 mov	 edx, eax
  00115	c1 ea 11	 shr	 edx, 17			; 00000011H
  00118	33 c2		 xor	 eax, edx
  0011a	8b d0		 mov	 edx, eax
  0011c	c1 e2 09	 shl	 edx, 9
  0011f	2b c2		 sub	 eax, edx
  00121	8b d0		 mov	 edx, eax
  00123	c1 e2 04	 shl	 edx, 4
  00126	33 c2		 xor	 eax, edx
  00128	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0012f	2b c2		 sub	 eax, edx
  00131	8b d0		 mov	 edx, eax
  00133	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00136	33 c2		 xor	 eax, edx
  00138	8b d0		 mov	 edx, eax
  0013a	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0013d	33 d0		 xor	 edx, eax

; 918  : 		HASHTABLE[i].value = key;

  0013f	89 79 10	 mov	 DWORD PTR [ecx+16], edi

; 919  : 		tommy_hashtable_insert(&hashtable, &HASHTABLE[i].node, &HASHTABLE[i], hash_key);

  00142	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00147	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0014d	23 c2		 and	 eax, edx
  0014f	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  00152	8b 07		 mov	 eax, DWORD PTR [edi]
  00154	85 c0		 test	 eax, eax
  00156	74 16		 je	 SHORT $LN138@test_inser
  00158	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0015b	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0015e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00161	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00164	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0016a	89 08		 mov	 DWORD PTR [eax], ecx
  0016c	eb 0b		 jmp	 SHORT $LN145@test_inser
$LN138@test_inser:
  0016e	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00171	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00177	89 0f		 mov	 DWORD PTR [edi], ecx
$LN145@test_inser:
  00179	89 49 08	 mov	 DWORD PTR [ecx+8], ecx
  0017c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0017f	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  00185	43		 inc	 ebx
  00186	83 c1 24	 add	 ecx, 36			; 00000024H
  00189	3b de		 cmp	 ebx, esi
  0018b	0f 82 73 ff ff
	ff		 jb	 $LL111@test_inser
$LN109@test_inser:

; 920  : 	} STOP();

  00191	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 921  : 
; 922  : 	START(DATA_HASHDYN) {

  00196	b8 01 00 00 00	 mov	 eax, 1
  0019b	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  001a0	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  001a6	0f 85 82 01 00
	00		 jne	 $LN105@test_inser
  001ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  001b3	75 30		 jne	 SHORT $LN147@test_inser
  001b5	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  001bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  001c1	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  001c8	51		 push	 ecx
  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  001cf	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  001d6	50		 push	 eax
  001d7	52		 push	 edx
  001d8	68 00 00 00 00	 push	 OFFSET $SG-100
  001dd	e8 00 00 00 00	 call	 _printf
  001e2	83 c4 10	 add	 esp, 16			; 00000010H
$LN147@test_inser:
  001e5	8d 45 e4	 lea	 eax, DWORD PTR _t$216990[ebp]
  001e8	50		 push	 eax
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  001ef	85 c0		 test	 eax, eax
  001f1	75 11		 jne	 SHORT $LN153@test_inser
  001f3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  001f7	66 0f 13 45 dc	 movlpd	 QWORD PTR $T216983[ebp], xmm0
  001fc	8b 5d e0	 mov	 ebx, DWORD PTR $T216983[ebp+4]
  001ff	8b 7d dc	 mov	 edi, DWORD PTR $T216983[ebp]
  00202	eb 54		 jmp	 SHORT $LN154@test_inser
$LN153@test_inser:
  00204	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0020a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00210	8b 4d e8	 mov	 ecx, DWORD PTR _t$216990[ebp+4]
  00213	8b 55 e4	 mov	 edx, DWORD PTR _t$216990[ebp]
  00216	57		 push	 edi
  00217	56		 push	 esi
  00218	51		 push	 ecx
  00219	52		 push	 edx
  0021a	e8 00 00 00 00	 call	 __alldvrm
  0021f	6a 00		 push	 0
  00221	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00226	53		 push	 ebx
  00227	51		 push	 ecx
  00228	89 45 dc	 mov	 DWORD PTR tv69[ebp], eax
  0022b	89 55 e0	 mov	 DWORD PTR tv69[ebp+4], edx
  0022e	e8 00 00 00 00	 call	 __allmul
  00233	57		 push	 edi
  00234	56		 push	 esi
  00235	52		 push	 edx
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 __alldiv
  0023c	8b 4d dc	 mov	 ecx, DWORD PTR tv69[ebp]
  0023f	6a 00		 push	 0
  00241	8b f8		 mov	 edi, eax
  00243	8b 45 e0	 mov	 eax, DWORD PTR tv69[ebp+4]
  00246	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0024b	50		 push	 eax
  0024c	51		 push	 ecx
  0024d	8b da		 mov	 ebx, edx
  0024f	e8 00 00 00 00	 call	 __allmul
  00254	03 f8		 add	 edi, eax
  00256	13 da		 adc	 ebx, edx
$LN154@test_inser:
  00258	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0025e	33 db		 xor	 ebx, ebx
  00260	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00266	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  0026c	0f 86 bc 00 00
	00		 jbe	 $LN105@test_inser
  00272	33 f6		 xor	 esi, esi
$LL107@test_inser:

; 923  : 		unsigned key = INSERT[i];

  00274	8b 55 08	 mov	 edx, DWORD PTR _INSERT$[ebp]
  00277	8b 14 9a	 mov	 edx, DWORD PTR [edx+ebx*4]

; 924  : 		unsigned hash_key = hash(key);

  0027a	8b ca		 mov	 ecx, edx
  0027c	c1 e1 06	 shl	 ecx, 6
  0027f	8b c2		 mov	 eax, edx
  00281	2b c1		 sub	 eax, ecx
  00283	8b c8		 mov	 ecx, eax
  00285	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00288	33 c1		 xor	 eax, ecx
  0028a	8b c8		 mov	 ecx, eax
  0028c	c1 e1 09	 shl	 ecx, 9
  0028f	2b c1		 sub	 eax, ecx
  00291	8b c8		 mov	 ecx, eax
  00293	c1 e1 04	 shl	 ecx, 4
  00296	33 c1		 xor	 eax, ecx
  00298	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0029f	2b c1		 sub	 eax, ecx
  002a1	8b c8		 mov	 ecx, eax
  002a3	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  002a6	33 c1		 xor	 eax, ecx
  002a8	8b c8		 mov	 ecx, eax
  002aa	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  002ad	33 c8		 xor	 ecx, eax

; 925  : 		HASHDYN[i].value = key;

  002af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?HASHDYN@@3PAUhashtable_object@@A ; HASHDYN
  002b4	03 c6		 add	 eax, esi
  002b6	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 926  : 		tommy_hashdyn_insert(&hashdyn, &HASHDYN[i].node, &HASHDYN[i], hash_key);

  002b9	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  002bf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  002c5	23 d1		 and	 edx, ecx
  002c7	8d 3c 97	 lea	 edi, DWORD PTR [edi+edx*4]
  002ca	8b 17		 mov	 edx, DWORD PTR [edi]
  002cc	85 d2		 test	 edx, edx
  002ce	74 16		 je	 SHORT $LN161@test_inser
  002d0	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  002d3	89 78 04	 mov	 DWORD PTR [eax+4], edi
  002d6	89 42 04	 mov	 DWORD PTR [edx+4], eax
  002d9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002dc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002e2	89 02		 mov	 DWORD PTR [edx], eax
  002e4	eb 0b		 jmp	 SHORT $LN168@test_inser
$LN161@test_inser:
  002e6	89 40 04	 mov	 DWORD PTR [eax+4], eax
  002e9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002ef	89 07		 mov	 DWORD PTR [edi], eax
$LN168@test_inser:
  002f1	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  002f4	89 40 08	 mov	 DWORD PTR [eax+8], eax
  002f7	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  002fc	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00302	40		 inc	 eax
  00303	d1 e9		 shr	 ecx, 1
  00305	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0030a	3b c1		 cmp	 eax, ecx
  0030c	72 10		 jb	 SHORT $LN106@test_inser
  0030e	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00314	42		 inc	 edx
  00315	52		 push	 edx
  00316	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0031b	83 c4 04	 add	 esp, 4
$LN106@test_inser:

; 921  : 
; 922  : 	START(DATA_HASHDYN) {

  0031e	43		 inc	 ebx
  0031f	83 c6 24	 add	 esi, 36			; 00000024H
  00322	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00328	0f 82 46 ff ff
	ff		 jb	 $LL107@test_inser
$LN105@test_inser:

; 927  : 	} STOP();

  0032e	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 928  : 
; 929  : 	START(DATA_HASHLIN) {

  00333	b8 02 00 00 00	 mov	 eax, 2
  00338	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0033d	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00343	0f 85 c4 01 00
	00		 jne	 $LN101@test_inser
  00349	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00350	75 2e		 jne	 SHORT $LN173@test_inser
  00352	a1 08 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  00357	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0035d	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00364	50		 push	 eax
  00365	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0036a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00371	52		 push	 edx
  00372	51		 push	 ecx
  00373	68 00 00 00 00	 push	 OFFSET $SG-100
  00378	e8 00 00 00 00	 call	 _printf
  0037d	83 c4 10	 add	 esp, 16			; 00000010H
$LN173@test_inser:
  00380	8d 55 e4	 lea	 edx, DWORD PTR _t$217065[ebp]
  00383	52		 push	 edx
  00384	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0038a	85 c0		 test	 eax, eax
  0038c	75 11		 jne	 SHORT $LN179@test_inser
  0038e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00392	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217056[ebp], xmm0
  00397	8b 5d e0	 mov	 ebx, DWORD PTR $T217056[ebp+4]
  0039a	8b 7d dc	 mov	 edi, DWORD PTR $T217056[ebp]
  0039d	eb 54		 jmp	 SHORT $LN180@test_inser
$LN179@test_inser:
  0039f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  003a5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  003ab	8b 45 e8	 mov	 eax, DWORD PTR _t$217065[ebp+4]
  003ae	8b 4d e4	 mov	 ecx, DWORD PTR _t$217065[ebp]
  003b1	57		 push	 edi
  003b2	56		 push	 esi
  003b3	50		 push	 eax
  003b4	51		 push	 ecx
  003b5	e8 00 00 00 00	 call	 __alldvrm
  003ba	6a 00		 push	 0
  003bc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003c1	53		 push	 ebx
  003c2	51		 push	 ecx
  003c3	89 45 dc	 mov	 DWORD PTR tv3500[ebp], eax
  003c6	89 55 e0	 mov	 DWORD PTR tv3500[ebp+4], edx
  003c9	e8 00 00 00 00	 call	 __allmul
  003ce	57		 push	 edi
  003cf	56		 push	 esi
  003d0	52		 push	 edx
  003d1	50		 push	 eax
  003d2	e8 00 00 00 00	 call	 __alldiv
  003d7	6a 00		 push	 0
  003d9	8b da		 mov	 ebx, edx
  003db	8b 55 e0	 mov	 edx, DWORD PTR tv3500[ebp+4]
  003de	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003e3	8b f8		 mov	 edi, eax
  003e5	8b 45 dc	 mov	 eax, DWORD PTR tv3500[ebp]
  003e8	52		 push	 edx
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 __allmul
  003ef	03 f8		 add	 edi, eax
  003f1	13 da		 adc	 ebx, edx
$LN180@test_inser:
  003f3	33 f6		 xor	 esi, esi
  003f5	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  003fb	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00401	89 75 f8	 mov	 DWORD PTR _i$[ebp], esi
  00404	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  0040a	0f 86 fd 00 00
	00		 jbe	 $LN101@test_inser
  00410	89 75 f4	 mov	 DWORD PTR tv5488[ebp], esi
$LL103@test_inser:

; 930  : 		unsigned key = INSERT[i];

  00413	8b 4d 08	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  00416	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]

; 931  : 		unsigned hash_key = hash(key);

  00419	8b d1		 mov	 edx, ecx
  0041b	c1 e2 06	 shl	 edx, 6
  0041e	8b c1		 mov	 eax, ecx
  00420	2b c2		 sub	 eax, edx
  00422	8b d0		 mov	 edx, eax
  00424	c1 ea 11	 shr	 edx, 17			; 00000011H
  00427	33 c2		 xor	 eax, edx
  00429	8b d0		 mov	 edx, eax
  0042b	c1 e2 09	 shl	 edx, 9
  0042e	2b c2		 sub	 eax, edx
  00430	8b d0		 mov	 edx, eax
  00432	c1 e2 04	 shl	 edx, 4
  00435	33 c2		 xor	 eax, edx
  00437	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0043e	2b c2		 sub	 eax, edx
  00440	8b d0		 mov	 edx, eax
  00442	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00445	33 c2		 xor	 eax, edx
  00447	8b d0		 mov	 edx, eax
  00449	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0044c	33 d0		 xor	 edx, eax

; 932  : 		HASHLIN[i].value = key;

  0044e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?HASHLIN@@3PAUhashtable_object@@A ; HASHLIN
  00453	03 45 f4	 add	 eax, DWORD PTR tv5488[ebp]
  00456	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 933  : 		tommy_hashlin_insert(&hashlin, &HASHLIN[i].node, &HASHLIN[i], hash_key);

  00459	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  00460	74 2e		 je	 SHORT $LN186@test_inser
  00462	8b 3d 94 00 00
	00		 mov	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  00468	23 fa		 and	 edi, edx
  0046a	3b 3d 98 00 00
	00		 cmp	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  00470	72 1e		 jb	 SHORT $LN186@test_inser
  00472	83 ff 40	 cmp	 edi, 64			; 00000040H
  00475	73 08		 jae	 SHORT $LN190@test_inser
  00477	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  0047d	eb 3f		 jmp	 SHORT $LN1082@test_inser
$LN190@test_inser:
  0047f	0f bd cf	 bsr	 ecx, edi
  00482	bb 01 00 00 00	 mov	 ebx, 1
  00487	d3 e3		 shl	 ebx, cl
  00489	89 4d f8	 mov	 DWORD PTR _count$217161[ebp], ecx
  0048c	2b fb		 sub	 edi, ebx
  0048e	eb 27		 jmp	 SHORT $LN1083@test_inser
$LN186@test_inser:
  00490	8b 3d 88 00 00
	00		 mov	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00496	23 fa		 and	 edi, edx
  00498	83 ff 40	 cmp	 edi, 64			; 00000040H
  0049b	73 08		 jae	 SHORT $LN195@test_inser
  0049d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  004a3	eb 19		 jmp	 SHORT $LN1082@test_inser
$LN195@test_inser:
  004a5	0f bd cf	 bsr	 ecx, edi
  004a8	be 01 00 00 00	 mov	 esi, 1
  004ad	d3 e6		 shl	 esi, cl
  004af	89 4d ec	 mov	 DWORD PTR _count$217147[ebp], ecx
  004b2	2b fe		 sub	 edi, esi
  004b4	8b 75 f8	 mov	 esi, DWORD PTR _i$[ebp]
$LN1083@test_inser:
  004b7	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
$LN1082@test_inser:
  004be	8d 3c b9	 lea	 edi, DWORD PTR [ecx+edi*4]
  004c1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004c3	85 c9		 test	 ecx, ecx
  004c5	74 16		 je	 SHORT $LN201@test_inser
  004c7	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  004ca	89 78 04	 mov	 DWORD PTR [eax+4], edi
  004cd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  004d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004d3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  004d9	89 01		 mov	 DWORD PTR [ecx], eax
  004db	eb 0b		 jmp	 SHORT $LN208@test_inser
$LN201@test_inser:
  004dd	89 40 04	 mov	 DWORD PTR [eax+4], eax
  004e0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  004e6	89 07		 mov	 DWORD PTR [edi], eax
$LN208@test_inser:
  004e8	89 40 08	 mov	 DWORD PTR [eax+8], eax
  004eb	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  004ee	ff 05 a0 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  004f4	e8 00 00 00 00	 call	 ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_grow_step
  004f9	83 45 f4 24	 add	 DWORD PTR tv5488[ebp], 36 ; 00000024H
  004fd	46		 inc	 esi
  004fe	89 75 f8	 mov	 DWORD PTR _i$[ebp], esi
  00501	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00507	0f 82 06 ff ff
	ff		 jb	 $LL103@test_inser
$LN101@test_inser:

; 934  : 	} STOP();

  0050d	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 935  : 
; 936  : 	START(DATA_TRIE) {

  00512	b8 03 00 00 00	 mov	 eax, 3
  00517	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0051c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00522	0f 85 03 01 00
	00		 jne	 $LN97@test_inser
  00528	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0052f	75 2f		 jne	 SHORT $LN210@test_inser
  00531	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  00537	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0053c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00543	52		 push	 edx
  00544	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0054a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00551	51		 push	 ecx
  00552	50		 push	 eax
  00553	68 00 00 00 00	 push	 OFFSET $SG-100
  00558	e8 00 00 00 00	 call	 _printf
  0055d	83 c4 10	 add	 esp, 16			; 00000010H
$LN210@test_inser:
  00560	8d 4d e4	 lea	 ecx, DWORD PTR _t$217195[ebp]
  00563	51		 push	 ecx
  00564	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0056a	85 c0		 test	 eax, eax
  0056c	75 11		 jne	 SHORT $LN216@test_inser
  0056e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00572	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217188[ebp], xmm0
  00577	8b 5d e0	 mov	 ebx, DWORD PTR $T217188[ebp+4]
  0057a	8b 7d dc	 mov	 edi, DWORD PTR $T217188[ebp]
  0057d	eb 54		 jmp	 SHORT $LN217@test_inser
$LN216@test_inser:
  0057f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00585	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0058b	8b 55 e8	 mov	 edx, DWORD PTR _t$217195[ebp+4]
  0058e	8b 45 e4	 mov	 eax, DWORD PTR _t$217195[ebp]
  00591	57		 push	 edi
  00592	56		 push	 esi
  00593	52		 push	 edx
  00594	50		 push	 eax
  00595	e8 00 00 00 00	 call	 __alldvrm
  0059a	6a 00		 push	 0
  0059c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  005a1	53		 push	 ebx
  005a2	51		 push	 ecx
  005a3	89 45 dc	 mov	 DWORD PTR tv960[ebp], eax
  005a6	89 55 e0	 mov	 DWORD PTR tv960[ebp+4], edx
  005a9	e8 00 00 00 00	 call	 __allmul
  005ae	57		 push	 edi
  005af	56		 push	 esi
  005b0	52		 push	 edx
  005b1	50		 push	 eax
  005b2	e8 00 00 00 00	 call	 __alldiv
  005b7	8b 4d e0	 mov	 ecx, DWORD PTR tv960[ebp+4]
  005ba	6a 00		 push	 0
  005bc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  005c1	8b da		 mov	 ebx, edx
  005c3	8b 55 dc	 mov	 edx, DWORD PTR tv960[ebp]
  005c6	51		 push	 ecx
  005c7	52		 push	 edx
  005c8	8b f8		 mov	 edi, eax
  005ca	e8 00 00 00 00	 call	 __allmul
  005cf	03 f8		 add	 edi, eax
  005d1	13 da		 adc	 ebx, edx
$LN217@test_inser:
  005d3	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  005d9	33 ff		 xor	 edi, edi
  005db	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  005e1	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  005e7	76 42		 jbe	 SHORT $LN97@test_inser
  005e9	8b 75 08	 mov	 esi, DWORD PTR _INSERT$[ebp]
  005ec	33 db		 xor	 ebx, ebx
  005ee	8b ff		 npad	 2
$LL99@test_inser:

; 937  : 		unsigned key = INSERT[i];

  005f0	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]

; 938  : 		TRIE[i].value = key;

  005f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?TRIE@@3PAUtrie_object@@A ; TRIE
  005f9	03 cb		 add	 ecx, ebx
  005fb	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 939  : 		tommy_trie_insert(&trie, &TRIE[i].node, &TRIE[i], key);

  005fe	50		 push	 eax
  005ff	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00602	c1 e8 1b	 shr	 eax, 27			; 0000001bH
  00605	51		 push	 ecx
  00606	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  0060d	52		 push	 edx
  0060e	89 49 08	 mov	 DWORD PTR [ecx+8], ecx
  00611	e8 00 00 00 00	 call	 ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ; trie_bucket_insert
  00616	ff 05 80 00 00
	00		 inc	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+128
  0061c	47		 inc	 edi
  0061d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00620	83 c3 24	 add	 ebx, 36			; 00000024H
  00623	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00629	72 c5		 jb	 SHORT $LL99@test_inser
$LN97@test_inser:

; 940  : 	} STOP();

  0062b	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 941  : 
; 942  : 	START(DATA_TRIE_INPLACE) {

  00630	b8 04 00 00 00	 mov	 eax, 4
  00635	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0063a	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00640	0f 85 72 01 00
	00		 jne	 $LN93@test_inser
  00646	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0064d	75 2e		 jne	 SHORT $LN221@test_inser
  0064f	a1 10 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  00654	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0065a	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00661	50		 push	 eax
  00662	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00667	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0066e	52		 push	 edx
  0066f	51		 push	 ecx
  00670	68 00 00 00 00	 push	 OFFSET $SG-100
  00675	e8 00 00 00 00	 call	 _printf
  0067a	83 c4 10	 add	 esp, 16			; 00000010H
$LN221@test_inser:
  0067d	8d 55 e4	 lea	 edx, DWORD PTR _t$217224[ebp]
  00680	52		 push	 edx
  00681	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00687	85 c0		 test	 eax, eax
  00689	75 11		 jne	 SHORT $LN227@test_inser
  0068b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0068f	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217217[ebp], xmm0
  00694	8b 5d e0	 mov	 ebx, DWORD PTR $T217217[ebp+4]
  00697	8b 7d dc	 mov	 edi, DWORD PTR $T217217[ebp]
  0069a	eb 54		 jmp	 SHORT $LN228@test_inser
$LN227@test_inser:
  0069c	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  006a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  006a8	8b 45 e8	 mov	 eax, DWORD PTR _t$217224[ebp+4]
  006ab	8b 4d e4	 mov	 ecx, DWORD PTR _t$217224[ebp]
  006ae	57		 push	 edi
  006af	56		 push	 esi
  006b0	50		 push	 eax
  006b1	51		 push	 ecx
  006b2	e8 00 00 00 00	 call	 __alldvrm
  006b7	6a 00		 push	 0
  006b9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  006be	53		 push	 ebx
  006bf	51		 push	 ecx
  006c0	89 45 dc	 mov	 DWORD PTR tv995[ebp], eax
  006c3	89 55 e0	 mov	 DWORD PTR tv995[ebp+4], edx
  006c6	e8 00 00 00 00	 call	 __allmul
  006cb	57		 push	 edi
  006cc	56		 push	 esi
  006cd	52		 push	 edx
  006ce	50		 push	 eax
  006cf	e8 00 00 00 00	 call	 __alldiv
  006d4	6a 00		 push	 0
  006d6	8b da		 mov	 ebx, edx
  006d8	8b 55 e0	 mov	 edx, DWORD PTR tv995[ebp+4]
  006db	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  006e0	8b f8		 mov	 edi, eax
  006e2	8b 45 dc	 mov	 eax, DWORD PTR tv995[ebp]
  006e5	52		 push	 edx
  006e6	50		 push	 eax
  006e7	e8 00 00 00 00	 call	 __allmul
  006ec	03 f8		 add	 edi, eax
  006ee	13 da		 adc	 ebx, edx
$LN228@test_inser:
  006f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  006f7	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  006fd	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00703	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0070a	0f 86 a8 00 00
	00		 jbe	 $LN93@test_inser
  00710	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?TRIE_INPLACE@@3PAUtrie_inplace_object@@A ; TRIE_INPLACE
  00716	83 c7 08	 add	 edi, 8
  00719	8d a4 24 00 00
	00 00		 npad	 7
$LL95@test_inser:

; 943  : 		unsigned key = INSERT[i];

  00720	8b 4d 08	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  00723	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00726	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]

; 944  : 		TRIE_INPLACE[i].value = key;

  00729	89 57 18	 mov	 DWORD PTR [edi+24], edx

; 945  : 		tommy_trie_inplace_insert(&trie_inplace, &TRIE_INPLACE[i].node, &TRIE_INPLACE[i], key);

  0072c	8b c2		 mov	 eax, edx
  0072e	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  00731	8d 77 f8	 lea	 esi, DWORD PTR [edi-8]
  00734	89 37		 mov	 DWORD PTR [edi], esi
  00736	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00739	66 0f ef c0	 pxor	 xmm0, xmm0
  0073d	66 0f d6 47 08	 movq	 QWORD PTR [edi+8], xmm0
  00742	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]
  00749	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
  0074e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00750	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00755	89 4d f4	 mov	 DWORD PTR $T217249[ebp], ecx
  00758	85 c0		 test	 eax, eax
  0075a	74 1f		 je	 SHORT $LN1034@test_inser
$LN238@test_inser:
  0075c	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  0075f	74 27		 je	 SHORT $LN236@test_inser
  00761	8b da		 mov	 ebx, edx
  00763	d3 eb		 shr	 ebx, cl
  00765	8b 4d f4	 mov	 ecx, DWORD PTR $T217249[ebp]
  00768	83 e9 02	 sub	 ecx, 2
  0076b	89 4d f4	 mov	 DWORD PTR $T217249[ebp], ecx
  0076e	83 e3 03	 and	 ebx, 3
  00771	8d 5c 98 10	 lea	 ebx, DWORD PTR [eax+ebx*4+16]
  00775	8b 03		 mov	 eax, DWORD PTR [ebx]
  00777	85 c0		 test	 eax, eax
  00779	75 e1		 jne	 SHORT $LN238@test_inser
$LN1034@test_inser:
  0077b	89 76 04	 mov	 DWORD PTR [esi+4], esi
  0077e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00784	89 33		 mov	 DWORD PTR [ebx], esi
  00786	eb 14		 jmp	 SHORT $LN243@test_inser
$LN236@test_inser:
  00788	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0078b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0078e	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00791	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00794	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0079a	89 32		 mov	 DWORD PTR [edx], esi
$LN243@test_inser:
  0079c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0079f	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  007a5	40		 inc	 eax
  007a6	83 c7 34	 add	 edi, 52			; 00000034H
  007a9	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  007ac	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  007b2	0f 82 68 ff ff
	ff		 jb	 $LL95@test_inser
$LN93@test_inser:

; 946  : 	} STOP();

  007b8	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 947  : 
; 948  : 	/* for khash we hash the key because internally khash doesn't use any hash for integer keys */
; 949  : 	START(DATA_KHASH) {

  007bd	b8 07 00 00 00	 mov	 eax, 7
  007c2	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  007c7	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  007cd	0f 85 45 01 00
	00		 jne	 $LN89@test_inser
  007d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  007da	75 2e		 jne	 SHORT $LN245@test_inser
  007dc	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  007e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  007e7	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  007ee	50		 push	 eax
  007ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  007f4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  007fb	52		 push	 edx
  007fc	51		 push	 ecx
  007fd	68 00 00 00 00	 push	 OFFSET $SG-100
  00802	e8 00 00 00 00	 call	 _printf
  00807	83 c4 10	 add	 esp, 16			; 00000010H
$LN245@test_inser:
  0080a	8d 55 e4	 lea	 edx, DWORD PTR _t$217288[ebp]
  0080d	52		 push	 edx
  0080e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00814	85 c0		 test	 eax, eax
  00816	75 11		 jne	 SHORT $LN251@test_inser
  00818	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0081c	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217281[ebp], xmm0
  00821	8b 5d e0	 mov	 ebx, DWORD PTR $T217281[ebp+4]
  00824	8b 7d dc	 mov	 edi, DWORD PTR $T217281[ebp]
  00827	eb 54		 jmp	 SHORT $LN252@test_inser
$LN251@test_inser:
  00829	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0082f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00835	8b 45 e8	 mov	 eax, DWORD PTR _t$217288[ebp+4]
  00838	8b 4d e4	 mov	 ecx, DWORD PTR _t$217288[ebp]
  0083b	57		 push	 edi
  0083c	56		 push	 esi
  0083d	50		 push	 eax
  0083e	51		 push	 ecx
  0083f	e8 00 00 00 00	 call	 __alldvrm
  00844	6a 00		 push	 0
  00846	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0084b	53		 push	 ebx
  0084c	51		 push	 ecx
  0084d	89 45 dc	 mov	 DWORD PTR tv3488[ebp], eax
  00850	89 55 e0	 mov	 DWORD PTR tv3488[ebp+4], edx
  00853	e8 00 00 00 00	 call	 __allmul
  00858	57		 push	 edi
  00859	56		 push	 esi
  0085a	52		 push	 edx
  0085b	50		 push	 eax
  0085c	e8 00 00 00 00	 call	 __alldiv
  00861	6a 00		 push	 0
  00863	8b da		 mov	 ebx, edx
  00865	8b 55 e0	 mov	 edx, DWORD PTR tv3488[ebp+4]
  00868	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0086d	8b f8		 mov	 edi, eax
  0086f	8b 45 dc	 mov	 eax, DWORD PTR tv3488[ebp]
  00872	52		 push	 edx
  00873	50		 push	 eax
  00874	e8 00 00 00 00	 call	 __allmul
  00879	03 f8		 add	 edi, eax
  0087b	13 da		 adc	 ebx, edx
$LN252@test_inser:
  0087d	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00883	33 ff		 xor	 edi, edi
  00885	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0088b	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00891	0f 86 81 00 00
	00		 jbe	 $LN89@test_inser
  00897	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?KHASH@@3PAUkhash_object@@A ; KHASH
  0089d	33 db		 xor	 ebx, ebx
$LN91@test_inser:

; 950  : 		unsigned key = INSERT[i];

  0089f	8b 4d 08	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  008a2	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]

; 951  : 		unsigned hash_key = hash(key);

  008a5	8b f1		 mov	 esi, ecx
  008a7	c1 e6 06	 shl	 esi, 6
  008aa	8b c1		 mov	 eax, ecx
  008ac	2b c6		 sub	 eax, esi
  008ae	8b f0		 mov	 esi, eax
  008b0	c1 ee 11	 shr	 esi, 17			; 00000011H
  008b3	33 c6		 xor	 eax, esi
  008b5	8b f0		 mov	 esi, eax
  008b7	c1 e6 09	 shl	 esi, 9
  008ba	2b c6		 sub	 eax, esi
  008bc	8b f0		 mov	 esi, eax
  008be	c1 e6 04	 shl	 esi, 4
  008c1	33 c6		 xor	 eax, esi
  008c3	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
  008ca	2b c6		 sub	 eax, esi
  008cc	8b f0		 mov	 esi, eax

; 952  : 		khiter_t k;
; 953  : 		int r;
; 954  : 		KHASH[i].value = key;

  008ce	89 0c 13	 mov	 DWORD PTR [ebx+edx], ecx
  008d1	c1 e6 0a	 shl	 esi, 10			; 0000000aH
  008d4	33 c6		 xor	 eax, esi
  008d6	8b c8		 mov	 ecx, eax

; 955  : 		k = kh_put(word, khash, hash_key, &r);

  008d8	8d 55 ec	 lea	 edx, DWORD PTR _r$148374[ebp]
  008db	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  008de	52		 push	 edx
  008df	33 c8		 xor	 ecx, eax
  008e1	51		 push	 ecx
  008e2	e8 00 00 00 00	 call	 ?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z ; kh_put_word
  008e7	83 c4 08	 add	 esp, 8

; 956  : 		if (!r)

  008ea	83 7d ec 00	 cmp	 DWORD PTR _r$148374[ebp], 0
  008ee	8b f0		 mov	 esi, eax
  008f0	75 05		 jne	 SHORT $LN88@test_inser

; 957  : 			abort();

  008f2	e8 00 00 00 00	 call	 _abort
$LN88@test_inser:

; 958  : 		kh_value(khash, k) = &KHASH[i];

  008f7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?KHASH@@3PAUkhash_object@@A ; KHASH
  008fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00903	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00906	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00909	47		 inc	 edi
  0090a	83 c3 14	 add	 ebx, 20			; 00000014H
  0090d	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  00910	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00916	72 87		 jb	 SHORT $LN91@test_inser
$LN89@test_inser:

; 959  : 	} STOP();

  00918	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 960  : 
; 961  : #ifdef USE_CGOOGLEDENSEHASH
; 962  : 	START(DATA_CGOOGLE) {
; 963  : 		unsigned key = INSERT[i];
; 964  : 		HTItem* r;
; 965  : 		u_long ptr_value = (u_long)&GOOGLE[i];
; 966  : 		GOOGLE[i].value = key;
; 967  : 		r = HashInsert(cgoogledensehash, key, ptr_value);
; 968  : 		if (!r)
; 969  : 			abort();
; 970  : 	} STOP();
; 971  : #endif
; 972  : 
; 973  : #ifdef USE_GOOGLEDENSEHASH
; 974  : 	START(DATA_GOOGLEDENSEHASH) {

  0091d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00922	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00927	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0092d	0f 85 3c 02 00
	00		 jne	 $LN84@test_inser
  00933	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0093a	75 2f		 jne	 SHORT $LN256@test_inser
  0093c	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  00942	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00947	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0094e	52		 push	 edx
  0094f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00955	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0095c	51		 push	 ecx
  0095d	50		 push	 eax
  0095e	68 00 00 00 00	 push	 OFFSET $SG-100
  00963	e8 00 00 00 00	 call	 _printf
  00968	83 c4 10	 add	 esp, 16			; 00000010H
$LN256@test_inser:
  0096b	8d 4d d4	 lea	 ecx, DWORD PTR _t$217315[ebp]
  0096e	51		 push	 ecx
  0096f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00975	85 c0		 test	 eax, eax
  00977	75 11		 jne	 SHORT $LN262@test_inser
  00979	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0097d	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217308[ebp], xmm0
  00982	8b 5d e0	 mov	 ebx, DWORD PTR $T217308[ebp+4]
  00985	8b 7d dc	 mov	 edi, DWORD PTR $T217308[ebp]
  00988	eb 54		 jmp	 SHORT $LN263@test_inser
$LN262@test_inser:
  0098a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00990	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00996	8b 55 d8	 mov	 edx, DWORD PTR _t$217315[ebp+4]
  00999	8b 45 d4	 mov	 eax, DWORD PTR _t$217315[ebp]
  0099c	57		 push	 edi
  0099d	56		 push	 esi
  0099e	52		 push	 edx
  0099f	50		 push	 eax
  009a0	e8 00 00 00 00	 call	 __alldvrm
  009a5	6a 00		 push	 0
  009a7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  009ac	53		 push	 ebx
  009ad	51		 push	 ecx
  009ae	89 45 dc	 mov	 DWORD PTR tv1085[ebp], eax
  009b1	89 55 e0	 mov	 DWORD PTR tv1085[ebp+4], edx
  009b4	e8 00 00 00 00	 call	 __allmul
  009b9	57		 push	 edi
  009ba	56		 push	 esi
  009bb	52		 push	 edx
  009bc	50		 push	 eax
  009bd	e8 00 00 00 00	 call	 __alldiv
  009c2	8b 4d e0	 mov	 ecx, DWORD PTR tv1085[ebp+4]
  009c5	6a 00		 push	 0
  009c7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  009cc	8b da		 mov	 ebx, edx
  009ce	8b 55 dc	 mov	 edx, DWORD PTR tv1085[ebp]
  009d1	51		 push	 ecx
  009d2	52		 push	 edx
  009d3	8b f8		 mov	 edi, eax
  009d5	e8 00 00 00 00	 call	 __allmul
  009da	03 f8		 add	 edi, eax
  009dc	13 da		 adc	 ebx, edx
$LN263@test_inser:
  009de	33 c0		 xor	 eax, eax
  009e0	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  009e6	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  009ec	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  009ef	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  009f5	0f 86 74 01 00
	00		 jbe	 $LN84@test_inser
  009fb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00a01	89 45 f4	 mov	 DWORD PTR tv5684[ebp], eax
$LL86@test_inser:

; 975  : 		unsigned key = INSERT[i];

  00a04	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00a07	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00a0a	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]

; 976  : 		struct google_object* obj = &GOOGLE[i];

  00a0d	8b 45 f4	 mov	 eax, DWORD PTR tv5684[ebp]
  00a10	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE

; 977  : 		GOOGLE[i].value = key;
; 978  : 		(*googledensehash)[key] = obj;

  00a16	8d 4d c4	 lea	 ecx, DWORD PTR _pos$220253[ebp]
  00a19	89 45 f0	 mov	 DWORD PTR tv5696[ebp], eax
  00a1c	89 30		 mov	 DWORD PTR [eax], esi
  00a1e	51		 push	 ecx
  00a1f	8d 45 ec	 lea	 eax, DWORD PTR _key$148380[ebp]
  00a22	89 75 ec	 mov	 DWORD PTR _key$148380[ebp], esi
  00a25	8b df		 mov	 ebx, edi
  00a27	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00a2c	8b 45 c4	 mov	 eax, DWORD PTR _pos$220253[ebp]
  00a2f	83 f8 ff	 cmp	 eax, -1
  00a32	74 0b		 je	 SHORT $LN270@test_inser
  00a34	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00a37	8d 1c c2	 lea	 ebx, DWORD PTR [edx+eax*8]
  00a3a	e9 13 01 00 00	 jmp	 $LN267@test_inser
$LN270@test_inser:
  00a3f	57		 push	 edi
  00a40	b8 01 00 00 00	 mov	 eax, 1
  00a45	e8 00 00 00 00	 call	 ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
  00a4a	84 c0		 test	 al, al
  00a4c	0f 84 ac 00 00
	00		 je	 $LN268@test_inser
  00a52	8d 45 cc	 lea	 eax, DWORD PTR _pos$220361[ebp]
  00a55	50		 push	 eax
  00a56	8d 45 ec	 lea	 eax, DWORD PTR $T220536[ebp]
  00a59	8b fb		 mov	 edi, ebx
  00a5b	89 75 ec	 mov	 DWORD PTR $T220536[ebp], esi
  00a5e	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00a63	8b 4d cc	 mov	 ecx, DWORD PTR _pos$220361[ebp]
  00a66	83 f9 ff	 cmp	 ecx, -1
  00a69	74 27		 je	 SHORT $LN304@test_inser
  00a6b	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00a6e	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  00a71	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00a74	89 5d b8	 mov	 DWORD PTR $T220544[ebp], ebx
  00a77	89 4d bc	 mov	 DWORD PTR $T220544[ebp+4], ecx
  00a7a	f3 0f 7e 45 b8	 movq	 xmm0, QWORD PTR $T220544[ebp]
  00a7f	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00a82	66 0f d6 45 84	 movq	 QWORD PTR $T220295[ebp], xmm0
  00a87	8b 5d 88	 mov	 ebx, DWORD PTR $T220295[ebp+4]
  00a8a	89 45 8c	 mov	 DWORD PTR $T220295[ebp+8], eax
  00a8d	e9 ba 00 00 00	 jmp	 $LN1085@test_inser
$LN304@test_inser:
  00a92	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00a95	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00a98	2b c8		 sub	 ecx, eax
  00a9a	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00aa0	0f 83 3e 01 00
	00		 jae	 $LN1002@test_inser
  00aa6	8b 4d d0	 mov	 ecx, DWORD PTR _pos$220361[ebp+4]
  00aa9	85 c0		 test	 eax, eax
  00aab	74 11		 je	 SHORT $LN376@test_inser
  00aad	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  00ab0	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00ab3	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  00ab6	75 06		 jne	 SHORT $LN376@test_inser
  00ab8	48		 dec	 eax
  00ab9	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00abc	eb 07		 jmp	 SHORT $LN375@test_inser
$LN376@test_inser:
  00abe	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00ac1	40		 inc	 eax
  00ac2	89 43 24	 mov	 DWORD PTR [ebx+36], eax
$LN375@test_inser:
  00ac5	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00ac8	03 c9		 add	 ecx, ecx
  00aca	03 c9		 add	 ecx, ecx
  00acc	03 c9		 add	 ecx, ecx
  00ace	03 c1		 add	 eax, ecx
  00ad0	74 09		 je	 SHORT $LN462@test_inser
  00ad2	89 30		 mov	 DWORD PTR [eax], esi
  00ad4	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN462@test_inser:
  00adb	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00ade	03 c8		 add	 ecx, eax
  00ae0	89 4d b0	 mov	 DWORD PTR $T220552[ebp+4], ecx
  00ae3	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00ae6	89 5d ac	 mov	 DWORD PTR $T220552[ebp], ebx
  00ae9	f3 0f 7e 45 ac	 movq	 xmm0, QWORD PTR $T220552[ebp]
  00aee	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  00af1	66 0f d6 45 84	 movq	 QWORD PTR $T220295[ebp], xmm0
  00af6	8b 5d 88	 mov	 ebx, DWORD PTR $T220295[ebp+4]
  00af9	89 45 8c	 mov	 DWORD PTR $T220295[ebp+8], eax
  00afc	eb 4e		 jmp	 SHORT $LN1085@test_inser
$LN268@test_inser:
  00afe	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00b01	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00b04	2b c8		 sub	 ecx, eax
  00b06	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00b0c	0f 83 fa 00 00
	00		 jae	 $LN1003@test_inser
  00b12	8b 4d c8	 mov	 ecx, DWORD PTR _pos$220253[ebp+4]
  00b15	85 c0		 test	 eax, eax
  00b17	74 11		 je	 SHORT $LN567@test_inser
  00b19	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  00b1c	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00b1f	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  00b22	75 06		 jne	 SHORT $LN567@test_inser
  00b24	48		 dec	 eax
  00b25	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00b28	eb 07		 jmp	 SHORT $LN566@test_inser
$LN567@test_inser:
  00b2a	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00b2d	40		 inc	 eax
  00b2e	89 43 24	 mov	 DWORD PTR [ebx+36], eax
$LN566@test_inser:
  00b31	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00b34	03 c9		 add	 ecx, ecx
  00b36	03 c9		 add	 ecx, ecx
  00b38	03 c9		 add	 ecx, ecx
  00b3a	03 c1		 add	 eax, ecx
  00b3c	74 09		 je	 SHORT $LN653@test_inser
  00b3e	89 30		 mov	 DWORD PTR [eax], esi
  00b40	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN653@test_inser:
  00b47	8b 5b 34	 mov	 ebx, DWORD PTR [ebx+52]
  00b4a	03 d9		 add	 ebx, ecx
$LN1085@test_inser:
  00b4c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN267@test_inser:
  00b52	8b 45 f0	 mov	 eax, DWORD PTR tv5696[ebp]
  00b55	83 45 f4 14	 add	 DWORD PTR tv5684[ebp], 20 ; 00000014H
  00b59	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00b5c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00b5f	40		 inc	 eax
  00b60	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00b63	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00b69	0f 82 95 fe ff
	ff		 jb	 $LL86@test_inser
$LN84@test_inser:

; 979  : 	} STOP();

  00b6f	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 980  : #endif
; 981  : 
; 982  : #ifdef USE_GOOGLEBTREE
; 983  : 	START(DATA_GOOGLEBTREE) {

  00b74	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00b79	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00b7e	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00b84	0f 85 5c 01 00
	00		 jne	 $LN80@test_inser
  00b8a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00b91	75 2f		 jne	 SHORT $LN715@test_inser
  00b93	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  00b99	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00b9e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00ba5	52		 push	 edx
  00ba6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00bac	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00bb3	51		 push	 ecx
  00bb4	50		 push	 eax
  00bb5	68 00 00 00 00	 push	 OFFSET $SG-100
  00bba	e8 00 00 00 00	 call	 _printf
  00bbf	83 c4 10	 add	 esp, 16			; 00000010H
$LN715@test_inser:
  00bc2	8d 4d cc	 lea	 ecx, DWORD PTR _t$220732[ebp]
  00bc5	51		 push	 ecx
  00bc6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00bcc	85 c0		 test	 eax, eax
  00bce	75 64		 jne	 SHORT $LN721@test_inser
  00bd0	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00bd4	66 0f 13 45 c4	 movlpd	 QWORD PTR $T220725[ebp], xmm0
  00bd9	8b 7d c8	 mov	 edi, DWORD PTR $T220725[ebp+4]
  00bdc	8b 75 c4	 mov	 esi, DWORD PTR $T220725[ebp]
  00bdf	e9 a4 00 00 00	 jmp	 $LN722@test_inser
$LN1002@test_inser:

; 977  : 		GOOGLE[i].value = key;
; 978  : 		(*googledensehash)[key] = obj;

  00be4	8d 4d e8	 lea	 ecx, DWORD PTR $T217777[ebp]
  00be7	51		 push	 ecx
  00be8	8d 4d a0	 lea	 ecx, DWORD PTR $T220501[ebp]
  00beb	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T217777[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  00bf2	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00bf7	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  00bfc	8d 55 a0	 lea	 edx, DWORD PTR $T220501[ebp]
  00bff	52		 push	 edx
  00c00	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T220501[ebp], OFFSET ??_7length_error@std@@6B@
  00c07	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1086@test_inser:
$LN1003@test_inser:
  00c0c	8d 45 e0	 lea	 eax, DWORD PTR $T218971[ebp]
  00c0f	50		 push	 eax
  00c10	8d 4d 94	 lea	 ecx, DWORD PTR $T220561[ebp]
  00c13	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T218971[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  00c1a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00c1f	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  00c24	8d 4d 94	 lea	 ecx, DWORD PTR $T220561[ebp]
  00c27	51		 push	 ecx
  00c28	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T220561[ebp], OFFSET ??_7length_error@std@@6B@
  00c2f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1087@test_inser:

; 980  : #endif
; 981  : 
; 982  : #ifdef USE_GOOGLEBTREE
; 983  : 	START(DATA_GOOGLEBTREE) {

$LN721@test_inser:
  00c34	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00c3a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00c40	8b 55 d0	 mov	 edx, DWORD PTR _t$220732[ebp+4]
  00c43	8b 45 cc	 mov	 eax, DWORD PTR _t$220732[ebp]
  00c46	56		 push	 esi
  00c47	57		 push	 edi
  00c48	52		 push	 edx
  00c49	50		 push	 eax
  00c4a	e8 00 00 00 00	 call	 __alldvrm
  00c4f	6a 00		 push	 0
  00c51	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c56	53		 push	 ebx
  00c57	51		 push	 ecx
  00c58	89 45 dc	 mov	 DWORD PTR tv1188[ebp], eax
  00c5b	89 55 e0	 mov	 DWORD PTR tv1188[ebp+4], edx
  00c5e	e8 00 00 00 00	 call	 __allmul
  00c63	56		 push	 esi
  00c64	57		 push	 edi
  00c65	52		 push	 edx
  00c66	50		 push	 eax
  00c67	e8 00 00 00 00	 call	 __alldiv
  00c6c	8b 4d e0	 mov	 ecx, DWORD PTR tv1188[ebp+4]
  00c6f	6a 00		 push	 0
  00c71	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c76	8b fa		 mov	 edi, edx
  00c78	8b 55 dc	 mov	 edx, DWORD PTR tv1188[ebp]
  00c7b	51		 push	 ecx
  00c7c	52		 push	 edx
  00c7d	8b f0		 mov	 esi, eax
  00c7f	e8 00 00 00 00	 call	 __allmul
  00c84	03 f0		 add	 esi, eax
  00c86	13 fa		 adc	 edi, edx
$LN722@test_inser:
  00c88	33 db		 xor	 ebx, ebx
  00c8a	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00c90	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  00c96	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  00c9c	76 48		 jbe	 SHORT $LN80@test_inser
  00c9e	89 5d f4	 mov	 DWORD PTR tv5713[ebp], ebx
$LN82@test_inser:

; 984  : 		unsigned key = INSERT[i];
; 985  : 		struct google_object* obj = &GOOGLE[i];

  00ca1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE
  00ca7	03 4d f4	 add	 ecx, DWORD PTR tv5713[ebp]
  00caa	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00cad	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 986  : 		GOOGLE[i].value = key;
; 987  : 		(*googlebtree)[key] = obj;

  00cb0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00cb6	89 45 f8	 mov	 DWORD PTR _key$148386[ebp], eax
  00cb9	89 01		 mov	 DWORD PTR [ecx], eax
  00cbb	8d 45 f8	 lea	 eax, DWORD PTR _key$148386[ebp]
  00cbe	89 4d e0	 mov	 DWORD PTR tv5725[ebp], ecx
  00cc1	50		 push	 eax
  00cc2	8b c8		 mov	 ecx, eax
  00cc4	51		 push	 ecx
  00cc5	8d 75 94	 lea	 esi, DWORD PTR $T220755[ebp]
  00cc8	e8 00 00 00 00	 call	 ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
  00ccd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00cd0	8b 00		 mov	 eax, DWORD PTR [eax]
  00cd2	8b 4d e0	 mov	 ecx, DWORD PTR tv5725[ebp]
  00cd5	83 45 f4 14	 add	 DWORD PTR tv5713[ebp], 20 ; 00000014H
  00cd9	43		 inc	 ebx
  00cda	89 4c d0 0c	 mov	 DWORD PTR [eax+edx*8+12], ecx
  00cde	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00ce4	72 bb		 jb	 SHORT $LN82@test_inser
$LN80@test_inser:

; 988  : 	} STOP();

  00ce6	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 989  : #endif
; 990  : 
; 991  : #ifdef USE_CPPMAP
; 992  : 	START(DATA_CPPMAP) {

  00ceb	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00cf0	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00cf5	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00cfb	0f 85 62 01 00
	00		 jne	 $LN76@test_inser
  00d01	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00d08	75 2f		 jne	 SHORT $LN732@test_inser
  00d0a	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  00d10	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00d15	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00d1c	52		 push	 edx
  00d1d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00d23	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00d2a	51		 push	 ecx
  00d2b	50		 push	 eax
  00d2c	68 00 00 00 00	 push	 OFFSET $SG-100
  00d31	e8 00 00 00 00	 call	 _printf
  00d36	83 c4 10	 add	 esp, 16			; 00000010H
$LN732@test_inser:
  00d39	8d 4d cc	 lea	 ecx, DWORD PTR _t$220781[ebp]
  00d3c	51		 push	 ecx
  00d3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00d43	85 c0		 test	 eax, eax
  00d45	75 11		 jne	 SHORT $LN738@test_inser
  00d47	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00d4b	66 0f 13 45 c4	 movlpd	 QWORD PTR $T220774[ebp], xmm0
  00d50	8b 7d c8	 mov	 edi, DWORD PTR $T220774[ebp+4]
  00d53	8b 75 c4	 mov	 esi, DWORD PTR $T220774[ebp]
  00d56	eb 54		 jmp	 SHORT $LN739@test_inser
$LN738@test_inser:
  00d58	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00d5e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00d64	8b 55 d0	 mov	 edx, DWORD PTR _t$220781[ebp+4]
  00d67	8b 45 cc	 mov	 eax, DWORD PTR _t$220781[ebp]
  00d6a	56		 push	 esi
  00d6b	57		 push	 edi
  00d6c	52		 push	 edx
  00d6d	50		 push	 eax
  00d6e	e8 00 00 00 00	 call	 __alldvrm
  00d73	6a 00		 push	 0
  00d75	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d7a	53		 push	 ebx
  00d7b	51		 push	 ecx
  00d7c	89 45 dc	 mov	 DWORD PTR tv3474[ebp], eax
  00d7f	89 55 e0	 mov	 DWORD PTR tv3474[ebp+4], edx
  00d82	e8 00 00 00 00	 call	 __allmul
  00d87	56		 push	 esi
  00d88	57		 push	 edi
  00d89	52		 push	 edx
  00d8a	50		 push	 eax
  00d8b	e8 00 00 00 00	 call	 __alldiv
  00d90	8b 4d e0	 mov	 ecx, DWORD PTR tv3474[ebp+4]
  00d93	6a 00		 push	 0
  00d95	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d9a	8b fa		 mov	 edi, edx
  00d9c	8b 55 dc	 mov	 edx, DWORD PTR tv3474[ebp]
  00d9f	51		 push	 ecx
  00da0	52		 push	 edx
  00da1	8b f0		 mov	 esi, eax
  00da3	e8 00 00 00 00	 call	 __allmul
  00da8	03 f0		 add	 esi, eax
  00daa	13 fa		 adc	 edi, edx
$LN739@test_inser:
  00dac	33 c0		 xor	 eax, eax
  00dae	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00db4	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  00dba	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00dbd	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  00dc3	0f 86 9a 00 00
	00		 jbe	 $LN76@test_inser
  00dc9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  00dcf	89 45 f4	 mov	 DWORD PTR tv5742[ebp], eax
$LL78@test_inser:

; 993  : 		unsigned key = INSERT[i];

  00dd2	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00dd5	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]

; 994  : 		struct cpp_object* obj = &CPP[i];

  00dd8	8b 7d f4	 mov	 edi, DWORD PTR tv5742[ebp]
  00ddb	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP
  00de1	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]

; 995  : 		CPP[i].value = key;

  00de4	89 17		 mov	 DWORD PTR [edi], edx

; 996  : 		(*cppmap)[key] = obj;

  00de6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00de9	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00dec	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00df0	89 7d ec	 mov	 DWORD PTR tv5754[ebp], edi
  00df3	89 75 e0	 mov	 DWORD PTR $T221101[ebp], esi
  00df6	8b d9		 mov	 ebx, ecx
  00df8	75 1a		 jne	 SHORT $LN749@test_inser
  00dfa	8d 9b 00 00 00
	00		 npad	 6
$LL750@test_inser:
  00e00	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00e03	73 05		 jae	 SHORT $LN748@test_inser
  00e05	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00e08	eb 04		 jmp	 SHORT $LN747@test_inser
$LN748@test_inser:
  00e0a	8b d8		 mov	 ebx, eax
  00e0c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN747@test_inser:
  00e0e	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00e12	74 ec		 je	 SHORT $LL750@test_inser
$LN749@test_inser:
  00e14	3b d9		 cmp	 ebx, ecx
  00e16	74 05		 je	 SHORT $LN741@test_inser
  00e18	3b 53 0c	 cmp	 edx, DWORD PTR [ebx+12]
  00e1b	73 2c		 jae	 SHORT $LN742@test_inser
$LN741@test_inser:
  00e1d	8d 7d c4	 lea	 edi, DWORD PTR $T221021[ebp]
  00e20	89 55 c4	 mov	 DWORD PTR $T221021[ebp], edx
  00e23	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T221021[ebp+4], 0
  00e2a	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00e2f	8b 55 e0	 mov	 edx, DWORD PTR $T221101[ebp]
  00e32	50		 push	 eax
  00e33	53		 push	 ebx
  00e34	52		 push	 edx
  00e35	8d 7d e8	 lea	 edi, DWORD PTR $T221024[ebp]
  00e38	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00e3d	8b 5d e8	 mov	 ebx, DWORD PTR $T221024[ebp]
  00e40	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  00e46	8b 7d ec	 mov	 edi, DWORD PTR tv5754[ebp]
$LN742@test_inser:

; 989  : #endif
; 990  : 
; 991  : #ifdef USE_CPPMAP
; 992  : 	START(DATA_CPPMAP) {

  00e49	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e4c	83 45 f4 14	 add	 DWORD PTR tv5742[ebp], 20 ; 00000014H
  00e50	40		 inc	 eax

; 996  : 		(*cppmap)[key] = obj;

  00e51	89 7b 10	 mov	 DWORD PTR [ebx+16], edi
  00e54	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00e57	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00e5d	0f 82 6f ff ff
	ff		 jb	 $LL78@test_inser
$LN76@test_inser:

; 997  : 	} STOP();

  00e63	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 998  : #endif
; 999  : 
; 1000 : #ifdef USE_CPPUNORDEREDMAP
; 1001 : 	START(DATA_CPPUNORDEREDMAP) {

  00e68	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  00e6d	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00e72	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00e78	0f 85 7f 01 00
	00		 jne	 $LN72@test_inser
  00e7e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00e85	75 2e		 jne	 SHORT $LN819@test_inser
  00e87	a1 34 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  00e8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00e92	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00e99	50		 push	 eax
  00e9a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00e9f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00ea6	52		 push	 edx
  00ea7	51		 push	 ecx
  00ea8	68 00 00 00 00	 push	 OFFSET $SG-100
  00ead	e8 00 00 00 00	 call	 _printf
  00eb2	83 c4 10	 add	 esp, 16			; 00000010H
$LN819@test_inser:
  00eb5	8d 55 cc	 lea	 edx, DWORD PTR _t$221118[ebp]
  00eb8	52		 push	 edx
  00eb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00ebf	85 c0		 test	 eax, eax
  00ec1	75 11		 jne	 SHORT $LN825@test_inser
  00ec3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ec7	66 0f 13 45 c4	 movlpd	 QWORD PTR $T221112[ebp], xmm0
  00ecc	8b 7d c8	 mov	 edi, DWORD PTR $T221112[ebp+4]
  00ecf	8b 75 c4	 mov	 esi, DWORD PTR $T221112[ebp]
  00ed2	eb 54		 jmp	 SHORT $LN826@test_inser
$LN825@test_inser:
  00ed4	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00eda	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00ee0	8b 45 d0	 mov	 eax, DWORD PTR _t$221118[ebp+4]
  00ee3	8b 4d cc	 mov	 ecx, DWORD PTR _t$221118[ebp]
  00ee6	56		 push	 esi
  00ee7	57		 push	 edi
  00ee8	50		 push	 eax
  00ee9	51		 push	 ecx
  00eea	e8 00 00 00 00	 call	 __alldvrm
  00eef	6a 00		 push	 0
  00ef1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00ef6	53		 push	 ebx
  00ef7	51		 push	 ecx
  00ef8	89 45 dc	 mov	 DWORD PTR tv3469[ebp], eax
  00efb	89 55 e0	 mov	 DWORD PTR tv3469[ebp+4], edx
  00efe	e8 00 00 00 00	 call	 __allmul
  00f03	56		 push	 esi
  00f04	57		 push	 edi
  00f05	52		 push	 edx
  00f06	50		 push	 eax
  00f07	e8 00 00 00 00	 call	 __alldiv
  00f0c	6a 00		 push	 0
  00f0e	8b fa		 mov	 edi, edx
  00f10	8b 55 e0	 mov	 edx, DWORD PTR tv3469[ebp+4]
  00f13	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f18	8b f0		 mov	 esi, eax
  00f1a	8b 45 dc	 mov	 eax, DWORD PTR tv3469[ebp]
  00f1d	52		 push	 edx
  00f1e	50		 push	 eax
  00f1f	e8 00 00 00 00	 call	 __allmul
  00f24	03 f0		 add	 esi, eax
  00f26	13 fa		 adc	 edi, edx
$LN826@test_inser:
  00f28	33 c0		 xor	 eax, eax
  00f2a	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00f30	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  00f36	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00f39	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  00f3f	0f 86 b8 00 00
	00		 jbe	 $LN72@test_inser
  00f45	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00f4b	89 45 f4	 mov	 DWORD PTR tv5771[ebp], eax
  00f4e	8b ff		 npad	 2
$LL74@test_inser:

; 1002 : 		unsigned key = INSERT[i];

  00f50	8b 4d 08	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  00f53	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00f56	8b 34 91	 mov	 esi, DWORD PTR [ecx+edx*4]

; 1003 : 		struct cpp_object* obj = &CPP[i];

  00f59	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP
  00f5e	03 45 f4	 add	 eax, DWORD PTR tv5771[ebp]

; 1004 : 		CPP[i].value = key;
; 1005 : 		(*cppunorderedmap)[key] = obj;

  00f61	8d 55 f0	 lea	 edx, DWORD PTR __Where$221624[ebp]
  00f64	89 45 ec	 mov	 DWORD PTR tv5783[ebp], eax
  00f67	89 30		 mov	 DWORD PTR [eax], esi
  00f69	52		 push	 edx
  00f6a	8d 45 e0	 lea	 eax, DWORD PTR _key$148398[ebp]
  00f6d	8b cb		 mov	 ecx, ebx
  00f6f	89 75 e0	 mov	 DWORD PTR _key$148398[ebp], esi
  00f72	89 5d e8	 mov	 DWORD PTR $T221735[ebp], ebx
  00f75	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
  00f7a	8b 45 f0	 mov	 eax, DWORD PTR __Where$221624[ebp]
  00f7d	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  00f80	8d 7b 04	 lea	 edi, DWORD PTR [ebx+4]
  00f83	75 5b		 jne	 SHORT $LN828@test_inser
  00f85	8b 07		 mov	 eax, DWORD PTR [edi]
  00f87	8b 18		 mov	 ebx, DWORD PTR [eax]
  00f89	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00f8c	51		 push	 ecx
  00f8d	89 75 c4	 mov	 DWORD PTR $T221718[ebp], esi
  00f90	53		 push	 ebx
  00f91	8d 75 c4	 lea	 esi, DWORD PTR $T221718[ebp]
  00f94	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T221718[ebp+4], 0
  00f9b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00fa0	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00fa3	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00fa8	2b d1		 sub	 edx, ecx
  00faa	83 fa 01	 cmp	 edx, 1
  00fad	0f 82 bc 00 00
	00		 jb	 $LN1004@test_inser
  00fb3	41		 inc	 ecx
  00fb4	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00fb7	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00fba	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00fbd	89 01		 mov	 DWORD PTR [ecx], eax
  00fbf	8b 17		 mov	 edx, DWORD PTR [edi]
  00fc1	8b 02		 mov	 eax, DWORD PTR [edx]
  00fc3	8b 55 e8	 mov	 edx, DWORD PTR $T221735[ebp]
  00fc6	50		 push	 eax
  00fc7	8d 4d d4	 lea	 ecx, DWORD PTR $T221720[ebp]
  00fca	51		 push	 ecx
  00fcb	83 c0 08	 add	 eax, 8
  00fce	52		 push	 edx
  00fcf	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00fd4	8b 45 d4	 mov	 eax, DWORD PTR $T221720[ebp]
  00fd7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00fdd	89 45 f0	 mov	 DWORD PTR __Where$221624[ebp], eax
$LN828@test_inser:
  00fe0	8b 4d ec	 mov	 ecx, DWORD PTR tv5783[ebp]
  00fe3	83 45 f4 14	 add	 DWORD PTR tv5771[ebp], 20 ; 00000014H
  00fe7	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00fea	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00fed	40		 inc	 eax
  00fee	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00ff1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00ff7	0f 82 53 ff ff
	ff		 jb	 $LL74@test_inser
$LN72@test_inser:

; 1006 : 	} STOP();

  00ffd	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1007 : #endif
; 1008 : 
; 1009 : 	START(DATA_UTHASH) {

  01002	b8 08 00 00 00	 mov	 eax, 8
  01007	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0100c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  01012	0f 85 ed 03 00
	00		 jne	 $LN68@test_inser
  01018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0101f	75 2f		 jne	 SHORT $LN940@test_inser
  01021	8b 15 20 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+32
  01027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0102c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01033	52		 push	 edx
  01034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0103a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01041	51		 push	 ecx
  01042	50		 push	 eax
  01043	68 00 00 00 00	 push	 OFFSET $SG-100
  01048	e8 00 00 00 00	 call	 _printf
  0104d	83 c4 10	 add	 esp, 16			; 00000010H
$LN940@test_inser:
  01050	8d 4d cc	 lea	 ecx, DWORD PTR _t$221754[ebp]
  01053	51		 push	 ecx
  01054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0105a	85 c0		 test	 eax, eax
  0105c	75 1b		 jne	 SHORT $LN946@test_inser
  0105e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01062	66 0f 13 45 c4	 movlpd	 QWORD PTR $T221747[ebp], xmm0
  01067	8b 7d c8	 mov	 edi, DWORD PTR $T221747[ebp+4]
  0106a	8b 75 c4	 mov	 esi, DWORD PTR $T221747[ebp]
  0106d	eb 5e		 jmp	 SHORT $LN947@test_inser
$LN1004@test_inser:

; 1004 : 		CPP[i].value = key;
; 1005 : 		(*cppunorderedmap)[key] = obj;

  0106f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  01074	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN1088@test_inser:

; 1007 : #endif
; 1008 : 
; 1009 : 	START(DATA_UTHASH) {

$LN946@test_inser:
  01079	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0107f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01085	8b 55 d0	 mov	 edx, DWORD PTR _t$221754[ebp+4]
  01088	8b 45 cc	 mov	 eax, DWORD PTR _t$221754[ebp]
  0108b	56		 push	 esi
  0108c	57		 push	 edi
  0108d	52		 push	 edx
  0108e	50		 push	 eax
  0108f	e8 00 00 00 00	 call	 __alldvrm
  01094	6a 00		 push	 0
  01096	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0109b	53		 push	 ebx
  0109c	51		 push	 ecx
  0109d	89 45 dc	 mov	 DWORD PTR tv3451[ebp], eax
  010a0	89 55 e0	 mov	 DWORD PTR tv3451[ebp+4], edx
  010a3	e8 00 00 00 00	 call	 __allmul
  010a8	56		 push	 esi
  010a9	57		 push	 edi
  010aa	52		 push	 edx
  010ab	50		 push	 eax
  010ac	e8 00 00 00 00	 call	 __alldiv
  010b1	8b 4d e0	 mov	 ecx, DWORD PTR tv3451[ebp+4]
  010b4	6a 00		 push	 0
  010b6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  010bb	8b fa		 mov	 edi, edx
  010bd	8b 55 dc	 mov	 edx, DWORD PTR tv3451[ebp]
  010c0	51		 push	 ecx
  010c1	52		 push	 edx
  010c2	8b f0		 mov	 esi, eax
  010c4	e8 00 00 00 00	 call	 __allmul
  010c9	03 f0		 add	 esi, eax
  010cb	13 fa		 adc	 edi, edx
$LN947@test_inser:
  010cd	33 c0		 xor	 eax, eax
  010cf	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  010d5	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  010db	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  010de	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  010e4	0f 86 1b 03 00
	00		 jbe	 $LN68@test_inser
  010ea	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?UTHASH@@3PAUuthash_object@@A ; UTHASH
  010f0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN70@test_inser:

; 1010 : 		unsigned key = INSERT[i];
; 1011 : 		struct uthash_object* obj = &UTHASH[i];
; 1012 : 		obj->value = key;

  010f6	8b 4d 08	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  010f9	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  010fc	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  010ff	89 13		 mov	 DWORD PTR [ebx], edx

; 1013 : 		HASH_ADD_INT(uthash, value, obj);

  01101	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  01108	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  0110b	c7 47 18 04 00
	00 00		 mov	 DWORD PTR [edi+24], 4
  01112	85 f6		 test	 esi, esi
  01114	0f 85 89 00 00
	00		 jne	 $LN64@test_inser
  0111a	8b f7		 mov	 esi, edi
  0111c	6a 2c		 push	 44			; 0000002cH
  0111e	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
  01124	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0112b	e8 00 00 00 00	 call	 _malloc
  01130	83 c4 04	 add	 esp, 4
  01133	89 07		 mov	 DWORD PTR [edi], eax
  01135	85 c0		 test	 eax, eax
  01137	0f 84 3a 03 00
	00		 je	 $LN1005@test_inser
  0113d	6a 2c		 push	 44			; 0000002cH
  0113f	6a 00		 push	 0
  01141	50		 push	 eax
  01142	e8 00 00 00 00	 call	 _memset
  01147	8b 07		 mov	 eax, DWORD PTR [edi]
  01149	89 78 10	 mov	 DWORD PTR [eax+16], edi
  0114c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0114e	c7 41 04 20 00
	00 00		 mov	 DWORD PTR [ecx+4], 32	; 00000020H
  01155	8b 17		 mov	 edx, DWORD PTR [edi]
  01157	c7 42 08 05 00
	00 00		 mov	 DWORD PTR [edx+8], 5
  0115e	8b 07		 mov	 eax, DWORD PTR [edi]
  01160	83 c4 0c	 add	 esp, 12			; 0000000cH
  01163	68 80 01 00 00	 push	 384			; 00000180H
  01168	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  0116f	e8 00 00 00 00	 call	 _malloc
  01174	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01176	89 01		 mov	 DWORD PTR [ecx], eax
  01178	8b 07		 mov	 eax, DWORD PTR [edi]
  0117a	83 c4 04	 add	 esp, 4
  0117d	83 38 00	 cmp	 DWORD PTR [eax], 0
  01180	0f 84 f1 02 00
	00		 je	 $LN1005@test_inser
  01186	8b 10		 mov	 edx, DWORD PTR [eax]
  01188	68 80 01 00 00	 push	 384			; 00000180H
  0118d	6a 00		 push	 0
  0118f	52		 push	 edx
  01190	e8 00 00 00 00	 call	 _memset
  01195	8b 07		 mov	 eax, DWORD PTR [edi]
  01197	83 c4 0c	 add	 esp, 12			; 0000000cH
  0119a	c7 40 28 e1 1f
	11 a0		 mov	 DWORD PTR [eax+40], -1609490463 ; a0111fe1H
  011a1	eb 18		 jmp	 SHORT $LN58@test_inser
$LN64@test_inser:
  011a3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  011a5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  011a8	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  011ab	8b 06		 mov	 eax, DWORD PTR [esi]
  011ad	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  011b0	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  011b3	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  011b6	8b 16		 mov	 edx, DWORD PTR [esi]
  011b8	89 7a 10	 mov	 DWORD PTR [edx+16], edi
$LN58@test_inser:
  011bb	8b 06		 mov	 eax, DWORD PTR [esi]
  011bd	ff 40 0c	 inc	 DWORD PTR [eax+12]
  011c0	8b 06		 mov	 eax, DWORD PTR [esi]
  011c2	89 07		 mov	 DWORD PTR [edi], eax
  011c4	ba f3 be ed fe	 mov	 edx, -17973517		; feedbef3H
  011c9	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  011cc	0f be 47 23	 movsx	 eax, BYTE PTR [edi+35]
  011d0	0f be 4f 22	 movsx	 ecx, BYTE PTR [edi+34]
  011d4	c1 e0 18	 shl	 eax, 24			; 00000018H
  011d7	c1 e1 10	 shl	 ecx, 16			; 00000010H
  011da	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  011df	03 c1		 add	 eax, ecx
  011e1	0f be 4f 21	 movsx	 ecx, BYTE PTR [edi+33]
  011e5	c1 e1 08	 shl	 ecx, 8
  011e8	03 c1		 add	 eax, ecx
  011ea	0f be 0b	 movsx	 ecx, BYTE PTR [ebx]
  011ed	03 c8		 add	 ecx, eax
  011ef	81 c1 54 c7 da
	62		 add	 ecx, 1658505044		; 62dac754H
  011f5	81 f1 6d f7 07
	00		 xor	 ecx, 522093		; 0007f76dH
  011fb	8b d9		 mov	 ebx, ecx
  011fd	c1 e3 08	 shl	 ebx, 8
  01200	b8 c6 ba 49 9f	 mov	 eax, -1622558010	; 9f49bac6H
  01205	2b c1		 sub	 eax, ecx
  01207	33 c3		 xor	 eax, ebx
  01209	2b d0		 sub	 edx, eax
  0120b	2b d1		 sub	 edx, ecx
  0120d	8b d8		 mov	 ebx, eax
  0120f	c1 eb 0d	 shr	 ebx, 13			; 0000000dH
  01212	33 d3		 xor	 edx, ebx
  01214	2b ca		 sub	 ecx, edx
  01216	2b c8		 sub	 ecx, eax
  01218	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  0121b	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  0121e	33 ca		 xor	 ecx, edx
  01220	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01223	2b c2		 sub	 eax, edx
  01225	2b c1		 sub	 eax, ecx
  01227	8b d9		 mov	 ebx, ecx
  01229	c1 e3 10	 shl	 ebx, 16			; 00000010H
  0122c	33 c3		 xor	 eax, ebx
  0122e	2b d0		 sub	 edx, eax
  01230	2b d1		 sub	 edx, ecx
  01232	8b d8		 mov	 ebx, eax
  01234	c1 eb 05	 shr	 ebx, 5
  01237	33 d3		 xor	 edx, ebx
  01239	2b ca		 sub	 ecx, edx
  0123b	2b c8		 sub	 ecx, eax
  0123d	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01240	c1 ea 03	 shr	 edx, 3
  01243	33 ca		 xor	 ecx, edx
  01245	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01248	2b c2		 sub	 eax, edx
  0124a	2b c1		 sub	 eax, ecx
  0124c	8b d9		 mov	 ebx, ecx
  0124e	c1 e3 0a	 shl	 ebx, 10			; 0000000aH
  01251	33 c3		 xor	 eax, ebx
  01253	2b d0		 sub	 edx, eax
  01255	2b d1		 sub	 edx, ecx
  01257	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  0125a	33 d0		 xor	 edx, eax
  0125c	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  0125f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01261	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01264	48		 dec	 eax
  01265	23 c2		 and	 eax, edx
  01267	8b 11		 mov	 edx, DWORD PTR [ecx]
  01269	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0126c	03 c0		 add	 eax, eax
  0126e	03 c0		 add	 eax, eax
  01270	ff 44 02 04	 inc	 DWORD PTR [edx+eax+4]
  01274	8d 4c 02 04	 lea	 ecx, DWORD PTR [edx+eax+4]
  01278	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0127a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0127c	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0127f	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  01282	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  01289	8b 16		 mov	 edx, DWORD PTR [esi]
  0128b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0128d	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  01290	85 c9		 test	 ecx, ecx
  01292	74 03		 je	 SHORT $LN30@test_inser
  01294	89 79 0c	 mov	 DWORD PTR [ecx+12], edi
$LN30@test_inser:
  01297	8b 16		 mov	 edx, DWORD PTR [esi]
  01299	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0129b	89 3c 08	 mov	 DWORD PTR [eax+ecx], edi
  0129e	8b 16		 mov	 edx, DWORD PTR [esi]
  012a0	03 02		 add	 eax, DWORD PTR [edx]
  012a2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  012a5	8d 54 89 05	 lea	 edx, DWORD PTR [ecx+ecx*4+5]
  012a9	03 d2		 add	 edx, edx
  012ab	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  012ae	0f 82 3b 01 00
	00		 jb	 $LN26@test_inser
  012b4	8b 07		 mov	 eax, DWORD PTR [edi]
  012b6	83 78 24 01	 cmp	 DWORD PTR [eax+36], 1
  012ba	0f 84 2f 01 00
	00		 je	 $LN26@test_inser
  012c0	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  012c3	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  012c6	03 db		 add	 ebx, ebx
  012c8	03 db		 add	 ebx, ebx
  012ca	03 db		 add	 ebx, ebx
  012cc	53		 push	 ebx
  012cd	e8 00 00 00 00	 call	 _malloc
  012d2	83 c4 04	 add	 esp, 4
  012d5	89 45 ec	 mov	 DWORD PTR __he_new_buckets$148493[ebp], eax
  012d8	85 c0		 test	 eax, eax
  012da	0f 84 97 01 00
	00		 je	 $LN1005@test_inser
  012e0	53		 push	 ebx
  012e1	6a 00		 push	 0
  012e3	50		 push	 eax
  012e4	e8 00 00 00 00	 call	 _memset
  012e9	8b 07		 mov	 eax, DWORD PTR [edi]
  012eb	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  012ee	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  012f1	41		 inc	 ecx
  012f2	8b da		 mov	 ebx, edx
  012f4	d3 eb		 shr	 ebx, cl
  012f6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  012f9	8d 4c 09 ff	 lea	 ecx, DWORD PTR [ecx+ecx-1]
  012fd	23 ca		 and	 ecx, edx
  012ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  01302	f7 d9		 neg	 ecx
  01304	1b c9		 sbb	 ecx, ecx
  01306	f7 d9		 neg	 ecx
  01308	03 d9		 add	 ebx, ecx
  0130a	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  0130d	8b 17		 mov	 edx, DWORD PTR [edi]
  0130f	33 db		 xor	 ebx, ebx
  01311	89 5a 1c	 mov	 DWORD PTR [edx+28], ebx
  01314	8b 07		 mov	 eax, DWORD PTR [edi]
  01316	89 5d f0	 mov	 DWORD PTR __he_bkt_i$148490[ebp], ebx
  01319	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0131c	0f 86 83 00 00
	00		 jbe	 $LN22@test_inser
  01322	89 5d f4	 mov	 DWORD PTR tv5800[ebp], ebx
$LL24@test_inser:
  01325	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01327	8b 11		 mov	 edx, DWORD PTR [ecx]
  01329	8b 45 f4	 mov	 eax, DWORD PTR tv5800[ebp]
  0132c	8b 1c 10	 mov	 ebx, DWORD PTR [eax+edx]
  0132f	85 db		 test	 ebx, ebx
  01331	74 5e		 je	 SHORT $LN23@test_inser
$LN21@test_inser:
  01333	8b 17		 mov	 edx, DWORD PTR [edi]
  01335	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01338	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0133b	8d 44 00 ff	 lea	 eax, DWORD PTR [eax+eax-1]
  0133f	23 43 1c	 and	 eax, DWORD PTR [ebx+28]
  01342	89 4d e0	 mov	 DWORD PTR __he_hh_nxt$148492[ebp], ecx
  01345	8b 4d ec	 mov	 ecx, DWORD PTR __he_new_buckets$148493[ebp]
  01348	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0134b	ff 44 81 04	 inc	 DWORD PTR [ecx+eax*4+4]
  0134f	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  01353	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  01356	8b 07		 mov	 eax, DWORD PTR [edi]
  01358	3b 50 18	 cmp	 edx, DWORD PTR [eax+24]
  0135b	76 16		 jbe	 SHORT $LN16@test_inser
  0135d	ff 40 1c	 inc	 DWORD PTR [eax+28]
  01360	8b 37		 mov	 esi, DWORD PTR [edi]
  01362	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01365	33 d2		 xor	 edx, edx
  01367	f7 76 18	 div	 DWORD PTR [esi+24]
  0136a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01370	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN16@test_inser:
  01373	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  0137a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0137c	89 53 10	 mov	 DWORD PTR [ebx+16], edx
  0137f	8b 01		 mov	 eax, DWORD PTR [ecx]
  01381	85 c0		 test	 eax, eax
  01383	74 03		 je	 SHORT $LN15@test_inser
  01385	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
$LN15@test_inser:
  01388	89 19		 mov	 DWORD PTR [ecx], ebx
  0138a	8b 5d e0	 mov	 ebx, DWORD PTR __he_hh_nxt$148492[ebp]
  0138d	85 db		 test	 ebx, ebx
  0138f	75 a2		 jne	 SHORT $LN21@test_inser
$LN23@test_inser:
  01391	8b 45 f0	 mov	 eax, DWORD PTR __he_bkt_i$148490[ebp]
  01394	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01396	83 45 f4 0c	 add	 DWORD PTR tv5800[ebp], 12 ; 0000000cH
  0139a	40		 inc	 eax
  0139b	89 45 f0	 mov	 DWORD PTR __he_bkt_i$148490[ebp], eax
  0139e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  013a1	72 82		 jb	 SHORT $LL24@test_inser
  013a3	33 db		 xor	 ebx, ebx
$LN22@test_inser:
  013a5	8b 17		 mov	 edx, DWORD PTR [edi]
  013a7	8b 02		 mov	 eax, DWORD PTR [edx]
  013a9	50		 push	 eax
  013aa	e8 00 00 00 00	 call	 _free
  013af	8b 07		 mov	 eax, DWORD PTR [edi]
  013b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  013b4	03 c9		 add	 ecx, ecx
  013b6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  013b9	8b 07		 mov	 eax, DWORD PTR [edi]
  013bb	8b 4d ec	 mov	 ecx, DWORD PTR __he_new_buckets$148493[ebp]
  013be	ba 01 00 00 00	 mov	 edx, 1
  013c3	01 50 08	 add	 DWORD PTR [eax+8], edx
  013c6	8b 07		 mov	 eax, DWORD PTR [edi]
  013c8	89 08		 mov	 DWORD PTR [eax], ecx
  013ca	8b 07		 mov	 eax, DWORD PTR [edi]
  013cc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  013cf	d1 e9		 shr	 ecx, 1
  013d1	83 c4 04	 add	 esp, 4
  013d4	39 48 1c	 cmp	 DWORD PTR [eax+28], ecx
  013d7	76 07		 jbe	 SHORT $LN119@test_inser
  013d9	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  013dc	03 ca		 add	 ecx, edx
  013de	eb 02		 jmp	 SHORT $LN120@test_inser
$LN119@test_inser:
  013e0	33 c9		 xor	 ecx, ecx
$LN120@test_inser:
  013e2	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  013e5	8b 07		 mov	 eax, DWORD PTR [edi]
  013e7	39 50 20	 cmp	 DWORD PTR [eax+32], edx
  013ea	76 03		 jbe	 SHORT $LN26@test_inser
  013ec	89 50 24	 mov	 DWORD PTR [eax+36], edx
$LN26@test_inser:

; 1007 : #endif
; 1008 : 
; 1009 : 	START(DATA_UTHASH) {

  013ef	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  013f2	40		 inc	 eax
  013f3	83 c7 34	 add	 edi, 52			; 00000034H
  013f6	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  013f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  013ff	0f 82 f1 fc ff
	ff		 jb	 $LN70@test_inser
$LN68@test_inser:

; 1014 : 	} STOP();

  01405	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1015 : 
; 1016 : 	START(DATA_NEDTRIE) {

  0140a	b8 06 00 00 00	 mov	 eax, 6
  0140f	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01414	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0141a	0f 85 e6 00 00
	00		 jne	 $LN10@test_inser
  01420	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01427	75 2f		 jne	 SHORT $LN949@test_inser
  01429	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+24
  0142f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01434	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0143b	52		 push	 edx
  0143c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01442	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01449	51		 push	 ecx
  0144a	50		 push	 eax
  0144b	68 00 00 00 00	 push	 OFFSET $SG-100
  01450	e8 00 00 00 00	 call	 _printf
  01455	83 c4 10	 add	 esp, 16			; 00000010H
$LN949@test_inser:
  01458	8d 4d cc	 lea	 ecx, DWORD PTR _t$221777[ebp]
  0145b	51		 push	 ecx
  0145c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01462	85 c0		 test	 eax, eax
  01464	75 18		 jne	 SHORT $LN955@test_inser
  01466	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0146a	66 0f 13 45 c4	 movlpd	 QWORD PTR $T221770[ebp], xmm0
  0146f	8b 7d c8	 mov	 edi, DWORD PTR $T221770[ebp+4]
  01472	8b 75 c4	 mov	 esi, DWORD PTR $T221770[ebp]
  01475	eb 5b		 jmp	 SHORT $LN956@test_inser
$LN1005@test_inser:

; 1013 : 		HASH_ADD_INT(uthash, value, obj);

  01477	6a ff		 push	 -1
  01479	e8 00 00 00 00	 call	 _exit
$LN1089@test_inser:

; 1015 : 
; 1016 : 	START(DATA_NEDTRIE) {

$LN955@test_inser:
  0147e	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01484	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0148a	8b 55 d0	 mov	 edx, DWORD PTR _t$221777[ebp+4]
  0148d	8b 45 cc	 mov	 eax, DWORD PTR _t$221777[ebp]
  01490	56		 push	 esi
  01491	57		 push	 edi
  01492	52		 push	 edx
  01493	50		 push	 eax
  01494	e8 00 00 00 00	 call	 __alldvrm
  01499	6a 00		 push	 0
  0149b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  014a0	53		 push	 ebx
  014a1	51		 push	 ecx
  014a2	89 45 dc	 mov	 DWORD PTR tv3381[ebp], eax
  014a5	89 55 e0	 mov	 DWORD PTR tv3381[ebp+4], edx
  014a8	e8 00 00 00 00	 call	 __allmul
  014ad	56		 push	 esi
  014ae	57		 push	 edi
  014af	52		 push	 edx
  014b0	50		 push	 eax
  014b1	e8 00 00 00 00	 call	 __alldiv
  014b6	8b 4d e0	 mov	 ecx, DWORD PTR tv3381[ebp+4]
  014b9	6a 00		 push	 0
  014bb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  014c0	8b fa		 mov	 edi, edx
  014c2	8b 55 dc	 mov	 edx, DWORD PTR tv3381[ebp]
  014c5	51		 push	 ecx
  014c6	52		 push	 edx
  014c7	8b f0		 mov	 esi, eax
  014c9	e8 00 00 00 00	 call	 __allmul
  014ce	03 f0		 add	 esi, eax
  014d0	13 fa		 adc	 edi, edx
$LN956@test_inser:
  014d2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  014d8	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  014de	33 ff		 xor	 edi, edi
  014e0	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  014e6	85 db		 test	 ebx, ebx
  014e8	74 1c		 je	 SHORT $LN10@test_inser
  014ea	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?NEDTRIE@@3PAUnedtrie_object@@A ; NEDTRIE
$LN12@test_inser:

; 1017 : 		unsigned key = INSERT[i];
; 1018 : 		NEDTRIE[i].value = key;

  014f0	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  014f3	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  014f6	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 1019 : 		NEDTRIE_INSERT(nedtrie_t, &nedtrie, &NEDTRIE[i]);

  014f9	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_INSERT
  014fe	47		 inc	 edi
  014ff	83 c6 28	 add	 esi, 40			; 00000028H
  01502	3b fb		 cmp	 edi, ebx
  01504	72 ea		 jb	 SHORT $LN12@test_inser
$LN10@test_inser:

; 1020 : 	} STOP();

  01506	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1021 : 
; 1022 : #ifdef USE_JUDY
; 1023 : 	START(DATA_JUDY) {

  0150b	b8 09 00 00 00	 mov	 eax, 9
  01510	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  01515	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0151b	0f 85 0a 01 00
	00		 jne	 $LN6@test_inser
  01521	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01528	75 2f		 jne	 SHORT $LN958@test_inser
  0152a	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+36
  01530	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01535	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0153c	52		 push	 edx
  0153d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01543	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0154a	51		 push	 ecx
  0154b	50		 push	 eax
  0154c	68 00 00 00 00	 push	 OFFSET $SG-100
  01551	e8 00 00 00 00	 call	 _printf
  01556	83 c4 10	 add	 esp, 16			; 00000010H
$LN958@test_inser:
  01559	8d 4d c4	 lea	 ecx, DWORD PTR _t$221800[ebp]
  0155c	51		 push	 ecx
  0155d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01563	85 c0		 test	 eax, eax
  01565	75 11		 jne	 SHORT $LN964@test_inser
  01567	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0156b	66 0f 13 45 c4	 movlpd	 QWORD PTR $T221793[ebp], xmm0
  01570	8b 7d c8	 mov	 edi, DWORD PTR $T221793[ebp+4]
  01573	8b 75 c4	 mov	 esi, DWORD PTR $T221793[ebp]
  01576	eb 54		 jmp	 SHORT $LN965@test_inser
$LN964@test_inser:
  01578	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0157e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01584	8b 55 c8	 mov	 edx, DWORD PTR _t$221800[ebp+4]
  01587	8b 45 c4	 mov	 eax, DWORD PTR _t$221800[ebp]
  0158a	56		 push	 esi
  0158b	57		 push	 edi
  0158c	52		 push	 edx
  0158d	50		 push	 eax
  0158e	e8 00 00 00 00	 call	 __alldvrm
  01593	6a 00		 push	 0
  01595	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0159a	53		 push	 ebx
  0159b	51		 push	 ecx
  0159c	89 45 dc	 mov	 DWORD PTR tv2603[ebp], eax
  0159f	89 55 e0	 mov	 DWORD PTR tv2603[ebp+4], edx
  015a2	e8 00 00 00 00	 call	 __allmul
  015a7	56		 push	 esi
  015a8	57		 push	 edi
  015a9	52		 push	 edx
  015aa	50		 push	 eax
  015ab	e8 00 00 00 00	 call	 __alldiv
  015b0	8b 4d e0	 mov	 ecx, DWORD PTR tv2603[ebp+4]
  015b3	6a 00		 push	 0
  015b5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  015ba	8b fa		 mov	 edi, edx
  015bc	8b 55 dc	 mov	 edx, DWORD PTR tv2603[ebp]
  015bf	51		 push	 ecx
  015c0	52		 push	 edx
  015c1	8b f0		 mov	 esi, eax
  015c3	e8 00 00 00 00	 call	 __allmul
  015c8	03 f0		 add	 esi, eax
  015ca	13 fa		 adc	 edi, edx
$LN965@test_inser:
  015cc	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  015d2	33 f6		 xor	 esi, esi
  015d4	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  015da	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  015e0	76 49		 jbe	 SHORT $LN6@test_inser
  015e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDY@@3PAUjudy_object@@A ; JUDY
  015e8	8b 7d 08	 mov	 edi, DWORD PTR _INSERT$[ebp]
  015eb	33 db		 xor	 ebx, ebx
  015ed	8d 49 00	 npad	 3
$LL8@test_inser:

; 1024 : 		unsigned key = INSERT[i];

  015f0	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]

; 1025 : 		Pvoid_t PValue;
; 1026 : 		JUDY[i].value = key;

  015f3	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax

; 1027 : 		JLI(PValue, judy, key);

  015f6	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _J_Error$148522[ebp]
  015fc	51		 push	 ecx
  015fd	50		 push	 eax
  015fe	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  01603	e8 00 00 00 00	 call	 _JudyLIns
  01608	83 c4 0c	 add	 esp, 12			; 0000000cH
  0160b	83 f8 ff	 cmp	 eax, -1
  0160e	0f 84 8c 00 00
	00		 je	 $LN1008@test_inser

; 1028 : 		*(struct judy_object**)PValue = &JUDY[i];

  01614	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDY@@3PAUjudy_object@@A ; JUDY
  0161a	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0161d	46		 inc	 esi
  0161e	83 c3 14	 add	 ebx, 20			; 00000014H
  01621	89 10		 mov	 DWORD PTR [eax], edx
  01623	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01629	72 c5		 jb	 SHORT $LL8@test_inser
$LN6@test_inser:

; 1029 : 	} STOP();

  0162b	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1030 : #endif
; 1031 : 
; 1032 : #ifdef USE_JUDYARRAY
; 1033 : 	START(DATA_JUDYARRAY) {

  01630	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  01635	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  0163a	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  01640	0f 85 39 01 00
	00		 jne	 $LN1@test_inser
  01646	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0164d	75 2f		 jne	 SHORT $LN967@test_inser
  0164f	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+40
  01655	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0165a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01661	52		 push	 edx
  01662	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01668	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0166f	51		 push	 ecx
  01670	50		 push	 eax
  01671	68 00 00 00 00	 push	 OFFSET $SG-100
  01676	e8 00 00 00 00	 call	 _printf
  0167b	83 c4 10	 add	 esp, 16			; 00000010H
$LN967@test_inser:
  0167e	8d 4d cc	 lea	 ecx, DWORD PTR _t$221823[ebp]
  01681	51		 push	 ecx
  01682	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01688	85 c0		 test	 eax, eax
  0168a	75 4b		 jne	 SHORT $LN973@test_inser
  0168c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01690	66 0f 13 45 c4	 movlpd	 QWORD PTR $T221816[ebp], xmm0
  01695	8b 5d c8	 mov	 ebx, DWORD PTR $T221816[ebp+4]
  01698	8b 75 c4	 mov	 esi, DWORD PTR $T221816[ebp]
  0169b	e9 8b 00 00 00	 jmp	 $LN974@test_inser
$LN1008@test_inser:

; 1027 : 		JLI(PValue, judy, key);

  016a0	8b 45 80	 mov	 eax, DWORD PTR _J_Error$148522[ebp+4]
  016a3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _J_Error$148522[ebp]
  016a9	50		 push	 eax
  016aa	51		 push	 ecx
  016ab	68 00 00 00 00	 push	 OFFSET $SG-105
  016b0	68 03 04 00 00	 push	 1027			; 00000403H
  016b5	68 00 00 00 00	 push	 OFFSET $SG-106
  016ba	68 00 00 00 00	 push	 OFFSET $SG-107
  016bf	e8 00 00 00 00	 call	 ___iob_func
  016c4	83 c0 40	 add	 eax, 64			; 00000040H
  016c7	50		 push	 eax
  016c8	e8 00 00 00 00	 call	 _fprintf
  016cd	83 c4 1c	 add	 esp, 28			; 0000001cH
  016d0	6a 01		 push	 1
  016d2	e8 00 00 00 00	 call	 _exit
$LN1090@test_inser:

; 1030 : #endif
; 1031 : 
; 1032 : #ifdef USE_JUDYARRAY
; 1033 : 	START(DATA_JUDYARRAY) {

$LN973@test_inser:
  016d7	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  016dd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  016e3	8b 55 d0	 mov	 edx, DWORD PTR _t$221823[ebp+4]
  016e6	8b 45 cc	 mov	 eax, DWORD PTR _t$221823[ebp]
  016e9	56		 push	 esi
  016ea	57		 push	 edi
  016eb	52		 push	 edx
  016ec	50		 push	 eax
  016ed	e8 00 00 00 00	 call	 __alldvrm
  016f2	6a 00		 push	 0
  016f4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  016f9	53		 push	 ebx
  016fa	51		 push	 ecx
  016fb	89 45 dc	 mov	 DWORD PTR tv292[ebp], eax
  016fe	89 55 e0	 mov	 DWORD PTR tv292[ebp+4], edx
  01701	e8 00 00 00 00	 call	 __allmul
  01706	56		 push	 esi
  01707	57		 push	 edi
  01708	52		 push	 edx
  01709	50		 push	 eax
  0170a	e8 00 00 00 00	 call	 __alldiv
  0170f	8b 4d e0	 mov	 ecx, DWORD PTR tv292[ebp+4]
  01712	6a 00		 push	 0
  01714	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01719	8b da		 mov	 ebx, edx
  0171b	8b 55 dc	 mov	 edx, DWORD PTR tv292[ebp]
  0171e	51		 push	 ecx
  0171f	52		 push	 edx
  01720	8b f0		 mov	 esi, eax
  01722	e8 00 00 00 00	 call	 __allmul
  01727	03 f0		 add	 esi, eax
  01729	13 da		 adc	 ebx, edx
$LN974@test_inser:
  0172b	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01731	33 f6		 xor	 esi, esi
  01733	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01739	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  0173f	76 3e		 jbe	 SHORT $LN1@test_inser
  01741	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A ; JUDYARRAY
  01747	33 db		 xor	 ebx, ebx
  01749	8d a4 24 00 00
	00 00		 npad	 7
$LL3@test_inser:

; 1034 : 		judyvalue key = INSERT[i];

  01750	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  01753	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  01756	89 45 e0	 mov	 DWORD PTR _key$148535[ebp], eax

; 1035 : 		JudySlot* pvalue;
; 1036 : 		JUDYARRAY[i].value = key;

  01759	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax

; 1037 : 		pvalue = judy_cell(judyarray, (uchar*)&key, 0);

  0175c	8d 4d e0	 lea	 ecx, DWORD PTR _key$148535[ebp]
  0175f	51		 push	 ecx
  01760	e8 00 00 00 00	 call	 ?judy_cell@@YAPAIPAUJudy@@PAEI@Z ; judy_cell

; 1038 : 		*(struct judyarray_object**)pvalue = &JUDYARRAY[i];

  01765	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A ; JUDYARRAY
  0176b	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0176e	46		 inc	 esi
  0176f	83 c4 04	 add	 esp, 4
  01772	83 c3 14	 add	 ebx, 20			; 00000014H
  01775	89 10		 mov	 DWORD PTR [eax], edx
  01777	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0177d	72 d1		 jb	 SHORT $LL3@test_inser
$LN1@test_inser:

; 1039 : 	} STOP();

  0177f	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1040 : #endif
; 1041 : }

  01784	5f		 pop	 edi
  01785	5e		 pop	 esi
  01786	5b		 pop	 ebx
  01787	8b e5		 mov	 esp, ebp
  01789	5d		 pop	 ebp
  0178a	c3		 ret	 0
$LN1081@test_inser:
?test_insert@@YAXPAI@Z ENDP				; test_insert
_TEXT	ENDS
PUBLIC	?test_operation@@YAXPAI0@Z			; test_operation
; Function compile flags: /Ogtp
;	COMDAT ?test_operation@@YAXPAI0@Z
_TEXT	SEGMENT
?test_operation@@YAXPAI0@Z PROC				; test_operation, COMDAT
; _INSERT$ = edi
; _SEARCH$ = esi

; 2028 : {

  00000	51		 push	 ecx

; 2029 : 	cache_clear();

  00001	33 c0		 xor	 eax, eax
  00003	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL5@test_opera:
  00010	fe 80 00 00 00
	00		 inc	 BYTE PTR ?CACHE@@3PAEA[eax]
  00016	83 c0 20	 add	 eax, 32			; 00000020H
  00019	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0001e	72 f0		 jb	 SHORT $LL5@test_opera
  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2030 : 
; 2031 : 	OPERATION(OPERATION_INSERT);
; 2032 : 	test_insert(INSERT);

  00028	57		 push	 edi
  00029	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 0 ; the_operation
  00033	e8 00 00 00 00	 call	 ?test_insert@@YAXPAI@Z	; test_insert
  00038	83 c4 04	 add	 esp, 4

; 2033 : 
; 2034 : 	OPERATION(OPERATION_CHANGE);
; 2035 : 	test_change(SEARCH, INSERT);

  0003b	57		 push	 edi
  0003c	56		 push	 esi
  0003d	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 4 ; the_operation
  00047	e8 00 00 00 00	 call	 ?test_change@@YAXPAI0@Z	; test_change

; 2036 : 
; 2037 : 	OPERATION(OPERATION_HIT);
; 2038 : 	test_hit(SEARCH);

  0004c	56		 push	 esi
  0004d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 1 ; the_operation
  00057	e8 00 00 00 00	 call	 ?test_hit@@YAXPAI@Z	; test_hit
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2039 : 
; 2040 : 	OPERATION(OPERATION_MISS);
; 2041 : 	test_miss(SEARCH);

  0005f	56		 push	 esi
  00060	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 2 ; the_operation
  0006a	e8 00 00 00 00	 call	 ?test_miss@@YAXPAI@Z	; test_miss
  0006f	83 c4 04	 add	 esp, 4

; 2042 : 
; 2043 : 	OPERATION(OPERATION_SIZE);

  00072	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 3 ; the_operation

; 2044 : 	test_size();

  0007c	e8 00 00 00 00	 call	 ?test_size@@YAXXZ	; test_size

; 2045 : 
; 2046 : 	OPERATION(OPERATION_REMOVE);
; 2047 : 	test_remove(SEARCH);

  00081	56		 push	 esi
  00082	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 5 ; the_operation
  0008c	e8 00 00 00 00	 call	 ?test_remove@@YAXPAI@Z	; test_remove
  00091	83 c4 04	 add	 esp, 4
  00094	59		 pop	 ecx

; 2048 : }

  00095	c3		 ret	 0
?test_operation@@YAXPAI0@Z ENDP				; test_operation
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@408f400000000000
PUBLIC	?test@@YAXIIHH@Z				; test
EXTRN	___libm_sse2_pow:PROC
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?test@@YAXIIHH@Z
_TEXT	SEGMENT
_buf$221977 = -160					; size = 128
_buf$221964 = -160					; size = 128
_f$ = -32						; size = 8
_b$ = -24						; size = 8
tv604 = -16						; size = 8
tv606 = -12						; size = 4
_retry$150522 = -4					; size = 4
tv609 = -2						; size = 2
_size$ = 8						; size = 4
_data$ = 12						; size = 4
_log$ = 16						; size = 4
_sparse$ = 20						; size = 4
?test@@YAXIIHH@Z PROC					; test, COMDAT

; 2059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H

; 2060 : 	double b;
; 2061 : 	double f;
; 2062 : 
; 2063 : 	b = 1000;

  00009	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@408f400000000000

; 2064 : 	f = pow(10, 0.1);

  00011	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fb999999999999a
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	f2 0f 11 45 e8	 movsd	 QWORD PTR _b$[ebp], xmm0
  00020	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ___libm_sse2_pow

; 2065 : 
; 2066 : 	/* log if batch test or requested */
; 2067 : 	the_log = (size == 0 && data == DATA_MAX) || log;

  0002e	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  00031	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
  00034	33 c0		 xor	 eax, eax
  00036	f2 0f 11 45 e0	 movsd	 QWORD PTR _f$[ebp], xmm0
  0003b	3b f8		 cmp	 edi, eax
  0003d	75 05		 jne	 SHORT $LN53@test
  0003f	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  00042	74 0f		 je	 SHORT $LN54@test
$LN53@test:
  00044	39 45 10	 cmp	 DWORD PTR _log$[ebp], eax
  00047	75 0a		 jne	 SHORT $LN54@test
  00049	a3 00 00 00 00	 mov	 DWORD PTR ?the_log@@3HA, eax ; the_log
  0004e	e9 cf 00 00 00	 jmp	 $LN47@test
$LN54@test:
  00053	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?the_log@@3HA, 1 ; the_log

; 2068 : 
; 2069 : 	/* write the header */
; 2070 : 	if (the_log)
; 2071 : 	for(the_order=0;the_order<ORDER_MAX;++the_order) {

  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
$LN49@test:

; 2072 : 		for(the_operation=0;the_operation<OPERATION_MAX;++the_operation) {

  00062	33 c0		 xor	 eax, eax
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
$LN46@test:

; 2073 : 			FILE* f = open("wt");

  00069	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00076	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0007d	50		 push	 eax
  0007e	52		 push	 edx
  0007f	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf$221964[ebp]
  00085	68 00 00 00 00	 push	 OFFSET $SG-104
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _sprintf
  00090	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$221964[ebp]
  00096	68 00 00 00 00	 push	 OFFSET $SG-117
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _fopen
  000a1	8b f0		 mov	 esi, eax

; 2074 : 			fprintf(f, "0\t");

  000a3	68 00 00 00 00	 push	 OFFSET $SG-118
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 _fprintf
  000ae	83 c4 20	 add	 esp, 32			; 00000020H

; 2075 : 			for(the_data=0;the_data<DATA_MAX;++the_data) {

  000b1	33 c0		 xor	 eax, eax
  000b3	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
  000b8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL43@test:

; 2076 : 				if (is_listed(the_data))
; 2077 : 					fprintf(f, "%s\t", DATA_NAME[the_data]);

  000c0	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA[eax*4]
  000c7	52		 push	 edx
  000c8	68 00 00 00 00	 push	 OFFSET $SG-119
  000cd	56		 push	 esi
  000ce	e8 00 00 00 00	 call	 _fprintf
  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  000d8	40		 inc	 eax
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dc	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
  000e1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000e4	72 da		 jb	 SHORT $LL43@test

; 2078 : 			}
; 2079 : 			fprintf(f, "\n");

  000e6	68 00 00 00 00	 push	 OFFSET $SG-120
  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 _fprintf

; 2080 : 			fclose(f);

  000f1	56		 push	 esi
  000f2	e8 00 00 00 00	 call	 _fclose
  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  000fc	40		 inc	 eax
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
  00105	83 f8 06	 cmp	 eax, 6
  00108	0f 82 5b ff ff
	ff		 jb	 $LN46@test

; 2068 : 
; 2069 : 	/* write the header */
; 2070 : 	if (the_log)
; 2071 : 	for(the_order=0;the_order<ORDER_MAX;++the_order) {

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00113	40		 inc	 eax
  00114	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  00119	83 f8 02	 cmp	 eax, 2
  0011c	0f 82 40 ff ff
	ff		 jb	 $LN49@test
$LN47@test:

; 2081 : 		}
; 2082 : 	}
; 2083 : 
; 2084 : 	if (size != 0)

  00122	85 ff		 test	 edi, edi
  00124	74 36		 je	 SHORT $LN39@test

; 2085 : 		the_max = size;

  00126	8b cf		 mov	 ecx, edi
  00128	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_max@@3IA, ecx ; the_max

; 2088 : 
; 2089 : 	while (the_max <= MAX) {

  0012e	81 ff 80 96 98
	00		 cmp	 edi, 10000000		; 00989680H
  00134	0f 87 0f 03 00
	00		 ja	 $LN79@test
  0013a	8d 9b 00 00 00
	00		 npad	 6
$LL37@test:

; 2090 : 		unsigned retry;
; 2091 : 	
; 2092 : 		/* number of retries to avoid spikes */
; 2093 : 		retry = MIN_TRY / the_max;

  00140	33 d2		 xor	 edx, edx
  00142	b8 80 84 1e 00	 mov	 eax, 2000000		; 001e8480H
  00147	f7 f1		 div	 ecx
  00149	8b f8		 mov	 edi, eax
  0014b	89 7d fc	 mov	 DWORD PTR _retry$150522[ebp], edi

; 2094 : 		if (retry < 1)

  0014e	83 ff 01	 cmp	 edi, 1
  00151	73 16		 jae	 SHORT $LN35@test

; 2095 : 			retry = 1;

  00153	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _retry$150522[ebp], 1

; 2096 : 		if (retry > RETRY_MAX)

  0015a	eb 19		 jmp	 SHORT $LN118@test
$LN39@test:

; 2086 : 	else
; 2087 : 		the_max = (unsigned)b;

  0015c	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00161	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_max@@3IA, ecx ; the_max

; 2088 : 
; 2089 : 	while (the_max <= MAX) {

  00167	eb d7		 jmp	 SHORT $LL37@test
$LN35@test:

; 2096 : 		if (retry > RETRY_MAX)

  00169	83 ff 07	 cmp	 edi, 7
  0016c	76 0a		 jbe	 SHORT $LN34@test

; 2097 : 			retry = RETRY_MAX;

  0016e	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR _retry$150522[ebp], 7
$LN118@test:
  00175	8b 7d fc	 mov	 edi, DWORD PTR _retry$150522[ebp]
$LN34@test:

; 2098 : 		if (size != 0)

  00178	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  0017c	74 0a		 je	 SHORT $LN33@test

; 2099 : 			retry = 1;

  0017e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _retry$150522[ebp], 1
  00185	8b 7d fc	 mov	 edi, DWORD PTR _retry$150522[ebp]
$LN33@test:

; 2100 : 
; 2101 : 		/* clear the log */
; 2102 : 		memset(LOG, 0, sizeof(LOG));

  00188	68 b0 13 00 00	 push	 5040			; 000013b0H
  0018d	6a 00		 push	 0
  0018f	68 00 00 00 00	 push	 OFFSET ?LOG@@3PAY2P@15IA ; LOG
  00194	e8 00 00 00 00	 call	 _memset

; 2103 : 
; 2104 : 		order_init(the_max, sparse);

  00199	8b 45 14	 mov	 eax, DWORD PTR _sparse$[ebp]
  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ?order_init@@YAXHH@Z	; order_init
  001a5	83 c4 04	 add	 esp, 4

; 2105 : 
; 2106 : 		/* run the test */
; 2107 : 		for(the_retry=0;the_retry<retry;++the_retry) {

  001a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_retry@@3IA, 0 ; the_retry
  001b2	85 ff		 test	 edi, edi
  001b4	0f 84 f7 00 00
	00		 je	 $LN30@test
$LN32@test:

; 2108 : 			/* data */
; 2109 : 			for(the_data=0;the_data<DATA_MAX;++the_data) {

  001ba	33 c9		 xor	 ecx, ecx
  001bc	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_data@@3IA, ecx ; the_data
$LN29@test:

; 2110 : 				if (!is_listed(the_data))
; 2111 : 					continue;
; 2112 : 
; 2113 : 				if (data != DATA_MAX && data != the_data)

  001c2	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  001c5	74 08		 je	 SHORT $LN25@test
  001c7	3b d9		 cmp	 ebx, ecx
  001c9	0f 85 bf 00 00
	00		 jne	 $LN28@test
$LN25@test:

; 2114 : 					continue;
; 2115 : 
; 2116 : 				for(the_order=0;the_order<ORDER_MAX;++the_order) {

  001cf	33 c0		 xor	 eax, eax
  001d1	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  001d6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL24@test:

; 2117 : 					printf("%d %s %s", the_max, DATA_NAME[the_data], ORDER_NAME[the_order]);

  001e0	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  001e7	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA[ecx*4]
  001ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  001f4	52		 push	 edx
  001f5	50		 push	 eax
  001f6	51		 push	 ecx
  001f7	68 00 00 00 00	 push	 OFFSET $SG-121
  001fc	e8 00 00 00 00	 call	 _printf
  00201	83 c4 10	 add	 esp, 16			; 00000010H

; 2118 : 
; 2119 : 					/* skip degenerated cases */
; 2120 : 					if (data == DATA_MAX && LAST[the_data][the_order] > TIME_MAX_NS) {

  00204	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  00207	75 2a		 jne	 SHORT $LN21@test
  00209	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00214	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00217	81 3c 8d 00 00
	00 00 dc 05 00
	00		 cmp	 DWORD PTR ?LAST@@3PAY01IA[ecx*4], 1500 ; 000005dcH
  00222	76 0f		 jbe	 SHORT $LN21@test

; 2121 : 						printf(" (skipped, too slow)\n");

  00224	68 00 00 00 00	 push	 OFFSET $SG-122
  00229	e8 00 00 00 00	 call	 _printf
  0022e	83 c4 04	 add	 esp, 4

; 2122 : 						continue;

  00231	eb 41		 jmp	 SHORT $LN23@test
$LN21@test:

; 2123 : 					}
; 2124 : 
; 2125 : 					printf("\n");

  00233	68 00 00 00 00	 push	 OFFSET $SG-123
  00238	e8 00 00 00 00	 call	 _printf
  0023d	83 c4 04	 add	 esp, 4

; 2126 : 					
; 2127 : 					test_alloc();

  00240	e8 00 00 00 00	 call	 ?test_alloc@@YAXXZ	; test_alloc

; 2128 : 					if (the_order == ORDER_FORWARD)

  00245	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_order@@3IA, 0 ; the_order
  0024c	75 0a		 jne	 SHORT $LN20@test

; 2129 : 						test_operation(FORWARD, FORWARD);

  0024e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00254	8b fe		 mov	 edi, esi

; 2130 : 					else

  00256	eb 0c		 jmp	 SHORT $LN119@test
$LN20@test:

; 2131 : 						test_operation(RAND0, RAND1);

  00258	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?RAND1@@3PAIA ; RAND1
  0025e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?RAND0@@3PAIA ; RAND0
$LN119@test:
  00264	e8 00 00 00 00	 call	 ?test_operation@@YAXPAI0@Z ; test_operation

; 2132 : 					test_free();

  00269	e8 00 00 00 00	 call	 ?test_free@@YAXXZ	; test_free
  0026e	8b 7d fc	 mov	 edi, DWORD PTR _retry$150522[ebp]
  00271	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
$LN23@test:

; 2114 : 					continue;
; 2115 : 
; 2116 : 				for(the_order=0;the_order<ORDER_MAX;++the_order) {

  00274	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00279	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  0027f	40		 inc	 eax
  00280	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  00285	83 f8 02	 cmp	 eax, 2
  00288	0f 82 52 ff ff
	ff		 jb	 $LL24@test
$LN28@test:

; 2108 : 			/* data */
; 2109 : 			for(the_data=0;the_data<DATA_MAX;++the_data) {

  0028e	41		 inc	 ecx
  0028f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_data@@3IA, ecx ; the_data
  00295	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00298	0f 82 24 ff ff
	ff		 jb	 $LN29@test

; 2105 : 
; 2106 : 		/* run the test */
; 2107 : 		for(the_retry=0;the_retry<retry;++the_retry) {

  0029e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_retry@@3IA ; the_retry
  002a3	40		 inc	 eax
  002a4	a3 00 00 00 00	 mov	 DWORD PTR ?the_retry@@3IA, eax ; the_retry
  002a9	3b c7		 cmp	 eax, edi
  002ab	0f 82 09 ff ff
	ff		 jb	 $LN32@test
$LN30@test:

; 2133 : 				}
; 2134 : 			}
; 2135 : 		}
; 2136 : 
; 2137 : 		order_done();

  002b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  002b7	52		 push	 edx
  002b8	e8 00 00 00 00	 call	 _free
  002bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RAND0@@3PAIA ; RAND0
  002c2	83 c4 04	 add	 esp, 4
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 _free
  002cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  002d1	83 c4 04	 add	 esp, 4
  002d4	51		 push	 ecx
  002d5	e8 00 00 00 00	 call	 _free
  002da	83 c4 04	 add	 esp, 4

; 2138 : 
; 2139 : 		/* write the data */
; 2140 : 		if (the_log)

  002dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  002e4	0f 84 23 01 00
	00		 je	 $LN15@test

; 2141 : 		for(the_order=0;the_order<ORDER_MAX;++the_order) {

  002ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, 0 ; the_order
$LN17@test:

; 2142 : 			for(the_operation=0;the_operation<OPERATION_MAX;++the_operation) {

  002f4	33 c0		 xor	 eax, eax
  002f6	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
$LN14@test:

; 2143 : 				FILE* f = open("at");

  002fb	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00302	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00307	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0030e	52		 push	 edx
  0030f	51		 push	 ecx
  00310	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _buf$221977[ebp]
  00316	68 00 00 00 00	 push	 OFFSET $SG-104
  0031b	52		 push	 edx
  0031c	e8 00 00 00 00	 call	 _sprintf
  00321	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf$221977[ebp]
  00327	68 00 00 00 00	 push	 OFFSET $SG-124
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 _fopen

; 2144 : 
; 2145 : 				fprintf(f, "%u\t", the_max);

  00332	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00338	51		 push	 ecx
  00339	8b d8		 mov	 ebx, eax
  0033b	68 00 00 00 00	 push	 OFFSET $SG-125
  00340	53		 push	 ebx
  00341	e8 00 00 00 00	 call	 _fprintf
  00346	83 c4 24	 add	 esp, 36			; 00000024H

; 2146 : 				
; 2147 : 				/* data */
; 2148 : 				for(the_data=0;the_data<DATA_MAX;++the_data) {

  00349	33 c0		 xor	 eax, eax
  0034b	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
$LN11@test:

; 2149 : 					unsigned i, v;
; 2150 : 
; 2151 : 					if (!is_listed(the_data))
; 2152 : 						continue;
; 2153 : 
; 2154 : 					/* get the minimum */
; 2155 : 					v = LOG[0][the_data][the_order][the_operation];

  00350	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00356	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0035c	8d 34 42	 lea	 esi, DWORD PTR [edx+eax*2]
  0035f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00362	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00365	03 c0		 add	 eax, eax
  00367	8b 8c 00 00 00
	00 00		 mov	 ecx, DWORD PTR ?LOG@@3PAY2P@15IA[eax+eax]
  0036e	03 c0		 add	 eax, eax

; 2156 : 					for(i=1;i<retry;++i) {

  00370	83 ff 01	 cmp	 edi, 1
  00373	76 1d		 jbe	 SHORT $LN5@test

; 2149 : 					unsigned i, v;
; 2150 : 
; 2151 : 					if (!is_listed(the_data))
; 2152 : 						continue;
; 2153 : 
; 2154 : 					/* get the minimum */
; 2155 : 					v = LOG[0][the_data][the_order][the_operation];

  00375	8d 80 d0 02 00
	00		 lea	 eax, DWORD PTR ?LOG@@3PAY2P@15IA[eax+720]
  0037b	4f		 dec	 edi
  0037c	8d 64 24 00	 npad	 4
$LL7@test:

; 2157 : 						if (LOG[i][the_data][the_order][the_operation] < v)

  00380	8b 10		 mov	 edx, DWORD PTR [eax]
  00382	3b d1		 cmp	 edx, ecx

; 2158 : 							v = LOG[i][the_data][the_order][the_operation];

  00384	0f 42 ca	 cmovb	 ecx, edx
  00387	05 d0 02 00 00	 add	 eax, 720		; 000002d0H
  0038c	4f		 dec	 edi
  0038d	75 f1		 jne	 SHORT $LL7@test

; 2156 : 					for(i=1;i<retry;++i) {

  0038f	8b 7d fc	 mov	 edi, DWORD PTR _retry$150522[ebp]
$LN5@test:

; 2159 : 					}
; 2160 : 
; 2161 : 					/* save the *longest* measured time */
; 2162 : 					if (the_operation != OPERATION_SIZE) {

  00392	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?the_operation@@3IA, 3 ; the_operation
  00399	74 14		 je	 SHORT $LN2@test

; 2163 : 						if (v != 0 && LAST[the_data][the_order] < v)

  0039b	85 c9		 test	 ecx, ecx
  0039d	74 10		 je	 SHORT $LN2@test
  0039f	39 0c b5 00 00
	00 00		 cmp	 DWORD PTR ?LAST@@3PAY01IA[esi*4], ecx
  003a6	73 07		 jae	 SHORT $LN2@test

; 2164 : 							LAST[the_data][the_order] = v;

  003a8	89 0c b5 00 00
	00 00		 mov	 DWORD PTR ?LAST@@3PAY01IA[esi*4], ecx
$LN2@test:

; 2165 : 					}
; 2166 : 
; 2167 : 					fprintf(f, "%u\t", v);

  003af	51		 push	 ecx
  003b0	68 00 00 00 00	 push	 OFFSET $SG-126
  003b5	53		 push	 ebx
  003b6	e8 00 00 00 00	 call	 _fprintf
  003bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  003c0	40		 inc	 eax
  003c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c4	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
  003c9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  003cc	72 82		 jb	 SHORT $LN11@test

; 2168 : 				}
; 2169 : 
; 2170 : 				fprintf(f, "\n");

  003ce	68 00 00 00 00	 push	 OFFSET $SG-127
  003d3	53		 push	 ebx
  003d4	e8 00 00 00 00	 call	 _fprintf

; 2171 : 				fclose(f);

  003d9	53		 push	 ebx
  003da	e8 00 00 00 00	 call	 _fclose
  003df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  003e4	40		 inc	 eax
  003e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e8	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
  003ed	83 f8 06	 cmp	 eax, 6
  003f0	0f 82 05 ff ff
	ff		 jb	 $LN14@test

; 2141 : 		for(the_order=0;the_order<ORDER_MAX;++the_order) {

  003f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  003fb	40		 inc	 eax
  003fc	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  00401	83 f8 02	 cmp	 eax, 2
  00404	0f 82 ea fe ff
	ff		 jb	 $LN17@test
  0040a	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
$LN15@test:

; 2172 : 			}
; 2173 : 		}
; 2174 : 
; 2175 : 		if (size != 0)

  0040d	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  00411	75 36		 jne	 SHORT $LN79@test

; 2176 : 			break;
; 2177 : 
; 2178 : 		/* new max */
; 2179 : 		b *= f;

  00413	dd 45 e0	 fld	 QWORD PTR _f$[ebp]
  00416	dc 4d e8	 fmul	 QWORD PTR _b$[ebp]

; 2180 : 		the_max = (unsigned)b;

  00419	d9 7d fe	 fnstcw	 WORD PTR tv609[ebp]
  0041c	0f b7 45 fe	 movzx	 eax, WORD PTR tv609[ebp]
  00420	dd 55 e8	 fst	 QWORD PTR _b$[ebp]
  00423	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00428	89 45 f4	 mov	 DWORD PTR tv606[ebp], eax
  0042b	d9 6d f4	 fldcw	 WORD PTR tv606[ebp]
  0042e	df 7d f0	 fistp	 QWORD PTR tv604[ebp]
  00431	8b 4d f0	 mov	 ecx, DWORD PTR tv604[ebp]
  00434	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_max@@3IA, ecx ; the_max
  0043a	d9 6d fe	 fldcw	 WORD PTR tv609[ebp]
  0043d	81 f9 80 96 98
	00		 cmp	 ecx, 10000000		; 00989680H
  00443	0f 86 f7 fc ff
	ff		 jbe	 $LL37@test
$LN79@test:

; 2181 : 	}
; 2182 : }

  00449	5f		 pop	 edi
  0044a	5e		 pop	 esi
  0044b	5b		 pop	 ebx
  0044c	8b e5		 mov	 esp, ebp
  0044e	5d		 pop	 ebp
  0044f	c3		 ret	 0
?test@@YAXIIHH@Z ENDP					; test
_TEXT	ENDS
PUBLIC	_main
; Function compile flags: /Ogtp
;	COMDAT _main
_TEXT	SEGMENT
tv308 = -24						; size = 4
_flag_data$ = -20					; size = 4
_flag_size$ = -16					; size = 4
_flag_miss$ = -12					; size = 4
_flag_sparse$ = -8					; size = 4
_flag_log$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 2215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 2216 : 	int i;
; 2217 : 	int flag_data = DATA_MAX;
; 2218 : 	int flag_size = 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	57		 push	 edi

; 2219 : 	int flag_log = 0;
; 2220 : 	int flag_miss = 0;
; 2221 : 	int flag_sparse = 0;
; 2222 : 
; 2223 : 	nano_init();

  0000e	68 00 00 00 00	 push	 OFFSET _win_frequency
  00013	c7 44 24 18 0f
	00 00 00	 mov	 DWORD PTR _flag_data$[esp+44], 15 ; 0000000fH
  0001b	89 44 24 1c	 mov	 DWORD PTR _flag_size$[esp+44], eax
  0001f	89 44 24 28	 mov	 DWORD PTR _flag_log$[esp+44], eax
  00023	89 44 24 20	 mov	 DWORD PTR _flag_miss$[esp+44], eax
  00027	89 44 24 24	 mov	 DWORD PTR _flag_sparse$[esp+44], eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  00031	85 c0		 test	 eax, eax
  00033	75 0c		 jne	 SHORT $LN26@main
  00035	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00039	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR _win_frequency, xmm0
$LN26@main:

; 2224 : 
; 2225 : 	printf("Tommy benchmark program.\n");

  00041	68 00 00 00 00	 push	 OFFSET $SG-129
  00046	e8 00 00 00 00	 call	 _printf

; 2226 : 
; 2227 : 	for(i=1;i<argc;++i) {

  0004b	bb 01 00 00 00	 mov	 ebx, 1
  00050	83 c4 04	 add	 esp, 4
  00053	39 5d 08	 cmp	 DWORD PTR _argc$[ebp], ebx
  00056	0f 8e 81 02 00
	00		 jle	 $LN1@main

; 2224 : 
; 2225 : 	printf("Tommy benchmark program.\n");

  0005c	c7 44 24 10 02
	00 00 00	 mov	 DWORD PTR tv308[esp+40], 2
$LL23@main:

; 2228 : 		if (strcmp(argv[i], "-l") == 0) {

  00064	8b 7d 0c	 mov	 edi, DWORD PTR _argv$[ebp]
  00067	8b 34 9f	 mov	 esi, DWORD PTR [edi+ebx*4]
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-130
  0006f	8b c6		 mov	 eax, esi
$LL36@main:
  00071	8a 10		 mov	 dl, BYTE PTR [eax]
  00073	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00075	75 1a		 jne	 SHORT $LN37@main
  00077	84 d2		 test	 dl, dl
  00079	74 12		 je	 SHORT $LN38@main
  0007b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0007e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00081	75 0e		 jne	 SHORT $LN37@main
  00083	83 c0 02	 add	 eax, 2
  00086	83 c1 02	 add	 ecx, 2
  00089	84 d2		 test	 dl, dl
  0008b	75 e4		 jne	 SHORT $LL36@main
$LN38@main:
  0008d	33 c0		 xor	 eax, eax
  0008f	eb 05		 jmp	 SHORT $LN39@main
$LN37@main:
  00091	1b c0		 sbb	 eax, eax
  00093	83 d8 ff	 sbb	 eax, -1
$LN39@main:
  00096	85 c0		 test	 eax, eax
  00098	75 0d		 jne	 SHORT $LN20@main

; 2229 : 			flag_log = 1;

  0009a	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR _flag_log$[esp+40], 1
  000a2	e9 b8 01 00 00	 jmp	 $LN22@main
$LN20@main:

; 2230 : 		} else if (strcmp(argv[i], "-s") == 0) {

  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-131
  000ac	8b c6		 mov	 eax, esi
  000ae	8b ff		 npad	 2
$LL40@main:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN41@main
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN42@main
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN41@main
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL40@main
$LN42@main:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN43@main
$LN41@main:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 d8 ff	 sbb	 eax, -1
$LN43@main:
  000d5	85 c0		 test	 eax, eax
  000d7	75 0d		 jne	 SHORT $LN18@main

; 2231 : 			flag_sparse = 1;

  000d9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _flag_sparse$[esp+40], 1
  000e1	e9 79 01 00 00	 jmp	 $LN22@main
$LN18@main:

; 2232 : 		} else if (strcmp(argv[i], "-m") == 0) {

  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-132
  000eb	8b c6		 mov	 eax, esi
  000ed	8d 49 00	 npad	 3
$LL44@main:
  000f0	8a 10		 mov	 dl, BYTE PTR [eax]
  000f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f4	75 1a		 jne	 SHORT $LN45@main
  000f6	84 d2		 test	 dl, dl
  000f8	74 12		 je	 SHORT $LN46@main
  000fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00100	75 0e		 jne	 SHORT $LN45@main
  00102	83 c0 02	 add	 eax, 2
  00105	83 c1 02	 add	 ecx, 2
  00108	84 d2		 test	 dl, dl
  0010a	75 e4		 jne	 SHORT $LL44@main
$LN46@main:
  0010c	33 c0		 xor	 eax, eax
  0010e	eb 05		 jmp	 SHORT $LN47@main
$LN45@main:
  00110	1b c0		 sbb	 eax, eax
  00112	83 d8 ff	 sbb	 eax, -1
$LN47@main:
  00115	85 c0		 test	 eax, eax
  00117	75 0d		 jne	 SHORT $LN16@main

; 2233 : 			flag_miss = 1;

  00119	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _flag_miss$[esp+40], 1
  00121	e9 39 01 00 00	 jmp	 $LN22@main
$LN16@main:

; 2234 : 		} else if (strcmp(argv[i], "-n") == 0) {

  00126	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-133
  0012b	8b c6		 mov	 eax, esi
  0012d	8d 49 00	 npad	 3
$LL48@main:
  00130	8a 10		 mov	 dl, BYTE PTR [eax]
  00132	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00134	75 1a		 jne	 SHORT $LN49@main
  00136	84 d2		 test	 dl, dl
  00138	74 12		 je	 SHORT $LN50@main
  0013a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0013d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00140	75 0e		 jne	 SHORT $LN49@main
  00142	83 c0 02	 add	 eax, 2
  00145	83 c1 02	 add	 ecx, 2
  00148	84 d2		 test	 dl, dl
  0014a	75 e4		 jne	 SHORT $LL48@main
$LN50@main:
  0014c	33 c0		 xor	 eax, eax
  0014e	eb 05		 jmp	 SHORT $LN51@main
$LN49@main:
  00150	1b c0		 sbb	 eax, eax
  00152	83 d8 ff	 sbb	 eax, -1
$LN51@main:
  00155	85 c0		 test	 eax, eax
  00157	75 0d		 jne	 SHORT $LN14@main

; 2235 : 			flag_size = MAX;

  00159	c7 44 24 18 80
	96 98 00	 mov	 DWORD PTR _flag_size$[esp+40], 10000000 ; 00989680H
  00161	e9 f9 00 00 00	 jmp	 $LN22@main
$LN14@main:

; 2236 : 		} else if (strcmp(argv[i], "-N") == 0) {

  00166	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-134
  0016b	8b c6		 mov	 eax, esi
  0016d	8d 49 00	 npad	 3
$LL52@main:
  00170	8a 10		 mov	 dl, BYTE PTR [eax]
  00172	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00174	75 1a		 jne	 SHORT $LN53@main
  00176	84 d2		 test	 dl, dl
  00178	74 12		 je	 SHORT $LN54@main
  0017a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0017d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00180	75 0e		 jne	 SHORT $LN53@main
  00182	83 c0 02	 add	 eax, 2
  00185	83 c1 02	 add	 ecx, 2
  00188	84 d2		 test	 dl, dl
  0018a	75 e4		 jne	 SHORT $LL52@main
$LN54@main:
  0018c	33 c0		 xor	 eax, eax
  0018e	eb 05		 jmp	 SHORT $LN55@main
$LN53@main:
  00190	1b c0		 sbb	 eax, eax
  00192	83 d8 ff	 sbb	 eax, -1
$LN55@main:
  00195	85 c0		 test	 eax, eax
  00197	75 23		 jne	 SHORT $LN12@main

; 2237 : 			if (i+1 >= argc) {

  00199	8b 44 24 10	 mov	 eax, DWORD PTR tv308[esp+40]
  0019d	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  001a0	0f 8d dc 00 00
	00		 jge	 $LN31@main

; 2240 : 			}
; 2241 : 			flag_size = atoi(argv[i+1]);

  001a6	8b 4c 9f 04	 mov	 ecx, DWORD PTR [edi+ebx*4+4]
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 _atoi
  001b0	83 c4 04	 add	 esp, 4
  001b3	89 44 24 18	 mov	 DWORD PTR _flag_size$[esp+40], eax

; 2242 : 			++i;

  001b7	e9 9e 00 00 00	 jmp	 $LN66@main
$LN12@main:

; 2243 : 		} else if (strcmp(argv[i], "-d") == 0) {

  001bc	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-136
  001c1	8b c6		 mov	 eax, esi
$LL56@main:
  001c3	8a 10		 mov	 dl, BYTE PTR [eax]
  001c5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001c7	75 1a		 jne	 SHORT $LN57@main
  001c9	84 d2		 test	 dl, dl
  001cb	74 12		 je	 SHORT $LN58@main
  001cd	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001d0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001d3	75 0e		 jne	 SHORT $LN57@main
  001d5	83 c0 02	 add	 eax, 2
  001d8	83 c1 02	 add	 ecx, 2
  001db	84 d2		 test	 dl, dl
  001dd	75 e4		 jne	 SHORT $LL56@main
$LN58@main:
  001df	33 c0		 xor	 eax, eax
  001e1	eb 05		 jmp	 SHORT $LN59@main
$LN57@main:
  001e3	1b c0		 sbb	 eax, eax
  001e5	83 d8 ff	 sbb	 eax, -1
$LN59@main:
  001e8	85 c0		 test	 eax, eax
  001ea	0f 85 d8 00 00
	00		 jne	 $LN9@main

; 2244 : 			int j;
; 2245 : 			if (i+1 >= argc) {

  001f0	8b 55 08	 mov	 edx, DWORD PTR _argc$[ebp]
  001f3	39 54 24 10	 cmp	 DWORD PTR tv308[esp+40], edx
  001f7	0f 8d 9a 00 00
	00		 jge	 $LN32@main

; 2248 : 			}
; 2249 : 			flag_data = DATA_MAX;

  001fd	8b 7c 9f 04	 mov	 edi, DWORD PTR [edi+ebx*4+4]
  00201	c7 44 24 14 0f
	00 00 00	 mov	 DWORD PTR _flag_data$[esp+40], 15 ; 0000000fH

; 2250 : 			for(j=0;j<DATA_MAX;++j) {

  00209	33 f6		 xor	 esi, esi
  0020b	eb 03 8d 49 00	 npad	 5
$LL7@main:

; 2251 : 				if (strcmp(argv[i+1], DATA_NAME[j]) == 0) {

  00210	8b 0c b5 00 00
	00 00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA[esi*4]
  00217	8b c7		 mov	 eax, edi
  00219	8d a4 24 00 00
	00 00		 npad	 7
$LL60@main:
  00220	8a 10		 mov	 dl, BYTE PTR [eax]
  00222	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00224	75 1a		 jne	 SHORT $LN61@main
  00226	84 d2		 test	 dl, dl
  00228	74 12		 je	 SHORT $LN62@main
  0022a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0022d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00230	75 0e		 jne	 SHORT $LN61@main
  00232	83 c0 02	 add	 eax, 2
  00235	83 c1 02	 add	 ecx, 2
  00238	84 d2		 test	 dl, dl
  0023a	75 e4		 jne	 SHORT $LL60@main
$LN62@main:
  0023c	33 c0		 xor	 eax, eax
  0023e	eb 05		 jmp	 SHORT $LN63@main
$LN61@main:
  00240	1b c0		 sbb	 eax, eax
  00242	83 d8 ff	 sbb	 eax, -1
$LN63@main:
  00245	85 c0		 test	 eax, eax
  00247	75 04		 jne	 SHORT $LN6@main

; 2252 : 					flag_data = j;

  00249	89 74 24 14	 mov	 DWORD PTR _flag_data$[esp+40], esi
$LN6@main:

; 2250 : 			for(j=0;j<DATA_MAX;++j) {

  0024d	46		 inc	 esi
  0024e	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00251	7c bd		 jl	 SHORT $LL7@main

; 2253 : 				}
; 2254 : 			}
; 2255 : 			if (flag_data == DATA_MAX) {

  00253	83 7c 24 14 0f	 cmp	 DWORD PTR _flag_data$[esp+40], 15 ; 0000000fH
  00258	74 52		 je	 SHORT $LN33@main
$LN66@main:

; 2258 : 			}
; 2259 : 			++i;

  0025a	43		 inc	 ebx
  0025b	ff 44 24 10	 inc	 DWORD PTR tv308[esp+40]
$LN22@main:

; 2226 : 
; 2227 : 	for(i=1;i<argc;++i) {

  0025f	ff 44 24 10	 inc	 DWORD PTR tv308[esp+40]
  00263	43		 inc	 ebx
  00264	3b 5d 08	 cmp	 ebx, DWORD PTR _argc$[ebp]
  00267	0f 8c f7 fd ff
	ff		 jl	 $LL23@main

; 2263 : 		} 
; 2264 : 	}
; 2265 : 
; 2266 : 	if (flag_miss) {

  0026d	83 7c 24 1c 00	 cmp	 DWORD PTR _flag_miss$[esp+40], 0
  00272	74 69		 je	 SHORT $LN1@main

; 2267 : 		test_cache_miss();

  00274	e8 00 00 00 00	 call	 ?test_cache_miss@@YAXXZ	; test_cache_miss

; 2274 : 
; 2275 : 	return EXIT_SUCCESS;

  00279	33 c0		 xor	 eax, eax

; 2276 : }

  0027b	5f		 pop	 edi
  0027c	5e		 pop	 esi
  0027d	5b		 pop	 ebx
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c3		 ret	 0
$LN31@main:

; 2238 : 				printf("Missing data in %s\n", argv[i]);

  00282	56		 push	 esi
  00283	68 00 00 00 00	 push	 OFFSET $SG-135
  00288	e8 00 00 00 00	 call	 _printf
  0028d	83 c4 08	 add	 esp, 8

; 2239 : 				exit(EXIT_FAILURE);

  00290	6a 01		 push	 1
  00292	e8 00 00 00 00	 call	 _exit
$LN68@main:
$LN32@main:

; 2246 : 				printf("Missing data in %s\n", argv[i]);

  00297	56		 push	 esi
  00298	68 00 00 00 00	 push	 OFFSET $SG-137
  0029d	e8 00 00 00 00	 call	 _printf
  002a2	83 c4 08	 add	 esp, 8

; 2247 : 				exit(EXIT_FAILURE);

  002a5	6a 01		 push	 1
  002a7	e8 00 00 00 00	 call	 _exit
$LN69@main:
$LN33@main:

; 2256 : 				printf("Unknown data %s\n", argv[i+1]);

  002ac	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  002af	8b 44 9a 04	 mov	 eax, DWORD PTR [edx+ebx*4+4]
  002b3	50		 push	 eax
  002b4	68 00 00 00 00	 push	 OFFSET $SG-138
  002b9	e8 00 00 00 00	 call	 _printf
  002be	83 c4 08	 add	 esp, 8

; 2257 : 				exit(EXIT_FAILURE);

  002c1	6a 01		 push	 1
  002c3	e8 00 00 00 00	 call	 _exit
$LN70@main:
$LN9@main:

; 2260 : 		} else {
; 2261 : 			printf("Unknown option %s\n", argv[i]);

  002c8	56		 push	 esi
  002c9	68 00 00 00 00	 push	 OFFSET $SG-139
  002ce	e8 00 00 00 00	 call	 _printf
  002d3	83 c4 08	 add	 esp, 8

; 2262 : 			exit(EXIT_FAILURE);

  002d6	6a 01		 push	 1
  002d8	e8 00 00 00 00	 call	 _exit
$LN71@main:
$LN1@main:

; 2268 : 		return EXIT_SUCCESS;
; 2269 : 	}
; 2270 : 
; 2271 : 	test(flag_size, flag_data, flag_log, flag_sparse);

  002dd	8b 54 24 20	 mov	 edx, DWORD PTR _flag_sparse$[esp+40]
  002e1	8b 44 24 24	 mov	 eax, DWORD PTR _flag_log$[esp+40]
  002e5	8b 4c 24 14	 mov	 ecx, DWORD PTR _flag_data$[esp+40]
  002e9	52		 push	 edx
  002ea	8b 54 24 1c	 mov	 edx, DWORD PTR _flag_size$[esp+44]
  002ee	50		 push	 eax
  002ef	51		 push	 ecx
  002f0	52		 push	 edx
  002f1	e8 00 00 00 00	 call	 ?test@@YAXIIHH@Z	; test

; 2272 : 
; 2273 : 	printf("OK\n");

  002f6	68 00 00 00 00	 push	 OFFSET $SG-140
  002fb	e8 00 00 00 00	 call	 _printf
  00300	83 c4 14	 add	 esp, 20			; 00000014H

; 2276 : }

  00303	5f		 pop	 edi
  00304	5e		 pop	 esi
  00305	33 c0		 xor	 eax, eax
  00307	5b		 pop	 ebx
  00308	8b e5		 mov	 esp, ebp
  0030a	5d		 pop	 ebp
  0030b	c3		 ret	 0
$LN65@main:
_main	ENDP
_TEXT	ENDS
END
