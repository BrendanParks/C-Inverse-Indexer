<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Tommy Documentation</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="Introduction"></a>
Introduction</h2>
<p>Tommy is a C library of hashtables and tries designed to store objects with high performance.</p>
<p>It's <b>faster</b> than all the similar libraries like <a href="http://www.canonware.com/rb/">rbtree</a>, <a href="http://judy.sourceforge.net/">judy</a>, <a href="http://code.google.com/p/google-sparsehash/">googledensehash</a>, <a href="http://attractivechaos.awardspace.com/">khash</a>, <a href="http://uthash.sourceforge.net/">uthash</a>, <a href="http://www.nedprod.com/programs/portable/nedtries/">nedtrie</a>, <a href="http://code.google.com/p/judyarray/">judyarray</a> and others.</p>
<p>The data structures provided are:</p>
<ul>
<li><a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list for collisions into hashtables.">tommy_list</a> - A double linked list.</li>
<li><a class="el" href="tommyarray_8h.html#a0f2ab5f891aee3ba7aae019ac74cb5eb" title="Array.">tommy_array</a> - A linear array. It doesn't fragment the heap.</li>
<li><a class="el" href="tommyhashtbl_8h.html#a506978bdee7fd24f76a0ba7547206513" title="Fixed size chained hashtable.">tommy_hashtable</a> - A fixed size chained hashtable.</li>
<li><a class="el" href="tommyhashdyn_8h.html#a00c8b944d273f38f9eef91417a1e8991" title="Dynamic chained hashtable.">tommy_hashdyn</a> - A dynamic chained hashtable.</li>
<li><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Linear chained hashtable.">tommy_hashlin</a> - A linear chained hashtable. It doesn't have the problem of the delay when resizing and it doesn't fragment the heap.</li>
<li><a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a> - A trie optimized for cache utilization.</li>
<li><a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Inplace trie.">tommy_trie_inplace</a> - A trie completely inplace.</li>
</ul>
<p>The most interesting are <a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Linear chained hashtable.">tommy_hashlin</a>, <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a> and <a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Inplace trie.">tommy_trie_inplace</a>.</p>
<p>Tommy is released with a <a class="el" href="license.html">2-clause BSD license</a>.</p>
<p>The official site of TommyDS is <a href="http://tommyds.sourceforge.net/">http://tommyds.sourceforge.net/</a>,</p>
<h2><a class="anchor" id="Use"></a>
Use</h2>
<p>All the data structures share the same interface that needs to embedded in the object to store a node of type <a class="el" href="tommytypes_8h.html#a56a5b6211015e83fd69c4f990ac5612b" title="Data structure node.">tommy_node</a>.</p>
<p>Inside this node is stored a pointer to the object itself in the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer at the object containing the node.">tommy_node::data</a> field, and the key used to identify the object in the <a class="el" href="structtommy__node__struct.html#a124aaecab9e5d3d1fbb9239dac779d23" title="Key used to store the node.">tommy_node::key</a> field.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
     <span class="comment">// other fields</span>
     <span class="keywordtype">int</span> value;
 };
</pre></div><p>To insert an object you have to provide the address of the embedded node, the address of the object and the value of the key. </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>));

 <a class="code" href="tommytrie_8h.html#a7f48a4942d6b607c24b7236ab257b7d7" title="Inserts an element in the trie.">tommy_trie_insert</a>(..., &amp;obj-&gt;node, obj, obj-&gt;value);
</pre></div><p>To search an object you have to provide the key and call the search function. </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object* obj = <a class="code" href="tommytrie_8h.html#a1170abedabdc9d919db8728d238c50db" title="Searches an element in the trie.">tommy_trie_search</a>(..., value_to_find);
 <span class="keywordflow">if</span> (!obj) {
   <span class="comment">// not found</span>
 } <span class="keywordflow">else</span> {
   <span class="comment">// found</span>
 }
</pre></div><p>To access all the objects with the same keys you have to iterate over the bucket assigned at the specified key. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_trie_node</a>* i = <a class="code" href="tommytrie_8h.html#a0ab11f26139ff2a1d405ace4a1af0e6a" title="Gets the bucket of the specified key.">tommy_trie_bucket</a>(..., value_to_find);

 <span class="keywordflow">while</span> (i) {
     <span class="keyword">struct </span>object* obj = i-&gt;<a class="code" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer at the object containing the node.">data</a>; <span class="comment">// gets the object pointer</span>

     printf(<span class="stringliteral">&quot;%d\n&quot;</span>, obj-&gt;value); <span class="comment">// process the object</span>

     i = i-&gt;<a class="code" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">next</a>; <span class="comment">// goes to the next element</span>
 }
</pre></div><p>To remove an object you have to provide the key and call the remove function. </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object* obj = <a class="code" href="tommytrie_8h.html#a47ed46af4087783c351172280d03ed6b" title="Searches and removes the first element with the specified key.">tommy_trie_remove</a>(..., value);
 <span class="keywordflow">if</span> (obj) {
     free(obj); <span class="comment">// frees the object allocated memory</span>
 }
</pre></div><p>Dealing with hashtables, instead of the key, you have to provide the hash value of the object, and a compare function able to differentiate objects with the same hash value.</p>
<p>To compute the hash value, you can use the generic <a class="el" href="tommyhash_8h.html#ab020046d7799cda5b440bd49b4e282d8" title="Hash function with a 32 bits result.">tommy_hash_u32()</a> function, or the specialized integer hash function <a class="el" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer hash of 32 bits.">tommy_inthash_u32()</a>.</p>
<h2><a class="anchor" id="Performance"></a>
Performance</h2>
<p>Here you can see some timings compared to other common implementations in <em>Hit</em> and <em>Change</em> performance. Hit is searching an object with success, and Change is searching, removing and reinsert it with a different key value.</p>
<p>Times are expressed in nanoseconds for element, so <b>lower is better</b>.</p>
<p>A complete analysis is available in the <a class="el" href="benchmark.html">Tommy Benchmarks</a> page.</p>
<div align="center">
<img src="def/img_random_hit.png" alt="img_random_hit.png"/>
</div>
<div align="center">
<img src="def/img_random_change.png" alt="img_random_change.png"/>
</div>
<h2><a class="anchor" id="Features"></a>
Features</h2>
<p>Tommy is 100% portable in all the platforms and operating systems.</p>
<p>Tommy containers support multiple elements with the same key.</p>
<h2><a class="anchor" id="Limitations"></a>
Limitations</h2>
<p>Tommy is not thread safe. You have always to provide thread safety using locks before calling any Tommy functions.</p>
<p>Tommy doesn't provide iterators over the implicit order defined by the data structures. To iterate on elements you must insert them also into a <a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list for collisions into hashtables.">tommy_list</a>, and use the list as iterator. See the <a class="el" href="multiindex.html">Tommy Multi Indexing</a> example for more details. Note that this is a real limitation only for <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a>, as it's the only data structure defining an useable order.</p>
<p>Tommy doesn't provide an error reporting mechanism for a malloc() failure. You have to provide it redefining malloc() if you expect it to fail.</p>
<p>Tommy assumes to never have more than 2^32 elements in a container. </p>
</div></div>
</body>
</html>
