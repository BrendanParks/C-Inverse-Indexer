<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Tommy Design </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Tommy is mainly designed to provide high performance, but also much care was given in the definition of an useable API.</p>
<p>In some case, even at the cost of some efficency.</p>
<h2><a class="anchor" id="datapointer"></a>
Data pointer</h2>
<p>The <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer at the object containing the node.">tommy_node::data</a> field is present only to provide a simpler API.</p>
<p>A more memory conservative approach is to do not store this pointer, and computing it from the node pointer every time considering that they are always at a constant offset.</p>
<p>See for example the Linux Kernel declaration of container_of() at <a href="http://lxr.linux.no/#linux+v2.6.37/include/linux/kernel.h#L526">http://lxr.linux.no/#linux+v2.6.37/include/linux/kernel.h#L526</a></p>
<p>Although, it would have required more complexity for the user to require a manual conversion from a node to the object containing the node.</p>
<h2><a class="anchor" id="zero_list"></a>
Zero terminated next list</h2>
<p>The half 0 terminated format of <a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list for collisions into hashtables.">tommy_list</a> is present only to provide a forward iterator terminating in 0.</p>
<p>A more efficient approach is to use a double circular list, as operating on nodes in a circular list doesn't requires to manage the special terminating case.</p>
<p>Although, it would have required too much complexity at the user for a simple iteration.</p>
<h2><a class="anchor" id="double_linked"></a>
Double linked list for collisions</h2>
<p>The linked list used for collision is a double linked list to allow insertion of elements at the end of the list to keep the insertion order of equal elements.</p>
<p>A more memory conservative approach is to use a single linked list, inserting elements only at the start of the list. On the other hand, with with a double linked list we can concatenate two lists in constant time, as using the previous circular element we can get a tail pointer. </p>
</div></div>
</body>
</html>
